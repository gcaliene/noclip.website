// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

// eslint-disable-next-line no-global-assign
parcelRequire = (function (modules, cache, entry, globalName) {
  // Save the require from previous bundle to this closure if any
  var previousRequire = typeof parcelRequire === 'function' && parcelRequire;
  var nodeRequire = typeof require === 'function' && require;

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire = typeof parcelRequire === 'function' && parcelRequire;
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error('Cannot find module \'' + name + '\'');
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;

      var module = cache[name] = new newRequire.Module(name);

      modules[name][0].call(module.exports, localRequire, module, module.exports, this);
    }

    return cache[name].exports;

    function localRequire(x){
      return newRequire(localRequire.resolve(x));
    }

    function resolve(x){
      return modules[name][1][x] || x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [function (require, module) {
      module.exports = exports;
    }, {}];
  };

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (entry.length) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(entry[entry.length - 1]);

    // CommonJS
    if (typeof exports === "object" && typeof module !== "undefined") {
      module.exports = mainExports;

    // RequireJS
    } else if (typeof define === "function" && define.amd) {
     define(function () {
       return mainExports;
     });

    // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }

  // Override the current require with this new one
  return newRequire;
})({"..\\node_modules\\gl-matrix\\src\\gl-matrix\\common.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setMatrixArrayType = setMatrixArrayType;
exports.toRadian = toRadian;
exports.equals = equals;
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

/**
 * Common utilities
 * @module glMatrix
 */

// Configuration Constants
const EPSILON = exports.EPSILON = 0.000001;
let ARRAY_TYPE = exports.ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;
const RANDOM = exports.RANDOM = Math.random;

/**
 * Sets the type of array used when creating new vectors and matrices
 *
 * @param {Type} type Array type, such as Float32Array or Array
 */
function setMatrixArrayType(type) {
  exports.ARRAY_TYPE = ARRAY_TYPE = type;
}

const degree = Math.PI / 180;

/**
 * Convert Degree To Radian
 *
 * @param {Number} a Angle in Degrees
 */
function toRadian(a) {
  return a * degree;
}

/**
 * Tests whether or not the arguments have approximately the same value, within an absolute
 * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less
 * than or equal to 1.0, and a relative tolerance is used for larger values)
 *
 * @param {Number} a The first number to test.
 * @param {Number} b The second number to test.
 * @returns {Boolean} True if the numbers are approximately equal, false otherwise.
 */
function equals(a, b) {
  return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));
}
},{}],"..\\node_modules\\gl-matrix\\src\\gl-matrix\\mat2.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.sub = exports.mul = undefined;
exports.create = create;
exports.clone = clone;
exports.copy = copy;
exports.identity = identity;
exports.fromValues = fromValues;
exports.set = set;
exports.transpose = transpose;
exports.invert = invert;
exports.adjoint = adjoint;
exports.determinant = determinant;
exports.multiply = multiply;
exports.rotate = rotate;
exports.scale = scale;
exports.fromRotation = fromRotation;
exports.fromScaling = fromScaling;
exports.str = str;
exports.frob = frob;
exports.LDU = LDU;
exports.add = add;
exports.subtract = subtract;
exports.exactEquals = exactEquals;
exports.equals = equals;
exports.multiplyScalar = multiplyScalar;
exports.multiplyScalarAndAdd = multiplyScalarAndAdd;

var _common = require('./common');

var glMatrix = _interopRequireWildcard(_common);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * 2x2 Matrix
 * @module mat2
 */

/**
 * Creates a new identity mat2
 *
 * @returns {mat2} a new 2x2 matrix
 */
function create() {
  let out = new glMatrix.ARRAY_TYPE(4);
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}

/**
 * Creates a new mat2 initialized with values from an existing matrix
 *
 * @param {mat2} a matrix to clone
 * @returns {mat2} a new 2x2 matrix
 */
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

function clone(a) {
  let out = new glMatrix.ARRAY_TYPE(4);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}

/**
 * Copy the values from one mat2 to another
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}

/**
 * Set a mat2 to the identity matrix
 *
 * @param {mat2} out the receiving matrix
 * @returns {mat2} out
 */
function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}

/**
 * Create a new mat2 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m10 Component in column 1, row 0 position (index 2)
 * @param {Number} m11 Component in column 1, row 1 position (index 3)
 * @returns {mat2} out A new 2x2 matrix
 */
function fromValues(m00, m01, m10, m11) {
  let out = new glMatrix.ARRAY_TYPE(4);
  out[0] = m00;
  out[1] = m01;
  out[2] = m10;
  out[3] = m11;
  return out;
}

/**
 * Set the components of a mat2 to the given values
 *
 * @param {mat2} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m10 Component in column 1, row 0 position (index 2)
 * @param {Number} m11 Component in column 1, row 1 position (index 3)
 * @returns {mat2} out
 */
function set(out, m00, m01, m10, m11) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m10;
  out[3] = m11;
  return out;
}

/**
 * Transpose the values of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache
  // some values
  if (out === a) {
    let a1 = a[1];
    out[1] = a[2];
    out[2] = a1;
  } else {
    out[0] = a[0];
    out[1] = a[2];
    out[2] = a[1];
    out[3] = a[3];
  }

  return out;
}

/**
 * Inverts a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
function invert(out, a) {
  let a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];

  // Calculate the determinant
  let det = a0 * a3 - a2 * a1;

  if (!det) {
    return null;
  }
  det = 1.0 / det;

  out[0] = a3 * det;
  out[1] = -a1 * det;
  out[2] = -a2 * det;
  out[3] = a0 * det;

  return out;
}

/**
 * Calculates the adjugate of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
function adjoint(out, a) {
  // Caching this value is nessecary if out == a
  let a0 = a[0];
  out[0] = a[3];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a0;

  return out;
}

/**
 * Calculates the determinant of a mat2
 *
 * @param {mat2} a the source matrix
 * @returns {Number} determinant of a
 */
function determinant(a) {
  return a[0] * a[3] - a[2] * a[1];
}

/**
 * Multiplies two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */
function multiply(out, a, b) {
  let a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  let b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  out[0] = a0 * b0 + a2 * b1;
  out[1] = a1 * b0 + a3 * b1;
  out[2] = a0 * b2 + a2 * b3;
  out[3] = a1 * b2 + a3 * b3;
  return out;
}

/**
 * Rotates a mat2 by the given angle
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */
function rotate(out, a, rad) {
  let a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  let s = Math.sin(rad);
  let c = Math.cos(rad);
  out[0] = a0 * c + a2 * s;
  out[1] = a1 * c + a3 * s;
  out[2] = a0 * -s + a2 * c;
  out[3] = a1 * -s + a3 * c;
  return out;
}

/**
 * Scales the mat2 by the dimensions in the given vec2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2} out
 **/
function scale(out, a, v) {
  let a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  let v0 = v[0],
      v1 = v[1];
  out[0] = a0 * v0;
  out[1] = a1 * v0;
  out[2] = a2 * v1;
  out[3] = a3 * v1;
  return out;
}

/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.rotate(dest, dest, rad);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */
function fromRotation(out, rad) {
  let s = Math.sin(rad);
  let c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = -s;
  out[3] = c;
  return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.scale(dest, dest, vec);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat2} out
 */
function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = v[1];
  return out;
}

/**
 * Returns a string representation of a mat2
 *
 * @param {mat2} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
function str(a) {
  return 'mat2(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
}

/**
 * Returns Frobenius norm of a mat2
 *
 * @param {mat2} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
function frob(a) {
  return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2));
}

/**
 * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix
 * @param {mat2} L the lower triangular matrix
 * @param {mat2} D the diagonal matrix
 * @param {mat2} U the upper triangular matrix
 * @param {mat2} a the input matrix to factorize
 */

function LDU(L, D, U, a) {
  L[2] = a[2] / a[0];
  U[0] = a[0];
  U[1] = a[1];
  U[3] = a[3] - L[2] * U[1];
  return [L, D, U];
}

/**
 * Adds two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  return out;
}

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  return out;
}

/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat2} a The first matrix.
 * @param {mat2} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat2} a The first matrix.
 * @param {mat2} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function equals(a, b) {
  let a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  let b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3));
}

/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat2} out
 */
function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  return out;
}

/**
 * Adds two mat2's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat2} out the receiving vector
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat2} out
 */
function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  return out;
}

/**
 * Alias for {@link mat2.multiply}
 * @function
 */
const mul = exports.mul = multiply;

/**
 * Alias for {@link mat2.subtract}
 * @function
 */
const sub = exports.sub = subtract;
},{"./common":"..\\node_modules\\gl-matrix\\src\\gl-matrix\\common.js"}],"..\\node_modules\\gl-matrix\\src\\gl-matrix\\mat2d.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.sub = exports.mul = undefined;
exports.create = create;
exports.clone = clone;
exports.copy = copy;
exports.identity = identity;
exports.fromValues = fromValues;
exports.set = set;
exports.invert = invert;
exports.determinant = determinant;
exports.multiply = multiply;
exports.rotate = rotate;
exports.scale = scale;
exports.translate = translate;
exports.fromRotation = fromRotation;
exports.fromScaling = fromScaling;
exports.fromTranslation = fromTranslation;
exports.str = str;
exports.frob = frob;
exports.add = add;
exports.subtract = subtract;
exports.multiplyScalar = multiplyScalar;
exports.multiplyScalarAndAdd = multiplyScalarAndAdd;
exports.exactEquals = exactEquals;
exports.equals = equals;

var _common = require('./common');

var glMatrix = _interopRequireWildcard(_common);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * 2x3 Matrix
 * @module mat2d
 *
 * @description
 * A mat2d contains six elements defined as:
 * <pre>
 * [a, c, tx,
 *  b, d, ty]
 * </pre>
 * This is a short form for the 3x3 matrix:
 * <pre>
 * [a, c, tx,
 *  b, d, ty,
 *  0, 0, 1]
 * </pre>
 * The last row is ignored so the array is shorter and operations are faster.
 */

/**
 * Creates a new identity mat2d
 *
 * @returns {mat2d} a new 2x3 matrix
 */
function create() {
  let out = new glMatrix.ARRAY_TYPE(6);
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = 0;
  out[5] = 0;
  return out;
}

/**
 * Creates a new mat2d initialized with values from an existing matrix
 *
 * @param {mat2d} a matrix to clone
 * @returns {mat2d} a new 2x3 matrix
 */
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

function clone(a) {
  let out = new glMatrix.ARRAY_TYPE(6);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  return out;
}

/**
 * Copy the values from one mat2d to another
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the source matrix
 * @returns {mat2d} out
 */
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  return out;
}

/**
 * Set a mat2d to the identity matrix
 *
 * @param {mat2d} out the receiving matrix
 * @returns {mat2d} out
 */
function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = 0;
  out[5] = 0;
  return out;
}

/**
 * Create a new mat2d with the given values
 *
 * @param {Number} a Component A (index 0)
 * @param {Number} b Component B (index 1)
 * @param {Number} c Component C (index 2)
 * @param {Number} d Component D (index 3)
 * @param {Number} tx Component TX (index 4)
 * @param {Number} ty Component TY (index 5)
 * @returns {mat2d} A new mat2d
 */
function fromValues(a, b, c, d, tx, ty) {
  let out = new glMatrix.ARRAY_TYPE(6);
  out[0] = a;
  out[1] = b;
  out[2] = c;
  out[3] = d;
  out[4] = tx;
  out[5] = ty;
  return out;
}

/**
 * Set the components of a mat2d to the given values
 *
 * @param {mat2d} out the receiving matrix
 * @param {Number} a Component A (index 0)
 * @param {Number} b Component B (index 1)
 * @param {Number} c Component C (index 2)
 * @param {Number} d Component D (index 3)
 * @param {Number} tx Component TX (index 4)
 * @param {Number} ty Component TY (index 5)
 * @returns {mat2d} out
 */
function set(out, a, b, c, d, tx, ty) {
  out[0] = a;
  out[1] = b;
  out[2] = c;
  out[3] = d;
  out[4] = tx;
  out[5] = ty;
  return out;
}

/**
 * Inverts a mat2d
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the source matrix
 * @returns {mat2d} out
 */
function invert(out, a) {
  let aa = a[0],
      ab = a[1],
      ac = a[2],
      ad = a[3];
  let atx = a[4],
      aty = a[5];

  let det = aa * ad - ab * ac;
  if (!det) {
    return null;
  }
  det = 1.0 / det;

  out[0] = ad * det;
  out[1] = -ab * det;
  out[2] = -ac * det;
  out[3] = aa * det;
  out[4] = (ac * aty - ad * atx) * det;
  out[5] = (ab * atx - aa * aty) * det;
  return out;
}

/**
 * Calculates the determinant of a mat2d
 *
 * @param {mat2d} a the source matrix
 * @returns {Number} determinant of a
 */
function determinant(a) {
  return a[0] * a[3] - a[1] * a[2];
}

/**
 * Multiplies two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */
function multiply(out, a, b) {
  let a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  let b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5];
  out[0] = a0 * b0 + a2 * b1;
  out[1] = a1 * b0 + a3 * b1;
  out[2] = a0 * b2 + a2 * b3;
  out[3] = a1 * b2 + a3 * b3;
  out[4] = a0 * b4 + a2 * b5 + a4;
  out[5] = a1 * b4 + a3 * b5 + a5;
  return out;
}

/**
 * Rotates a mat2d by the given angle
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */
function rotate(out, a, rad) {
  let a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  let s = Math.sin(rad);
  let c = Math.cos(rad);
  out[0] = a0 * c + a2 * s;
  out[1] = a1 * c + a3 * s;
  out[2] = a0 * -s + a2 * c;
  out[3] = a1 * -s + a3 * c;
  out[4] = a4;
  out[5] = a5;
  return out;
}

/**
 * Scales the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to translate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2d} out
 **/
function scale(out, a, v) {
  let a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  let v0 = v[0],
      v1 = v[1];
  out[0] = a0 * v0;
  out[1] = a1 * v0;
  out[2] = a2 * v1;
  out[3] = a3 * v1;
  out[4] = a4;
  out[5] = a5;
  return out;
}

/**
 * Translates the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to translate
 * @param {vec2} v the vec2 to translate the matrix by
 * @returns {mat2d} out
 **/
function translate(out, a, v) {
  let a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  let v0 = v[0],
      v1 = v[1];
  out[0] = a0;
  out[1] = a1;
  out[2] = a2;
  out[3] = a3;
  out[4] = a0 * v0 + a2 * v1 + a4;
  out[5] = a1 * v0 + a3 * v1 + a5;
  return out;
}

/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.rotate(dest, dest, rad);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */
function fromRotation(out, rad) {
  let s = Math.sin(rad),
      c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = -s;
  out[3] = c;
  out[4] = 0;
  out[5] = 0;
  return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.scale(dest, dest, vec);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat2d} out
 */
function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = v[1];
  out[4] = 0;
  out[5] = 0;
  return out;
}

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.translate(dest, dest, vec);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {vec2} v Translation vector
 * @returns {mat2d} out
 */
function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = v[0];
  out[5] = v[1];
  return out;
}

/**
 * Returns a string representation of a mat2d
 *
 * @param {mat2d} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
function str(a) {
  return 'mat2d(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ')';
}

/**
 * Returns Frobenius norm of a mat2d
 *
 * @param {mat2d} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
function frob(a) {
  return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + 1);
}

/**
 * Adds two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  return out;
}

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  return out;
}

/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat2d} out
 */
function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  return out;
}

/**
 * Adds two mat2d's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat2d} out the receiving vector
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat2d} out
 */
function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  return out;
}

/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat2d} a The first matrix.
 * @param {mat2d} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5];
}

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat2d} a The first matrix.
 * @param {mat2d} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function equals(a, b) {
  let a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  let b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5));
}

/**
 * Alias for {@link mat2d.multiply}
 * @function
 */
const mul = exports.mul = multiply;

/**
 * Alias for {@link mat2d.subtract}
 * @function
 */
const sub = exports.sub = subtract;
},{"./common":"..\\node_modules\\gl-matrix\\src\\gl-matrix\\common.js"}],"..\\node_modules\\gl-matrix\\src\\gl-matrix\\mat3.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.sub = exports.mul = undefined;
exports.create = create;
exports.fromMat4 = fromMat4;
exports.clone = clone;
exports.copy = copy;
exports.fromValues = fromValues;
exports.set = set;
exports.identity = identity;
exports.transpose = transpose;
exports.invert = invert;
exports.adjoint = adjoint;
exports.determinant = determinant;
exports.multiply = multiply;
exports.translate = translate;
exports.rotate = rotate;
exports.scale = scale;
exports.fromTranslation = fromTranslation;
exports.fromRotation = fromRotation;
exports.fromScaling = fromScaling;
exports.fromMat2d = fromMat2d;
exports.fromQuat = fromQuat;
exports.normalFromMat4 = normalFromMat4;
exports.projection = projection;
exports.str = str;
exports.frob = frob;
exports.add = add;
exports.subtract = subtract;
exports.multiplyScalar = multiplyScalar;
exports.multiplyScalarAndAdd = multiplyScalarAndAdd;
exports.exactEquals = exactEquals;
exports.equals = equals;

var _common = require('./common');

var glMatrix = _interopRequireWildcard(_common);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * 3x3 Matrix
 * @module mat3
 */

/**
 * Creates a new identity mat3
 *
 * @returns {mat3} a new 3x3 matrix
 */
function create() {
  let out = new glMatrix.ARRAY_TYPE(9);
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}

/**
 * Copies the upper-left 3x3 values into the given mat3.
 *
 * @param {mat3} out the receiving 3x3 matrix
 * @param {mat4} a   the source 4x4 matrix
 * @returns {mat3} out
 */
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

function fromMat4(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[4];
  out[4] = a[5];
  out[5] = a[6];
  out[6] = a[8];
  out[7] = a[9];
  out[8] = a[10];
  return out;
}

/**
 * Creates a new mat3 initialized with values from an existing matrix
 *
 * @param {mat3} a matrix to clone
 * @returns {mat3} a new 3x3 matrix
 */
function clone(a) {
  let out = new glMatrix.ARRAY_TYPE(9);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}

/**
 * Copy the values from one mat3 to another
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}

/**
 * Create a new mat3 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} A new mat3
 */
function fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  let out = new glMatrix.ARRAY_TYPE(9);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}

/**
 * Set the components of a mat3 to the given values
 *
 * @param {mat3} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} out
 */
function set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}

/**
 * Set a mat3 to the identity matrix
 *
 * @param {mat3} out the receiving matrix
 * @returns {mat3} out
 */
function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}

/**
 * Transpose the values of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    let a01 = a[1],
        a02 = a[2],
        a12 = a[5];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a01;
    out[5] = a[7];
    out[6] = a02;
    out[7] = a12;
  } else {
    out[0] = a[0];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a[1];
    out[4] = a[4];
    out[5] = a[7];
    out[6] = a[2];
    out[7] = a[5];
    out[8] = a[8];
  }

  return out;
}

/**
 * Inverts a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
function invert(out, a) {
  let a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  let a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  let a20 = a[6],
      a21 = a[7],
      a22 = a[8];

  let b01 = a22 * a11 - a12 * a21;
  let b11 = -a22 * a10 + a12 * a20;
  let b21 = a21 * a10 - a11 * a20;

  // Calculate the determinant
  let det = a00 * b01 + a01 * b11 + a02 * b21;

  if (!det) {
    return null;
  }
  det = 1.0 / det;

  out[0] = b01 * det;
  out[1] = (-a22 * a01 + a02 * a21) * det;
  out[2] = (a12 * a01 - a02 * a11) * det;
  out[3] = b11 * det;
  out[4] = (a22 * a00 - a02 * a20) * det;
  out[5] = (-a12 * a00 + a02 * a10) * det;
  out[6] = b21 * det;
  out[7] = (-a21 * a00 + a01 * a20) * det;
  out[8] = (a11 * a00 - a01 * a10) * det;
  return out;
}

/**
 * Calculates the adjugate of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
function adjoint(out, a) {
  let a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  let a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  let a20 = a[6],
      a21 = a[7],
      a22 = a[8];

  out[0] = a11 * a22 - a12 * a21;
  out[1] = a02 * a21 - a01 * a22;
  out[2] = a01 * a12 - a02 * a11;
  out[3] = a12 * a20 - a10 * a22;
  out[4] = a00 * a22 - a02 * a20;
  out[5] = a02 * a10 - a00 * a12;
  out[6] = a10 * a21 - a11 * a20;
  out[7] = a01 * a20 - a00 * a21;
  out[8] = a00 * a11 - a01 * a10;
  return out;
}

/**
 * Calculates the determinant of a mat3
 *
 * @param {mat3} a the source matrix
 * @returns {Number} determinant of a
 */
function determinant(a) {
  let a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  let a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  let a20 = a[6],
      a21 = a[7],
      a22 = a[8];

  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
}

/**
 * Multiplies two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
function multiply(out, a, b) {
  let a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  let a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  let a20 = a[6],
      a21 = a[7],
      a22 = a[8];

  let b00 = b[0],
      b01 = b[1],
      b02 = b[2];
  let b10 = b[3],
      b11 = b[4],
      b12 = b[5];
  let b20 = b[6],
      b21 = b[7],
      b22 = b[8];

  out[0] = b00 * a00 + b01 * a10 + b02 * a20;
  out[1] = b00 * a01 + b01 * a11 + b02 * a21;
  out[2] = b00 * a02 + b01 * a12 + b02 * a22;

  out[3] = b10 * a00 + b11 * a10 + b12 * a20;
  out[4] = b10 * a01 + b11 * a11 + b12 * a21;
  out[5] = b10 * a02 + b11 * a12 + b12 * a22;

  out[6] = b20 * a00 + b21 * a10 + b22 * a20;
  out[7] = b20 * a01 + b21 * a11 + b22 * a21;
  out[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return out;
}

/**
 * Translate a mat3 by the given vector
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to translate
 * @param {vec2} v vector to translate by
 * @returns {mat3} out
 */
function translate(out, a, v) {
  let a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a10 = a[3],
      a11 = a[4],
      a12 = a[5],
      a20 = a[6],
      a21 = a[7],
      a22 = a[8],
      x = v[0],
      y = v[1];

  out[0] = a00;
  out[1] = a01;
  out[2] = a02;

  out[3] = a10;
  out[4] = a11;
  out[5] = a12;

  out[6] = x * a00 + y * a10 + a20;
  out[7] = x * a01 + y * a11 + a21;
  out[8] = x * a02 + y * a12 + a22;
  return out;
}

/**
 * Rotates a mat3 by the given angle
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */
function rotate(out, a, rad) {
  let a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a10 = a[3],
      a11 = a[4],
      a12 = a[5],
      a20 = a[6],
      a21 = a[7],
      a22 = a[8],
      s = Math.sin(rad),
      c = Math.cos(rad);

  out[0] = c * a00 + s * a10;
  out[1] = c * a01 + s * a11;
  out[2] = c * a02 + s * a12;

  out[3] = c * a10 - s * a00;
  out[4] = c * a11 - s * a01;
  out[5] = c * a12 - s * a02;

  out[6] = a20;
  out[7] = a21;
  out[8] = a22;
  return out;
};

/**
 * Scales the mat3 by the dimensions in the given vec2
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat3} out
 **/
function scale(out, a, v) {
  let x = v[0],
      y = v[1];

  out[0] = x * a[0];
  out[1] = x * a[1];
  out[2] = x * a[2];

  out[3] = y * a[3];
  out[4] = y * a[4];
  out[5] = y * a[5];

  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.translate(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {vec2} v Translation vector
 * @returns {mat3} out
 */
function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = v[0];
  out[7] = v[1];
  out[8] = 1;
  return out;
}

/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.rotate(dest, dest, rad);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */
function fromRotation(out, rad) {
  let s = Math.sin(rad),
      c = Math.cos(rad);

  out[0] = c;
  out[1] = s;
  out[2] = 0;

  out[3] = -s;
  out[4] = c;
  out[5] = 0;

  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.scale(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat3} out
 */
function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;

  out[3] = 0;
  out[4] = v[1];
  out[5] = 0;

  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}

/**
 * Copies the values from a mat2d into a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat2d} a the matrix to copy
 * @returns {mat3} out
 **/
function fromMat2d(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = 0;

  out[3] = a[2];
  out[4] = a[3];
  out[5] = 0;

  out[6] = a[4];
  out[7] = a[5];
  out[8] = 1;
  return out;
}

/**
* Calculates a 3x3 matrix from the given quaternion
*
* @param {mat3} out mat3 receiving operation result
* @param {quat} q Quaternion to create matrix from
*
* @returns {mat3} out
*/
function fromQuat(out, q) {
  let x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  let x2 = x + x;
  let y2 = y + y;
  let z2 = z + z;

  let xx = x * x2;
  let yx = y * x2;
  let yy = y * y2;
  let zx = z * x2;
  let zy = z * y2;
  let zz = z * z2;
  let wx = w * x2;
  let wy = w * y2;
  let wz = w * z2;

  out[0] = 1 - yy - zz;
  out[3] = yx - wz;
  out[6] = zx + wy;

  out[1] = yx + wz;
  out[4] = 1 - xx - zz;
  out[7] = zy - wx;

  out[2] = zx - wy;
  out[5] = zy + wx;
  out[8] = 1 - xx - yy;

  return out;
}

/**
* Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
*
* @param {mat3} out mat3 receiving operation result
* @param {mat4} a Mat4 to derive the normal matrix from
*
* @returns {mat3} out
*/
function normalFromMat4(out, a) {
  let a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  let a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  let a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  let a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];

  let b00 = a00 * a11 - a01 * a10;
  let b01 = a00 * a12 - a02 * a10;
  let b02 = a00 * a13 - a03 * a10;
  let b03 = a01 * a12 - a02 * a11;
  let b04 = a01 * a13 - a03 * a11;
  let b05 = a02 * a13 - a03 * a12;
  let b06 = a20 * a31 - a21 * a30;
  let b07 = a20 * a32 - a22 * a30;
  let b08 = a20 * a33 - a23 * a30;
  let b09 = a21 * a32 - a22 * a31;
  let b10 = a21 * a33 - a23 * a31;
  let b11 = a22 * a33 - a23 * a32;

  // Calculate the determinant
  let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  if (!det) {
    return null;
  }
  det = 1.0 / det;

  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;

  out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;

  out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;

  return out;
}

/**
 * Generates a 2D projection matrix with the given bounds
 *
 * @param {mat3} out mat3 frustum matrix will be written into
 * @param {number} width Width of your gl context
 * @param {number} height Height of gl context
 * @returns {mat3} out
 */
function projection(out, width, height) {
  out[0] = 2 / width;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = -2 / height;
  out[5] = 0;
  out[6] = -1;
  out[7] = 1;
  out[8] = 1;
  return out;
}

/**
 * Returns a string representation of a mat3
 *
 * @param {mat3} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
function str(a) {
  return 'mat3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' + a[8] + ')';
}

/**
 * Returns Frobenius norm of a mat3
 *
 * @param {mat3} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
function frob(a) {
  return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2));
}

/**
 * Adds two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  return out;
}

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  return out;
}

/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat3} out
 */
function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  return out;
}

/**
 * Adds two mat3's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat3} out the receiving vector
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat3} out
 */
function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  out[6] = a[6] + b[6] * scale;
  out[7] = a[7] + b[7] * scale;
  out[8] = a[8] + b[8] * scale;
  return out;
}

/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat3} a The first matrix.
 * @param {mat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8];
}

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat3} a The first matrix.
 * @param {mat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function equals(a, b) {
  let a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5],
      a6 = a[6],
      a7 = a[7],
      a8 = a[8];
  let b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5],
      b6 = b[6],
      b7 = b[7],
      b8 = b[8];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8));
}

/**
 * Alias for {@link mat3.multiply}
 * @function
 */
const mul = exports.mul = multiply;

/**
 * Alias for {@link mat3.subtract}
 * @function
 */
const sub = exports.sub = subtract;
},{"./common":"..\\node_modules\\gl-matrix\\src\\gl-matrix\\common.js"}],"..\\node_modules\\gl-matrix\\src\\gl-matrix\\mat4.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.sub = exports.mul = undefined;
exports.create = create;
exports.clone = clone;
exports.copy = copy;
exports.fromValues = fromValues;
exports.set = set;
exports.identity = identity;
exports.transpose = transpose;
exports.invert = invert;
exports.adjoint = adjoint;
exports.determinant = determinant;
exports.multiply = multiply;
exports.translate = translate;
exports.scale = scale;
exports.rotate = rotate;
exports.rotateX = rotateX;
exports.rotateY = rotateY;
exports.rotateZ = rotateZ;
exports.fromTranslation = fromTranslation;
exports.fromScaling = fromScaling;
exports.fromRotation = fromRotation;
exports.fromXRotation = fromXRotation;
exports.fromYRotation = fromYRotation;
exports.fromZRotation = fromZRotation;
exports.fromRotationTranslation = fromRotationTranslation;
exports.getTranslation = getTranslation;
exports.getScaling = getScaling;
exports.getRotation = getRotation;
exports.fromRotationTranslationScale = fromRotationTranslationScale;
exports.fromRotationTranslationScaleOrigin = fromRotationTranslationScaleOrigin;
exports.fromQuat = fromQuat;
exports.frustum = frustum;
exports.perspective = perspective;
exports.perspectiveFromFieldOfView = perspectiveFromFieldOfView;
exports.ortho = ortho;
exports.lookAt = lookAt;
exports.targetTo = targetTo;
exports.str = str;
exports.frob = frob;
exports.add = add;
exports.subtract = subtract;
exports.multiplyScalar = multiplyScalar;
exports.multiplyScalarAndAdd = multiplyScalarAndAdd;
exports.exactEquals = exactEquals;
exports.equals = equals;

var _common = require('./common');

var glMatrix = _interopRequireWildcard(_common);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * 4x4 Matrix
 * @module mat4
 */

/**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */
function create() {
  let out = new glMatrix.ARRAY_TYPE(16);
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

/**
 * Creates a new mat4 initialized with values from an existing matrix
 *
 * @param {mat4} a matrix to clone
 * @returns {mat4} a new 4x4 matrix
 */
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

function clone(a) {
  let out = new glMatrix.ARRAY_TYPE(16);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}

/**
 * Copy the values from one mat4 to another
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}

/**
 * Create a new mat4 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} A new mat4
 */
function fromValues(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  let out = new glMatrix.ARRAY_TYPE(16);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}

/**
 * Set the components of a mat4 to the given values
 *
 * @param {mat4} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} out
 */
function set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}

/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */
function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

/**
 * Transpose the values of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    let a01 = a[1],
        a02 = a[2],
        a03 = a[3];
    let a12 = a[6],
        a13 = a[7];
    let a23 = a[11];

    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a01;
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a02;
    out[9] = a12;
    out[11] = a[14];
    out[12] = a03;
    out[13] = a13;
    out[14] = a23;
  } else {
    out[0] = a[0];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a[1];
    out[5] = a[5];
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a[2];
    out[9] = a[6];
    out[10] = a[10];
    out[11] = a[14];
    out[12] = a[3];
    out[13] = a[7];
    out[14] = a[11];
    out[15] = a[15];
  }

  return out;
}

/**
 * Inverts a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
function invert(out, a) {
  let a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  let a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  let a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  let a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];

  let b00 = a00 * a11 - a01 * a10;
  let b01 = a00 * a12 - a02 * a10;
  let b02 = a00 * a13 - a03 * a10;
  let b03 = a01 * a12 - a02 * a11;
  let b04 = a01 * a13 - a03 * a11;
  let b05 = a02 * a13 - a03 * a12;
  let b06 = a20 * a31 - a21 * a30;
  let b07 = a20 * a32 - a22 * a30;
  let b08 = a20 * a33 - a23 * a30;
  let b09 = a21 * a32 - a22 * a31;
  let b10 = a21 * a33 - a23 * a31;
  let b11 = a22 * a33 - a23 * a32;

  // Calculate the determinant
  let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  if (!det) {
    return null;
  }
  det = 1.0 / det;

  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;

  return out;
}

/**
 * Calculates the adjugate of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
function adjoint(out, a) {
  let a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  let a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  let a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  let a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];

  out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);
  out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
  out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);
  out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
  out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
  out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);
  out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
  out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);
  out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);
  out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
  out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);
  out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
  out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
  out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);
  out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
  out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);
  return out;
}

/**
 * Calculates the determinant of a mat4
 *
 * @param {mat4} a the source matrix
 * @returns {Number} determinant of a
 */
function determinant(a) {
  let a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  let a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  let a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  let a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];

  let b00 = a00 * a11 - a01 * a10;
  let b01 = a00 * a12 - a02 * a10;
  let b02 = a00 * a13 - a03 * a10;
  let b03 = a01 * a12 - a02 * a11;
  let b04 = a01 * a13 - a03 * a11;
  let b05 = a02 * a13 - a03 * a12;
  let b06 = a20 * a31 - a21 * a30;
  let b07 = a20 * a32 - a22 * a30;
  let b08 = a20 * a33 - a23 * a30;
  let b09 = a21 * a32 - a22 * a31;
  let b10 = a21 * a33 - a23 * a31;
  let b11 = a22 * a33 - a23 * a32;

  // Calculate the determinant
  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
}

/**
 * Multiplies two mat4s
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
function multiply(out, a, b) {
  let a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  let a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  let a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  let a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];

  // Cache only the current line of the second matrix
  let b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

  b0 = b[4];b1 = b[5];b2 = b[6];b3 = b[7];
  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

  b0 = b[8];b1 = b[9];b2 = b[10];b3 = b[11];
  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

  b0 = b[12];b1 = b[13];b2 = b[14];b3 = b[15];
  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  return out;
}

/**
 * Translate a mat4 by the given vector
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to translate
 * @param {vec3} v vector to translate by
 * @returns {mat4} out
 */
function translate(out, a, v) {
  let x = v[0],
      y = v[1],
      z = v[2];
  let a00, a01, a02, a03;
  let a10, a11, a12, a13;
  let a20, a21, a22, a23;

  if (a === out) {
    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
  } else {
    a00 = a[0];a01 = a[1];a02 = a[2];a03 = a[3];
    a10 = a[4];a11 = a[5];a12 = a[6];a13 = a[7];
    a20 = a[8];a21 = a[9];a22 = a[10];a23 = a[11];

    out[0] = a00;out[1] = a01;out[2] = a02;out[3] = a03;
    out[4] = a10;out[5] = a11;out[6] = a12;out[7] = a13;
    out[8] = a20;out[9] = a21;out[10] = a22;out[11] = a23;

    out[12] = a00 * x + a10 * y + a20 * z + a[12];
    out[13] = a01 * x + a11 * y + a21 * z + a[13];
    out[14] = a02 * x + a12 * y + a22 * z + a[14];
    out[15] = a03 * x + a13 * y + a23 * z + a[15];
  }

  return out;
}

/**
 * Scales the mat4 by the dimensions in the given vec3 not using vectorization
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {vec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/
function scale(out, a, v) {
  let x = v[0],
      y = v[1],
      z = v[2];

  out[0] = a[0] * x;
  out[1] = a[1] * x;
  out[2] = a[2] * x;
  out[3] = a[3] * x;
  out[4] = a[4] * y;
  out[5] = a[5] * y;
  out[6] = a[6] * y;
  out[7] = a[7] * y;
  out[8] = a[8] * z;
  out[9] = a[9] * z;
  out[10] = a[10] * z;
  out[11] = a[11] * z;
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}

/**
 * Rotates a mat4 by the given angle around the given axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */
function rotate(out, a, rad, axis) {
  let x = axis[0],
      y = axis[1],
      z = axis[2];
  let len = Math.sqrt(x * x + y * y + z * z);
  let s, c, t;
  let a00, a01, a02, a03;
  let a10, a11, a12, a13;
  let a20, a21, a22, a23;
  let b00, b01, b02;
  let b10, b11, b12;
  let b20, b21, b22;

  if (Math.abs(len) < glMatrix.EPSILON) {
    return null;
  }

  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;

  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c;

  a00 = a[0];a01 = a[1];a02 = a[2];a03 = a[3];
  a10 = a[4];a11 = a[5];a12 = a[6];a13 = a[7];
  a20 = a[8];a21 = a[9];a22 = a[10];a23 = a[11];

  // Construct the elements of the rotation matrix
  b00 = x * x * t + c;b01 = y * x * t + z * s;b02 = z * x * t - y * s;
  b10 = x * y * t - z * s;b11 = y * y * t + c;b12 = z * y * t + x * s;
  b20 = x * z * t + y * s;b21 = y * z * t - x * s;b22 = z * z * t + c;

  // Perform rotation-specific matrix multiplication
  out[0] = a00 * b00 + a10 * b01 + a20 * b02;
  out[1] = a01 * b00 + a11 * b01 + a21 * b02;
  out[2] = a02 * b00 + a12 * b01 + a22 * b02;
  out[3] = a03 * b00 + a13 * b01 + a23 * b02;
  out[4] = a00 * b10 + a10 * b11 + a20 * b12;
  out[5] = a01 * b10 + a11 * b11 + a21 * b12;
  out[6] = a02 * b10 + a12 * b11 + a22 * b12;
  out[7] = a03 * b10 + a13 * b11 + a23 * b12;
  out[8] = a00 * b20 + a10 * b21 + a20 * b22;
  out[9] = a01 * b20 + a11 * b21 + a21 * b22;
  out[10] = a02 * b20 + a12 * b21 + a22 * b22;
  out[11] = a03 * b20 + a13 * b21 + a23 * b22;

  if (a !== out) {
    // If the source and destination differ, copy the unchanged last row
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }
  return out;
}

/**
 * Rotates a matrix by the given angle around the X axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function rotateX(out, a, rad) {
  let s = Math.sin(rad);
  let c = Math.cos(rad);
  let a10 = a[4];
  let a11 = a[5];
  let a12 = a[6];
  let a13 = a[7];
  let a20 = a[8];
  let a21 = a[9];
  let a22 = a[10];
  let a23 = a[11];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged rows
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }

  // Perform axis-specific matrix multiplication
  out[4] = a10 * c + a20 * s;
  out[5] = a11 * c + a21 * s;
  out[6] = a12 * c + a22 * s;
  out[7] = a13 * c + a23 * s;
  out[8] = a20 * c - a10 * s;
  out[9] = a21 * c - a11 * s;
  out[10] = a22 * c - a12 * s;
  out[11] = a23 * c - a13 * s;
  return out;
}

/**
 * Rotates a matrix by the given angle around the Y axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function rotateY(out, a, rad) {
  let s = Math.sin(rad);
  let c = Math.cos(rad);
  let a00 = a[0];
  let a01 = a[1];
  let a02 = a[2];
  let a03 = a[3];
  let a20 = a[8];
  let a21 = a[9];
  let a22 = a[10];
  let a23 = a[11];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged rows
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }

  // Perform axis-specific matrix multiplication
  out[0] = a00 * c - a20 * s;
  out[1] = a01 * c - a21 * s;
  out[2] = a02 * c - a22 * s;
  out[3] = a03 * c - a23 * s;
  out[8] = a00 * s + a20 * c;
  out[9] = a01 * s + a21 * c;
  out[10] = a02 * s + a22 * c;
  out[11] = a03 * s + a23 * c;
  return out;
}

/**
 * Rotates a matrix by the given angle around the Z axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function rotateZ(out, a, rad) {
  let s = Math.sin(rad);
  let c = Math.cos(rad);
  let a00 = a[0];
  let a01 = a[1];
  let a02 = a[2];
  let a03 = a[3];
  let a10 = a[4];
  let a11 = a[5];
  let a12 = a[6];
  let a13 = a[7];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged last row
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }

  // Perform axis-specific matrix multiplication
  out[0] = a00 * c + a10 * s;
  out[1] = a01 * c + a11 * s;
  out[2] = a02 * c + a12 * s;
  out[3] = a03 * c + a13 * s;
  out[4] = a10 * c - a00 * s;
  out[5] = a11 * c - a01 * s;
  out[6] = a12 * c - a02 * s;
  out[7] = a13 * c - a03 * s;
  return out;
}

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */
function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.scale(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Scaling vector
 * @returns {mat4} out
 */
function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = v[1];
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = v[2];
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

/**
 * Creates a matrix from a given angle around a given axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotate(dest, dest, rad, axis);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */
function fromRotation(out, rad, axis) {
  let x = axis[0],
      y = axis[1],
      z = axis[2];
  let len = Math.sqrt(x * x + y * y + z * z);
  let s, c, t;

  if (Math.abs(len) < glMatrix.EPSILON) {
    return null;
  }

  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;

  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c;

  // Perform rotation-specific matrix multiplication
  out[0] = x * x * t + c;
  out[1] = y * x * t + z * s;
  out[2] = z * x * t - y * s;
  out[3] = 0;
  out[4] = x * y * t - z * s;
  out[5] = y * y * t + c;
  out[6] = z * y * t + x * s;
  out[7] = 0;
  out[8] = x * z * t + y * s;
  out[9] = y * z * t - x * s;
  out[10] = z * z * t + c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

/**
 * Creates a matrix from the given angle around the X axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateX(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function fromXRotation(out, rad) {
  let s = Math.sin(rad);
  let c = Math.cos(rad);

  // Perform axis-specific matrix multiplication
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = c;
  out[6] = s;
  out[7] = 0;
  out[8] = 0;
  out[9] = -s;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

/**
 * Creates a matrix from the given angle around the Y axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateY(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function fromYRotation(out, rad) {
  let s = Math.sin(rad);
  let c = Math.cos(rad);

  // Perform axis-specific matrix multiplication
  out[0] = c;
  out[1] = 0;
  out[2] = -s;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = s;
  out[9] = 0;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

/**
 * Creates a matrix from the given angle around the Z axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateZ(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function fromZRotation(out, rad) {
  let s = Math.sin(rad);
  let c = Math.cos(rad);

  // Perform axis-specific matrix multiplication
  out[0] = c;
  out[1] = s;
  out[2] = 0;
  out[3] = 0;
  out[4] = -s;
  out[5] = c;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

/**
 * Creates a matrix from a quaternion rotation and vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */
function fromRotationTranslation(out, q, v) {
  // Quaternion math
  let x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  let x2 = x + x;
  let y2 = y + y;
  let z2 = z + z;

  let xx = x * x2;
  let xy = x * y2;
  let xz = x * z2;
  let yy = y * y2;
  let yz = y * z2;
  let zz = z * z2;
  let wx = w * x2;
  let wy = w * y2;
  let wz = w * z2;

  out[0] = 1 - (yy + zz);
  out[1] = xy + wz;
  out[2] = xz - wy;
  out[3] = 0;
  out[4] = xy - wz;
  out[5] = 1 - (xx + zz);
  out[6] = yz + wx;
  out[7] = 0;
  out[8] = xz + wy;
  out[9] = yz - wx;
  out[10] = 1 - (xx + yy);
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;

  return out;
}

/**
 * Returns the translation vector component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslation,
 *  the returned vector will be the same as the translation vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive translation component
 * @param  {mat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */
function getTranslation(out, mat) {
  out[0] = mat[12];
  out[1] = mat[13];
  out[2] = mat[14];

  return out;
}

/**
 * Returns the scaling factor component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslationScale
 *  with a normalized Quaternion paramter, the returned vector will be
 *  the same as the scaling vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive scaling factor component
 * @param  {mat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */
function getScaling(out, mat) {
  let m11 = mat[0];
  let m12 = mat[1];
  let m13 = mat[2];
  let m21 = mat[4];
  let m22 = mat[5];
  let m23 = mat[6];
  let m31 = mat[8];
  let m32 = mat[9];
  let m33 = mat[10];

  out[0] = Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13);
  out[1] = Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23);
  out[2] = Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33);

  return out;
}

/**
 * Returns a quaternion representing the rotational component
 *  of a transformation matrix. If a matrix is built with
 *  fromRotationTranslation, the returned quaternion will be the
 *  same as the quaternion originally supplied.
 * @param {quat} out Quaternion to receive the rotation component
 * @param {mat4} mat Matrix to be decomposed (input)
 * @return {quat} out
 */
function getRotation(out, mat) {
  // Algorithm taken from http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
  let trace = mat[0] + mat[5] + mat[10];
  let S = 0;

  if (trace > 0) {
    S = Math.sqrt(trace + 1.0) * 2;
    out[3] = 0.25 * S;
    out[0] = (mat[6] - mat[9]) / S;
    out[1] = (mat[8] - mat[2]) / S;
    out[2] = (mat[1] - mat[4]) / S;
  } else if (mat[0] > mat[5] & mat[0] > mat[10]) {
    S = Math.sqrt(1.0 + mat[0] - mat[5] - mat[10]) * 2;
    out[3] = (mat[6] - mat[9]) / S;
    out[0] = 0.25 * S;
    out[1] = (mat[1] + mat[4]) / S;
    out[2] = (mat[8] + mat[2]) / S;
  } else if (mat[5] > mat[10]) {
    S = Math.sqrt(1.0 + mat[5] - mat[0] - mat[10]) * 2;
    out[3] = (mat[8] - mat[2]) / S;
    out[0] = (mat[1] + mat[4]) / S;
    out[1] = 0.25 * S;
    out[2] = (mat[6] + mat[9]) / S;
  } else {
    S = Math.sqrt(1.0 + mat[10] - mat[0] - mat[5]) * 2;
    out[3] = (mat[1] - mat[4]) / S;
    out[0] = (mat[8] + mat[2]) / S;
    out[1] = (mat[6] + mat[9]) / S;
    out[2] = 0.25 * S;
  }

  return out;
}

/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @param {vec3} s Scaling vector
 * @returns {mat4} out
 */
function fromRotationTranslationScale(out, q, v, s) {
  // Quaternion math
  let x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  let x2 = x + x;
  let y2 = y + y;
  let z2 = z + z;

  let xx = x * x2;
  let xy = x * y2;
  let xz = x * z2;
  let yy = y * y2;
  let yz = y * z2;
  let zz = z * z2;
  let wx = w * x2;
  let wy = w * y2;
  let wz = w * z2;
  let sx = s[0];
  let sy = s[1];
  let sz = s[2];

  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;

  return out;
}

/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     mat4.translate(dest, origin);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *     mat4.translate(dest, negativeOrigin);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @param {vec3} s Scaling vector
 * @param {vec3} o The origin vector around which to scale and rotate
 * @returns {mat4} out
 */
function fromRotationTranslationScaleOrigin(out, q, v, s, o) {
  // Quaternion math
  let x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  let x2 = x + x;
  let y2 = y + y;
  let z2 = z + z;

  let xx = x * x2;
  let xy = x * y2;
  let xz = x * z2;
  let yy = y * y2;
  let yz = y * z2;
  let zz = z * z2;
  let wx = w * x2;
  let wy = w * y2;
  let wz = w * z2;

  let sx = s[0];
  let sy = s[1];
  let sz = s[2];

  let ox = o[0];
  let oy = o[1];
  let oz = o[2];

  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v[0] + ox - (out[0] * ox + out[4] * oy + out[8] * oz);
  out[13] = v[1] + oy - (out[1] * ox + out[5] * oy + out[9] * oz);
  out[14] = v[2] + oz - (out[2] * ox + out[6] * oy + out[10] * oz);
  out[15] = 1;

  return out;
}

/**
 * Calculates a 4x4 matrix from the given quaternion
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat} q Quaternion to create matrix from
 *
 * @returns {mat4} out
 */
function fromQuat(out, q) {
  let x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  let x2 = x + x;
  let y2 = y + y;
  let z2 = z + z;

  let xx = x * x2;
  let yx = y * x2;
  let yy = y * y2;
  let zx = z * x2;
  let zy = z * y2;
  let zz = z * z2;
  let wx = w * x2;
  let wy = w * y2;
  let wz = w * z2;

  out[0] = 1 - yy - zz;
  out[1] = yx + wz;
  out[2] = zx - wy;
  out[3] = 0;

  out[4] = yx - wz;
  out[5] = 1 - xx - zz;
  out[6] = zy + wx;
  out[7] = 0;

  out[8] = zx + wy;
  out[9] = zy - wx;
  out[10] = 1 - xx - yy;
  out[11] = 0;

  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;

  return out;
}

/**
 * Generates a frustum matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Number} left Left bound of the frustum
 * @param {Number} right Right bound of the frustum
 * @param {Number} bottom Bottom bound of the frustum
 * @param {Number} top Top bound of the frustum
 * @param {Number} near Near bound of the frustum
 * @param {Number} far Far bound of the frustum
 * @returns {mat4} out
 */
function frustum(out, left, right, bottom, top, near, far) {
  let rl = 1 / (right - left);
  let tb = 1 / (top - bottom);
  let nf = 1 / (near - far);
  out[0] = near * 2 * rl;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = near * 2 * tb;
  out[6] = 0;
  out[7] = 0;
  out[8] = (right + left) * rl;
  out[9] = (top + bottom) * tb;
  out[10] = (far + near) * nf;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = far * near * 2 * nf;
  out[15] = 0;
  return out;
}

/**
 * Generates a perspective projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
function perspective(out, fovy, aspect, near, far) {
  let f = 1.0 / Math.tan(fovy / 2);
  let nf = 1 / (near - far);
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = (far + near) * nf;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = 2 * far * near * nf;
  out[15] = 0;
  return out;
}

/**
 * Generates a perspective projection matrix with the given field of view.
 * This is primarily useful for generating projection matrices to be used
 * with the still experiemental WebVR API.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
function perspectiveFromFieldOfView(out, fov, near, far) {
  let upTan = Math.tan(fov.upDegrees * Math.PI / 180.0);
  let downTan = Math.tan(fov.downDegrees * Math.PI / 180.0);
  let leftTan = Math.tan(fov.leftDegrees * Math.PI / 180.0);
  let rightTan = Math.tan(fov.rightDegrees * Math.PI / 180.0);
  let xScale = 2.0 / (leftTan + rightTan);
  let yScale = 2.0 / (upTan + downTan);

  out[0] = xScale;
  out[1] = 0.0;
  out[2] = 0.0;
  out[3] = 0.0;
  out[4] = 0.0;
  out[5] = yScale;
  out[6] = 0.0;
  out[7] = 0.0;
  out[8] = -((leftTan - rightTan) * xScale * 0.5);
  out[9] = (upTan - downTan) * yScale * 0.5;
  out[10] = far / (near - far);
  out[11] = -1.0;
  out[12] = 0.0;
  out[13] = 0.0;
  out[14] = far * near / (near - far);
  out[15] = 0.0;
  return out;
}

/**
 * Generates a orthogonal projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
function ortho(out, left, right, bottom, top, near, far) {
  let lr = 1 / (left - right);
  let bt = 1 / (bottom - top);
  let nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 2 * nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = (far + near) * nf;
  out[15] = 1;
  return out;
}

/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */
function lookAt(out, eye, center, up) {
  let x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
  let eyex = eye[0];
  let eyey = eye[1];
  let eyez = eye[2];
  let upx = up[0];
  let upy = up[1];
  let upz = up[2];
  let centerx = center[0];
  let centery = center[1];
  let centerz = center[2];

  if (Math.abs(eyex - centerx) < glMatrix.EPSILON && Math.abs(eyey - centery) < glMatrix.EPSILON && Math.abs(eyez - centerz) < glMatrix.EPSILON) {
    return mat4.identity(out);
  }

  z0 = eyex - centerx;
  z1 = eyey - centery;
  z2 = eyez - centerz;

  len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
  z0 *= len;
  z1 *= len;
  z2 *= len;

  x0 = upy * z2 - upz * z1;
  x1 = upz * z0 - upx * z2;
  x2 = upx * z1 - upy * z0;
  len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
  if (!len) {
    x0 = 0;
    x1 = 0;
    x2 = 0;
  } else {
    len = 1 / len;
    x0 *= len;
    x1 *= len;
    x2 *= len;
  }

  y0 = z1 * x2 - z2 * x1;
  y1 = z2 * x0 - z0 * x2;
  y2 = z0 * x1 - z1 * x0;

  len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
  if (!len) {
    y0 = 0;
    y1 = 0;
    y2 = 0;
  } else {
    len = 1 / len;
    y0 *= len;
    y1 *= len;
    y2 *= len;
  }

  out[0] = x0;
  out[1] = y0;
  out[2] = z0;
  out[3] = 0;
  out[4] = x1;
  out[5] = y1;
  out[6] = z1;
  out[7] = 0;
  out[8] = x2;
  out[9] = y2;
  out[10] = z2;
  out[11] = 0;
  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
  out[15] = 1;

  return out;
}

/**
 * Generates a matrix that makes something look at something else.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */
function targetTo(out, eye, target, up) {
  let eyex = eye[0],
      eyey = eye[1],
      eyez = eye[2],
      upx = up[0],
      upy = up[1],
      upz = up[2];

  let z0 = eyex - target[0],
      z1 = eyey - target[1],
      z2 = eyez - target[2];

  let len = z0 * z0 + z1 * z1 + z2 * z2;
  if (len > 0) {
    len = 1 / Math.sqrt(len);
    z0 *= len;
    z1 *= len;
    z2 *= len;
  }

  let x0 = upy * z2 - upz * z1,
      x1 = upz * z0 - upx * z2,
      x2 = upx * z1 - upy * z0;

  out[0] = x0;
  out[1] = x1;
  out[2] = x2;
  out[3] = 0;
  out[4] = z1 * x2 - z2 * x1;
  out[5] = z2 * x0 - z0 * x2;
  out[6] = z0 * x1 - z1 * x0;
  out[7] = 0;
  out[8] = z0;
  out[9] = z1;
  out[10] = z2;
  out[11] = 0;
  out[12] = eyex;
  out[13] = eyey;
  out[14] = eyez;
  out[15] = 1;
  return out;
};

/**
 * Returns a string representation of a mat4
 *
 * @param {mat4} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
function str(a) {
  return 'mat4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' + a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' + a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ')';
}

/**
 * Returns Frobenius norm of a mat4
 *
 * @param {mat4} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
function frob(a) {
  return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2) + Math.pow(a[9], 2) + Math.pow(a[10], 2) + Math.pow(a[11], 2) + Math.pow(a[12], 2) + Math.pow(a[13], 2) + Math.pow(a[14], 2) + Math.pow(a[15], 2));
}

/**
 * Adds two mat4's
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  out[9] = a[9] + b[9];
  out[10] = a[10] + b[10];
  out[11] = a[11] + b[11];
  out[12] = a[12] + b[12];
  out[13] = a[13] + b[13];
  out[14] = a[14] + b[14];
  out[15] = a[15] + b[15];
  return out;
}

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  out[9] = a[9] - b[9];
  out[10] = a[10] - b[10];
  out[11] = a[11] - b[11];
  out[12] = a[12] - b[12];
  out[13] = a[13] - b[13];
  out[14] = a[14] - b[14];
  out[15] = a[15] - b[15];
  return out;
}

/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat4} out
 */
function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  out[9] = a[9] * b;
  out[10] = a[10] * b;
  out[11] = a[11] * b;
  out[12] = a[12] * b;
  out[13] = a[13] * b;
  out[14] = a[14] * b;
  out[15] = a[15] * b;
  return out;
}

/**
 * Adds two mat4's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat4} out the receiving vector
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat4} out
 */
function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  out[6] = a[6] + b[6] * scale;
  out[7] = a[7] + b[7] * scale;
  out[8] = a[8] + b[8] * scale;
  out[9] = a[9] + b[9] * scale;
  out[10] = a[10] + b[10] * scale;
  out[11] = a[11] + b[11] * scale;
  out[12] = a[12] + b[12] * scale;
  out[13] = a[13] + b[13] * scale;
  out[14] = a[14] + b[14] * scale;
  out[15] = a[15] + b[15] * scale;
  return out;
}

/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat4} a The first matrix.
 * @param {mat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
}

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat4} a The first matrix.
 * @param {mat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function equals(a, b) {
  let a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  let a4 = a[4],
      a5 = a[5],
      a6 = a[6],
      a7 = a[7];
  let a8 = a[8],
      a9 = a[9],
      a10 = a[10],
      a11 = a[11];
  let a12 = a[12],
      a13 = a[13],
      a14 = a[14],
      a15 = a[15];

  let b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  let b4 = b[4],
      b5 = b[5],
      b6 = b[6],
      b7 = b[7];
  let b8 = b[8],
      b9 = b[9],
      b10 = b[10],
      b11 = b[11];
  let b12 = b[12],
      b13 = b[13],
      b14 = b[14],
      b15 = b[15];

  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a15), Math.abs(b15));
}

/**
 * Alias for {@link mat4.multiply}
 * @function
 */
const mul = exports.mul = multiply;

/**
 * Alias for {@link mat4.subtract}
 * @function
 */
const sub = exports.sub = subtract;
},{"./common":"..\\node_modules\\gl-matrix\\src\\gl-matrix\\common.js"}],"..\\node_modules\\gl-matrix\\src\\gl-matrix\\vec3.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.forEach = exports.sqrLen = exports.len = exports.sqrDist = exports.dist = exports.div = exports.mul = exports.sub = undefined;
exports.create = create;
exports.clone = clone;
exports.length = length;
exports.fromValues = fromValues;
exports.copy = copy;
exports.set = set;
exports.add = add;
exports.subtract = subtract;
exports.multiply = multiply;
exports.divide = divide;
exports.ceil = ceil;
exports.floor = floor;
exports.min = min;
exports.max = max;
exports.round = round;
exports.scale = scale;
exports.scaleAndAdd = scaleAndAdd;
exports.distance = distance;
exports.squaredDistance = squaredDistance;
exports.squaredLength = squaredLength;
exports.negate = negate;
exports.inverse = inverse;
exports.normalize = normalize;
exports.dot = dot;
exports.cross = cross;
exports.lerp = lerp;
exports.hermite = hermite;
exports.bezier = bezier;
exports.random = random;
exports.transformMat4 = transformMat4;
exports.transformMat3 = transformMat3;
exports.transformQuat = transformQuat;
exports.rotateX = rotateX;
exports.rotateY = rotateY;
exports.rotateZ = rotateZ;
exports.angle = angle;
exports.str = str;
exports.exactEquals = exactEquals;
exports.equals = equals;

var _common = require('./common');

var glMatrix = _interopRequireWildcard(_common);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * 3 Dimensional Vector
 * @module vec3
 */

/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */
function create() {
  let out = new glMatrix.ARRAY_TYPE(3);
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  return out;
}

/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {vec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(3);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}

/**
 * Calculates the length of a vec3
 *
 * @param {vec3} a vector to calculate length of
 * @returns {Number} length of a
 */
function length(a) {
  let x = a[0];
  let y = a[1];
  let z = a[2];
  return Math.sqrt(x * x + y * y + z * z);
}

/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */
function fromValues(x, y, z) {
  let out = new glMatrix.ARRAY_TYPE(3);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}

/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the source vector
 * @returns {vec3} out
 */
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}

/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */
function set(out, x, y, z) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}

/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}

/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  return out;
}

/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  return out;
}

/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  return out;
}

/**
 * Math.ceil the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to ceil
 * @returns {vec3} out
 */
function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  return out;
}

/**
 * Math.floor the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to floor
 * @returns {vec3} out
 */
function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  return out;
}

/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  return out;
}

/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  return out;
}

/**
 * Math.round the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to round
 * @returns {vec3} out
 */
function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  return out;
}

/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */
function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  return out;
}

/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */
function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  return out;
}

/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} distance between a and b
 */
function distance(a, b) {
  let x = b[0] - a[0];
  let y = b[1] - a[1];
  let z = b[2] - a[2];
  return Math.sqrt(x * x + y * y + z * z);
}

/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} squared distance between a and b
 */
function squaredDistance(a, b) {
  let x = b[0] - a[0];
  let y = b[1] - a[1];
  let z = b[2] - a[2];
  return x * x + y * y + z * z;
}

/**
 * Calculates the squared length of a vec3
 *
 * @param {vec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
function squaredLength(a) {
  let x = a[0];
  let y = a[1];
  let z = a[2];
  return x * x + y * y + z * z;
}

/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to negate
 * @returns {vec3} out
 */
function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  return out;
}

/**
 * Returns the inverse of the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to invert
 * @returns {vec3} out
 */
function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  return out;
}

/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to normalize
 * @returns {vec3} out
 */
function normalize(out, a) {
  let x = a[0];
  let y = a[1];
  let z = a[2];
  let len = x * x + y * y + z * z;
  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
    out[0] = a[0] * len;
    out[1] = a[1] * len;
    out[2] = a[2] * len;
  }
  return out;
}

/**
 * Calculates the dot product of two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} dot product of a and b
 */
function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}

/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function cross(out, a, b) {
  let ax = a[0],
      ay = a[1],
      az = a[2];
  let bx = b[0],
      by = b[1],
      bz = b[2];

  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}

/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */
function lerp(out, a, b, t) {
  let ax = a[0];
  let ay = a[1];
  let az = a[2];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  return out;
}

/**
 * Performs a hermite interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {vec3} c the third operand
 * @param {vec3} d the fourth operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */
function hermite(out, a, b, c, d, t) {
  let factorTimes2 = t * t;
  let factor1 = factorTimes2 * (2 * t - 3) + 1;
  let factor2 = factorTimes2 * (t - 2) + t;
  let factor3 = factorTimes2 * (t - 1);
  let factor4 = factorTimes2 * (3 - 2 * t);

  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;

  return out;
}

/**
 * Performs a bezier interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {vec3} c the third operand
 * @param {vec3} d the fourth operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */
function bezier(out, a, b, c, d, t) {
  let inverseFactor = 1 - t;
  let inverseFactorTimesTwo = inverseFactor * inverseFactor;
  let factorTimes2 = t * t;
  let factor1 = inverseFactorTimesTwo * inverseFactor;
  let factor2 = 3 * t * inverseFactorTimesTwo;
  let factor3 = 3 * factorTimes2 * inverseFactor;
  let factor4 = factorTimes2 * t;

  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;

  return out;
}

/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec3} out
 */
function random(out, scale) {
  scale = scale || 1.0;

  let r = glMatrix.RANDOM() * 2.0 * Math.PI;
  let z = glMatrix.RANDOM() * 2.0 - 1.0;
  let zScale = Math.sqrt(1.0 - z * z) * scale;

  out[0] = Math.cos(r) * zScale;
  out[1] = Math.sin(r) * zScale;
  out[2] = z * scale;
  return out;
}

/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec3} out
 */
function transformMat4(out, a, m) {
  let x = a[0],
      y = a[1],
      z = a[2];
  let w = m[3] * x + m[7] * y + m[11] * z + m[15];
  w = w || 1.0;
  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
  return out;
}

/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat3} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */
function transformMat3(out, a, m) {
  let x = a[0],
      y = a[1],
      z = a[2];
  out[0] = x * m[0] + y * m[3] + z * m[6];
  out[1] = x * m[1] + y * m[4] + z * m[7];
  out[2] = x * m[2] + y * m[5] + z * m[8];
  return out;
}

/**
 * Transforms the vec3 with a quat
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec3} out
 */
function transformQuat(out, a, q) {
  // benchmarks: http://jsperf.com/quaternion-transform-vec3-implementations

  let x = a[0],
      y = a[1],
      z = a[2];
  let qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3];

  // calculate quat * vec
  let ix = qw * x + qy * z - qz * y;
  let iy = qw * y + qz * x - qx * z;
  let iz = qw * z + qx * y - qy * x;
  let iw = -qx * x - qy * y - qz * z;

  // calculate result * inverse quat
  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
  return out;
}

/**
 * Rotate a 3D vector around the x-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
function rotateX(out, a, b, c) {
  let p = [],
      r = [];
  //Translate point to the origin
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];

  //perform rotation
  r[0] = p[0];
  r[1] = p[1] * Math.cos(c) - p[2] * Math.sin(c);
  r[2] = p[1] * Math.sin(c) + p[2] * Math.cos(c);

  //translate to correct position
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];

  return out;
}

/**
 * Rotate a 3D vector around the y-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
function rotateY(out, a, b, c) {
  let p = [],
      r = [];
  //Translate point to the origin
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];

  //perform rotation
  r[0] = p[2] * Math.sin(c) + p[0] * Math.cos(c);
  r[1] = p[1];
  r[2] = p[2] * Math.cos(c) - p[0] * Math.sin(c);

  //translate to correct position
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];

  return out;
}

/**
 * Rotate a 3D vector around the z-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
function rotateZ(out, a, b, c) {
  let p = [],
      r = [];
  //Translate point to the origin
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];

  //perform rotation
  r[0] = p[0] * Math.cos(c) - p[1] * Math.sin(c);
  r[1] = p[0] * Math.sin(c) + p[1] * Math.cos(c);
  r[2] = p[2];

  //translate to correct position
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];

  return out;
}

/**
 * Get the angle between two 3D vectors
 * @param {vec3} a The first operand
 * @param {vec3} b The second operand
 * @returns {Number} The angle in radians
 */
function angle(a, b) {
  let tempA = fromValues(a[0], a[1], a[2]);
  let tempB = fromValues(b[0], b[1], b[2]);

  normalize(tempA, tempA);
  normalize(tempB, tempB);

  let cosine = dot(tempA, tempB);

  if (cosine > 1.0) {
    return 0;
  } else if (cosine < -1.0) {
    return Math.PI;
  } else {
    return Math.acos(cosine);
  }
}

/**
 * Returns a string representation of a vector
 *
 * @param {vec3} a vector to represent as a string
 * @returns {String} string representation of the vector
 */
function str(a) {
  return 'vec3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ')';
}

/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
}

/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function equals(a, b) {
  let a0 = a[0],
      a1 = a[1],
      a2 = a[2];
  let b0 = b[0],
      b1 = b[1],
      b2 = b[2];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2));
}

/**
 * Alias for {@link vec3.subtract}
 * @function
 */
const sub = exports.sub = subtract;

/**
 * Alias for {@link vec3.multiply}
 * @function
 */
const mul = exports.mul = multiply;

/**
 * Alias for {@link vec3.divide}
 * @function
 */
const div = exports.div = divide;

/**
 * Alias for {@link vec3.distance}
 * @function
 */
const dist = exports.dist = distance;

/**
 * Alias for {@link vec3.squaredDistance}
 * @function
 */
const sqrDist = exports.sqrDist = squaredDistance;

/**
 * Alias for {@link vec3.length}
 * @function
 */
const len = exports.len = length;

/**
 * Alias for {@link vec3.squaredLength}
 * @function
 */
const sqrLen = exports.sqrLen = squaredLength;

/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
const forEach = exports.forEach = function () {
  let vec = create();

  return function (a, stride, offset, count, fn, arg) {
    let i, l;
    if (!stride) {
      stride = 3;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];vec[1] = a[i + 1];vec[2] = a[i + 2];
      fn(vec, vec, arg);
      a[i] = vec[0];a[i + 1] = vec[1];a[i + 2] = vec[2];
    }

    return a;
  };
}();
},{"./common":"..\\node_modules\\gl-matrix\\src\\gl-matrix\\common.js"}],"..\\node_modules\\gl-matrix\\src\\gl-matrix\\vec4.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.forEach = exports.sqrLen = exports.len = exports.sqrDist = exports.dist = exports.div = exports.mul = exports.sub = undefined;
exports.create = create;
exports.clone = clone;
exports.fromValues = fromValues;
exports.copy = copy;
exports.set = set;
exports.add = add;
exports.subtract = subtract;
exports.multiply = multiply;
exports.divide = divide;
exports.ceil = ceil;
exports.floor = floor;
exports.min = min;
exports.max = max;
exports.round = round;
exports.scale = scale;
exports.scaleAndAdd = scaleAndAdd;
exports.distance = distance;
exports.squaredDistance = squaredDistance;
exports.length = length;
exports.squaredLength = squaredLength;
exports.negate = negate;
exports.inverse = inverse;
exports.normalize = normalize;
exports.dot = dot;
exports.lerp = lerp;
exports.random = random;
exports.transformMat4 = transformMat4;
exports.transformQuat = transformQuat;
exports.str = str;
exports.exactEquals = exactEquals;
exports.equals = equals;

var _common = require('./common');

var glMatrix = _interopRequireWildcard(_common);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * 4 Dimensional Vector
 * @module vec4
 */

/**
 * Creates a new, empty vec4
 *
 * @returns {vec4} a new 4D vector
 */
function create() {
  let out = new glMatrix.ARRAY_TYPE(4);
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  return out;
}

/**
 * Creates a new vec4 initialized with values from an existing vector
 *
 * @param {vec4} a vector to clone
 * @returns {vec4} a new 4D vector
 */
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

function clone(a) {
  let out = new glMatrix.ARRAY_TYPE(4);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}

/**
 * Creates a new vec4 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} a new 4D vector
 */
function fromValues(x, y, z, w) {
  let out = new glMatrix.ARRAY_TYPE(4);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}

/**
 * Copy the values from one vec4 to another
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the source vector
 * @returns {vec4} out
 */
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}

/**
 * Set the components of a vec4 to the given values
 *
 * @param {vec4} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} out
 */
function set(out, x, y, z, w) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}

/**
 * Adds two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  return out;
}

/**
 * Subtracts vector b from vector a
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  return out;
}

/**
 * Multiplies two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  out[3] = a[3] * b[3];
  return out;
}

/**
 * Divides two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  out[3] = a[3] / b[3];
  return out;
}

/**
 * Math.ceil the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to ceil
 * @returns {vec4} out
 */
function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  out[3] = Math.ceil(a[3]);
  return out;
}

/**
 * Math.floor the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to floor
 * @returns {vec4} out
 */
function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  out[3] = Math.floor(a[3]);
  return out;
}

/**
 * Returns the minimum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  out[3] = Math.min(a[3], b[3]);
  return out;
}

/**
 * Returns the maximum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  out[3] = Math.max(a[3], b[3]);
  return out;
}

/**
 * Math.round the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to round
 * @returns {vec4} out
 */
function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  out[3] = Math.round(a[3]);
  return out;
}

/**
 * Scales a vec4 by a scalar number
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec4} out
 */
function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  return out;
}

/**
 * Adds two vec4's after scaling the second operand by a scalar value
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec4} out
 */
function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  return out;
}

/**
 * Calculates the euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} distance between a and b
 */
function distance(a, b) {
  let x = b[0] - a[0];
  let y = b[1] - a[1];
  let z = b[2] - a[2];
  let w = b[3] - a[3];
  return Math.sqrt(x * x + y * y + z * z + w * w);
}

/**
 * Calculates the squared euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} squared distance between a and b
 */
function squaredDistance(a, b) {
  let x = b[0] - a[0];
  let y = b[1] - a[1];
  let z = b[2] - a[2];
  let w = b[3] - a[3];
  return x * x + y * y + z * z + w * w;
}

/**
 * Calculates the length of a vec4
 *
 * @param {vec4} a vector to calculate length of
 * @returns {Number} length of a
 */
function length(a) {
  let x = a[0];
  let y = a[1];
  let z = a[2];
  let w = a[3];
  return Math.sqrt(x * x + y * y + z * z + w * w);
}

/**
 * Calculates the squared length of a vec4
 *
 * @param {vec4} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
function squaredLength(a) {
  let x = a[0];
  let y = a[1];
  let z = a[2];
  let w = a[3];
  return x * x + y * y + z * z + w * w;
}

/**
 * Negates the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to negate
 * @returns {vec4} out
 */
function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = -a[3];
  return out;
}

/**
 * Returns the inverse of the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to invert
 * @returns {vec4} out
 */
function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  out[3] = 1.0 / a[3];
  return out;
}

/**
 * Normalize a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to normalize
 * @returns {vec4} out
 */
function normalize(out, a) {
  let x = a[0];
  let y = a[1];
  let z = a[2];
  let w = a[3];
  let len = x * x + y * y + z * z + w * w;
  if (len > 0) {
    len = 1 / Math.sqrt(len);
    out[0] = x * len;
    out[1] = y * len;
    out[2] = z * len;
    out[3] = w * len;
  }
  return out;
}

/**
 * Calculates the dot product of two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} dot product of a and b
 */
function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
}

/**
 * Performs a linear interpolation between two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec4} out
 */
function lerp(out, a, b, t) {
  let ax = a[0];
  let ay = a[1];
  let az = a[2];
  let aw = a[3];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  out[3] = aw + t * (b[3] - aw);
  return out;
}

/**
 * Generates a random vector with the given scale
 *
 * @param {vec4} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec4} out
 */
function random(out, vectorScale) {
  vectorScale = vectorScale || 1.0;

  //TODO: This is a pretty awful way of doing this. Find something better.
  out[0] = glMatrix.RANDOM();
  out[1] = glMatrix.RANDOM();
  out[2] = glMatrix.RANDOM();
  out[3] = glMatrix.RANDOM();
  normalize(out, out);
  scale(out, out, vectorScale);
  return out;
}

/**
 * Transforms the vec4 with a mat4.
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec4} out
 */
function transformMat4(out, a, m) {
  let x = a[0],
      y = a[1],
      z = a[2],
      w = a[3];
  out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
  out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
  out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
  out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
  return out;
}

/**
 * Transforms the vec4 with a quat
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec4} out
 */
function transformQuat(out, a, q) {
  let x = a[0],
      y = a[1],
      z = a[2];
  let qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3];

  // calculate quat * vec
  let ix = qw * x + qy * z - qz * y;
  let iy = qw * y + qz * x - qx * z;
  let iz = qw * z + qx * y - qy * x;
  let iw = -qx * x - qy * y - qz * z;

  // calculate result * inverse quat
  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
  out[3] = a[3];
  return out;
}

/**
 * Returns a string representation of a vector
 *
 * @param {vec4} a vector to represent as a string
 * @returns {String} string representation of the vector
 */
function str(a) {
  return 'vec4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
}

/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {vec4} a The first vector.
 * @param {vec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}

/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec4} a The first vector.
 * @param {vec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function equals(a, b) {
  let a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  let b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3));
}

/**
 * Alias for {@link vec4.subtract}
 * @function
 */
const sub = exports.sub = subtract;

/**
 * Alias for {@link vec4.multiply}
 * @function
 */
const mul = exports.mul = multiply;

/**
 * Alias for {@link vec4.divide}
 * @function
 */
const div = exports.div = divide;

/**
 * Alias for {@link vec4.distance}
 * @function
 */
const dist = exports.dist = distance;

/**
 * Alias for {@link vec4.squaredDistance}
 * @function
 */
const sqrDist = exports.sqrDist = squaredDistance;

/**
 * Alias for {@link vec4.length}
 * @function
 */
const len = exports.len = length;

/**
 * Alias for {@link vec4.squaredLength}
 * @function
 */
const sqrLen = exports.sqrLen = squaredLength;

/**
 * Perform some operation over an array of vec4s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
const forEach = exports.forEach = function () {
  let vec = create();

  return function (a, stride, offset, count, fn, arg) {
    let i, l;
    if (!stride) {
      stride = 4;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];vec[1] = a[i + 1];vec[2] = a[i + 2];vec[3] = a[i + 3];
      fn(vec, vec, arg);
      a[i] = vec[0];a[i + 1] = vec[1];a[i + 2] = vec[2];a[i + 3] = vec[3];
    }

    return a;
  };
}();
},{"./common":"..\\node_modules\\gl-matrix\\src\\gl-matrix\\common.js"}],"..\\node_modules\\gl-matrix\\src\\gl-matrix\\quat.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setAxes = exports.sqlerp = exports.rotationTo = exports.equals = exports.exactEquals = exports.normalize = exports.sqrLen = exports.squaredLength = exports.len = exports.length = exports.lerp = exports.dot = exports.scale = exports.mul = exports.add = exports.set = exports.copy = exports.fromValues = exports.clone = undefined;
exports.create = create;
exports.identity = identity;
exports.setAxisAngle = setAxisAngle;
exports.getAxisAngle = getAxisAngle;
exports.multiply = multiply;
exports.rotateX = rotateX;
exports.rotateY = rotateY;
exports.rotateZ = rotateZ;
exports.calculateW = calculateW;
exports.slerp = slerp;
exports.invert = invert;
exports.conjugate = conjugate;
exports.fromMat3 = fromMat3;
exports.fromEuler = fromEuler;
exports.str = str;

var _common = require("./common");

var glMatrix = _interopRequireWildcard(_common);

var _mat = require("./mat3");

var mat3 = _interopRequireWildcard(_mat);

var _vec = require("./vec3");

var vec3 = _interopRequireWildcard(_vec);

var _vec2 = require("./vec4");

var vec4 = _interopRequireWildcard(_vec2);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * Quaternion
 * @module quat
 */

/**
 * Creates a new identity quat
 *
 * @returns {quat} a new quaternion
 */
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

function create() {
  let out = new glMatrix.ARRAY_TYPE(4);
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}

/**
 * Set a quat to the identity quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */
function identity(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}

/**
 * Sets a quat from the given angle and rotation axis,
 * then returns it.
 *
 * @param {quat} out the receiving quaternion
 * @param {vec3} axis the axis around which to rotate
 * @param {Number} rad the angle in radians
 * @returns {quat} out
 **/
function setAxisAngle(out, axis, rad) {
  rad = rad * 0.5;
  let s = Math.sin(rad);
  out[0] = s * axis[0];
  out[1] = s * axis[1];
  out[2] = s * axis[2];
  out[3] = Math.cos(rad);
  return out;
}

/**
 * Gets the rotation axis and angle for a given
 *  quaternion. If a quaternion is created with
 *  setAxisAngle, this method will return the same
 *  values as providied in the original parameter list
 *  OR functionally equivalent values.
 * Example: The quaternion formed by axis [0, 0, 1] and
 *  angle -90 is the same as the quaternion formed by
 *  [0, 0, 1] and 270. This method favors the latter.
 * @param  {vec3} out_axis  Vector receiving the axis of rotation
 * @param  {quat} q     Quaternion to be decomposed
 * @return {Number}     Angle, in radians, of the rotation
 */
function getAxisAngle(out_axis, q) {
  let rad = Math.acos(q[3]) * 2.0;
  let s = Math.sin(rad / 2.0);
  if (s != 0.0) {
    out_axis[0] = q[0] / s;
    out_axis[1] = q[1] / s;
    out_axis[2] = q[2] / s;
  } else {
    // If s is zero, return any axis (no rotation - axis does not matter)
    out_axis[0] = 1;
    out_axis[1] = 0;
    out_axis[2] = 0;
  }
  return rad;
}

/**
 * Multiplies two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 */
function multiply(out, a, b) {
  let ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  let bx = b[0],
      by = b[1],
      bz = b[2],
      bw = b[3];

  out[0] = ax * bw + aw * bx + ay * bz - az * by;
  out[1] = ay * bw + aw * by + az * bx - ax * bz;
  out[2] = az * bw + aw * bz + ax * by - ay * bx;
  out[3] = aw * bw - ax * bx - ay * by - az * bz;
  return out;
}

/**
 * Rotates a quaternion by the given angle about the X axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
function rotateX(out, a, rad) {
  rad *= 0.5;

  let ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  let bx = Math.sin(rad),
      bw = Math.cos(rad);

  out[0] = ax * bw + aw * bx;
  out[1] = ay * bw + az * bx;
  out[2] = az * bw - ay * bx;
  out[3] = aw * bw - ax * bx;
  return out;
}

/**
 * Rotates a quaternion by the given angle about the Y axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
function rotateY(out, a, rad) {
  rad *= 0.5;

  let ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  let by = Math.sin(rad),
      bw = Math.cos(rad);

  out[0] = ax * bw - az * by;
  out[1] = ay * bw + aw * by;
  out[2] = az * bw + ax * by;
  out[3] = aw * bw - ay * by;
  return out;
}

/**
 * Rotates a quaternion by the given angle about the Z axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
function rotateZ(out, a, rad) {
  rad *= 0.5;

  let ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  let bz = Math.sin(rad),
      bw = Math.cos(rad);

  out[0] = ax * bw + ay * bz;
  out[1] = ay * bw - ax * bz;
  out[2] = az * bw + aw * bz;
  out[3] = aw * bw - az * bz;
  return out;
}

/**
 * Calculates the W component of a quat from the X, Y, and Z components.
 * Assumes that quaternion is 1 unit in length.
 * Any existing W component will be ignored.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate W component of
 * @returns {quat} out
 */
function calculateW(out, a) {
  let x = a[0],
      y = a[1],
      z = a[2];

  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
  return out;
}

/**
 * Performs a spherical linear interpolation between two quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {quat} out
 */
function slerp(out, a, b, t) {
  // benchmarks:
  //    http://jsperf.com/quaternion-slerp-implementations
  let ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  let bx = b[0],
      by = b[1],
      bz = b[2],
      bw = b[3];

  let omega, cosom, sinom, scale0, scale1;

  // calc cosine
  cosom = ax * bx + ay * by + az * bz + aw * bw;
  // adjust signs (if necessary)
  if (cosom < 0.0) {
    cosom = -cosom;
    bx = -bx;
    by = -by;
    bz = -bz;
    bw = -bw;
  }
  // calculate coefficients
  if (1.0 - cosom > 0.000001) {
    // standard case (slerp)
    omega = Math.acos(cosom);
    sinom = Math.sin(omega);
    scale0 = Math.sin((1.0 - t) * omega) / sinom;
    scale1 = Math.sin(t * omega) / sinom;
  } else {
    // "from" and "to" quaternions are very close
    //  ... so we can do a linear interpolation
    scale0 = 1.0 - t;
    scale1 = t;
  }
  // calculate final values
  out[0] = scale0 * ax + scale1 * bx;
  out[1] = scale0 * ay + scale1 * by;
  out[2] = scale0 * az + scale1 * bz;
  out[3] = scale0 * aw + scale1 * bw;

  return out;
}

/**
 * Calculates the inverse of a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate inverse of
 * @returns {quat} out
 */
function invert(out, a) {
  let a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  let dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;
  let invDot = dot ? 1.0 / dot : 0;

  // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0

  out[0] = -a0 * invDot;
  out[1] = -a1 * invDot;
  out[2] = -a2 * invDot;
  out[3] = a3 * invDot;
  return out;
}

/**
 * Calculates the conjugate of a quat
 * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate conjugate of
 * @returns {quat} out
 */
function conjugate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a[3];
  return out;
}

/**
 * Creates a quaternion from the given 3x3 rotation matrix.
 *
 * NOTE: The resultant quaternion is not normalized, so you should be sure
 * to renormalize the quaternion yourself where necessary.
 *
 * @param {quat} out the receiving quaternion
 * @param {mat3} m rotation matrix
 * @returns {quat} out
 * @function
 */
function fromMat3(out, m) {
  // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
  // article "Quaternion Calculus and Fast Animation".
  let fTrace = m[0] + m[4] + m[8];
  let fRoot;

  if (fTrace > 0.0) {
    // |w| > 1/2, may as well choose w > 1/2
    fRoot = Math.sqrt(fTrace + 1.0); // 2w
    out[3] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot; // 1/(4w)
    out[0] = (m[5] - m[7]) * fRoot;
    out[1] = (m[6] - m[2]) * fRoot;
    out[2] = (m[1] - m[3]) * fRoot;
  } else {
    // |w| <= 1/2
    let i = 0;
    if (m[4] > m[0]) i = 1;
    if (m[8] > m[i * 3 + i]) i = 2;
    let j = (i + 1) % 3;
    let k = (i + 2) % 3;

    fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1.0);
    out[i] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;
    out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
    out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
  }

  return out;
}

/**
 * Creates a quaternion from the given euler angle x, y, z.
 *
 * @param {quat} out the receiving quaternion
 * @param {x} Angle to rotate around X axis in degrees.
 * @param {y} Angle to rotate around Y axis in degrees.
 * @param {z} Angle to rotate around Z axis in degrees.
 * @returns {quat} out
 * @function
 */
function fromEuler(out, x, y, z) {
  let halfToRad = 0.5 * Math.PI / 180.0;
  x *= halfToRad;
  y *= halfToRad;
  z *= halfToRad;

  let sx = Math.sin(x);
  let cx = Math.cos(x);
  let sy = Math.sin(y);
  let cy = Math.cos(y);
  let sz = Math.sin(z);
  let cz = Math.cos(z);

  out[0] = sx * cy * cz - cx * sy * sz;
  out[1] = cx * sy * cz + sx * cy * sz;
  out[2] = cx * cy * sz - sx * sy * cz;
  out[3] = cx * cy * cz + sx * sy * sz;

  return out;
}

/**
 * Returns a string representation of a quatenion
 *
 * @param {quat} a vector to represent as a string
 * @returns {String} string representation of the vector
 */
function str(a) {
  return 'quat(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
}

/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {quat} a quaternion to clone
 * @returns {quat} a new quaternion
 * @function
 */
const clone = exports.clone = vec4.clone;

/**
 * Creates a new quat initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} a new quaternion
 * @function
 */
const fromValues = exports.fromValues = vec4.fromValues;

/**
 * Copy the values from one quat to another
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the source quaternion
 * @returns {quat} out
 * @function
 */
const copy = exports.copy = vec4.copy;

/**
 * Set the components of a quat to the given values
 *
 * @param {quat} out the receiving quaternion
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} out
 * @function
 */
const set = exports.set = vec4.set;

/**
 * Adds two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 * @function
 */
const add = exports.add = vec4.add;

/**
 * Alias for {@link quat.multiply}
 * @function
 */
const mul = exports.mul = multiply;

/**
 * Scales a quat by a scalar number
 *
 * @param {quat} out the receiving vector
 * @param {quat} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {quat} out
 * @function
 */
const scale = exports.scale = vec4.scale;

/**
 * Calculates the dot product of two quat's
 *
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {Number} dot product of a and b
 * @function
 */
const dot = exports.dot = vec4.dot;

/**
 * Performs a linear interpolation between two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {quat} out
 * @function
 */
const lerp = exports.lerp = vec4.lerp;

/**
 * Calculates the length of a quat
 *
 * @param {quat} a vector to calculate length of
 * @returns {Number} length of a
 */
const length = exports.length = vec4.length;

/**
 * Alias for {@link quat.length}
 * @function
 */
const len = exports.len = length;

/**
 * Calculates the squared length of a quat
 *
 * @param {quat} a vector to calculate squared length of
 * @returns {Number} squared length of a
 * @function
 */
const squaredLength = exports.squaredLength = vec4.squaredLength;

/**
 * Alias for {@link quat.squaredLength}
 * @function
 */
const sqrLen = exports.sqrLen = squaredLength;

/**
 * Normalize a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quaternion to normalize
 * @returns {quat} out
 * @function
 */
const normalize = exports.normalize = vec4.normalize;

/**
 * Returns whether or not the quaternions have exactly the same elements in the same position (when compared with ===)
 *
 * @param {quat} a The first quaternion.
 * @param {quat} b The second quaternion.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
const exactEquals = exports.exactEquals = vec4.exactEquals;

/**
 * Returns whether or not the quaternions have approximately the same elements in the same position.
 *
 * @param {quat} a The first vector.
 * @param {quat} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
const equals = exports.equals = vec4.equals;

/**
 * Sets a quaternion to represent the shortest rotation from one
 * vector to another.
 *
 * Both vectors are assumed to be unit length.
 *
 * @param {quat} out the receiving quaternion.
 * @param {vec3} a the initial vector
 * @param {vec3} b the destination vector
 * @returns {quat} out
 */
const rotationTo = exports.rotationTo = function () {
  let tmpvec3 = vec3.create();
  let xUnitVec3 = vec3.fromValues(1, 0, 0);
  let yUnitVec3 = vec3.fromValues(0, 1, 0);

  return function (out, a, b) {
    let dot = vec3.dot(a, b);
    if (dot < -0.999999) {
      vec3.cross(tmpvec3, xUnitVec3, a);
      if (vec3.len(tmpvec3) < 0.000001) vec3.cross(tmpvec3, yUnitVec3, a);
      vec3.normalize(tmpvec3, tmpvec3);
      setAxisAngle(out, tmpvec3, Math.PI);
      return out;
    } else if (dot > 0.999999) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 1;
      return out;
    } else {
      vec3.cross(tmpvec3, a, b);
      out[0] = tmpvec3[0];
      out[1] = tmpvec3[1];
      out[2] = tmpvec3[2];
      out[3] = 1 + dot;
      return normalize(out, out);
    }
  };
}();

/**
 * Performs a spherical linear interpolation with two control points
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {quat} c the third operand
 * @param {quat} d the fourth operand
 * @param {Number} t interpolation amount
 * @returns {quat} out
 */
const sqlerp = exports.sqlerp = function () {
  let temp1 = create();
  let temp2 = create();

  return function (out, a, b, c, d, t) {
    slerp(temp1, a, d, t);
    slerp(temp2, b, c, t);
    slerp(out, temp1, temp2, 2 * t * (1 - t));

    return out;
  };
}();

/**
 * Sets the specified quaternion with values corresponding to the given
 * axes. Each axis is a vec3 and is expected to be unit length and
 * perpendicular to all other specified axes.
 *
 * @param {vec3} view  the vector representing the viewing direction
 * @param {vec3} right the vector representing the local "right" direction
 * @param {vec3} up    the vector representing the local "up" direction
 * @returns {quat} out
 */
const setAxes = exports.setAxes = function () {
  let matr = mat3.create();

  return function (out, view, right, up) {
    matr[0] = right[0];
    matr[3] = right[1];
    matr[6] = right[2];

    matr[1] = up[0];
    matr[4] = up[1];
    matr[7] = up[2];

    matr[2] = -view[0];
    matr[5] = -view[1];
    matr[8] = -view[2];

    return normalize(out, fromMat3(out, matr));
  };
}();
},{"./common":"..\\node_modules\\gl-matrix\\src\\gl-matrix\\common.js","./mat3":"..\\node_modules\\gl-matrix\\src\\gl-matrix\\mat3.js","./vec3":"..\\node_modules\\gl-matrix\\src\\gl-matrix\\vec3.js","./vec4":"..\\node_modules\\gl-matrix\\src\\gl-matrix\\vec4.js"}],"..\\node_modules\\gl-matrix\\src\\gl-matrix\\vec2.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.forEach = exports.sqrLen = exports.sqrDist = exports.dist = exports.div = exports.mul = exports.sub = exports.len = undefined;
exports.create = create;
exports.clone = clone;
exports.fromValues = fromValues;
exports.copy = copy;
exports.set = set;
exports.add = add;
exports.subtract = subtract;
exports.multiply = multiply;
exports.divide = divide;
exports.ceil = ceil;
exports.floor = floor;
exports.min = min;
exports.max = max;
exports.round = round;
exports.scale = scale;
exports.scaleAndAdd = scaleAndAdd;
exports.distance = distance;
exports.squaredDistance = squaredDistance;
exports.length = length;
exports.squaredLength = squaredLength;
exports.negate = negate;
exports.inverse = inverse;
exports.normalize = normalize;
exports.dot = dot;
exports.cross = cross;
exports.lerp = lerp;
exports.random = random;
exports.transformMat2 = transformMat2;
exports.transformMat2d = transformMat2d;
exports.transformMat3 = transformMat3;
exports.transformMat4 = transformMat4;
exports.str = str;
exports.exactEquals = exactEquals;
exports.equals = equals;

var _common = require('./common');

var glMatrix = _interopRequireWildcard(_common);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * 2 Dimensional Vector
 * @module vec2
 */

/**
 * Creates a new, empty vec2
 *
 * @returns {vec2} a new 2D vector
 */
function create() {
  let out = new glMatrix.ARRAY_TYPE(2);
  out[0] = 0;
  out[1] = 0;
  return out;
}

/**
 * Creates a new vec2 initialized with values from an existing vector
 *
 * @param {vec2} a vector to clone
 * @returns {vec2} a new 2D vector
 */
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

function clone(a) {
  let out = new glMatrix.ARRAY_TYPE(2);
  out[0] = a[0];
  out[1] = a[1];
  return out;
}

/**
 * Creates a new vec2 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} a new 2D vector
 */
function fromValues(x, y) {
  let out = new glMatrix.ARRAY_TYPE(2);
  out[0] = x;
  out[1] = y;
  return out;
}

/**
 * Copy the values from one vec2 to another
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the source vector
 * @returns {vec2} out
 */
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  return out;
}

/**
 * Set the components of a vec2 to the given values
 *
 * @param {vec2} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} out
 */
function set(out, x, y) {
  out[0] = x;
  out[1] = y;
  return out;
}

/**
 * Adds two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  return out;
}

/**
 * Subtracts vector b from vector a
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  return out;
}

/**
 * Multiplies two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  return out;
};

/**
 * Divides two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  return out;
};

/**
 * Math.ceil the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to ceil
 * @returns {vec2} out
 */
function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  return out;
};

/**
 * Math.floor the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to floor
 * @returns {vec2} out
 */
function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  return out;
};

/**
 * Returns the minimum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  return out;
};

/**
 * Returns the maximum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  return out;
};

/**
 * Math.round the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to round
 * @returns {vec2} out
 */
function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  return out;
};

/**
 * Scales a vec2 by a scalar number
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec2} out
 */
function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  return out;
};

/**
 * Adds two vec2's after scaling the second operand by a scalar value
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec2} out
 */
function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  return out;
};

/**
 * Calculates the euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} distance between a and b
 */
function distance(a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1];
  return Math.sqrt(x * x + y * y);
};

/**
 * Calculates the squared euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} squared distance between a and b
 */
function squaredDistance(a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1];
  return x * x + y * y;
};

/**
 * Calculates the length of a vec2
 *
 * @param {vec2} a vector to calculate length of
 * @returns {Number} length of a
 */
function length(a) {
  var x = a[0],
      y = a[1];
  return Math.sqrt(x * x + y * y);
};

/**
 * Calculates the squared length of a vec2
 *
 * @param {vec2} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
function squaredLength(a) {
  var x = a[0],
      y = a[1];
  return x * x + y * y;
};

/**
 * Negates the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to negate
 * @returns {vec2} out
 */
function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  return out;
};

/**
 * Returns the inverse of the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to invert
 * @returns {vec2} out
 */
function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  return out;
};

/**
 * Normalize a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to normalize
 * @returns {vec2} out
 */
function normalize(out, a) {
  var x = a[0],
      y = a[1];
  var len = x * x + y * y;
  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
    out[0] = a[0] * len;
    out[1] = a[1] * len;
  }
  return out;
};

/**
 * Calculates the dot product of two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} dot product of a and b
 */
function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1];
};

/**
 * Computes the cross product of two vec2's
 * Note that the cross product must by definition produce a 3D vector
 *
 * @param {vec3} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec3} out
 */
function cross(out, a, b) {
  var z = a[0] * b[1] - a[1] * b[0];
  out[0] = out[1] = 0;
  out[2] = z;
  return out;
};

/**
 * Performs a linear interpolation between two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec2} out
 */
function lerp(out, a, b, t) {
  var ax = a[0],
      ay = a[1];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  return out;
};

/**
 * Generates a random vector with the given scale
 *
 * @param {vec2} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec2} out
 */
function random(out, scale) {
  scale = scale || 1.0;
  var r = glMatrix.RANDOM() * 2.0 * Math.PI;
  out[0] = Math.cos(r) * scale;
  out[1] = Math.sin(r) * scale;
  return out;
};

/**
 * Transforms the vec2 with a mat2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2} m matrix to transform with
 * @returns {vec2} out
 */
function transformMat2(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[2] * y;
  out[1] = m[1] * x + m[3] * y;
  return out;
};

/**
 * Transforms the vec2 with a mat2d
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2d} m matrix to transform with
 * @returns {vec2} out
 */
function transformMat2d(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[2] * y + m[4];
  out[1] = m[1] * x + m[3] * y + m[5];
  return out;
};

/**
 * Transforms the vec2 with a mat3
 * 3rd vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat3} m matrix to transform with
 * @returns {vec2} out
 */
function transformMat3(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[3] * y + m[6];
  out[1] = m[1] * x + m[4] * y + m[7];
  return out;
};

/**
 * Transforms the vec2 with a mat4
 * 3rd vector component is implicitly '0'
 * 4th vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec2} out
 */
function transformMat4(out, a, m) {
  let x = a[0];
  let y = a[1];
  out[0] = m[0] * x + m[4] * y + m[12];
  out[1] = m[1] * x + m[5] * y + m[13];
  return out;
}

/**
 * Returns a string representation of a vector
 *
 * @param {vec2} a vector to represent as a string
 * @returns {String} string representation of the vector
 */
function str(a) {
  return 'vec2(' + a[0] + ', ' + a[1] + ')';
}

/**
 * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
 *
 * @param {vec2} a The first vector.
 * @param {vec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1];
}

/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec2} a The first vector.
 * @param {vec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function equals(a, b) {
  let a0 = a[0],
      a1 = a[1];
  let b0 = b[0],
      b1 = b[1];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1));
}

/**
 * Alias for {@link vec2.length}
 * @function
 */
const len = exports.len = length;

/**
 * Alias for {@link vec2.subtract}
 * @function
 */
const sub = exports.sub = subtract;

/**
 * Alias for {@link vec2.multiply}
 * @function
 */
const mul = exports.mul = multiply;

/**
 * Alias for {@link vec2.divide}
 * @function
 */
const div = exports.div = divide;

/**
 * Alias for {@link vec2.distance}
 * @function
 */
const dist = exports.dist = distance;

/**
 * Alias for {@link vec2.squaredDistance}
 * @function
 */
const sqrDist = exports.sqrDist = squaredDistance;

/**
 * Alias for {@link vec2.squaredLength}
 * @function
 */
const sqrLen = exports.sqrLen = squaredLength;

/**
 * Perform some operation over an array of vec2s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
const forEach = exports.forEach = function () {
  let vec = create();

  return function (a, stride, offset, count, fn, arg) {
    let i, l;
    if (!stride) {
      stride = 2;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];vec[1] = a[i + 1];
      fn(vec, vec, arg);
      a[i] = vec[0];a[i + 1] = vec[1];
    }

    return a;
  };
}();
},{"./common":"..\\node_modules\\gl-matrix\\src\\gl-matrix\\common.js"}],"..\\node_modules\\gl-matrix\\src\\gl-matrix.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.vec4 = exports.vec3 = exports.vec2 = exports.quat = exports.mat4 = exports.mat3 = exports.mat2d = exports.mat2 = exports.glMatrix = undefined;

var _common = require("./gl-matrix/common");

var glMatrix = _interopRequireWildcard(_common);

var _mat = require("./gl-matrix/mat2");

var mat2 = _interopRequireWildcard(_mat);

var _mat2d = require("./gl-matrix/mat2d");

var mat2d = _interopRequireWildcard(_mat2d);

var _mat2 = require("./gl-matrix/mat3");

var mat3 = _interopRequireWildcard(_mat2);

var _mat3 = require("./gl-matrix/mat4");

var mat4 = _interopRequireWildcard(_mat3);

var _quat = require("./gl-matrix/quat");

var quat = _interopRequireWildcard(_quat);

var _vec = require("./gl-matrix/vec2");

var vec2 = _interopRequireWildcard(_vec);

var _vec2 = require("./gl-matrix/vec3");

var vec3 = _interopRequireWildcard(_vec2);

var _vec3 = require("./gl-matrix/vec4");

var vec4 = _interopRequireWildcard(_vec3);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

exports.glMatrix = glMatrix;
exports.mat2 = mat2;
exports.mat2d = mat2d;
exports.mat3 = mat3;
exports.mat4 = mat4;
exports.quat = quat;
exports.vec2 = vec2;
exports.vec3 = vec3;
exports.vec4 = vec4; /**
                      * @fileoverview gl-matrix - High performance matrix and vector operations
                      * @author Brandon Jones
                      * @author Colin MacKenzie IV
                      * @version 2.4.0
                      */

/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */
// END HEADER
},{"./gl-matrix/common":"..\\node_modules\\gl-matrix\\src\\gl-matrix\\common.js","./gl-matrix/mat2":"..\\node_modules\\gl-matrix\\src\\gl-matrix\\mat2.js","./gl-matrix/mat2d":"..\\node_modules\\gl-matrix\\src\\gl-matrix\\mat2d.js","./gl-matrix/mat3":"..\\node_modules\\gl-matrix\\src\\gl-matrix\\mat3.js","./gl-matrix/mat4":"..\\node_modules\\gl-matrix\\src\\gl-matrix\\mat4.js","./gl-matrix/quat":"..\\node_modules\\gl-matrix\\src\\gl-matrix\\quat.js","./gl-matrix/vec2":"..\\node_modules\\gl-matrix\\src\\gl-matrix\\vec2.js","./gl-matrix/vec3":"..\\node_modules\\gl-matrix\\src\\gl-matrix\\vec3.js","./gl-matrix/vec4":"..\\node_modules\\gl-matrix\\src\\gl-matrix\\vec4.js"}],"endian.ts":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Endianness;
(function (Endianness) {
    Endianness[Endianness["LITTLE_ENDIAN"] = 0] = "LITTLE_ENDIAN";
    Endianness[Endianness["BIG_ENDIAN"] = 1] = "BIG_ENDIAN";
})(Endianness = exports.Endianness || (exports.Endianness = {}));
var test = new Uint16Array([0xFEFF]);
var testView = new DataView(test.buffer);
var systemEndianness = testView.getUint8(0) == 0xFF ? Endianness.LITTLE_ENDIAN : Endianness.BIG_ENDIAN;
function getSystemEndianness() {
    return systemEndianness;
}
exports.getSystemEndianness = getSystemEndianness;
},{}],"ArrayBufferSlice.ts":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("./util");
var endian_1 = require("./endian");
// This implements a "saner" ArrayBuffer, since the JS one is absurd.
//
// The biggest issue is that ArrayBuffer.prototype.slice does not make a read-only view, but instead
// a copy, and most browsers do not implement it as a COW buffer but instead a separate buffer backed
// by a separate memcpy. There is no way to create a read-only or ArrayBufferView, since that goal is
// mostly relegated to the typed arrays or DataViews, which have unmatching and different APIs.
//
// ArrayBufferSlice's are designed to be read-only, however, JavaScript has no way of enforcing this
// currently...
// Install our dummy ArrayBuffer.prototype.slice to catch any rogue offenders.
var ArrayBuffer_slice = ArrayBuffer.prototype.slice;
ArrayBuffer.prototype.slice = function (begin, end) {
    throw new Error("Do not use ArrayBuffer.prototype.slice");
};
function isAligned(n, m) {
    return (n & m - 1) === 0;
}
var ArrayBufferSlice = /** @class */function () {
    function ArrayBufferSlice(
    // The name arrayBuffer is chosen so that someone can't easily mistake an ArrayBufferSlice
    // for an ArrayBuffer or ArrayBufferView, which is important for native APIs like OpenGL that
    // will silently choke on something like this. TypeScript has no way to explicitly mark our
    // class as incompatible with the ArrayBuffer interface.
    arrayBuffer, byteOffset, byteLength) {
        if (byteOffset === void 0) {
            byteOffset = 0;
        }
        if (byteLength === void 0) {
            byteLength = arrayBuffer.byteLength;
        }
        this.arrayBuffer = arrayBuffer;
        this.byteOffset = byteOffset;
        this.byteLength = byteLength;
        util_1.assert(byteOffset >= 0 && byteLength >= 0 && byteOffset + byteLength <= this.arrayBuffer.byteLength);
    }
    ArrayBufferSlice.prototype.slice = function (begin, end) {
        var absBegin = this.byteOffset + begin;
        var absEnd = this.byteOffset + (end !== undefined ? end : this.byteLength);
        return new ArrayBufferSlice(this.arrayBuffer, absBegin, absEnd - absBegin);
    };
    ArrayBufferSlice.prototype.subarray = function (begin, byteLength) {
        var absBegin = this.byteOffset + begin;
        if (byteLength === undefined) byteLength = this.byteLength - begin;
        util_1.assert(byteLength >= 0 && byteLength <= this.byteLength);
        return new ArrayBufferSlice(this.arrayBuffer, absBegin, byteLength);
    };
    ArrayBufferSlice.prototype.copyToBuffer = function (offs, length) {
        if (offs === void 0) {
            offs = 0;
        }
        var start = this.byteOffset + offs;
        var end = length !== undefined ? start + length : this.byteOffset + this.byteLength;
        return ArrayBuffer_slice.call(this.arrayBuffer, start, end);
    };
    ArrayBufferSlice.prototype.copyToSlice = function (offs, length) {
        if (offs === void 0) {
            offs = 0;
        }
        return new ArrayBufferSlice(this.copyToBuffer(offs, length));
    };
    ArrayBufferSlice.prototype.castToBuffer = function () {
        if (this.byteOffset === 0 && this.byteLength === this.arrayBuffer.byteLength) {
            return this.arrayBuffer;
        } else {
            return this.copyToBuffer();
        }
    };
    ArrayBufferSlice.prototype.createDataView = function (offs, length) {
        if (offs === void 0) {
            offs = 0;
        }
        if (offs === 0 && length === undefined) {
            return new DataView(this.arrayBuffer, this.byteOffset, this.byteLength);
        } else {
            return this.subarray(offs, length).createDataView();
        }
    };
    ArrayBufferSlice.prototype.bswap16 = function () {
        util_1.assert(this.byteLength % 2 === 0);
        var a = this.createTypedArray(Uint8Array);
        var o = new Uint8Array(this.byteLength);
        for (var i = 0; i < a.byteLength; i += 2) {
            o[i + 0] = a[i + 1];
            o[i + 1] = a[i + 0];
        }
        return new ArrayBufferSlice(o.buffer);
    };
    ArrayBufferSlice.prototype.bswap32 = function () {
        util_1.assert(this.byteLength % 4 === 0);
        var a = this.createTypedArray(Uint8Array);
        var o = new Uint8Array(a.byteLength);
        for (var i = 0; i < a.byteLength; i += 4) {
            o[i + 0] = a[i + 3];
            o[i + 1] = a[i + 2];
            o[i + 2] = a[i + 1];
            o[i + 3] = a[i + 0];
        }
        return new ArrayBufferSlice(o.buffer);
    };
    ArrayBufferSlice.prototype.bswap = function (componentSize) {
        if (componentSize === 2) {
            return this.bswap16();
        } else if (componentSize === 4) {
            return this.bswap32();
        } else {
            return componentSize;
        }
    };
    ArrayBufferSlice.prototype.convertFromEndianness = function (endianness, componentSize) {
        if (componentSize !== 1 && endianness !== endian_1.getSystemEndianness()) return this.bswap(componentSize);else return this;
    };
    ArrayBufferSlice.prototype.createTypedArray = function (clazz, offs, count, endianness) {
        if (offs === void 0) {
            offs = 0;
        }
        if (endianness === void 0) {
            endianness = endian_1.Endianness.LITTLE_ENDIAN;
        }
        var begin = this.byteOffset + offs;
        var byteLength;
        if (count !== undefined) {
            byteLength = clazz.BYTES_PER_ELEMENT * count;
        } else {
            byteLength = this.byteLength - offs;
            util_1.assert(isAligned(begin, clazz.BYTES_PER_ELEMENT));
            count = byteLength / clazz.BYTES_PER_ELEMENT;
            util_1.assert((count | 0) === count);
        }
        var componentSize = clazz.BYTES_PER_ELEMENT;
        var needsEndianSwap = componentSize > 1 && endianness !== endian_1.getSystemEndianness();
        // Typed arrays require alignment.
        if (needsEndianSwap) {
            var componentSize_ = componentSize;
            var copy = this.subarray(offs, byteLength).bswap(componentSize_);
            return copy.createTypedArray(clazz);
        } else if (isAligned(begin, componentSize)) {
            return new clazz(this.arrayBuffer, begin, count);
        } else {
            return new clazz(this.copyToBuffer(offs, byteLength), 0);
        }
    };
    return ArrayBufferSlice;
}();
exports.default = ArrayBufferSlice;
},{"./util":"util.ts","./endian":"endian.ts"}],"Progressable.ts":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Progressable = /** @class */function () {
    function Progressable(promise, initialProgress) {
        if (initialProgress === void 0) {
            initialProgress = 0;
        }
        this.promise = promise;
        this.onProgress = null;
        this.progress = initialProgress;
    }
    Progressable.prototype.setProgress = function (n) {
        this.progress = n;
        if (this.onProgress !== null) this.onProgress();
    };
    Progressable.prototype.then = function (onfulfilled) {
        var _this = this;
        // The rough idea is that any then-able is implicitly at the same progress as this one.
        var pr = new Progressable(this.promise.then(onfulfilled), this.progress);
        this.onProgress = function () {
            pr.setProgress(_this.progress);
        };
        return pr;
    };
    Progressable.all = function (progressables) {
        var p = Promise.all(progressables.map(function (p) {
            return p.promise;
        }));
        function calcProgress() {
            var progresses = progressables.map(function (p) {
                return p.progress;
            });
            pr.progress = avg(progresses);
            if (pr.onProgress !== null) pr.onProgress();
        }
        progressables.forEach(function (p) {
            p.onProgress = calcProgress;
        });
        var pr = new Progressable(p);
        return pr;
    };
    return Progressable;
}();
exports.default = Progressable;
function avg(L) {
    var s = 0;
    L.forEach(function (i) {
        return s += i;
    });
    s /= L.length;
    return s;
}
function setTimeoutProgressable(n) {
    var p = new Promise(function (resolve, reject) {
        setTimeout(function () {
            resolve(n);
        }, n);
    });
    var pr = new Progressable(p);
    var start = +new Date();
    function tick() {
        var ms = +new Date();
        var t = (ms - start) / n;
        pr.setProgress(t);
        if (t < 1) window.requestAnimationFrame(tick);
    }
    tick();
    return pr;
}
},{}],"util.ts":[function(require,module,exports) {
"use strict";

var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var ArrayBufferSlice_1 = __importDefault(require("./ArrayBufferSlice"));
var Progressable_1 = __importDefault(require("./Progressable"));
function fetch(path) {
    var request = new XMLHttpRequest();
    request.open("GET", path, true);
    request.responseType = "arraybuffer";
    request.send();
    var p = new Promise(function (resolve, reject) {
        request.onload = function () {
            pr.setProgress(1);
            var buffer = request.response;
            var slice = new ArrayBufferSlice_1.default(buffer);
            resolve(slice);
        };
        request.onerror = function () {
            reject();
        };
        request.onprogress = function (e) {
            if (e.lengthComputable) pr.setProgress(e.loaded / e.total);
        };
    });
    var pr = new Progressable_1.default(p);
    return pr;
}
exports.fetch = fetch;
function assert(b) {
    if (!b) {
        console.error(new Error().stack);
        throw new Error("Assert fail");
    }
}
exports.assert = assert;
function assertExists(v) {
    if (v) return v;else throw new Error("Missing object");
}
exports.assertExists = assertExists;
function readString(buffer, offs, length, nulTerminated) {
    if (length === void 0) {
        length = -1;
    }
    if (nulTerminated === void 0) {
        nulTerminated = true;
    }
    var buf = buffer.createTypedArray(Uint8Array, offs);
    var S = '';
    var i = 0;
    while (true) {
        if (length > 0 && i >= length) break;
        if (nulTerminated && buf[i] === 0) break;
        S += String.fromCharCode(buf[i]);
        i++;
    }
    return S;
}
exports.readString = readString;
function align(n, multiple) {
    var mask = multiple - 1;
    return n + mask & ~mask;
}
exports.align = align;
var counter = 0;
function generateFormID() {
    return "FormGeneratedID_" + counter++;
}
exports.generateFormID = generateFormID;
function nArray(n, c) {
    var d = new Array(n);
    while (n--) {
        d[n] = c();
    }return d;
}
exports.nArray = nArray;
// Eat your heart out, npm.
function leftPad(S, spaces) {
    while (S.length < spaces) {
        S = "0" + S;
    }return S;
}
exports.leftPad = leftPad;
function hexzero(n, spaces) {
    var S = n.toString(16);
    return leftPad(S, spaces);
}
exports.hexzero = hexzero;
function hexdump(buffer, offs, length) {
    if (offs === void 0) {
        offs = 0;
    }
    if (length === void 0) {
        length = 0x100;
    }
    var groupSize = 16;
    var S = '';
    var arr = buffer.createTypedArray(Uint8Array, offs, length);
    for (var i = offs; i < length; i += groupSize) {
        S += hexzero(i, 8) + "    ";
        for (var j = 0; j < groupSize; j++) {
            var b = arr[i + j];
            S += " " + hexzero(b, 2);
        }
        S += '  ';
        for (var j = 0; j < groupSize; j++) {
            var b = arr[i + j];
            var c = b >= 0x20 && b < 0x7F ? String.fromCharCode(b) : '.';
            S += "" + c;
        }
        S += '\n';
    }
    console.log(S);
}
exports.hexdump = hexdump;
window.hexdump = hexdump;
},{"./ArrayBufferSlice":"ArrayBufferSlice.ts","./Progressable":"Progressable.ts"}],"MemoizeCache.ts":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("./util");
var MemoizeCache = /** @class */function () {
    function MemoizeCache() {
        this.cache = new Map();
    }
    MemoizeCache.prototype.get = function (key) {
        var keyStr = this.makeKey(key);
        if (this.cache.has(keyStr)) {
            return util_1.assertExists(this.cache.get(keyStr));
        } else {
            var obj = this.make(key);
            if (obj !== null) this.cache.set(keyStr, obj);
            return obj;
        }
    };
    MemoizeCache.prototype.clear = function () {
        this.cache.clear();
    };
    return MemoizeCache;
}();
exports.default = MemoizeCache;
},{"./util":"util.ts"}],"CodeEditor.ts":[function(require,module,exports) {
"use strict";

var __values = this && this.__values || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator],
        i = 0;
    if (m) return m.call(o);
    return {
        next: function next() {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
var __read = this && this.__read || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o),
        r,
        ar = [],
        e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {
            ar.push(r.value);
        }
    } catch (error) {
        e = { error: error };
    } finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
            if (e) throw e.error;
        }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
// The monospace font we use...
var MONOSPACE = '"Source Code Pro", "Droid Sans Mono", monospace';
function visibleRAF(elem, func) {
    var window = elem.ownerDocument.defaultView;
    var isRunning = false;
    function setRunning(running) {
        if (isRunning == running) return;
        isRunning = running;
        if (isRunning) window.requestAnimationFrame(update);
    }
    function update(t) {
        func(t);
        if (isRunning) window.requestAnimationFrame(update);
    }
    function callback(entries) {
        var intersectionRatio = entries[entries.length - 1].intersectionRatio;
        var shouldBeRunning = intersectionRatio > 0;
        setRunning(shouldBeRunning);
    }
    var observer = new IntersectionObserver(callback);
    observer.observe(elem);
}
// #region Color Utilities
function colorLerp(ca, cb, t) {
    console.assert(ca[0] === '#' && ca.length === 7);
    var ar = parseInt(ca.slice(1, 3), 16),
        ag = parseInt(ca.slice(3, 5), 16),
        ab = parseInt(ca.slice(5, 7), 16);
    console.assert(cb[0] === '#' && cb.length === 7);
    var br = parseInt(cb.slice(1, 3), 16),
        bg = parseInt(cb.slice(3, 5), 16),
        bb = parseInt(cb.slice(5, 7), 16);
    var nr = ar + (br - ar) * t,
        ng = ag + (bg - ag) * t,
        nb = ab + (bb - ab) * t;
    var r = (nr | 0).toString(16),
        g = (ng | 0).toString(16),
        b = (nb | 0).toString(16);
    return "#" + r + g + b;
}
function colorGrayscale(c) {
    console.assert(c[0] === '#' && c.length === 7);
    var r = parseInt(c.slice(1, 3), 16),
        g = parseInt(c.slice(3, 5), 16),
        b = parseInt(c.slice(5, 7), 16);
    // NTSC primaries.
    var ny = r * 0.299 + g * 0.587 + b * 0.114;
    var y = (ny | 0).toString(16);
    return "#" + y + y + y;
}
// #endregion
// #region Cursor
// Helper class to globally set a cursor.
var CursorOverride = /** @class */function () {
    function CursorOverride(_document) {
        this._document = _document;
        this._styleElem = this._document.createElement('style');
        this._document.head.appendChild(this._styleElem);
        this._style = this._styleElem.sheet;
        this._owner = null;
    }
    CursorOverride.prototype.setCursor = function (owner, cursor) {
        // If we have a current owner, don't let modifications by other owners...
        if (this._owner && owner !== this._owner) return;
        if (this._style.cssRules.length) this._style.deleteRule(0);
        if (cursor) {
            var rule = "* { cursor: " + cursor + " !important; }";
            this._style.insertRule(rule, 0);
            this._owner = owner;
        } else {
            this._owner = null;
        }
    };
    return CursorOverride;
}();
// #endregion
// #region NumberDragger
// Gross number formatting function used to lop unlucky floating points off...
// e.g. 12345.100000007 => '12345.1'
function formatDecimal(value, places) {
    if (places === void 0) {
        places = 2;
    }
    var valueStr = value.toFixed(places);
    while (valueStr.includes('.') && '.0'.includes(valueStr.slice(-1))) {
        valueStr = valueStr.slice(0, -1);
    }return valueStr;
}
var NumberDragger = /** @class */function () {
    function NumberDragger(_document, _cursorOverride) {
        this._document = _document;
        this._cursorOverride = _cursorOverride;
        // User callback.
        this.onvalue = null;
        this.onend = null;
        this._toplevel = this._document.createElement('div');
        this._toplevel.style.position = 'absolute';
        this._toplevel.style.transform = 'translate(0, -50%)';
        this._toplevel.style.fontFamily = MONOSPACE;
        this._toplevel.style.backgroundColor = '#232323';
        this._toplevel.style.color = '#c93';
        this._toplevel.style.border = '2px solid #c93';
        this._toplevel.style.lineHeight = '2em';
        this._toplevel.style.marginLeft = '1em';
        this._toplevel.style.borderRadius = '6px';
        this._toplevel.style.boxShadow = 'rgba(0, 0, 0, .4) 0px 4px 16px';
        this._toplevel.style.zIndex = '9999';
        this._segments = [];
        for (var exp = 2; exp >= -2; exp--) {
            var incr = Math.pow(10, exp);
            var segment = this._document.createElement('div');
            segment._incr = incr;
            segment.style.padding = '.5em 1em';
            segment.textContent = '' + incr;
            this._toplevel.appendChild(segment);
            this._segments.push(segment);
        }
        this._anchorMouseX = 0;
        this._anchorValue = undefined;
        this._value = undefined;
        this._onMouseMove = this._onMouseMove.bind(this);
        this._onMouseUp = this._onMouseUp.bind(this);
    }
    NumberDragger.prototype._onMouseMove = function (e) {
        var e_1, _a;
        e.stopPropagation();
        var accel = 15;
        var dx = Math.round((e.clientX - this._anchorMouseX) / accel);
        var newValue = this._anchorValue + dx * this._currentIncr;
        if (this._value !== newValue) {
            this._value = newValue;
            this.onvalue(this._value);
        }
        var y = e.clientY;
        try {
            for (var _b = __values(this._segments), _c = _b.next(); !_c.done; _c = _b.next()) {
                var segment = _c.value;
                var bbox = segment.getBoundingClientRect();
                if (y < bbox.bottom) {
                    if (this._selectSegment(segment)) {
                        // Set new anchor.
                        if (this._anchorValue !== this._value) {
                            this._anchorMouseX = e.clientX;
                            this._anchorValue = this._value;
                        }
                    }
                    break;
                }
            }
        } catch (e_1_1) {
            e_1 = { error: e_1_1 };
        } finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally {
                if (e_1) throw e_1.error;
            }
        }
    };
    NumberDragger.prototype._onMouseUp = function (e) {
        this._cursorOverride.setCursor(this, '');
        this._document.documentElement.removeEventListener('mouseup', this._onMouseUp);
        this.onend();
        if (this._showTimeout) {
            clearTimeout(this._showTimeout);
            this._showTimeout = 0;
            return;
        }
        this._document.documentElement.removeEventListener('mousemove', this._onMouseMove, { capture: true });
        this._document.body.removeChild(this._toplevel);
    };
    NumberDragger.prototype._selectSegment = function (segment) {
        var e_2, _a;
        var incr = segment._incr;
        if (this._currentIncr === incr) return false;
        this._currentIncr = incr;
        try {
            for (var _b = __values(this._segments), _c = _b.next(); !_c.done; _c = _b.next()) {
                var seg = _c.value;
                var hilite = seg === segment;
                seg.style.backgroundColor = hilite ? '#c93' : '';
                seg.style.color = hilite ? '#222' : '';
                seg.style.fontWeight = hilite ? 'bold' : '';
            }
        } catch (e_2_1) {
            e_2 = { error: e_2_1 };
        } finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally {
                if (e_2) throw e_2.error;
            }
        }
        return true;
    };
    NumberDragger.prototype._show = function () {
        this._showTimeout = 0;
        this._document.body.appendChild(this._toplevel);
        this._document.documentElement.addEventListener('mousemove', this._onMouseMove, { capture: true });
    };
    NumberDragger.prototype.setPosition = function (x, y) {
        this._toplevel.style.left = x + 'px';
        this._toplevel.style.top = y + 'px';
    };
    NumberDragger.prototype.show = function (value, e) {
        this._anchorMouseX = e.clientX;
        this._anchorValue = value;
        // reset
        this._selectSegment(this._segments[2]);
        this._document.documentElement.addEventListener('mouseup', this._onMouseUp);
        // Delay the show a tiny bit...
        this._showTimeout = setTimeout(this._show.bind(this), 100);
        this._cursorOverride.setCursor(this, 'e-resize');
    };
    return NumberDragger;
}();
// #endregion
// XXX: Differing browsers have inconsistent ways of drawing text... specifically,
// they don't always agree on what 'top' baseline alignment is. This tries to
// accurately measure the top margin by drawing a character and scanning where the top is...
function expensiveMeasureTextMargin(document, width, height, font) {
    var canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;
    var ctx = canvas.getContext('2d');
    ctx.font = font;
    ctx.textBaseline = 'top';
    ctx.fillStyle = 'black';
    ctx.fillText('l', 0, 0);
    var image = ctx.getImageData(0, 0, width, height);
    for (var y = 0; y < image.height; y++) {
        for (var x = 0; x < image.width; x++) {
            if (image.data[4 * (y * image.width + x) + 3]) return y;
        }
    }throw new Error('wtf');
}
;
;
;
var CodeEditor = /** @class */function () {
    function CodeEditor(_document) {
        this._document = _document;
        this.onvaluechanged = null;
        this._prefix = '';
        this._suffix = '';
        // Padding, in units of line height.
        this._paddingTop = .2;
        this._paddingBottom = 1.5;
        this._toplevel = this._document.createElement('div');
        this._toplevel.style.position = 'relative';
        // We need to append this to the body to measure / get metrics... :(
        // Setup is particularly wacky... maybe clean it up at some point?
        this._document.body.appendChild(this._toplevel);
        this._textarea = this._document.createElement('textarea');
        this._textarea.style.fontFamily = MONOSPACE;
        this._textarea.oninput = this._onInput.bind(this);
        this._textarea.onkeydown = this._onKeyDown.bind(this);
        this._toplevel.appendChild(this._textarea);
        this._canvas = this._document.createElement('canvas');
        this._toplevel.appendChild(this._canvas);
        this._onMouseDown = this._onMouseDown.bind(this);
        this._onMouseMove = this._onMouseMove.bind(this);
        this._onMouseUp = this._onMouseUp.bind(this);
        this._onMouseLeave = this._onMouseLeave.bind(this);
        this._canvas.onmousedown = this._onMouseDown;
        this._canvas.onmouseleave = this._onMouseLeave;
        this._canvas.onmousemove = this._onMouseMove;
        this._textarea.style.whiteSpace = 'pre-wrap';
        this._textarea.style.wordBreak = 'break-all';
        // Hide the textarea the canvas now that we've sized it...
        this._textarea.style.position = 'absolute';
        this._textarea.style.left = '-99999px';
        this._canvas.style.position = 'absolute';
        this._needsRecalculate = false;
        this._valueChanged = false;
        // Redraw-internal state.
        this._redraw_cursorPosition = undefined;
        this._redraw_cursorBlinkStart = undefined;
        this._cursorOverride = new CursorOverride(this._document);
        this._numberDragger = new NumberDragger(this._document, this._cursorOverride);
        this._numberDragger.onvalue = this._onNumberDraggerValue.bind(this);
        this._numberDragger.onend = this._onNumberDraggerEnd.bind(this);
        this.elem = this._toplevel;
        visibleRAF(this._canvas, this._redraw.bind(this));
    }
    CodeEditor.prototype._setNeedsRecalculate = function () {
        this._needsRecalculate = true;
    };
    CodeEditor.prototype._setValueChanged = function () {
        this._valueChanged = true;
    };
    // Sets a chunk of text at the beginning and end that the user cannot modify.
    CodeEditor.prototype.setPrefixSuffix = function (prefix, suffix) {
        this._prefix = prefix;
        this._suffix = suffix;
        this._setNeedsRecalculate();
    };
    CodeEditor.prototype.setFontSize = function (size) {
        this._textarea.style.fontSize = size;
        this._setNeedsRecalculate();
    };
    CodeEditor.prototype.setLineFlairs = function (lineFlairs) {
        this._lineFlairs = lineFlairs;
    };
    // Sets the size. The height here is actually a minimum height. Since we don't
    // yet have scrolling, the Editor always expands to fill however many lines it
    // takes up...
    CodeEditor.prototype.setSize = function (w, h) {
        if (h !== undefined) this._minHeight = h;
        if (w !== undefined) {
            this._width = w;
            this._canvas.style.width = w + "px";
            this._toplevel.style.width = w + "px";
            // Calculate cols immediately.
            this._cols = this._xyToRowCol(w, 0).col;
            this._textarea.style.width = this._cols + "ch";
        }
        if (w !== undefined || h !== undefined) this._setNeedsRecalculate();
    };
    CodeEditor.prototype.getValue = function () {
        return this._textarea.value;
    };
    CodeEditor.prototype.setValue = function (t) {
        this._textarea.value = t;
        this._setValueChanged();
        this._setNeedsRecalculate();
    };
    CodeEditor.prototype.getFullText = function () {
        return this._prefix + this._textarea.value + this._suffix;
    };
    CodeEditor.prototype._isLineLocked = function (line) {
        if (line.lineno < this._prefixLines) return true;
        if (line.lineno >= this._suffixLines) return true;
        return false;
    };
    CodeEditor.prototype._recalculate = function () {
        if (!this._needsRecalculate) return;
        // If we aren't attached to a parent node, recalculating is futile...
        if (!this._toplevel.parentNode) return;
        // Recalculate our line model.
        var chars = this.getFullText() + '\n';
        var lineModel = [];
        var idx = 0,
            row = 0,
            lineno = 0;
        while (true) {
            var newIdx = chars.indexOf('\n', idx);
            if (newIdx < 0) break;
            var start = idx,
                end = newIdx + 1;
            var length = end - start - 1;
            var startRow = row;
            var rows = Math.max(Math.ceil(length / this._cols), 1);
            lineModel.push({ start: start, end: end, length: length, rows: rows, startRow: startRow, lineno: lineno });
            row += rows;
            lineno++;
            idx = end;
        }
        this._lineModel = lineModel;
        this._prefixLines = this._prefix.split('\n').length - 1;
        this._suffixLines = this._lineModel.length - (this._suffix.split('\n').length - 1);
        // Compute syntax highlights.
        var syntaxRuns = [];
        var draggableNumbers = [];
        var match;
        // Colors taken from the railscasts color scheme.
        var keywords = /\b(function|for|while|if|else|break|continue|in|out|attribute|uniform|varying|return|struct|layout|precision|mediump|lowp|highp|discard)\b/g;
        while ((match = keywords.exec(chars)) !== null) {
            syntaxRuns.push({ start: match.index, end: match.index + match[0].length, color: '#c26230' });
        }var types = /\b(void|bool|float|[ui]?vec[234]|mat[234]|mat[234]x[234]|[u]?int|sampler[23]D)\b/g;
        while ((match = types.exec(chars)) !== null) {
            syntaxRuns.push({ start: match.index, end: match.index + match[0].length, color: '#6d9cbe' });
        }var numbers = /\W-?\d+(\.\d+)?\b/g; // Don't bother supporting scientific notation on numbers...
        while ((match = numbers.exec(chars)) !== null) {
            syntaxRuns.push({ start: match.index + 1, end: match.index + match[0].length, color: '#a5c261' });
            draggableNumbers.push({ start: match.index + 1, end: match.index + match[0].length });
        }
        var strings = /("[^"]*")|('[^']*')/g;
        while ((match = strings.exec(chars)) !== null) {
            syntaxRuns.push({ start: match.index, end: match.index + match[0].length, color: '#6d9cbe' });
        }var comments = /\/\/.*$/gm;
        while ((match = comments.exec(chars)) !== null) {
            syntaxRuns.push({ start: match.index, end: match.index + match[0].length, color: '#bc9458', style: 'italic' });
        }syntaxRuns.sort(function (a, b) {
            return a.start - b.start;
        });
        this._syntaxRuns = syntaxRuns;
        this._draggableNumbers = draggableNumbers;
        var textareaStyle = this._document.defaultView.getComputedStyle(this._textarea);
        this._textareaStyle = textareaStyle;
        var ctx = this._canvas.getContext('2d');
        ctx.font = textareaStyle.fontSize + " " + textareaStyle.fontFamily;
        // We're using a monospace font. It should have identical metrics for all characters,
        // so just measuring one should be fine...
        this._charWidth = ctx.measureText(' ').width;
        var rowHeight = textareaStyle.lineHeight;
        var rowHeightN;
        // XXX: This seems to be a Chrome default for the line-height? Not sure how else I can
        // calculate this guy... grr...
        if (rowHeight === 'normal') rowHeightN = 1.3 * parseFloat(textareaStyle.fontSize);else rowHeightN = parseFloat(rowHeight);
        this._rowHeight = Math.ceil(rowHeightN);
        if (this._charMarginTop === undefined) {
            var stdMargin = 4;
            this._charMarginTop = stdMargin - expensiveMeasureTextMargin(this._document, this._charWidth, this._rowHeight, ctx.font);
        }
        // Recalculate geometry.
        var numLines = this._lineModel.length;
        var gutterChars = ('' + numLines).length;
        this._gutterMargin = 10;
        this._gutterWidth = this._charWidth * Math.max(gutterChars, 2) + this._gutterMargin * 2;
        this._textMargin = 10;
        var lastRow = this._lineModel[this._lineModel.length - 1];
        var numRows = lastRow.startRow + lastRow.rows - 1;
        var newHeight = Math.ceil(Math.max(this._minHeight, this._rowHeight * (numRows + this._paddingTop + this._paddingBottom)));
        if (newHeight !== this._height) {
            this._height = newHeight;
            this._canvas.style.height = this._height + "px";
            this._toplevel.style.height = this._height + "px";
            // Resize the textarea so the window doesn't scroll back in when we click on it...
            this._textarea.style.height = this._height - this._rowHeight + 'px';
        }
        this._needsRecalculate = false;
        this._recalculateMouseIdx();
        if (this._valueChanged && this.onvaluechanged) this.onvaluechanged();
        this._valueChanged = false;
    };
    CodeEditor.prototype._recalculateMouseIdx = function () {
        if (this._mouseX === undefined || this._mouseY === undefined) {
            this._mouseIdx = undefined;
        } else {
            var _a = this._xyToRowCol(this._mouseX, this._mouseY),
                row = _a.row,
                col = _a.col;
            var _b = this._rowColToLineIdx(row, col, false),
                line = _b.line,
                idx = _b.idx;
            var isLineLocked = this._isLineLocked(line);
            this._mouseIdx = isLineLocked ? undefined : idx;
        }
    };
    CodeEditor.prototype._calculateIndentedLineStart = function (line) {
        var chars = this.getFullText();
        var idx = line.start;
        while (chars.charAt(idx) === ' ' && idx <= line.end) {
            idx++;
        }return idx;
    };
    CodeEditor.prototype._onInput = function () {
        this._setValueChanged();
        this._setNeedsRecalculate();
    };
    CodeEditor.prototype._onKeyDown = function (e) {
        if (e.key === 'Tab' && !e.shiftKey) {
            // XXX: If we have a selection, then indent the selection.
            if (!this._hasSelection()) {
                this._insertAtCursor('    ');
            }
            e.preventDefault();
        } else if (e.key === 'Tab' && e.shiftKey) {
            // XXX: If we have a selection, then unindent the selection.
            e.preventDefault();
        } else if (e.key === 'Home') {
            // Move to the start of indentation.
            var cursorIdx = this._getCursorIdx();
            var _a = this._getCharPos(cursorIdx),
                line = _a.line,
                lineIdx = _a.lineIdx;
            var indentedIdx = this._calculateIndentedLineStart(line);
            if (cursorIdx !== indentedIdx) {
                if (e.shiftKey) {
                    var _b = __read(this._getSelection(), 1),
                        selectionPoint = _b[0];
                    this._setSelection(this._idxToTextarea(selectionPoint), this._idxToTextarea(indentedIdx));
                } else {
                    this._setCursor(this._idxToTextarea(indentedIdx));
                }
                e.preventDefault();
            }
        }
    };
    CodeEditor.prototype._onMouseDown = function (e) {
        e.preventDefault();
        var _a = this._xyToRowCol(e.offsetX, e.offsetY),
            row = _a.row,
            col = _a.col;
        var line = this._rowColToLineIdx(row, 0, true).line;
        if (this._isLineLocked(line)) {
            this._textarea.blur();
        } else if (col === -1) {
            this._setSelection(this._idxToTextarea(line.start), this._idxToTextarea(line.end));
            this._textarea.focus();
        } else {
            var idx = this._rowColToLineIdx(row, col, true).idx;
            this._textarea.focus();
            this._dragStartX = e.clientX;
            this._dragStartY = e.clientY;
            var exactIdx = this._rowColToLineIdx(row, col, false).idx;
            var draggableNumber = this._findDraggableNumber(exactIdx);
            if (!e.shiftKey && draggableNumber) {
                var start = this._idxToTextarea(draggableNumber.start);
                var end = this._idxToTextarea(draggableNumber.end);
                var value = +this.getValue().slice(start, end);
                this._draggingNumber = { start: start, end: end, value: value };
                this._syncNumberDraggerPosition();
                this._setCursor(this._idxToTextarea(idx));
                this._numberDragger.show(value, e);
            } else {
                if (e.shiftKey) {
                    // If we don't have a selection, start a new one where the cursor is...
                    // If we have an existing selection, just keep the current dragStartIdx,
                    // since it's still valid.
                    if (!this._hasSelection()) this._dragStartIdx = this._textarea.selectionStart;
                    this._setSelection(this._dragStartIdx, this._idxToTextarea(idx));
                } else {
                    this._dragStartIdx = this._idxToTextarea(idx);
                    this._setCursor(this._dragStartIdx);
                }
                this._dragging = 'selection';
                this._document.documentElement.addEventListener('mousemove', this._onMouseMove, { capture: true });
                this._document.documentElement.addEventListener('mouseup', this._onMouseUp);
            }
        }
    };
    CodeEditor.prototype._onMouseUp = function (e) {
        this._dragging = undefined;
        this._document.documentElement.removeEventListener('mousemove', this._onMouseMove, { capture: true });
        this._document.documentElement.removeEventListener('mouseup', this._onMouseUp);
    };
    CodeEditor.prototype._onMouseMove = function (e) {
        e.stopPropagation();
        this._mouseX = e.offsetX;
        this._mouseY = e.offsetY;
        this._recalculateMouseIdx();
        var _a = this._xyToRowCol(this._mouseX, this._mouseY),
            row = _a.row,
            col = _a.col;
        var _b = this._rowColToLineIdx(row, col, true),
            line = _b.line,
            idx = _b.idx;
        if (this._dragging === 'selection') {
            this._setSelection(this._dragStartIdx, this._idxToTextarea(idx));
            this._textarea.focus();
        }
        var _c = this._rowColToLineIdx(row, col, false),
            exactLine = _c.line,
            exactIdx = _c.idx;
        var isLineLocked = this._isLineLocked(line);
        // Dragging takes priority.
        var cursor;
        if (this._dragging === 'selection') {
            cursor = 'text';
        } else if (col === -1 || isLineLocked) {
            cursor = 'default';
        } else if (!e.shiftKey && this._findDraggableNumber(exactIdx)) {
            cursor = 'e-resize';
        } else {
            cursor = 'text';
        }
        this._canvas.style.cursor = cursor;
        if (this._dragging) this._cursorOverride.setCursor(this, cursor);else this._cursorOverride.setCursor(this, '');
    };
    CodeEditor.prototype._onMouseLeave = function (e) {
        this._mouseX = undefined;
        this._mouseY = undefined;
        this._mouseIdx = undefined;
    };
    CodeEditor.prototype._onNumberDraggerValue = function (newValue) {
        this._textarea.blur();
        var _a = this._draggingNumber,
            start = _a.start,
            end = _a.end;
        var newValueString = formatDecimal(newValue);
        this.setValue(this._spliceValue(start, end, newValueString));
        this._draggingNumber.end = this._draggingNumber.start + newValueString.length;
        this._syncNumberDraggerPosition();
    };
    CodeEditor.prototype._onNumberDraggerEnd = function () {
        this._draggingNumber = null;
    };
    CodeEditor.prototype._syncNumberDraggerPosition = function () {
        var _a = this._draggingNumber,
            start = _a.start,
            end = _a.end;
        var endPos = this._getCharPos(this._textareaToIdx(end));
        var _b = this._rowColToXY(endPos.row, endPos.col),
            x = _b.x,
            y = _b.y;
        var bbox = this._toplevel.getBoundingClientRect();
        var absX = bbox.left + x;
        var absY = bbox.top + y + this._rowHeight / 2 + this._document.defaultView.scrollY;
        this._numberDragger.setPosition(absX, absY);
    };
    CodeEditor.prototype._spliceValue = function (start, end, v) {
        var chars = this.getValue();
        return chars.slice(0, start) + v + chars.slice(end);
    };
    CodeEditor.prototype._findDraggableNumber = function (idx) {
        this._recalculate();
        return this._draggableNumbers.find(function (_a) {
            var start = _a.start,
                end = _a.end;
            return idx >= start && idx <= end;
        });
    };
    CodeEditor.prototype._idxToTextarea = function (idx) {
        return idx - this._prefix.length;
    };
    CodeEditor.prototype._textareaToIdx = function (idx) {
        return idx + this._prefix.length;
    };
    CodeEditor.prototype._rowColToLineIdx = function (row, col, clampIdx) {
        var e_3, _a;
        this._recalculate();
        var line;
        try {
            for (var _b = __values(this._lineModel), _c = _b.next(); !_c.done; _c = _b.next()) {
                line = _c.value;
                if (row >= line.startRow && row < line.startRow + line.rows) break;
            }
        } catch (e_3_1) {
            e_3 = { error: e_3_1 };
        } finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally {
                if (e_3) throw e_3.error;
            }
        }
        var lineIdx;
        // Fast path.
        if (line.rows === 1) {
            lineIdx = col;
        } else {
            lineIdx = (row - line.startRow) * this._cols + col;
        }
        var idx;
        if (clampIdx) idx = line.start + Math.min(Math.max(lineIdx, 0), line.length);else if (lineIdx > line.length) idx = -1;else idx = line.start + lineIdx;
        return { line: line, idx: idx };
    };
    CodeEditor.prototype._xyToRowCol = function (x, y) {
        this._recalculate();
        y -= this._paddingTop * this._rowHeight;
        var row = Math.floor(y / this._rowHeight);
        var col;
        if (x < this._gutterWidth) col = -1;
        x -= this._gutterWidth;
        if (col === undefined && x < this._textMargin) col = 0;
        x -= this._textMargin;
        if (col === undefined) col = Math.round(x / this._charWidth);
        return { row: row, col: col };
    };
    CodeEditor.prototype._rowColToXY = function (row, col) {
        var x = this._gutterWidth + this._textMargin + col * this._charWidth;
        var y = (this._paddingTop + row) * this._rowHeight;
        return { x: x, y: y };
    };
    CodeEditor.prototype._getRowLength = function (row) {
        var e_4, _a;
        this._recalculate();
        var line;
        try {
            for (var _b = __values(this._lineModel), _c = _b.next(); !_c.done; _c = _b.next()) {
                line = _c.value;
                if (row >= line.startRow && row < line.startRow + line.rows) break;
            }
        } catch (e_4_1) {
            e_4 = { error: e_4_1 };
        } finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally {
                if (e_4) throw e_4.error;
            }
        }
        // Fast path.
        if (line.rows === 1) return line.length;
        if (row === line.startRow + line.rows - 1) return line.length % this._cols;else return this._cols;
    };
    CodeEditor.prototype._getCharPos = function (idx) {
        var e_5, _a;
        this._recalculate();
        var line;
        try {
            for (var _b = __values(this._lineModel), _c = _b.next(); !_c.done; _c = _b.next()) {
                line = _c.value;
                if (idx >= line.start && idx < line.end) break;
            }
        } catch (e_5_1) {
            e_5 = { error: e_5_1 };
        } finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally {
                if (e_5) throw e_5.error;
            }
        }
        var lineIdx = idx - line.start;
        // Fast path.
        if (line.rows === 1) return { line: line, lineIdx: lineIdx, row: line.startRow, col: lineIdx };
        // Slow path.
        var col = lineIdx % this._cols;
        var row = line.startRow + Math.min(lineIdx / this._cols | 0, line.rows);
        return { line: line, lineIdx: lineIdx, row: row, col: col };
    };
    CodeEditor.prototype._hasSelection = function () {
        return this._textarea.selectionStart !== this._textarea.selectionEnd;
    };
    CodeEditor.prototype._getSelection = function () {
        var selStartIdx = this._textareaToIdx(this._textarea.selectionStart);
        var selEndIdx = this._textareaToIdx(this._textarea.selectionEnd);
        // [selectionStart, cursor]
        if (this._textarea.selectionDirection === 'forward') return [selStartIdx, selEndIdx];else return [selEndIdx, selStartIdx];
    };
    CodeEditor.prototype._getCursorIdx = function () {
        var _a = __read(this._getSelection(), 2),
            selectionPointIdx = _a[0],
            cursorIdx = _a[1];
        return cursorIdx;
    };
    CodeEditor.prototype._setSelection = function (a, b) {
        // The selection starts at "a" and ends with the cursor position being at "b".
        var start = Math.min(a, b),
            end = Math.max(a, b);
        var direction = a < b ? 'forward' : 'backward';
        this._textarea.setSelectionRange(start, end, direction);
    };
    CodeEditor.prototype._setCursor = function (a) {
        this._textarea.setSelectionRange(a, a);
    };
    CodeEditor.prototype._insertAtCursor = function (s) {
        this._textarea.focus();
        if (!this._document.execCommand('insertText', false, s)) {
            // execCommand failed. Fall back to setting value manually. This happens in Firefox:
            // https://github.com/w3c/editing/issues/160
            // https://bugzilla.mozilla.org/show_bug.cgi?id=1220696
            // On modern Firefox versions, it will also wipe the undo buffer unfortunately.
            // The """web platform"" is a piece of trash and I don't like it.
            var value = this._textarea.value;
            var selStart = this._textarea.selectionStart;
            var selEnd = this._textarea.selectionEnd;
            this._textarea.value = value.slice(0, selStart) + s + value.slice(selEnd);
            this._textarea.focus();
        }
        this._setValueChanged();
        this._setNeedsRecalculate();
    };
    CodeEditor.prototype._redraw = function (t) {
        var _this = this;
        var e_6, _a;
        var hasFocus = this._textarea.matches(':focus');
        // Skip redrawing if we're up to date to cut down on costs...
        if (!this._needsRecalculate && !hasFocus) return;
        this._recalculate();
        var canvasRect = this._canvas.getBoundingClientRect();
        var ratio = this._document.defaultView.devicePixelRatio;
        var canvasWidth = this._width * ratio;
        var canvasHeight = this._height * ratio;
        var sizeChanged = false;
        if (this._canvas.width !== canvasWidth || this._canvas.height !== canvasHeight) {
            this._canvas.width = canvasWidth;
            this._canvas.height = canvasHeight;
            sizeChanged = true;
        }
        // Clip to viewport.
        var scissorX1 = Math.max(0, canvasRect.left);
        var scissorY1 = Math.max(0, canvasRect.top);
        var viewportWidth = this._document.defaultView.innerWidth;
        var viewportHeight = this._document.defaultView.innerHeight;
        var scissorX2 = Math.min(viewportWidth, canvasRect.right);
        var scissorY2 = Math.min(viewportHeight, canvasRect.bottom);
        // Put in canvas space.
        var clipRectX = scissorX1 - canvasRect.left;
        var clipRectY = scissorY1 - canvasRect.top;
        var clipRectW = scissorX2 - scissorX1;
        var clipRectH = scissorY2 - scissorY1;
        var ctx = this._canvas.getContext('2d');
        ctx.save();
        if (!sizeChanged) {
            ctx.rect(clipRectX, clipRectY, clipRectW, clipRectH);
            ctx.clip();
        }
        ctx.scale(ratio, ratio);
        var bgcolor = '#232323';
        ctx.fillStyle = bgcolor;
        ctx.fillRect(0, 0, this._width, this._height);
        if (hasFocus) {
            // Has a cursor.
            var cursorPosition = this._idxToTextarea(this._getCursorIdx());
            if (this._redraw_cursorPosition !== cursorPosition) {
                this._redraw_cursorPosition = cursorPosition;
                // Set it blinking again.
                this._redraw_cursorBlinkStart = t;
            }
        } else {
            this._redraw_cursorPosition = undefined;
        }
        var textareaStyleFontSize = this._textareaStyle.fontSize;
        var textareaStyleFontFamily = this._textareaStyle.fontFamily;
        ctx.font = textareaStyleFontSize + " " + textareaStyleFontFamily;
        var drawFlair = function drawFlair(line, flair) {
            var y = (_this._paddingTop + line.startRow) * _this._rowHeight;
            var height = line.rows * _this._rowHeight;
            ctx.fillStyle = flair.color;
            ctx.fillRect(0, y, _this._canvas.width, _this._rowHeight);
        };
        if (this._redraw_cursorPosition) {
            var line = this._getCharPos(this._textareaToIdx(this._redraw_cursorPosition)).line;
            drawFlair(line, { color: '#2f2a34', lineno: -1 });
        }
        if (this._lineFlairs) {
            try {
                for (var _b = __values(this._lineFlairs), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var flair = _c.value;
                    var line = this._lineModel[flair.lineno];
                    if (!line) continue;
                    drawFlair(line, flair);
                }
            } catch (e_6_1) {
                e_6 = { error: e_6_1 };
            } finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                } finally {
                    if (e_6) throw e_6.error;
                }
            }
        }
        // Gutter
        ctx.save();
        ctx.fillStyle = '#445';
        ctx.fillRect(0, 0, this._gutterWidth, this._canvas.height);
        ctx.restore();
        // Gutter text.
        for (var i = 0; i < this._lineModel.length; i++) {
            var line = this._lineModel[i];
            var no = line.lineno + 1;
            var y = (this._paddingTop + line.startRow) * this._rowHeight;
            ctx.fillStyle = this._isLineLocked(line) ? '#888' : '#ccc';
            ctx.textBaseline = 'top';
            ctx.textAlign = 'right';
            var noString = '' + no;
            ctx.fillText(noString, this._gutterWidth - this._gutterMargin, this._charMarginTop + y);
        }
        // Add a newline at the end to make paint logic simpler.
        var chars = this.getFullText() + '\n';
        ctx.save();
        ctx.translate(this._gutterWidth + this._textMargin, 0);
        if (this._hasSelection()) {
            // Draw selection bounds.
            var inSelection = false;
            var startPos = this._getCharPos(this._textareaToIdx(this._textarea.selectionStart));
            var endPos = this._getCharPos(this._textareaToIdx(this._textarea.selectionEnd));
            for (var row = startPos.row; row <= endPos.row; row++) {
                var colStart = row === startPos.row ? startPos.col : 0;
                var colEnd = row === endPos.row ? endPos.col : this._getRowLength(row);
                var selectionColor = hasFocus ? '#336' : '#333';
                var startX = colStart * this._charWidth;
                var endX = colEnd * this._charWidth;
                var y = (this._paddingTop + row) * this._rowHeight;
                ctx.fillStyle = selectionColor;
                ctx.fillRect(startX, y, endX - startX, this._rowHeight);
            }
        }
        var syntaxRuns = this._syntaxRuns;
        var currentSyntaxRun = 0;
        // Anything interesting under the mouse?
        var draggableNumber;
        if (this._draggingNumber) {
            var _d = this._draggingNumber,
                start = _d.start,
                end = _d.end;
            draggableNumber = { start: this._textareaToIdx(start), end: this._textareaToIdx(end) };
        } else if (!this._dragging && this._mouseIdx > -1) {
            draggableNumber = this._findDraggableNumber(this._mouseIdx);
        }
        // Setting the font on a CanvasRenderingContext2D in Firefox is expensive, so try
        // to set it as little as possible by only setting it when it changes.
        var currentFont;
        // Now for the actual paint.
        for (var m = 0; m < this._lineModel.length; m++) {
            var line = this._lineModel[m];
            var row = line.startRow,
                col = 0;
            for (var i = line.start; i < line.end; i++) {
                if (col === this._cols && row - line.startRow < line.rows - 1) {
                    row++;
                    col = 0;
                }
                // XXX: Use something else other than charAt for Unicode compliance.
                var char = chars.charAt(i);
                var x = col * this._charWidth,
                    y = (this._paddingTop + row) * this._rowHeight;
                if (i === this._textareaToIdx(this._redraw_cursorPosition)) {
                    // Draw cursor.
                    ctx.save();
                    ctx.fillStyle = '#fff';
                    var blinkAnimationT = (t - this._redraw_cursorBlinkStart) / 1000;
                    var blinkAlpha = Math.sin(blinkAnimationT * 6) + 1;
                    ctx.globalAlpha = blinkAlpha;
                    ctx.fillRect(Math.floor(x), y, 2, this._rowHeight);
                    ctx.restore();
                }
                if (char === '\n') break;
                if (draggableNumber !== undefined && i >= draggableNumber.start && i < draggableNumber.end) {
                    ctx.save();
                    ctx.beginPath();
                    ctx.moveTo(x | 0, y + this._rowHeight);
                    ctx.lineTo(x + this._charWidth | 0, y + this._rowHeight);
                    ctx.setLineDash([1, 1]);
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                    ctx.restore();
                }
                var color = '#e6e1dc';
                var style = '';
                while (currentSyntaxRun < syntaxRuns.length && i >= syntaxRuns[currentSyntaxRun].end) {
                    currentSyntaxRun++;
                }if (currentSyntaxRun < syntaxRuns.length) {
                    var run = syntaxRuns[currentSyntaxRun];
                    if (i >= run.start && i < run.end) {
                        if (run.color) color = run.color;
                        if (run.style) style = run.style;
                    }
                }
                if (this._isLineLocked(line)) {
                    color = colorLerp(color, colorGrayscale(color), 0.75);
                }
                ctx.textBaseline = 'top';
                ctx.textAlign = 'left';
                ctx.fillStyle = color;
                var newFont = style + " " + textareaStyleFontSize + " " + textareaStyleFontFamily;
                if (currentFont !== newFont) {
                    ctx.font = newFont;
                    currentFont = newFont;
                }
                ctx.fillText(char, x, y + this._charMarginTop);
                col++;
            }
        }
        ctx.restore();
        ctx.restore();
    };
    return CodeEditor;
}();
exports.default = CodeEditor;
},{}],"Program.ts":[function(require,module,exports) {
"use strict";

var __extends = this && this.__extends || function () {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
        d.__proto__ = b;
    } || function (d, b) {
        for (var p in b) {
            if (b.hasOwnProperty(p)) d[p] = b[p];
        }
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var MemoizeCache_1 = __importDefault(require("./MemoizeCache"));
var CodeEditor_1 = __importDefault(require("./CodeEditor"));
var util_1 = require("./util");
var DEBUG = true;
function leftPad(n, v, num) {
    var s = '' + n;
    while (s.length < num) {
        s = v + s;
    }return s;
}
function prependLineNo(str, lineStart) {
    if (lineStart === void 0) {
        lineStart = 1;
    }
    var lines = str.split('\n');
    return lines.map(function (s, i) {
        return leftPad(lineStart + i, ' ', 4) + "  " + s;
    }).join('\n');
}
function compileShader(gl, str, type) {
    var shader = util_1.assertExists(gl.createShader(type));
    gl.shaderSource(shader, str);
    gl.compileShader(shader);
    if (DEBUG && !gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error(prependLineNo(str));
        var debug_shaders = gl.getExtension('WEBGL_debug_shaders');
        if (debug_shaders) console.error(debug_shaders.getTranslatedShaderSource(shader));
        console.error(gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
    }
    return shader;
}
var BaseProgram = /** @class */function () {
    function BaseProgram() {
        this.name = '(unnamed)';
        // Add some extra fields so that the monstrosity of frag/vert doesn't show up in Firefox's debugger.
        this._pad0 = false;
        this._pad1 = false;
        this.vert = '';
        this.frag = '';
        this.forceRecompile = false;
    }
    BaseProgram.prototype.compile = function (gl, programCache) {
        if (!this.glProg || this.forceRecompile) {
            this.forceRecompile = false;
            var vert = this.preprocessShader(gl, this.vert, "vert");
            var frag = this.preprocessShader(gl, this.frag, "frag");
            var newProg = programCache.compileProgram(vert, frag);
            if (newProg !== null) {
                this.glProg = newProg;
                this.bind(gl, this.glProg);
            }
        }
        if (!this.glProg) {
            throw new Error();
        }
        return this.glProg;
    };
    BaseProgram.prototype.preprocessShader = function (gl, source, type) {
        // Garbage WebGL2 shader compiler until I get something better down the line...
        var lines = source.split('\n').map(function (n) {
            // Remove comments.
            return n.replace(/[/][/].*$/, '');
        }).filter(function (n) {
            // Filter whitespace.
            var isEmpty = !n || /^\s+$/.test(n);
            return !isEmpty;
        });
        var precision = lines.find(function (line) {
            return line.startsWith('precision');
        }) || 'precision mediump float;';
        var extensionLines = lines.filter(function (line) {
            return line.startsWith('#extension');
        });
        var extensions = extensionLines.filter(function (line) {
            return line.indexOf('GL_EXT_frag_depth') === -1 || line.indexOf('GL_OES_standard_derivatives') === -1;
        }).join('\n');
        var rest = lines.filter(function (line) {
            return !line.startsWith('precision') && !line.startsWith('#extension');
        }).join('\n');
        var extensionDefines = util_1.assertExists(gl.getSupportedExtensions()).map(function (s) {
            return "#define HAS_" + s;
        }).join('\n');
        return ("\n#version 300 es\n#define attribute in\n#define varying " + (type === 'vert' ? 'out' : 'in') + "\n" + extensionDefines + "\n#define gl_FragColor o_color\n#define texture2D texture\n" + extensions + "\n" + precision + "\nout vec4 o_color;\n" + rest + "\n").trim();
    };
    BaseProgram.prototype.destroy = function (gl) {
        // TODO(jstpierre): Refcounting in the program cache?
    };
    BaseProgram.prototype._editShader = function (n) {
        var _this = this;
        var win = util_1.assertExists(window.open('about:blank', undefined, "location=off, resizable, alwaysRaised, left=20, top=20, width=1200, height=900"));
        var init = function init() {
            var editor = new CodeEditor_1.default(win.document);
            var document = win.document;
            var title = n === 'vert' ? _this.name + " - Vertex Shader" : _this.name + " - Fragment Shader";
            document.title = title;
            document.body.style.margin = '0';
            var shader = _this[n];
            editor.setValue(shader);
            editor.setFontSize('16px');
            var timeout = 0;
            editor.onvaluechanged = function () {
                if (timeout > 0) clearTimeout(timeout);
                timeout = setTimeout(tryCompile, 500);
            };
            var onresize = win.onresize = function () {
                editor.setSize(document.body.offsetWidth, window.innerHeight);
            };
            onresize();
            var tryCompile = function tryCompile() {
                timeout = 0;
                _this[n] = editor.getValue();
                _this.forceRecompile = true;
            };
            win.editor = editor;
            win.document.body.appendChild(editor.elem);
        };
        if (win.document.readyState === 'complete') init();else win.onload = init;
    };
    BaseProgram.prototype.editv = function () {
        this._editShader('vert');
    };
    BaseProgram.prototype.editf = function () {
        this._editShader('frag');
    };
    return BaseProgram;
}();
exports.BaseProgram = BaseProgram;
// TODO(jstpierre): Remove.
var Program = /** @class */function (_super) {
    __extends(Program, _super);
    function Program() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.projectionLocation = null;
        _this.modelViewLocation = null;
        return _this;
    }
    Program.prototype.bind = function (gl, prog) {
        this.modelViewLocation = util_1.assertExists(gl.getUniformLocation(prog, "u_modelView"));
        this.projectionLocation = util_1.assertExists(gl.getUniformLocation(prog, "u_projection"));
    };
    return Program;
}(BaseProgram);
exports.default = Program;
var FullscreenProgram = /** @class */function (_super) {
    __extends(FullscreenProgram, _super);
    function FullscreenProgram() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.vert = "\nout vec2 v_TexCoord;\n\nvoid main() {\n    v_TexCoord.x = (gl_VertexID == 1) ? 2.0 : 0.0;\n    v_TexCoord.y = (gl_VertexID == 2) ? 2.0 : 0.0;\n    gl_Position.xy = v_TexCoord * vec2(2) - vec2(1);\n    gl_Position.zw = vec2(1);\n}\n";
        return _this;
    }
    FullscreenProgram.prototype.bind = function (gl, prog) {
        // Nothing to do.
    };
    return FullscreenProgram;
}(BaseProgram);
exports.FullscreenProgram = FullscreenProgram;
var ProgramCache = /** @class */function (_super) {
    __extends(ProgramCache, _super);
    function ProgramCache(gl) {
        var _this = _super.call(this) || this;
        _this.gl = gl;
        return _this;
    }
    ProgramCache.prototype.make = function (key) {
        var gl = this.gl;
        var vertShader = compileShader(gl, key.vert, gl.VERTEX_SHADER);
        var fragShader = compileShader(gl, key.frag, gl.FRAGMENT_SHADER);
        if (!vertShader || !fragShader) return null;
        var prog = gl.createProgram();
        gl.attachShader(prog, vertShader);
        gl.attachShader(prog, fragShader);
        gl.linkProgram(prog);
        gl.deleteShader(vertShader);
        gl.deleteShader(fragShader);
        if (DEBUG && !gl.getProgramParameter(prog, gl.LINK_STATUS)) {
            console.error(key.vert);
            console.error(key.frag);
            console.error(gl.getProgramInfoLog(prog));
            gl.deleteProgram(prog);
            return null;
        }
        return prog;
    };
    ProgramCache.prototype.destroy = function (obj) {
        var gl = this.gl;
        gl.deleteProgram(obj);
    };
    ProgramCache.prototype.makeKey = function (key) {
        return key.vert + "$" + key.frag;
    };
    ProgramCache.prototype.compileProgram = function (vert, frag) {
        return this.get({ vert: vert, frag: frag });
    };
    return ProgramCache;
}(MemoizeCache_1.default);
exports.ProgramCache = ProgramCache;
},{"./MemoizeCache":"MemoizeCache.ts","./CodeEditor":"CodeEditor.ts","./util":"util.ts"}],"Camera.ts":[function(require,module,exports) {
"use strict";

var __read = this && this.__read || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o),
        r,
        ar = [],
        e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {
            ar.push(r.value);
        }
    } catch (error) {
        e = { error: error };
    } finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
            if (e) throw e.error;
        }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var gl_matrix_1 = require("gl-matrix");
var util_1 = require("./util");
var Plane = /** @class */function () {
    function Plane() {}
    Plane.prototype.test = function (x, y, z) {
        var dot = x * this.x + y * this.y + z * this.z;
        return this.d + dot;
    };
    Plane.prototype.set = function (p0, p1, p2) {
        var scratch = Plane.scratchVec3;
        gl_matrix_1.vec3.sub(scratch[0], p2, p0);
        gl_matrix_1.vec3.sub(scratch[1], p1, p0);
        gl_matrix_1.vec3.cross(scratch[0], scratch[0], scratch[1]);
        gl_matrix_1.vec3.normalize(scratch[0], scratch[0]);
        this.x = scratch[0][0];
        this.y = scratch[0][1];
        this.z = scratch[0][2];
        this.d = -gl_matrix_1.vec3.dot(scratch[0], p0);
    };
    Plane.scratchVec3 = util_1.nArray(2, function () {
        return gl_matrix_1.vec3.create();
    });
    return Plane;
}();
var scratchVec3a = gl_matrix_1.vec3.create();
var scratchVec3b = gl_matrix_1.vec3.create();
var scratchVec3c = gl_matrix_1.vec3.create();
var scratchVec3d = gl_matrix_1.vec3.create();
var AABB = /** @class */function () {
    function AABB(minX, minY, minZ, maxX, maxY, maxZ) {
        if (minX === void 0) {
            minX = 0;
        }
        if (minY === void 0) {
            minY = 0;
        }
        if (minZ === void 0) {
            minZ = 0;
        }
        if (maxX === void 0) {
            maxX = 0;
        }
        if (maxY === void 0) {
            maxY = 0;
        }
        if (maxZ === void 0) {
            maxZ = 0;
        }
        this.minX = minX;
        this.minY = minY;
        this.minZ = minZ;
        this.maxX = maxX;
        this.maxY = maxY;
        this.maxZ = maxZ;
    }
    AABB.prototype.transform = function (src, m) {
        // Transforming Axis-Aligned Bounding Boxes from Graphics Gems.
        var srcMin = scratchVec3a,
            srcMax = scratchVec3b;
        gl_matrix_1.vec3.set(srcMin, src.minX, src.minY, src.minZ);
        gl_matrix_1.vec3.set(srcMax, src.maxX, src.maxY, src.maxZ);
        var dstMin = scratchVec3c,
            dstMax = scratchVec3d;
        // Translation can be applied directly.
        gl_matrix_1.vec3.set(dstMin, m[12], m[13], m[14]);
        gl_matrix_1.vec3.set(dstMax, m[12], m[13], m[14]);
        for (var i = 0; i < 3; i++) {
            for (var j = 0; j < 3; j++) {
                var a = m[j * 4 + i] * srcMin[j];
                var b = m[j * 4 + i] * srcMax[j];
                if (a < b) {
                    dstMin[i] += a;
                    dstMax[i] += b;
                } else {
                    dstMin[i] += b;
                    dstMax[i] += a;
                }
            }
        }
        this.minX = dstMin[0];
        this.minY = dstMin[1];
        this.minZ = dstMin[2];
        this.maxX = dstMax[0];
        this.maxY = dstMax[1];
        this.maxZ = dstMax[2];
    };
    AABB.prototype.set = function (points) {
        this.minX = this.minY = this.minZ = Infinity;
        this.maxX = this.maxY = this.maxZ = -Infinity;
        for (var i = 0; i < points.length; i++) {
            var p = points[i];
            this.minX = Math.min(this.minX, p[0]);
            this.minY = Math.min(this.minY, p[1]);
            this.minZ = Math.min(this.minZ, p[2]);
            this.maxX = Math.max(this.maxX, p[0]);
            this.maxY = Math.max(this.maxY, p[1]);
            this.maxZ = Math.max(this.maxZ, p[2]);
        }
    };
    AABB.intersect = function (a, b) {
        return !(a.minX > b.maxX || b.minX > a.maxX || a.minY > b.maxY || b.minY > a.maxY || a.minZ > b.maxZ || b.minZ > a.maxZ);
    };
    return AABB;
}();
exports.AABB = AABB;
var FrustumVisualizer = /** @class */function () {
    function FrustumVisualizer() {
        this.scale = 1 / 100000;
        this.canvas = document.createElement('canvas');
        this.canvas.width = 1080;
        this.canvas.height = 768;
        document.body.appendChild(this.canvas);
        this.canvas.style.position = 'absolute';
        this.canvas.style.top = '0';
        this.canvas.style.left = '0';
        this.canvas.style.opacity = '0.5';
        this.canvas.style.pointerEvents = 'none';
        this.ctx = this.canvas.getContext('2d');
    }
    FrustumVisualizer.prototype.newFrame = function () {
        this.ctx.fillStyle = 'white';
        this.ctx.save();
        this.ctx.setTransform(1, 0, 0, 1, 0, 0);
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        this.ctx.restore();
    };
    FrustumVisualizer.prototype.dsx = function (n) {
        return (n * this.scale + 0.5) * this.canvas.width;
    };
    FrustumVisualizer.prototype.dsy = function (n) {
        return (n * this.scale + 0.5) * this.canvas.height;
    };
    FrustumVisualizer.prototype.daabb /* on the haters */ = function (aabb) {
        var x1 = this.dsx(aabb.minX);
        var y1 = this.dsy(aabb.minZ);
        var x2 = this.dsx(aabb.maxX);
        var y2 = this.dsy(aabb.maxZ);
        this.ctx.strokeRect(x1, y1, x2 - x1, y2 - y1);
    };
    return FrustumVisualizer;
}();
var IntersectionState;
(function (IntersectionState) {
    IntersectionState[IntersectionState["FULLY_INSIDE"] = 0] = "FULLY_INSIDE";
    IntersectionState[IntersectionState["FULLY_OUTSIDE"] = 1] = "FULLY_OUTSIDE";
    IntersectionState[IntersectionState["PARTIAL_INTERSECT"] = 2] = "PARTIAL_INTERSECT";
})(IntersectionState = exports.IntersectionState || (exports.IntersectionState = {}));
var Frustum = /** @class */function () {
    function Frustum() {
        // World-space configuration.
        this.aabb = new AABB();
        // Left, Right, Near, Far, Top, Bottom
        this.planes = util_1.nArray(6, function () {
            return new Plane();
        });
        this.visualizer = null;
    }
    Frustum.prototype.makeVisualizer = function () {
        this.visualizer = new FrustumVisualizer();
    };
    Frustum.prototype.setViewFrustum = function (left, right, bottom, top, n, f) {
        this.left = left;
        this.right = right;
        this.bottom = bottom;
        this.top = top;
        this.near = -n;
        this.far = -f;
    };
    Frustum.prototype.updateWorldFrustum = function (worldMatrix) {
        var scratch = Frustum.scratchPlaneVec3;
        var fn = this.far / this.near;
        gl_matrix_1.vec3.set(scratch[0], this.left, this.top, this.near);
        gl_matrix_1.vec3.set(scratch[1], this.right, this.top, this.near);
        gl_matrix_1.vec3.set(scratch[2], this.right, this.bottom, this.near);
        gl_matrix_1.vec3.set(scratch[3], this.left, this.bottom, this.near);
        gl_matrix_1.vec3.set(scratch[4], fn * this.left, fn * this.top, this.far);
        gl_matrix_1.vec3.set(scratch[5], fn * this.right, fn * this.top, this.far);
        gl_matrix_1.vec3.set(scratch[6], fn * this.right, fn * this.bottom, this.far);
        gl_matrix_1.vec3.set(scratch[7], fn * this.left, fn * this.bottom, this.far);
        gl_matrix_1.vec3.set(scratch[8], 0, 0, 0);
        for (var i = 0; i < 9; i++) {
            gl_matrix_1.vec3.transformMat4(scratch[i], scratch[i], worldMatrix);
        }this.aabb.set(scratch);
        this.planes[0].set(scratch[8], scratch[3], scratch[0]); // left plane
        this.planes[1].set(scratch[8], scratch[1], scratch[2]); // right plane
        this.planes[2].set(scratch[0], scratch[1], scratch[2]); // near plane
        this.planes[3].set(scratch[4], scratch[7], scratch[6]); // far plane
        this.planes[4].set(scratch[8], scratch[0], scratch[1]); // top plane
        this.planes[5].set(scratch[8], scratch[2], scratch[3]); // bottom plane
        if (this.visualizer) {
            var ctx = this.visualizer.ctx;
            var scale = this.visualizer.scale;
            // TODO(jstpierre): why isn't this working?
            ctx.setTransform(1, 0, 0, 1, -worldMatrix[12] * scale, -worldMatrix[14] * scale);
            ctx.strokeStyle = 'red';
            this.visualizer.daabb(this.aabb);
            gl_matrix_1.vec3.set(scratch[0], this.left, 0, this.near);
            gl_matrix_1.vec3.set(scratch[1], this.right, 0, this.near);
            gl_matrix_1.vec3.set(scratch[2], fn * this.right, 0, this.far);
            gl_matrix_1.vec3.set(scratch[3], fn * this.left, 0, this.far);
            ctx.strokeStyle = 'green';
            ctx.beginPath();
            for (var i = 0; i < 4; i++) {
                var p = scratch[i];
                gl_matrix_1.vec3.transformMat4(p, p, worldMatrix);
                var x = this.visualizer.dsx(p[0]);
                var y = this.visualizer.dsy(p[2]);
                ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.stroke();
        }
    };
    Frustum.prototype._intersect = function (aabb) {
        if (!AABB.intersect(this.aabb, aabb)) return IntersectionState.FULLY_OUTSIDE;
        var ret = IntersectionState.FULLY_INSIDE;
        // Test planes.
        for (var i = 0; i < 6; i++) {
            var plane = this.planes[i];
            // Nearest point to the frustum.
            var px = plane.x >= 0 ? aabb.minX : aabb.maxX;
            var py = plane.y >= 0 ? aabb.minY : aabb.maxY;
            var pz = plane.z >= 0 ? aabb.minZ : aabb.maxZ;
            if (plane.test(px, py, pz) > 0) return IntersectionState.FULLY_OUTSIDE;
            // Farthest point from the frustum.
            var fx = plane.x >= 0 ? aabb.maxX : aabb.minX;
            var fy = plane.y >= 0 ? aabb.maxY : aabb.minY;
            var fz = plane.z >= 0 ? aabb.maxZ : aabb.minZ;
            if (plane.test(fx, fy, fz) > 0) ret = IntersectionState.PARTIAL_INTERSECT;
        }
        return ret;
    };
    Frustum.prototype.intersect = function (aabb) {
        var res = this._intersect(aabb);
        if (this.visualizer) {
            var ctx = this.visualizer.ctx;
            ctx.strokeStyle = res === IntersectionState.FULLY_INSIDE ? 'black' : res === IntersectionState.FULLY_OUTSIDE ? 'red' : 'cyan';
            this.visualizer.daabb(aabb);
        }
        return res;
    };
    Frustum.prototype.newFrame = function () {
        if (this.visualizer) this.visualizer.newFrame();
    };
    Frustum.scratchPlaneVec3 = util_1.nArray(9, function () {
        return gl_matrix_1.vec3.create();
    });
    return Frustum;
}();
var Camera = /** @class */function () {
    function Camera() {
        this.viewMatrix = gl_matrix_1.mat4.create();
        this.worldMatrix = gl_matrix_1.mat4.create();
        this.projectionMatrix = gl_matrix_1.mat4.create();
        this.frustum = new Frustum();
    }
    Camera.prototype.identity = function () {
        gl_matrix_1.mat4.identity(this.worldMatrix);
        gl_matrix_1.mat4.identity(this.viewMatrix);
    };
    Camera.prototype.worldMatrixUpdated = function () {
        gl_matrix_1.mat4.invert(this.viewMatrix, this.worldMatrix);
        this.frustum.updateWorldFrustum(this.worldMatrix);
    };
    Camera.prototype.setPerspective = function (fovY, aspect, n, f) {
        var nearY = Math.tan(fovY * 0.5) * n;
        var nearX = nearY * aspect;
        this.setFrustum(-nearX, nearX, -nearY, nearY, n, f);
    };
    Camera.prototype.setFrustum = function (left, right, bottom, top, n, f) {
        this.frustum.setViewFrustum(left, right, bottom, top, n, f);
        this.frustum.updateWorldFrustum(this.worldMatrix);
        gl_matrix_1.mat4.frustum(this.projectionMatrix, left, right, bottom, top, n, f);
    };
    Camera.prototype.newFrame = function () {
        this.frustum.newFrame();
    };
    // For documentation more than anything.
    Camera.prototype.getWorldRight = function (out) {
        gl_matrix_1.vec3.set(out, this.worldMatrix[0], this.worldMatrix[4], this.worldMatrix[8]);
    };
    Camera.prototype.getWorldUp = function (out) {
        gl_matrix_1.vec3.set(out, this.worldMatrix[1], this.worldMatrix[5], this.worldMatrix[9]);
    };
    Camera.prototype.getWorldForward = function (out) {
        gl_matrix_1.vec3.set(out, this.worldMatrix[2], this.worldMatrix[6], this.worldMatrix[10]);
    };
    return Camera;
}();
exports.Camera = Camera;
function computeViewMatrix(out, camera) {
    gl_matrix_1.mat4.copy(out, camera.viewMatrix);
}
exports.computeViewMatrix = computeViewMatrix;
function computeViewMatrixSkybox(out, camera) {
    gl_matrix_1.mat4.copy(out, camera.viewMatrix);
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
}
exports.computeViewMatrixSkybox = computeViewMatrixSkybox;
function computeModelMatrixBillboard(out, camera) {
    gl_matrix_1.mat4.identity(out);
    // Right vector
    out[0] = camera.worldMatrix[0];
    out[4] = camera.worldMatrix[4];
    out[8] = camera.worldMatrix[8];
    // Up vector
    out[1] = camera.worldMatrix[1];
    out[5] = camera.worldMatrix[5];
    out[9] = camera.worldMatrix[9];
    // Forward vector
    out[2] = camera.worldMatrix[2];
    out[6] = camera.worldMatrix[6];
    out[8] = camera.worldMatrix[8];
}
exports.computeModelMatrixBillboard = computeModelMatrixBillboard;
function computeModelMatrixYBillboard(out, camera) {
    gl_matrix_1.mat4.identity(out);
    // Right vector
    out[0] = camera.worldMatrix[0];
    out[4] = camera.worldMatrix[4];
    out[8] = camera.worldMatrix[8];
    // Forward vector
    out[2] = camera.worldMatrix[2];
    out[6] = camera.worldMatrix[6];
    out[8] = camera.worldMatrix[8];
}
exports.computeModelMatrixYBillboard = computeModelMatrixYBillboard;
var FPSCameraController = /** @class */function () {
    function FPSCameraController() {
        this.tmp1 = gl_matrix_1.vec3.create();
        this.tmp2 = gl_matrix_1.vec3.create();
        this.speed = 10;
    }
    FPSCameraController.prototype.serialize = function () {
        var camera = this.camera;
        var tx = camera.worldMatrix[12],
            ty = camera.worldMatrix[13],
            tz = camera.worldMatrix[14];
        var rx = camera.worldMatrix[0],
            ry = camera.worldMatrix[4],
            rz = camera.worldMatrix[8];
        var fx = camera.worldMatrix[2],
            fy = camera.worldMatrix[6],
            fz = camera.worldMatrix[10];
        return tx.toFixed(2) + "," + ty.toFixed(2) + "," + tz.toFixed(2) + "," + fx.toFixed(2) + "," + fy.toFixed(2) + "," + fz.toFixed(2) + "," + rx.toFixed(2) + "," + ry.toFixed(2) + "," + rz.toFixed(2);
    };
    FPSCameraController.prototype.deserialize = function (state) {
        var _a = __read(state.split(','), 9),
            tx = _a[0],
            ty = _a[1],
            tz = _a[2],
            fx = _a[3],
            fy = _a[4],
            fz = _a[5],
            rx = _a[6],
            ry = _a[7],
            rz = _a[8];
        // Translation.
        this.camera.worldMatrix[12] = +tx;
        this.camera.worldMatrix[13] = +ty;
        this.camera.worldMatrix[14] = +tz;
        this.camera.worldMatrix[2] = +fx;
        this.camera.worldMatrix[6] = +fy;
        this.camera.worldMatrix[10] = +fz;
        this.camera.worldMatrix[0] = +rx;
        this.camera.worldMatrix[4] = +ry;
        this.camera.worldMatrix[8] = +rz;
        var u = gl_matrix_1.vec3.create();
        gl_matrix_1.vec3.cross(u, [this.camera.worldMatrix[2], this.camera.worldMatrix[6], this.camera.worldMatrix[10]], [this.camera.worldMatrix[0], this.camera.worldMatrix[4], this.camera.worldMatrix[8]]);
        gl_matrix_1.vec3.normalize(u, u);
        this.camera.worldMatrix[1] = u[0];
        this.camera.worldMatrix[5] = u[1];
        this.camera.worldMatrix[9] = u[2];
        this.camera.worldMatrixUpdated();
    };
    FPSCameraController.prototype.update = function (inputManager, dt) {
        var camera = this.camera;
        var updated = false;
        this.speed += inputManager.dz;
        this.speed = Math.max(this.speed, 1);
        var mult = this.speed;
        if (inputManager.isKeyDown('ShiftLeft') || inputManager.isKeyDown('ShiftRight')) mult *= 5;
        mult *= dt / 16.0;
        var movement = this.tmp1;
        gl_matrix_1.vec3.set(movement, 0, 0, 0);
        var tmp = this.tmp2;
        var amt;
        amt = 0;
        if (inputManager.isKeyDown('KeyW')) {
            amt = -mult;
        } else if (inputManager.isKeyDown('KeyS')) {
            amt = mult;
        }
        if (amt !== 0) {
            movement[2] = amt;
        }
        amt = 0;
        if (inputManager.isKeyDown('KeyA')) {
            amt = -mult;
        } else if (inputManager.isKeyDown('KeyD')) {
            amt = mult;
        }
        if (amt !== 0) {
            movement[0] = amt;
        }
        amt = 0;
        if (inputManager.isKeyDown('KeyQ')) {
            amt = -mult;
        } else if (inputManager.isKeyDown('KeyE')) {
            amt = mult;
        }
        if (amt !== 0) {
            // Instead of getting the camera up, instead use world up. Feels more natural.
            camera.getWorldUp(tmp);
            gl_matrix_1.vec3.scaleAndAdd(movement, movement, tmp, amt);
            updated = true;
        }
        if (inputManager.isKeyDown('KeyB')) {
            gl_matrix_1.mat4.identity(camera.worldMatrix);
            updated = true;
        }
        if (inputManager.isKeyDown('KeyC')) {
            console.log(camera);
        }
        // Rotate view.
        var dx = inputManager.dx;
        var dy = inputManager.dy;
        if (dx !== 0 || dy !== 0) {
            camera.getWorldUp(tmp);
            gl_matrix_1.vec3.normalize(tmp, tmp);
            gl_matrix_1.mat4.rotate(camera.worldMatrix, camera.worldMatrix, -dx / 500.0, tmp);
            gl_matrix_1.mat4.rotate(camera.worldMatrix, camera.worldMatrix, -dy / 500.0, [1, 0, 0]);
            updated = true;
        }
        if (!gl_matrix_1.vec3.exactEquals(movement, [0, 0, 0])) {
            gl_matrix_1.mat4.translate(camera.worldMatrix, camera.worldMatrix, movement);
            updated = true;
        }
        if (updated) {
            this.camera.worldMatrixUpdated();
        }
        return updated;
    };
    return FPSCameraController;
}();
exports.FPSCameraController = FPSCameraController;
function clamp(v, min, max) {
    return Math.max(min, Math.min(v, max));
}
function clampRange(v, lim) {
    return clamp(v, -lim, lim);
}
var OrbitCameraController = /** @class */function () {
    function OrbitCameraController() {
        this.x = 0.15;
        this.y = 0.35;
        this.z = -150;
        this.xVel = 0;
        this.yVel = 0;
        this.zVel = 0;
        this.tx = 0;
        this.ty = 0;
        this.txVel = 0;
        this.tyVel = 0;
    }
    OrbitCameraController.prototype.serialize = function () {
        return '';
    };
    OrbitCameraController.prototype.deserialize = function (state) {};
    OrbitCameraController.prototype.update = function (inputManager, dt) {
        // Get new velocities from inputs.
        if (inputManager.button === 1) {
            this.txVel += inputManager.dx * (-10 - Math.min(this.z, 0.01)) / 5000;
            this.tyVel += inputManager.dy * (-10 - Math.min(this.z, 0.01)) / -5000;
        } else {
            this.xVel += inputManager.dx / 200;
            this.yVel += inputManager.dy / 200;
        }
        this.zVel += inputManager.dz;
        if (inputManager.isKeyDown('A')) {
            this.xVel += 0.05;
        }
        if (inputManager.isKeyDown('D')) {
            this.xVel -= 0.05;
        }
        if (inputManager.isKeyDown('W')) {
            this.yVel += 0.05;
        }
        if (inputManager.isKeyDown('S')) {
            this.yVel -= 0.05;
        }
        this.xVel = clampRange(this.xVel, 2);
        this.yVel = clampRange(this.yVel, 2);
        var updated = this.xVel !== 0 || this.yVel !== 0 || this.zVel !== 0;
        if (updated) {
            // Apply velocities.
            var drag = inputManager.isDragging() ? 0.92 : 0.96;
            this.x += this.xVel / 10;
            this.xVel *= drag;
            this.y += this.yVel / 10;
            this.yVel *= drag;
            this.tx += this.txVel;
            this.txVel *= drag;
            this.ty += this.tyVel;
            this.tyVel *= drag;
            if (this.y < 0.04) {
                this.y = 0.04;
                this.yVel = 0;
            }
            if (this.y > 1.50) {
                this.y = 1.50;
                this.yVel = 0;
            }
            this.z += this.zVel;
            this.zVel *= 0.8;
            if (this.z > -10) {
                this.z = -10;
                this.zVel = 0;
            }
            var camera = this.camera;
            // Calculate new camera from new x/y/z.
            var sinX = Math.sin(this.x);
            var cosX = Math.cos(this.x);
            var sinY = Math.sin(this.y);
            var cosY = Math.cos(this.y);
            // TODO(jstpierre): Replace this with position/look direction.
            gl_matrix_1.mat4.set(camera.worldMatrix, cosX, sinY * sinX, -cosY * sinX, 0, 0, cosY, sinY, 0, sinX, -sinY * cosX, cosY * cosX, 0, this.tx, this.ty, this.z, 1);
            gl_matrix_1.mat4.invert(camera.worldMatrix, camera.worldMatrix);
            this.camera.worldMatrixUpdated();
        }
        return updated;
    };
    return OrbitCameraController;
}();
exports.OrbitCameraController = OrbitCameraController;
// Probably don't belong in here, but are helpful nonetheless.
function texProjPerspMtx(dst, fov, aspect, scaleS, scaleT, transS, transT) {
    var cot = 1 / Math.tan(fov / 2);
    dst[0] = cot / aspect * scaleS;
    dst[4] = 0.0;
    dst[8] = -transS;
    dst[12] = 0.0;
    dst[1] = 0.0;
    dst[5] = cot * scaleT;
    dst[9] = -transT;
    dst[13] = 0.0;
    dst[2] = 0.0;
    dst[6] = 0.0;
    dst[10] = -1.0;
    dst[14] = 0.0;
    // Fill with junk to try and signal when something has gone horribly wrong. This should go unused,
    // since this is supposed to generate a mat4x3 matrix.
    dst[3] = 9999.0;
    dst[7] = 9999.0;
    dst[11] = 9999.0;
    dst[15] = 9999.0;
}
exports.texProjPerspMtx = texProjPerspMtx;
function texEnvMtx(dst, scaleS, scaleT, transS, transT) {
    dst[0] = scaleS;
    dst[4] = 0.0;
    dst[8] = 0.0;
    dst[12] = transS;
    dst[1] = 0.0;
    dst[5] = -scaleT;
    dst[9] = 0.0;
    dst[13] = transT;
    dst[2] = 0.0;
    dst[6] = 0.0;
    dst[10] = 0.0;
    dst[14] = 1.0;
    // Fill with junk to try and signal when something has gone horribly wrong. This should go unused,
    // since this is supposed to generate a mat4x3 matrix.
    dst[3] = 9999.0;
    dst[7] = 9999.0;
    dst[11] = 9999.0;
    dst[15] = 9999.0;
}
exports.texEnvMtx = texEnvMtx;
},{"gl-matrix":"..\\node_modules\\gl-matrix\\src\\gl-matrix.js","./util":"util.ts"}],"render.ts":[function(require,module,exports) {
"use strict";

var __extends = this && this.__extends || function () {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
        d.__proto__ = b;
    } || function (d, b) {
        for (var p in b) {
            if (b.hasOwnProperty(p)) d[p] = b[p];
        }
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", { value: true });
var gl_matrix_1 = require("gl-matrix");
var util_1 = require("./util");
var Program_1 = require("./Program");
var Camera_1 = require("./Camera");
var CompareMode;
(function (CompareMode) {
    CompareMode[CompareMode["NEVER"] = WebGLRenderingContext.NEVER] = "NEVER";
    CompareMode[CompareMode["LESS"] = WebGLRenderingContext.LESS] = "LESS";
    CompareMode[CompareMode["EQUAL"] = WebGLRenderingContext.EQUAL] = "EQUAL";
    CompareMode[CompareMode["LEQUAL"] = WebGLRenderingContext.LEQUAL] = "LEQUAL";
    CompareMode[CompareMode["GREATER"] = WebGLRenderingContext.GREATER] = "GREATER";
    CompareMode[CompareMode["NEQUAL"] = WebGLRenderingContext.NOTEQUAL] = "NEQUAL";
    CompareMode[CompareMode["GEQUAL"] = WebGLRenderingContext.GEQUAL] = "GEQUAL";
    CompareMode[CompareMode["ALWAYS"] = WebGLRenderingContext.ALWAYS] = "ALWAYS";
})(CompareMode = exports.CompareMode || (exports.CompareMode = {}));
var FrontFaceMode;
(function (FrontFaceMode) {
    FrontFaceMode[FrontFaceMode["CCW"] = WebGLRenderingContext.CCW] = "CCW";
    FrontFaceMode[FrontFaceMode["CW"] = WebGLRenderingContext.CW] = "CW";
})(FrontFaceMode = exports.FrontFaceMode || (exports.FrontFaceMode = {}));
var CullMode;
(function (CullMode) {
    CullMode[CullMode["NONE"] = 0] = "NONE";
    CullMode[CullMode["FRONT"] = 1] = "FRONT";
    CullMode[CullMode["BACK"] = 2] = "BACK";
    CullMode[CullMode["FRONT_AND_BACK"] = 3] = "FRONT_AND_BACK";
})(CullMode = exports.CullMode || (exports.CullMode = {}));
var BlendFactor;
(function (BlendFactor) {
    BlendFactor[BlendFactor["ZERO"] = WebGLRenderingContext.ZERO] = "ZERO";
    BlendFactor[BlendFactor["ONE"] = WebGLRenderingContext.ONE] = "ONE";
    BlendFactor[BlendFactor["SRC_COLOR"] = WebGLRenderingContext.SRC_COLOR] = "SRC_COLOR";
    BlendFactor[BlendFactor["ONE_MINUS_SRC_COLOR"] = WebGLRenderingContext.ONE_MINUS_SRC_COLOR] = "ONE_MINUS_SRC_COLOR";
    BlendFactor[BlendFactor["DST_COLOR"] = WebGLRenderingContext.DST_COLOR] = "DST_COLOR";
    BlendFactor[BlendFactor["ONE_MINUS_DST_COLOR"] = WebGLRenderingContext.ONE_MINUS_DST_COLOR] = "ONE_MINUS_DST_COLOR";
    BlendFactor[BlendFactor["SRC_ALPHA"] = WebGLRenderingContext.SRC_ALPHA] = "SRC_ALPHA";
    BlendFactor[BlendFactor["ONE_MINUS_SRC_ALPHA"] = WebGLRenderingContext.ONE_MINUS_SRC_ALPHA] = "ONE_MINUS_SRC_ALPHA";
    BlendFactor[BlendFactor["DST_ALPHA"] = WebGLRenderingContext.DST_ALPHA] = "DST_ALPHA";
    BlendFactor[BlendFactor["ONE_MINUS_DST_ALPHA"] = WebGLRenderingContext.ONE_MINUS_DST_ALPHA] = "ONE_MINUS_DST_ALPHA";
})(BlendFactor = exports.BlendFactor || (exports.BlendFactor = {}));
var BlendMode;
(function (BlendMode) {
    BlendMode[BlendMode["NONE"] = 0] = "NONE";
    BlendMode[BlendMode["ADD"] = WebGLRenderingContext.FUNC_ADD] = "ADD";
    BlendMode[BlendMode["SUBTRACT"] = WebGLRenderingContext.FUNC_SUBTRACT] = "SUBTRACT";
    BlendMode[BlendMode["REVERSE_SUBTRACT"] = WebGLRenderingContext.FUNC_REVERSE_SUBTRACT] = "REVERSE_SUBTRACT";
})(BlendMode = exports.BlendMode || (exports.BlendMode = {}));
function flagChanged(stateFlag, newFlag) {
    return newFlag !== undefined && stateFlag !== newFlag;
}
function applyFlags(gl, stateFlags, newFlags) {
    if (flagChanged(stateFlags.depthWrite, newFlags.depthWrite)) {
        gl.depthMask(newFlags.depthWrite);
        stateFlags.depthWrite = newFlags.depthWrite;
    }
    if (flagChanged(stateFlags.depthTest, newFlags.depthTest)) {
        if (newFlags.depthTest) gl.enable(gl.DEPTH_TEST);else gl.disable(gl.DEPTH_TEST);
        stateFlags.depthTest = newFlags.depthTest;
    }
    if (flagChanged(stateFlags.depthFunc, newFlags.depthFunc)) {
        gl.depthFunc(newFlags.depthFunc);
        stateFlags.depthFunc = newFlags.depthFunc;
    }
    if (flagChanged(stateFlags.blendMode, newFlags.blendMode)) {
        if (newFlags.blendMode !== BlendMode.NONE) {
            gl.enable(gl.BLEND);
            gl.blendEquation(newFlags.blendMode);
        } else {
            gl.disable(gl.BLEND);
        }
        stateFlags.blendMode = newFlags.blendMode;
    }
    if (flagChanged(stateFlags.blendSrc, newFlags.blendSrc) || flagChanged(stateFlags.blendDst, newFlags.blendDst)) {
        gl.blendFunc(newFlags.blendSrc, newFlags.blendDst);
        stateFlags.blendSrc = newFlags.blendSrc;
        stateFlags.blendDst = newFlags.blendDst;
    }
    if (flagChanged(stateFlags.cullMode, newFlags.cullMode)) {
        // Try to be smart about this.
        if (stateFlags.cullMode === CullMode.NONE) gl.enable(gl.CULL_FACE);else if (newFlags.cullMode === CullMode.NONE) gl.disable(gl.CULL_FACE);
        if (newFlags.cullMode === CullMode.BACK) gl.cullFace(gl.BACK);else if (newFlags.cullMode === CullMode.FRONT) gl.cullFace(gl.FRONT);else if (newFlags.cullMode === CullMode.FRONT_AND_BACK) gl.cullFace(gl.FRONT_AND_BACK);
        stateFlags.cullMode = newFlags.cullMode;
    }
    if (flagChanged(stateFlags.frontFace, newFlags.frontFace)) {
        gl.frontFace(newFlags.frontFace);
        stateFlags.frontFace = newFlags.frontFace;
    }
}
var RenderFlags = /** @class */function () {
    function RenderFlags() {
        this.depthWrite = undefined;
        this.depthTest = undefined;
        this.depthFunc = undefined;
        this.blendSrc = undefined;
        this.blendDst = undefined;
        this.blendMode = undefined;
        this.cullMode = undefined;
        this.frontFace = undefined;
    }
    RenderFlags.default = new RenderFlags();
    return RenderFlags;
}();
exports.RenderFlags = RenderFlags;
RenderFlags.default.blendMode = BlendMode.NONE;
RenderFlags.default.blendSrc = BlendFactor.SRC_ALPHA;
RenderFlags.default.blendDst = BlendFactor.ONE_MINUS_SRC_ALPHA;
RenderFlags.default.cullMode = CullMode.NONE;
RenderFlags.default.depthTest = false;
RenderFlags.default.depthWrite = true;
RenderFlags.default.depthFunc = CompareMode.LEQUAL;
RenderFlags.default.frontFace = FrontFaceMode.CCW;
var FullscreenCopyProgram = /** @class */function (_super) {
    __extends(FullscreenCopyProgram, _super);
    function FullscreenCopyProgram() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.frag = "\nuniform sampler2D u_Texture;\nin vec2 v_TexCoord;\n\nvoid main() {\n    vec4 color = texture(u_Texture, v_TexCoord);\n    gl_FragColor = vec4(color.rgb, 1.0);\n}\n";
        return _this;
    }
    return FullscreenCopyProgram;
}(Program_1.FullscreenProgram);
var RENDER_SAMPLES = 4;
var ColorTarget = /** @class */function () {
    function ColorTarget() {}
    ColorTarget.prototype.destroy = function (gl) {
        if (this.msaaColorRenderbuffer) gl.deleteRenderbuffer(this.msaaColorRenderbuffer);
        if (this.resolvedColorTexture) gl.deleteTexture(this.resolvedColorTexture);
    };
    ColorTarget.prototype.setParameters = function (gl, width, height, samples) {
        if (samples === void 0) {
            samples = RENDER_SAMPLES;
        }
        if (this.width === width && this.height === height && this.samples === samples) return;
        this.destroy(gl);
        this.width = width;
        this.height = height;
        this.samples = samples;
        this.msaaColorRenderbuffer = gl.createRenderbuffer();
        gl.bindRenderbuffer(gl.RENDERBUFFER, this.msaaColorRenderbuffer);
        gl.renderbufferStorageMultisample(gl.RENDERBUFFER, samples, gl.RGBA8, this.width, this.height);
        this.resolvedColorTexture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, this.resolvedColorTexture);
        gl.texStorage2D(gl.TEXTURE_2D, 1, gl.RGBA8, this.width, this.height);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    };
    ColorTarget.prototype.resolve = function (gl) {
        var readFramebuffer = gl.createFramebuffer();
        var resolveFramebuffer = gl.createFramebuffer();
        gl.bindFramebuffer(gl.READ_FRAMEBUFFER, readFramebuffer);
        gl.framebufferRenderbuffer(gl.READ_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, this.msaaColorRenderbuffer);
        gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, resolveFramebuffer);
        gl.framebufferTexture2D(gl.DRAW_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.resolvedColorTexture, 0);
        gl.blitFramebuffer(0, 0, this.width, this.height, 0, 0, this.width, this.height, gl.COLOR_BUFFER_BIT, gl.LINEAR);
        gl.bindFramebuffer(gl.READ_FRAMEBUFFER, null);
        gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
        gl.deleteFramebuffer(readFramebuffer);
        gl.deleteFramebuffer(resolveFramebuffer);
        return this.resolvedColorTexture;
    };
    return ColorTarget;
}();
exports.ColorTarget = ColorTarget;
var DepthTarget = /** @class */function () {
    function DepthTarget() {}
    DepthTarget.prototype.destroy = function (gl) {
        if (this.msaaDepthRenderbuffer) gl.deleteRenderbuffer(this.msaaDepthRenderbuffer);
    };
    DepthTarget.prototype.setParameters = function (gl, width, height, samples) {
        if (samples === void 0) {
            samples = RENDER_SAMPLES;
        }
        if (this.width === width && this.height === height && this.samples === samples) return;
        this.destroy(gl);
        this.width = width;
        this.height = height;
        this.samples = samples;
        this.msaaDepthRenderbuffer = gl.createRenderbuffer();
        gl.bindRenderbuffer(gl.RENDERBUFFER, this.msaaDepthRenderbuffer);
        gl.renderbufferStorageMultisample(gl.RENDERBUFFER, samples, gl.DEPTH24_STENCIL8, this.width, this.height);
    };
    return DepthTarget;
}();
exports.DepthTarget = DepthTarget;
exports.depthClearFlags = new RenderFlags();
exports.depthClearFlags.depthWrite = true;
// XXX(jstpierre): This is becoming a lot more than just some render state.
// Rename to "SceneRenderer" at some point?
var RenderState = /** @class */function () {
    function RenderState(gl) {
        this.gl = gl;
        // State.
        this.currentProgram = null;
        this.currentFlags = new RenderFlags();
        this.currentColorTarget = null;
        this.currentDepthTarget = null;
        this.drawCallCount = 0;
        this.frameStartTime = 0;
        this.programCache = new Program_1.ProgramCache(this.gl);
        this.time = 0;
        this.fov = Math.PI / 4;
        this.camera = new Camera_1.Camera();
        this.scratchMatrix = gl_matrix_1.mat4.create();
        this.fullscreenCopyProgram = new FullscreenCopyProgram();
        this.fullscreenFlags = new RenderFlags();
        this.fullscreenFlags.depthTest = false;
        this.fullscreenFlags.blendMode = BlendMode.NONE;
        this.fullscreenFlags.cullMode = CullMode.NONE;
        this.msaaFramebuffer = util_1.assertExists(gl.createFramebuffer());
    }
    Object.defineProperty(RenderState.prototype, "view", {
        // TODO(jstpierre): Remove.
        get: function get() {
            return this.camera.viewMatrix;
        },
        enumerable: true,
        configurable: true
    });
    RenderState.prototype.destroy = function () {
        var gl = this.gl;
        gl.deleteFramebuffer(this.msaaFramebuffer);
    };
    RenderState.prototype.reset = function () {
        this.drawCallCount = 0;
        this.frameStartTime = window.performance.now();
        this.useRenderTarget(this.onscreenColorTarget, this.onscreenDepthTarget);
        this.useFlags(RenderFlags.default);
        this.camera.newFrame();
    };
    // XXX(jstpierre): Design a better API than this.
    RenderState.prototype.runFullscreen = function (flags) {
        if (flags === void 0) {
            flags = null;
        }
        var gl = this.gl;
        this.useFlags(flags !== null ? flags : this.fullscreenFlags);
        gl.drawArrays(gl.TRIANGLES, 0, 3);
    };
    RenderState.prototype.blitFullscreenTexture = function (colorTexture, flags) {
        if (flags === void 0) {
            flags = null;
        }
        var gl = this.gl;
        this.useProgram(this.fullscreenCopyProgram);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, colorTexture);
        gl.bindSampler(0, null);
        this.runFullscreen(flags);
    };
    RenderState.prototype.blitColorTarget = function (colorTarget, flags) {
        if (flags === void 0) {
            flags = null;
        }
        var gl = this.gl;
        var resolvedColorTexture = colorTarget.resolve(gl);
        // Make sure to re-bind our destination RT, since the resolve screws things up...
        gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this.msaaFramebuffer);
        this.blitFullscreenTexture(resolvedColorTexture, flags);
    };
    RenderState.prototype.blitOnscreenToGL = function () {
        var gl = this.gl;
        var resolvedColorTexture = this.onscreenColorTarget.resolve(gl);
        gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
        this.blitFullscreenTexture(resolvedColorTexture);
    };
    RenderState.prototype.setOnscreenRenderTarget = function (colorTarget, depthTarget) {
        this.onscreenColorTarget = colorTarget;
        this.onscreenDepthTarget = depthTarget;
    };
    RenderState.prototype.useRenderTarget = function (colorTarget, depthTarget) {
        if (depthTarget === void 0) {
            depthTarget = this.onscreenDepthTarget;
        }
        var gl = this.gl;
        if (colorTarget !== null && depthTarget !== null) {
            // Assert our invariants.
            util_1.assert(colorTarget.width === depthTarget.width);
            util_1.assert(colorTarget.height === depthTarget.height);
            util_1.assert(colorTarget.samples === depthTarget.samples);
        }
        gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this.msaaFramebuffer);
        this.currentColorTarget = colorTarget;
        var colorRenderbuffer = this.currentColorTarget ? this.currentColorTarget.msaaColorRenderbuffer : null;
        gl.framebufferRenderbuffer(gl.DRAW_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, colorRenderbuffer);
        this.currentDepthTarget = depthTarget;
        var depthRenderbuffer = this.currentDepthTarget ? this.currentDepthTarget.msaaDepthRenderbuffer : null;
        gl.framebufferRenderbuffer(gl.DRAW_FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, depthRenderbuffer);
        this.bindViewport();
    };
    RenderState.prototype.getAspect = function () {
        var width = this.currentColorTarget.width,
            height = this.currentColorTarget.height;
        return width / height;
    };
    RenderState.prototype.updateProjection = function () {
        this.camera.setPerspective(this.fov, this.getAspect(), this.nearClipPlane, this.farClipPlane);
    };
    RenderState.prototype.bindViewport = function () {
        this.updateProjection();
        var gl = this.gl;
        var width = this.currentColorTarget.width,
            height = this.currentColorTarget.height;
        gl.viewport(0, 0, width, height);
    };
    RenderState.prototype.setClipPlanes = function (near, far) {
        this.nearClipPlane = near;
        this.farClipPlane = far;
        if (this.currentColorTarget) {
            this.updateProjection();
        }
    };
    RenderState.prototype.compileProgram = function (prog) {
        return prog.compile(this.gl, this.programCache);
    };
    RenderState.prototype.useProgram = function (prog) {
        var gl = this.gl;
        this.currentProgram = prog;
        gl.useProgram(this.compileProgram(prog));
    };
    RenderState.prototype.updateModelView = function (isSkybox, model) {
        if (isSkybox === void 0) {
            isSkybox = false;
        }
        if (model === void 0) {
            model = null;
        }
        var modelView = this.scratchMatrix;
        if (isSkybox) {
            Camera_1.computeViewMatrixSkybox(modelView, this.camera);
        } else {
            Camera_1.computeViewMatrix(modelView, this.camera);
        }
        if (model) {
            gl_matrix_1.mat4.mul(modelView, modelView, model);
        }
        return modelView;
    };
    RenderState.prototype.bindModelView = function (isSkybox, model) {
        if (isSkybox === void 0) {
            isSkybox = false;
        }
        if (model === void 0) {
            model = null;
        }
        // XXX(jstpierre): Remove this junk
        var gl = this.gl;
        var prog = this.currentProgram;
        var scratch = this.updateModelView(isSkybox, model);
        gl.uniformMatrix4fv(prog.projectionLocation, false, this.camera.projectionMatrix);
        gl.uniformMatrix4fv(prog.modelViewLocation, false, scratch);
    };
    RenderState.prototype.useFlags = function (flags) {
        var gl = this.gl;
        applyFlags(gl, this.currentFlags, flags);
    };
    return RenderState;
}();
exports.RenderState = RenderState;
},{"gl-matrix":"..\\node_modules\\gl-matrix\\src\\gl-matrix.js","./util":"util.ts","./Program":"Program.ts","./Camera":"Camera.ts"}],"InputManager.ts":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var InputManager = /** @class */function () {
    function InputManager(toplevel) {
        var _this = this;
        this.grabbing = false;
        this._onKeyDown = function (e) {
            _this.keysDown.set(e.code, true);
        };
        this._onKeyUp = function (e) {
            _this.keysDown.delete(e.code);
        };
        this._onWheel = function (e) {
            e.preventDefault();
            _this.dz += Math.sign(e.deltaY) * -4;
        };
        this._onMouseMove = function (e) {
            if (!_this.grabbing) return;
            var dx = e.pageX - _this.lastX;
            var dy = e.pageY - _this.lastY;
            _this.lastX = e.pageX;
            _this.lastY = e.pageY;
            _this.dx += dx;
            _this.dy += dy;
        };
        this._onMouseUp = function (e) {
            _this._setGrabbing(false);
            _this.button = 0;
        };
        this._onMouseDown = function (e) {
            _this.button = e.button;
            _this.lastX = e.pageX;
            _this.lastY = e.pageY;
            _this._setGrabbing(true);
            // Needed to make the cursor update in Chrome. See:
            // https://bugs.chromium.org/p/chromium/issues/detail?id=676644
            _this.toplevel.focus();
            e.preventDefault();
        };
        this.toplevel = toplevel;
        this.keysDown = new Map();
        window.addEventListener('keydown', this._onKeyDown);
        window.addEventListener('keyup', this._onKeyUp);
        this.toplevel.addEventListener('wheel', this._onWheel, { passive: false });
        this.toplevel.addEventListener('mousedown', this._onMouseDown);
        this.resetMouse();
    }
    InputManager.prototype.isKeyDown = function (key) {
        return this.keysDown.get(key);
    };
    InputManager.prototype.isDragging = function () {
        return this.grabbing;
    };
    InputManager.prototype.resetMouse = function () {
        this.dx = 0;
        this.dy = 0;
        this.dz = 0;
    };
    InputManager.prototype._setGrabbing = function (v) {
        if (this.grabbing === v) return;
        this.grabbing = v;
        this.toplevel.style.cursor = v ? '-webkit-grabbing' : '-webkit-grab';
        this.toplevel.style.cursor = v ? 'grabbing' : 'grab';
        this.toplevel.style.setProperty('pointer-events', v ? 'auto' : '', 'important');
        if (v) {
            document.addEventListener('mousemove', this._onMouseMove);
            document.addEventListener('mouseup', this._onMouseUp);
        } else {
            document.removeEventListener('mousemove', this._onMouseMove);
            document.removeEventListener('mouseup', this._onMouseUp);
        }
    };
    return InputManager;
}();
exports.InputManager = InputManager;
},{}],"viewer.ts":[function(require,module,exports) {
"use strict";
// tslint:disable:no-console

Object.defineProperty(exports, "__esModule", { value: true });
var render_1 = require("./render");
var InputManager_1 = require("./InputManager");
var Viewer = /** @class */function () {
    function Viewer(canvas) {
        this.canvas = canvas;
        this.onscreenColorTarget = new render_1.ColorTarget();
        this.onscreenDepthTarget = new render_1.DepthTarget();
        this.oncamerachanged = function () {};
        var gl = canvas.getContext("webgl2", { alpha: false, antialias: false });
        this.renderState = new render_1.RenderState(gl);
        this.inputManager = new InputManager_1.InputManager(this.canvas);
        this.cameraController = null;
    }
    Viewer.prototype.reset = function () {
        var gl = this.renderState.gl;
        gl.activeTexture(gl.TEXTURE0);
        gl.clearColor(0.88, 0.88, 0.88, 1);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    };
    Viewer.prototype.render = function () {
        var gl = this.renderState.gl;
        if (!this.scene) return;
        this.onscreenColorTarget.setParameters(gl, this.canvas.width, this.canvas.height);
        this.onscreenDepthTarget.setParameters(gl, this.canvas.width, this.canvas.height);
        this.renderState.setOnscreenRenderTarget(this.onscreenColorTarget, this.onscreenDepthTarget);
        this.renderState.reset();
        this.renderState.setClipPlanes(10, 50000);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        // Main scene. This renders to the onscreen target.
        this.scene.render(this.renderState);
        // Blit to the screen.
        this.renderState.blitOnscreenToGL();
        var frameEndTime = window.performance.now();
        var diff = frameEndTime - this.renderState.frameStartTime;
        // console.log(`Time: ${diff} Draw calls: ${state.drawCallCount}`);
    };
    Viewer.prototype.setCameraController = function (cameraController) {
        this.cameraController = cameraController;
        this.cameraController.camera = this.renderState.camera;
    };
    Viewer.prototype.setScene = function (scene) {
        var gl = this.renderState.gl;
        this.reset();
        if (this.scene) {
            this.scene.destroy(gl);
        }
        if (scene) {
            this.scene = scene;
            this.oncamerachanged();
        } else {
            this.scene = null;
        }
    };
    Viewer.prototype.start = function () {
        var _this = this;
        var canvas = this.canvas;
        var t = 0;
        var update = function update(nt) {
            var dt = nt - t;
            t = nt;
            if (_this.cameraController) {
                var updated = _this.cameraController.update(_this.inputManager, dt);
                if (updated) _this.oncamerachanged();
            }
            _this.inputManager.resetMouse();
            _this.renderState.time += dt;
            _this.render();
            window.requestAnimationFrame(update);
        };
        update(0);
    };
    return Viewer;
}();
exports.Viewer = Viewer;
},{"./render":"render.ts","./InputManager":"InputManager.ts"}],"wat_modules.ts":[function(require,module,exports) {
"use strict";
// Generated by build_wat.js

Object.defineProperty(exports, "__esModule", { value: true });
var yaz0_asCode = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 11, 2, 96, 3, 127, 127, 127, 0, 96, 0, 1, 127, 3, 2, 1, 0, 5, 3, 1, 0, 1, 6, 6, 1, 127, 0, 65, 4, 11, 7, 23, 2, 10, 100, 101, 99, 111, 109, 112, 114, 101, 115, 115, 0, 0, 6, 109, 101, 109, 111, 114, 121, 2, 0, 10, 178, 3, 1, 175, 3, 1, 17, 127, 32, 0, 33, 3, 32, 1, 33, 4, 2, 64, 3, 64, 65, 1, 4, 64, 2, 64, 2, 64, 2, 127, 2, 127, 32, 4, 33, 5, 32, 5, 65, 1, 106, 33, 4, 32, 5, 11, 33, 5, 32, 5, 45, 0, 0, 12, 0, 11, 33, 6, 65, 8, 33, 7, 2, 64, 3, 64, 2, 127, 32, 7, 33, 8, 32, 8, 65, 1, 107, 33, 7, 32, 8, 11, 65, 255, 1, 113, 4, 64, 2, 64, 2, 64, 32, 6, 65, 1, 32, 7, 116, 113, 65, 255, 1, 113, 4, 64, 2, 64, 32, 2, 65, 1, 107, 33, 2, 2, 64, 2, 127, 32, 3, 33, 8, 32, 8, 65, 1, 106, 33, 3, 32, 8, 11, 33, 8, 2, 127, 2, 127, 32, 4, 33, 9, 32, 9, 65, 1, 106, 33, 4, 32, 9, 11, 33, 9, 32, 9, 45, 0, 0, 12, 0, 11, 33, 10, 32, 8, 32, 10, 58, 0, 0, 11, 11, 5, 2, 64, 2, 127, 32, 4, 45, 0, 0, 65, 8, 116, 32, 4, 65, 1, 106, 45, 0, 0, 114, 65, 255, 255, 3, 113, 12, 0, 11, 33, 11, 32, 4, 65, 2, 106, 33, 4, 32, 11, 65, 255, 31, 113, 65, 1, 106, 33, 12, 32, 11, 65, 255, 255, 3, 113, 65, 12, 118, 65, 2, 106, 65, 255, 1, 113, 33, 13, 32, 13, 65, 2, 70, 4, 64, 2, 64, 2, 127, 2, 127, 32, 4, 33, 14, 32, 14, 65, 1, 106, 33, 4, 32, 14, 11, 33, 14, 32, 14, 45, 0, 0, 12, 0, 11, 65, 255, 1, 113, 33, 15, 32, 13, 32, 15, 65, 16, 106, 106, 33, 13, 11, 11, 32, 3, 32, 12, 65, 255, 255, 3, 113, 107, 33, 16, 32, 2, 32, 13, 107, 33, 2, 2, 64, 3, 64, 2, 127, 32, 13, 33, 17, 32, 17, 65, 1, 107, 33, 13, 32, 17, 11, 65, 255, 255, 3, 113, 4, 64, 2, 64, 2, 64, 2, 127, 32, 3, 33, 17, 32, 17, 65, 1, 106, 33, 3, 32, 17, 11, 33, 17, 2, 127, 2, 127, 32, 16, 33, 18, 32, 18, 65, 1, 106, 33, 16, 32, 18, 11, 33, 18, 32, 18, 45, 0, 0, 12, 0, 11, 33, 19, 32, 17, 32, 19, 58, 0, 0, 11, 12, 2, 11, 11, 11, 11, 11, 11, 32, 2, 65, 0, 76, 4, 64, 15, 11, 11, 12, 2, 11, 11, 11, 11, 11, 12, 2, 11, 11, 11, 11, 11]);
function yaz0_asInstance(imports) {
    return WebAssembly.compile(yaz0_asCode).then(function (module) {
        return WebAssembly.instantiate(module, imports);
    }).then(function (instance) {
        return instance.exports;
    });
}
exports.yaz0_asInstance = yaz0_asInstance;
var gx_texture_asCode = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 5, 127, 127, 127, 127, 127, 0, 96, 0, 1, 127, 3, 9, 8, 0, 0, 0, 0, 0, 0, 0, 0, 5, 3, 1, 0, 1, 6, 6, 1, 127, 0, 65, 4, 11, 7, 121, 9, 9, 100, 101, 99, 111, 100, 101, 95, 73, 52, 0, 0, 9, 100, 101, 99, 111, 100, 101, 95, 73, 56, 0, 1, 10, 100, 101, 99, 111, 100, 101, 95, 73, 65, 52, 0, 2, 10, 100, 101, 99, 111, 100, 101, 95, 73, 65, 56, 0, 3, 13, 100, 101, 99, 111, 100, 101, 95, 82, 71, 66, 53, 54, 53, 0, 4, 13, 100, 101, 99, 111, 100, 101, 95, 82, 71, 66, 53, 65, 51, 0, 5, 12, 100, 101, 99, 111, 100, 101, 95, 82, 71, 66, 65, 56, 0, 6, 11, 100, 101, 99, 111, 100, 101, 95, 67, 77, 80, 82, 0, 7, 6, 109, 101, 109, 111, 114, 121, 2, 0, 10, 166, 36, 8, 178, 2, 1, 15, 127, 65, 0, 33, 5, 2, 64, 65, 0, 33, 6, 3, 64, 32, 6, 32, 4, 73, 4, 64, 2, 64, 2, 64, 65, 0, 33, 7, 3, 64, 32, 7, 32, 3, 73, 4, 64, 2, 64, 2, 64, 65, 0, 33, 8, 3, 64, 32, 8, 65, 8, 73, 4, 64, 2, 64, 2, 64, 65, 0, 33, 9, 3, 64, 32, 9, 65, 8, 73, 4, 64, 2, 64, 2, 64, 32, 3, 32, 6, 32, 8, 65, 255, 1, 113, 106, 108, 32, 7, 106, 32, 9, 65, 255, 1, 113, 106, 33, 10, 32, 1, 32, 10, 65, 4, 108, 106, 33, 11, 2, 127, 32, 2, 32, 5, 65, 1, 118, 106, 33, 12, 32, 12, 45, 0, 0, 12, 0, 11, 33, 13, 32, 13, 65, 255, 1, 113, 32, 5, 65, 1, 113, 4, 127, 65, 0, 5, 65, 4, 11, 118, 65, 15, 113, 33, 14, 2, 127, 32, 14, 65, 4, 116, 32, 14, 114, 65, 255, 1, 113, 12, 0, 11, 33, 15, 2, 64, 32, 11, 65, 0, 106, 33, 16, 32, 16, 32, 15, 58, 0, 0, 11, 2, 64, 32, 11, 65, 1, 106, 33, 17, 32, 17, 32, 15, 58, 0, 0, 11, 2, 64, 32, 11, 65, 2, 106, 33, 18, 32, 18, 32, 15, 58, 0, 0, 11, 2, 64, 32, 11, 65, 3, 106, 33, 19, 32, 19, 32, 15, 58, 0, 0, 11, 32, 5, 65, 1, 106, 33, 5, 11, 32, 9, 65, 1, 106, 33, 9, 12, 2, 11, 11, 11, 11, 32, 8, 65, 1, 106, 33, 8, 12, 2, 11, 11, 11, 11, 32, 7, 65, 8, 106, 33, 7, 12, 2, 11, 11, 11, 11, 32, 6, 65, 8, 106, 33, 6, 12, 2, 11, 11, 11, 11, 11, 131, 2, 1, 13, 127, 65, 0, 33, 5, 2, 64, 65, 0, 33, 6, 3, 64, 32, 6, 32, 4, 73, 4, 64, 2, 64, 2, 64, 65, 0, 33, 7, 3, 64, 32, 7, 32, 3, 73, 4, 64, 2, 64, 2, 64, 65, 0, 33, 8, 3, 64, 32, 8, 65, 4, 73, 4, 64, 2, 64, 2, 64, 65, 0, 33, 9, 3, 64, 32, 9, 65, 8, 73, 4, 64, 2, 64, 2, 64, 32, 3, 32, 6, 32, 8, 65, 255, 1, 113, 106, 108, 32, 7, 106, 32, 9, 65, 255, 1, 113, 106, 33, 10, 32, 1, 32, 10, 65, 4, 108, 106, 33, 11, 2, 127, 32, 2, 32, 5, 106, 33, 12, 32, 12, 45, 0, 0, 12, 0, 11, 33, 13, 2, 64, 32, 11, 65, 0, 106, 33, 14, 32, 14, 32, 13, 58, 0, 0, 11, 2, 64, 32, 11, 65, 1, 106, 33, 15, 32, 15, 32, 13, 58, 0, 0, 11, 2, 64, 32, 11, 65, 2, 106, 33, 16, 32, 16, 32, 13, 58, 0, 0, 11, 2, 64, 32, 11, 65, 3, 106, 33, 17, 32, 17, 32, 13, 58, 0, 0, 11, 32, 5, 65, 1, 106, 33, 5, 11, 32, 9, 65, 1, 106, 33, 9, 12, 2, 11, 11, 11, 11, 32, 8, 65, 1, 106, 33, 8, 12, 2, 11, 11, 11, 11, 32, 7, 65, 8, 106, 33, 7, 12, 2, 11, 11, 11, 11, 32, 6, 65, 4, 106, 33, 6, 12, 2, 11, 11, 11, 11, 11, 187, 2, 1, 17, 127, 65, 0, 33, 5, 2, 64, 65, 0, 33, 6, 3, 64, 32, 6, 32, 4, 73, 4, 64, 2, 64, 2, 64, 65, 0, 33, 7, 3, 64, 32, 7, 32, 3, 73, 4, 64, 2, 64, 2, 64, 65, 0, 33, 8, 3, 64, 32, 8, 65, 4, 73, 4, 64, 2, 64, 2, 64, 65, 0, 33, 9, 3, 64, 32, 9, 65, 8, 73, 4, 64, 2, 64, 2, 64, 32, 3, 32, 6, 32, 8, 65, 255, 1, 113, 106, 108, 32, 7, 106, 32, 9, 65, 255, 1, 113, 106, 33, 10, 32, 1, 32, 10, 65, 4, 108, 106, 33, 11, 2, 127, 32, 2, 32, 5, 106, 33, 12, 32, 12, 45, 0, 0, 12, 0, 11, 33, 13, 2, 127, 32, 13, 65, 255, 1, 113, 65, 4, 118, 33, 14, 32, 14, 65, 4, 116, 32, 14, 114, 65, 255, 1, 113, 12, 0, 11, 33, 15, 2, 127, 32, 13, 65, 15, 113, 33, 16, 32, 16, 65, 4, 116, 32, 16, 114, 65, 255, 1, 113, 12, 0, 11, 33, 17, 2, 64, 32, 11, 65, 0, 106, 33, 18, 32, 18, 32, 17, 58, 0, 0, 11, 2, 64, 32, 11, 65, 1, 106, 33, 19, 32, 19, 32, 17, 58, 0, 0, 11, 2, 64, 32, 11, 65, 2, 106, 33, 20, 32, 20, 32, 17, 58, 0, 0, 11, 2, 64, 32, 11, 65, 3, 106, 33, 21, 32, 21, 32, 15, 58, 0, 0, 11, 32, 5, 65, 1, 106, 33, 5, 11, 32, 9, 65, 1, 106, 33, 9, 12, 2, 11, 11, 11, 11, 32, 8, 65, 1, 106, 33, 8, 12, 2, 11, 11, 11, 11, 32, 7, 65, 8, 106, 33, 7, 12, 2, 11, 11, 11, 11, 32, 6, 65, 4, 106, 33, 6, 12, 2, 11, 11, 11, 11, 11, 156, 2, 1, 15, 127, 65, 0, 33, 5, 2, 64, 65, 0, 33, 6, 3, 64, 32, 6, 32, 4, 73, 4, 64, 2, 64, 2, 64, 65, 0, 33, 7, 3, 64, 32, 7, 32, 3, 73, 4, 64, 2, 64, 2, 64, 65, 0, 33, 8, 3, 64, 32, 8, 65, 4, 73, 4, 64, 2, 64, 2, 64, 65, 0, 33, 9, 3, 64, 32, 9, 65, 4, 73, 4, 64, 2, 64, 2, 64, 32, 3, 32, 6, 32, 8, 65, 255, 1, 113, 106, 108, 32, 7, 106, 32, 9, 65, 255, 1, 113, 106, 33, 10, 32, 1, 32, 10, 65, 4, 108, 106, 33, 11, 2, 127, 32, 2, 32, 5, 106, 65, 0, 106, 33, 12, 32, 12, 45, 0, 0, 12, 0, 11, 33, 13, 2, 127, 32, 2, 32, 5, 106, 65, 1, 106, 33, 14, 32, 14, 45, 0, 0, 12, 0, 11, 33, 15, 2, 64, 32, 11, 65, 0, 106, 33, 16, 32, 16, 32, 15, 58, 0, 0, 11, 2, 64, 32, 11, 65, 1, 106, 33, 17, 32, 17, 32, 15, 58, 0, 0, 11, 2, 64, 32, 11, 65, 2, 106, 33, 18, 32, 18, 32, 15, 58, 0, 0, 11, 2, 64, 32, 11, 65, 3, 106, 33, 19, 32, 19, 32, 13, 58, 0, 0, 11, 32, 5, 65, 2, 106, 33, 5, 11, 32, 9, 65, 1, 106, 33, 9, 12, 2, 11, 11, 11, 11, 32, 8, 65, 1, 106, 33, 8, 12, 2, 11, 11, 11, 11, 32, 7, 65, 4, 106, 33, 7, 12, 2, 11, 11, 11, 11, 32, 6, 65, 4, 106, 33, 6, 12, 2, 11, 11, 11, 11, 11, 146, 3, 1, 20, 127, 65, 0, 33, 5, 2, 64, 65, 0, 33, 6, 3, 64, 32, 6, 32, 4, 73, 4, 64, 2, 64, 2, 64, 65, 0, 33, 7, 3, 64, 32, 7, 32, 3, 73, 4, 64, 2, 64, 2, 64, 65, 0, 33, 8, 3, 64, 32, 8, 65, 4, 73, 4, 64, 2, 64, 2, 64, 65, 0, 33, 9, 3, 64, 32, 9, 65, 4, 73, 4, 64, 2, 64, 2, 64, 32, 3, 32, 6, 32, 8, 65, 255, 1, 113, 106, 108, 32, 7, 106, 32, 9, 65, 255, 1, 113, 106, 33, 10, 32, 1, 32, 10, 65, 4, 108, 106, 33, 11, 2, 127, 32, 2, 32, 5, 106, 33, 12, 32, 12, 45, 0, 0, 65, 8, 116, 32, 12, 65, 1, 106, 45, 0, 0, 114, 65, 255, 255, 3, 113, 12, 0, 11, 33, 13, 2, 64, 32, 11, 65, 0, 106, 33, 14, 2, 127, 32, 13, 65, 255, 255, 3, 113, 65, 11, 118, 65, 31, 113, 33, 15, 32, 15, 65, 8, 65, 5, 107, 116, 32, 15, 65, 10, 65, 8, 107, 118, 114, 65, 255, 1, 113, 12, 0, 11, 33, 16, 32, 14, 32, 16, 58, 0, 0, 11, 2, 64, 32, 11, 65, 1, 106, 33, 17, 2, 127, 32, 13, 65, 255, 255, 3, 113, 65, 5, 118, 65, 63, 113, 33, 18, 32, 18, 65, 8, 65, 6, 107, 116, 32, 18, 65, 12, 65, 8, 107, 118, 114, 65, 255, 1, 113, 12, 0, 11, 33, 19, 32, 17, 32, 19, 58, 0, 0, 11, 2, 64, 32, 11, 65, 2, 106, 33, 20, 2, 127, 32, 13, 65, 31, 113, 33, 21, 32, 21, 65, 8, 65, 5, 107, 116, 32, 21, 65, 10, 65, 8, 107, 118, 114, 65, 255, 1, 113, 12, 0, 11, 33, 22, 32, 20, 32, 22, 58, 0, 0, 11, 2, 64, 32, 11, 65, 3, 106, 33, 23, 65, 255, 1, 33, 24, 32, 23, 32, 24, 58, 0, 0, 11, 32, 5, 65, 2, 106, 33, 5, 11, 32, 9, 65, 1, 106, 33, 9, 12, 2, 11, 11, 11, 11, 32, 8, 65, 1, 106, 33, 8, 12, 2, 11, 11, 11, 11, 32, 7, 65, 4, 106, 33, 7, 12, 2, 11, 11, 11, 11, 32, 6, 65, 4, 106, 33, 6, 12, 2, 11, 11, 11, 11, 11, 250, 4, 1, 32, 127, 65, 0, 33, 5, 2, 64, 65, 0, 33, 6, 3, 64, 32, 6, 32, 4, 73, 4, 64, 2, 64, 2, 64, 65, 0, 33, 7, 3, 64, 32, 7, 32, 3, 73, 4, 64, 2, 64, 2, 64, 65, 0, 33, 8, 3, 64, 32, 8, 65, 4, 73, 4, 64, 2, 64, 2, 64, 65, 0, 33, 9, 3, 64, 32, 9, 65, 4, 73, 4, 64, 2, 64, 2, 64, 32, 3, 32, 6, 32, 8, 65, 255, 1, 113, 106, 108, 32, 7, 106, 32, 9, 65, 255, 1, 113, 106, 33, 10, 32, 1, 32, 10, 65, 4, 108, 106, 33, 11, 2, 127, 32, 2, 32, 5, 106, 33, 12, 32, 12, 45, 0, 0, 65, 8, 116, 32, 12, 65, 1, 106, 45, 0, 0, 114, 65, 255, 255, 3, 113, 12, 0, 11, 33, 13, 32, 13, 65, 128, 128, 2, 113, 4, 64, 2, 64, 2, 64, 32, 11, 65, 0, 106, 33, 14, 2, 127, 32, 13, 65, 255, 255, 3, 113, 65, 10, 118, 65, 31, 113, 33, 15, 32, 15, 65, 8, 65, 5, 107, 116, 32, 15, 65, 10, 65, 8, 107, 118, 114, 65, 255, 1, 113, 12, 0, 11, 33, 16, 32, 14, 32, 16, 58, 0, 0, 11, 2, 64, 32, 11, 65, 1, 106, 33, 17, 2, 127, 32, 13, 65, 255, 255, 3, 113, 65, 5, 118, 65, 31, 113, 33, 18, 32, 18, 65, 8, 65, 5, 107, 116, 32, 18, 65, 10, 65, 8, 107, 118, 114, 65, 255, 1, 113, 12, 0, 11, 33, 19, 32, 17, 32, 19, 58, 0, 0, 11, 2, 64, 32, 11, 65, 2, 106, 33, 20, 2, 127, 32, 13, 65, 31, 113, 33, 21, 32, 21, 65, 8, 65, 5, 107, 116, 32, 21, 65, 10, 65, 8, 107, 118, 114, 65, 255, 1, 113, 12, 0, 11, 33, 22, 32, 20, 32, 22, 58, 0, 0, 11, 2, 64, 32, 11, 65, 3, 106, 33, 23, 65, 255, 1, 33, 24, 32, 23, 32, 24, 58, 0, 0, 11, 11, 5, 2, 64, 2, 64, 32, 11, 65, 0, 106, 33, 25, 2, 127, 32, 13, 65, 255, 255, 3, 113, 65, 8, 118, 65, 15, 113, 33, 26, 32, 26, 65, 4, 116, 32, 26, 114, 65, 255, 1, 113, 12, 0, 11, 33, 27, 32, 25, 32, 27, 58, 0, 0, 11, 2, 64, 32, 11, 65, 1, 106, 33, 28, 2, 127, 32, 13, 65, 255, 255, 3, 113, 65, 4, 118, 65, 15, 113, 33, 29, 32, 29, 65, 4, 116, 32, 29, 114, 65, 255, 1, 113, 12, 0, 11, 33, 30, 32, 28, 32, 30, 58, 0, 0, 11, 2, 64, 32, 11, 65, 2, 106, 33, 31, 2, 127, 32, 13, 65, 15, 113, 33, 32, 32, 32, 65, 4, 116, 32, 32, 114, 65, 255, 1, 113, 12, 0, 11, 33, 33, 32, 31, 32, 33, 58, 0, 0, 11, 2, 64, 32, 11, 65, 3, 106, 33, 34, 2, 127, 32, 13, 65, 255, 255, 3, 113, 65, 12, 118, 33, 35, 32, 35, 65, 8, 65, 3, 107, 116, 32, 35, 65, 8, 65, 6, 107, 116, 114, 32, 35, 65, 255, 1, 113, 65, 9, 65, 8, 107, 118, 114, 65, 255, 1, 113, 12, 0, 11, 33, 36, 32, 34, 32, 36, 58, 0, 0, 11, 11, 11, 32, 5, 65, 2, 106, 33, 5, 11, 32, 9, 65, 1, 106, 33, 9, 12, 2, 11, 11, 11, 11, 32, 8, 65, 1, 106, 33, 8, 12, 2, 11, 11, 11, 11, 32, 7, 65, 4, 106, 33, 7, 12, 2, 11, 11, 11, 11, 32, 6, 65, 4, 106, 33, 6, 12, 2, 11, 11, 11, 11, 11, 163, 3, 1, 23, 127, 65, 0, 33, 5, 2, 64, 65, 0, 33, 6, 3, 64, 32, 6, 32, 4, 73, 4, 64, 2, 64, 2, 64, 65, 0, 33, 7, 3, 64, 32, 7, 32, 3, 73, 4, 64, 2, 64, 2, 64, 2, 64, 65, 0, 33, 8, 3, 64, 32, 8, 65, 4, 73, 4, 64, 2, 64, 2, 64, 65, 0, 33, 9, 3, 64, 32, 9, 65, 4, 73, 4, 64, 2, 64, 2, 64, 32, 3, 32, 6, 32, 8, 106, 108, 32, 7, 106, 32, 9, 106, 33, 10, 32, 1, 32, 10, 65, 4, 108, 106, 33, 11, 2, 64, 32, 11, 65, 3, 106, 33, 12, 2, 127, 32, 2, 32, 5, 106, 65, 0, 106, 33, 13, 32, 13, 45, 0, 0, 12, 0, 11, 33, 14, 32, 12, 32, 14, 58, 0, 0, 11, 2, 64, 32, 11, 65, 0, 106, 33, 15, 2, 127, 32, 2, 32, 5, 106, 65, 1, 106, 33, 16, 32, 16, 45, 0, 0, 12, 0, 11, 33, 17, 32, 15, 32, 17, 58, 0, 0, 11, 32, 5, 65, 2, 106, 33, 5, 11, 32, 9, 65, 1, 106, 33, 9, 12, 2, 11, 11, 11, 11, 32, 8, 65, 1, 106, 33, 8, 12, 2, 11, 11, 11, 11, 2, 64, 65, 0, 33, 18, 3, 64, 32, 18, 65, 4, 73, 4, 64, 2, 64, 2, 64, 65, 0, 33, 19, 3, 64, 32, 19, 65, 4, 73, 4, 64, 2, 64, 2, 64, 32, 3, 32, 6, 32, 18, 106, 108, 32, 7, 106, 32, 19, 106, 33, 20, 32, 1, 32, 20, 65, 4, 108, 106, 33, 21, 2, 64, 32, 21, 65, 1, 106, 33, 22, 2, 127, 32, 2, 32, 5, 106, 65, 0, 106, 33, 23, 32, 23, 45, 0, 0, 12, 0, 11, 33, 24, 32, 22, 32, 24, 58, 0, 0, 11, 2, 64, 32, 21, 65, 2, 106, 33, 25, 2, 127, 32, 2, 32, 5, 106, 65, 1, 106, 33, 26, 32, 26, 45, 0, 0, 12, 0, 11, 33, 27, 32, 25, 32, 27, 58, 0, 0, 11, 32, 5, 65, 2, 106, 33, 5, 11, 32, 19, 65, 1, 106, 33, 19, 12, 2, 11, 11, 11, 11, 32, 18, 65, 1, 106, 33, 18, 12, 2, 11, 11, 11, 11, 11, 32, 7, 65, 4, 106, 33, 7, 12, 2, 11, 11, 11, 11, 32, 6, 65, 4, 106, 33, 6, 12, 2, 11, 11, 11, 11, 11, 218, 15, 1, 131, 1, 127, 32, 0, 33, 5, 32, 2, 33, 6, 2, 64, 65, 0, 33, 7, 3, 64, 32, 7, 32, 4, 73, 4, 64, 2, 64, 2, 64, 65, 0, 33, 8, 3, 64, 32, 8, 32, 3, 73, 4, 64, 2, 64, 2, 64, 65, 0, 33, 9, 3, 64, 32, 9, 65, 8, 73, 4, 64, 2, 64, 2, 64, 65, 0, 33, 10, 3, 64, 32, 10, 65, 8, 73, 4, 64, 2, 64, 2, 64, 2, 127, 32, 6, 65, 0, 106, 33, 11, 32, 11, 45, 0, 0, 65, 8, 116, 32, 11, 65, 1, 106, 45, 0, 0, 114, 65, 255, 255, 3, 113, 12, 0, 11, 33, 12, 2, 127, 32, 6, 65, 2, 106, 33, 13, 32, 13, 45, 0, 0, 65, 8, 116, 32, 13, 65, 1, 106, 45, 0, 0, 114, 65, 255, 255, 3, 113, 12, 0, 11, 33, 14, 2, 64, 32, 5, 65, 0, 106, 33, 15, 2, 127, 32, 12, 65, 255, 255, 3, 113, 65, 11, 118, 65, 31, 113, 33, 16, 32, 16, 65, 8, 65, 5, 107, 116, 32, 16, 65, 10, 65, 8, 107, 118, 114, 65, 255, 1, 113, 12, 0, 11, 33, 17, 32, 15, 32, 17, 58, 0, 0, 11, 2, 64, 32, 5, 65, 1, 106, 33, 18, 2, 127, 32, 12, 65, 255, 255, 3, 113, 65, 5, 118, 65, 63, 113, 33, 19, 32, 19, 65, 8, 65, 6, 107, 116, 32, 19, 65, 12, 65, 8, 107, 118, 114, 65, 255, 1, 113, 12, 0, 11, 33, 20, 32, 18, 32, 20, 58, 0, 0, 11, 2, 64, 32, 5, 65, 2, 106, 33, 21, 2, 127, 32, 12, 65, 31, 113, 33, 22, 32, 22, 65, 8, 65, 5, 107, 116, 32, 22, 65, 10, 65, 8, 107, 118, 114, 65, 255, 1, 113, 12, 0, 11, 33, 23, 32, 21, 32, 23, 58, 0, 0, 11, 2, 64, 32, 5, 65, 3, 106, 33, 24, 65, 255, 1, 33, 25, 32, 24, 32, 25, 58, 0, 0, 11, 2, 64, 32, 5, 65, 4, 106, 33, 26, 2, 127, 32, 14, 65, 255, 255, 3, 113, 65, 11, 118, 65, 31, 113, 33, 27, 32, 27, 65, 8, 65, 5, 107, 116, 32, 27, 65, 10, 65, 8, 107, 118, 114, 65, 255, 1, 113, 12, 0, 11, 33, 28, 32, 26, 32, 28, 58, 0, 0, 11, 2, 64, 32, 5, 65, 5, 106, 33, 29, 2, 127, 32, 14, 65, 255, 255, 3, 113, 65, 5, 118, 65, 63, 113, 33, 30, 32, 30, 65, 8, 65, 6, 107, 116, 32, 30, 65, 12, 65, 8, 107, 118, 114, 65, 255, 1, 113, 12, 0, 11, 33, 31, 32, 29, 32, 31, 58, 0, 0, 11, 2, 64, 32, 5, 65, 6, 106, 33, 32, 2, 127, 32, 14, 65, 31, 113, 33, 33, 32, 33, 65, 8, 65, 5, 107, 116, 32, 33, 65, 10, 65, 8, 107, 118, 114, 65, 255, 1, 113, 12, 0, 11, 33, 34, 32, 32, 32, 34, 58, 0, 0, 11, 2, 64, 32, 5, 65, 7, 106, 33, 35, 65, 255, 1, 33, 36, 32, 35, 32, 36, 58, 0, 0, 11, 32, 12, 65, 255, 255, 3, 113, 32, 14, 65, 255, 255, 3, 113, 75, 4, 64, 2, 64, 2, 64, 32, 5, 65, 8, 106, 33, 37, 2, 127, 2, 127, 32, 5, 65, 4, 106, 33, 38, 32, 38, 45, 0, 0, 12, 0, 11, 65, 255, 1, 113, 33, 39, 2, 127, 32, 5, 65, 0, 106, 33, 40, 32, 40, 45, 0, 0, 12, 0, 11, 65, 255, 1, 113, 33, 41, 32, 39, 65, 1, 116, 32, 39, 106, 32, 41, 65, 2, 116, 32, 41, 106, 106, 65, 3, 118, 33, 42, 32, 42, 65, 255, 1, 113, 12, 0, 11, 33, 43, 32, 37, 32, 43, 58, 0, 0, 11, 2, 64, 32, 5, 65, 9, 106, 33, 44, 2, 127, 2, 127, 32, 5, 65, 5, 106, 33, 45, 32, 45, 45, 0, 0, 12, 0, 11, 65, 255, 1, 113, 33, 46, 2, 127, 32, 5, 65, 1, 106, 33, 47, 32, 47, 45, 0, 0, 12, 0, 11, 65, 255, 1, 113, 33, 48, 32, 46, 65, 1, 116, 32, 46, 106, 32, 48, 65, 2, 116, 32, 48, 106, 106, 65, 3, 118, 33, 49, 32, 49, 65, 255, 1, 113, 12, 0, 11, 33, 50, 32, 44, 32, 50, 58, 0, 0, 11, 2, 64, 32, 5, 65, 10, 106, 33, 51, 2, 127, 2, 127, 32, 5, 65, 6, 106, 33, 52, 32, 52, 45, 0, 0, 12, 0, 11, 65, 255, 1, 113, 33, 53, 2, 127, 32, 5, 65, 2, 106, 33, 54, 32, 54, 45, 0, 0, 12, 0, 11, 65, 255, 1, 113, 33, 55, 32, 53, 65, 1, 116, 32, 53, 106, 32, 55, 65, 2, 116, 32, 55, 106, 106, 65, 3, 118, 33, 56, 32, 56, 65, 255, 1, 113, 12, 0, 11, 33, 57, 32, 51, 32, 57, 58, 0, 0, 11, 2, 64, 32, 5, 65, 11, 106, 33, 58, 65, 255, 1, 33, 59, 32, 58, 32, 59, 58, 0, 0, 11, 2, 64, 32, 5, 65, 12, 106, 33, 60, 2, 127, 2, 127, 32, 5, 65, 0, 106, 33, 61, 32, 61, 45, 0, 0, 12, 0, 11, 65, 255, 1, 113, 33, 62, 2, 127, 32, 5, 65, 4, 106, 33, 63, 32, 63, 45, 0, 0, 12, 0, 11, 65, 255, 1, 113, 33, 64, 32, 62, 65, 1, 116, 32, 62, 106, 32, 64, 65, 2, 116, 32, 64, 106, 106, 65, 3, 118, 33, 65, 32, 65, 65, 255, 1, 113, 12, 0, 11, 33, 66, 32, 60, 32, 66, 58, 0, 0, 11, 2, 64, 32, 5, 65, 13, 106, 33, 67, 2, 127, 2, 127, 32, 5, 65, 1, 106, 33, 68, 32, 68, 45, 0, 0, 12, 0, 11, 65, 255, 1, 113, 33, 69, 2, 127, 32, 5, 65, 5, 106, 33, 70, 32, 70, 45, 0, 0, 12, 0, 11, 65, 255, 1, 113, 33, 71, 32, 69, 65, 1, 116, 32, 69, 106, 32, 71, 65, 2, 116, 32, 71, 106, 106, 65, 3, 118, 33, 72, 32, 72, 65, 255, 1, 113, 12, 0, 11, 33, 73, 32, 67, 32, 73, 58, 0, 0, 11, 2, 64, 32, 5, 65, 14, 106, 33, 74, 2, 127, 2, 127, 32, 5, 65, 2, 106, 33, 75, 32, 75, 45, 0, 0, 12, 0, 11, 65, 255, 1, 113, 33, 76, 2, 127, 32, 5, 65, 6, 106, 33, 77, 32, 77, 45, 0, 0, 12, 0, 11, 65, 255, 1, 113, 33, 78, 32, 76, 65, 1, 116, 32, 76, 106, 32, 78, 65, 2, 116, 32, 78, 106, 106, 65, 3, 118, 33, 79, 32, 79, 65, 255, 1, 113, 12, 0, 11, 33, 80, 32, 74, 32, 80, 58, 0, 0, 11, 2, 64, 32, 5, 65, 15, 106, 33, 81, 65, 255, 1, 33, 82, 32, 81, 32, 82, 58, 0, 0, 11, 11, 5, 2, 64, 2, 64, 32, 5, 65, 8, 106, 33, 83, 2, 127, 2, 127, 32, 5, 65, 0, 106, 33, 84, 32, 84, 45, 0, 0, 12, 0, 11, 65, 255, 1, 113, 33, 85, 2, 127, 32, 5, 65, 4, 106, 33, 86, 32, 86, 45, 0, 0, 12, 0, 11, 65, 255, 1, 113, 33, 87, 32, 85, 32, 87, 106, 65, 1, 118, 33, 88, 32, 88, 65, 255, 1, 113, 12, 0, 11, 33, 89, 32, 83, 32, 89, 58, 0, 0, 11, 2, 64, 32, 5, 65, 9, 106, 33, 90, 2, 127, 2, 127, 32, 5, 65, 1, 106, 33, 91, 32, 91, 45, 0, 0, 12, 0, 11, 65, 255, 1, 113, 33, 92, 2, 127, 32, 5, 65, 5, 106, 33, 93, 32, 93, 45, 0, 0, 12, 0, 11, 65, 255, 1, 113, 33, 94, 32, 92, 32, 94, 106, 65, 1, 118, 33, 95, 32, 95, 65, 255, 1, 113, 12, 0, 11, 33, 96, 32, 90, 32, 96, 58, 0, 0, 11, 2, 64, 32, 5, 65, 10, 106, 33, 97, 2, 127, 2, 127, 32, 5, 65, 2, 106, 33, 98, 32, 98, 45, 0, 0, 12, 0, 11, 65, 255, 1, 113, 33, 99, 2, 127, 32, 5, 65, 6, 106, 33, 100, 32, 100, 45, 0, 0, 12, 0, 11, 65, 255, 1, 113, 33, 101, 32, 99, 32, 101, 106, 65, 1, 118, 33, 102, 32, 102, 65, 255, 1, 113, 12, 0, 11, 33, 103, 32, 97, 32, 103, 58, 0, 0, 11, 2, 64, 32, 5, 65, 11, 106, 33, 104, 65, 255, 1, 33, 105, 32, 104, 32, 105, 58, 0, 0, 11, 2, 64, 32, 5, 65, 12, 106, 33, 106, 2, 127, 32, 5, 65, 8, 106, 33, 107, 32, 107, 45, 0, 0, 12, 0, 11, 33, 108, 32, 106, 32, 108, 58, 0, 0, 11, 2, 64, 32, 5, 65, 13, 106, 33, 109, 2, 127, 32, 5, 65, 9, 106, 33, 110, 32, 110, 45, 0, 0, 12, 0, 11, 33, 111, 32, 109, 32, 111, 58, 0, 0, 11, 2, 64, 32, 5, 65, 14, 106, 33, 112, 2, 127, 32, 5, 65, 10, 106, 33, 113, 32, 113, 45, 0, 0, 12, 0, 11, 33, 114, 32, 112, 32, 114, 58, 0, 0, 11, 2, 64, 32, 5, 65, 15, 106, 33, 115, 65, 0, 33, 116, 32, 115, 32, 116, 58, 0, 0, 11, 11, 11, 2, 64, 65, 0, 33, 117, 3, 64, 32, 117, 65, 4, 72, 4, 64, 2, 64, 2, 64, 2, 127, 32, 6, 65, 4, 106, 32, 117, 106, 33, 118, 32, 118, 45, 0, 0, 12, 0, 11, 33, 119, 2, 64, 65, 0, 33, 120, 3, 64, 32, 120, 65, 4, 72, 4, 64, 2, 64, 2, 64, 32, 7, 32, 9, 106, 32, 117, 106, 32, 3, 108, 32, 8, 106, 32, 10, 106, 32, 120, 106, 33, 121, 32, 1, 32, 121, 65, 4, 108, 106, 33, 122, 32, 119, 65, 255, 1, 113, 65, 6, 118, 65, 3, 113, 33, 123, 2, 64, 32, 122, 65, 0, 106, 33, 124, 2, 127, 32, 5, 32, 123, 65, 4, 108, 65, 255, 1, 113, 106, 65, 0, 106, 33, 125, 32, 125, 45, 0, 0, 12, 0, 11, 33, 126, 32, 124, 32, 126, 58, 0, 0, 11, 2, 64, 32, 122, 65, 1, 106, 33, 127, 2, 127, 32, 5, 32, 123, 65, 4, 108, 65, 255, 1, 113, 106, 65, 1, 106, 33, 128, 1, 32, 128, 1, 45, 0, 0, 12, 0, 11, 33, 129, 1, 32, 127, 32, 129, 1, 58, 0, 0, 11, 2, 64, 32, 122, 65, 2, 106, 33, 130, 1, 2, 127, 32, 5, 32, 123, 65, 4, 108, 65, 255, 1, 113, 106, 65, 2, 106, 33, 131, 1, 32, 131, 1, 45, 0, 0, 12, 0, 11, 33, 132, 1, 32, 130, 1, 32, 132, 1, 58, 0, 0, 11, 2, 64, 32, 122, 65, 3, 106, 33, 133, 1, 2, 127, 32, 5, 32, 123, 65, 4, 108, 65, 255, 1, 113, 106, 65, 3, 106, 33, 134, 1, 32, 134, 1, 45, 0, 0, 12, 0, 11, 33, 135, 1, 32, 133, 1, 32, 135, 1, 58, 0, 0, 11, 32, 119, 65, 2, 116, 33, 119, 11, 32, 120, 65, 1, 106, 33, 120, 12, 2, 11, 11, 11, 11, 11, 32, 117, 65, 1, 106, 33, 117, 12, 2, 11, 11, 11, 11, 32, 6, 65, 8, 106, 33, 6, 11, 32, 10, 65, 4, 106, 33, 10, 12, 2, 11, 11, 11, 11, 32, 9, 65, 4, 106, 33, 9, 12, 2, 11, 11, 11, 11, 32, 8, 65, 8, 106, 33, 8, 12, 2, 11, 11, 11, 11, 32, 7, 65, 8, 106, 33, 7, 12, 2, 11, 11, 11, 11, 11]);
function gx_texture_asInstance(imports) {
    return WebAssembly.compile(gx_texture_asCode).then(function (module) {
        return WebAssembly.instantiate(module, imports);
    }).then(function (instance) {
        return instance.exports;
    });
}
exports.gx_texture_asInstance = gx_texture_asInstance;
},{}],"WasmMemoryManager.ts":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var WasmMemoryManager = /** @class */function () {
    function WasmMemoryManager(mem) {
        // WebAssembly pages are 64k.
        this.PAGE_SIZE = 64 * 1024;
        if (mem !== undefined) this.mem = mem;else this.mem = new WebAssembly.Memory({ initial: 1 });
        this.currentNumPages = this.mem.buffer.byteLength / this.PAGE_SIZE;
        // resize must be called before use.
        this.heap = null;
    }
    WasmMemoryManager.prototype.resize = function (newSize) {
        var newNumPages = Math.ceil(newSize / this.PAGE_SIZE);
        if (newNumPages > this.currentNumPages) {
            this.mem.grow(newNumPages - this.currentNumPages);
            this.currentNumPages = newNumPages;
            this.heap = null;
        }
        if (this.heap === null) this.heap = new Uint8Array(this.mem.buffer);
        return this.heap;
    };
    return WasmMemoryManager;
}();
exports.default = WasmMemoryManager;
},{}],"compression\\Yaz0.ts":[function(require,module,exports) {
"use strict";
// Nintendo Yaz0 format.

var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// Header (8 bytes):
//   Magic: "Yaz0" (4 bytes)
//   Uncompressed size (4 bytes, big endian)
// Data:
//   Flags (1 byte)
//   For each bit in the flags byte, from MSB to LSB:
//     If flag is 1:
//       Literal: copy one byte from src to dest.
//     If flag is 0:
//       LZ77 (2 bytes, big endian):
//         Length: bits 0-4
//           If Length = 0, then read additional byte, add 16, and add it to Length.
//         Offset: bits 5-15
//         Copy Length+2 bytes from Offset back in the output buffer.
var util_1 = require("../util");
var wat_modules_1 = require("../wat_modules");
var ArrayBufferSlice_1 = __importDefault(require("../ArrayBufferSlice"));
var WasmMemoryManager_1 = __importDefault(require("../WasmMemoryManager"));
// XXX(jstpierre): Firefox has GC pressure when constructing new WebAssembly.Memory instances
// on 64-bit machines. Construct a global WebAssembly.Memory and use it. Remove this when the
// bug is fixed. https://bugzilla.mozilla.org/show_bug.cgi?id=1459761#c5
var _wasmInstance = wat_modules_1.yaz0_asInstance();
function decompress(srcBuffer) {
    return _wasmInstance.then(function (wasmInstance) {
        var srcView = srcBuffer.createDataView();
        util_1.assert(util_1.readString(srcBuffer, 0x00, 0x04) === 'Yaz0');
        var dstSize = srcView.getUint32(0x04, false);
        var srcSize = srcBuffer.byteLength;
        var pDst = 0;
        var pSrc = util_1.align(dstSize, 0x10);
        var heapSize = pSrc + util_1.align(srcSize, 0x10);
        var wasmMemory = new WasmMemoryManager_1.default(wasmInstance.memory);
        var heap = wasmMemory.resize(heapSize);
        // Copy src buffer.
        heap.set(srcBuffer.createTypedArray(Uint8Array, 0x10), pSrc);
        wasmInstance.decompress(pDst, pSrc, dstSize);
        // Copy the result buffer to a new buffer for memory usage purposes.
        var result = new ArrayBufferSlice_1.default(heap.buffer).copyToSlice(pDst, dstSize);
        return result;
    });
}
exports.decompress = decompress;
},{"../util":"util.ts","../wat_modules":"wat_modules.ts","../ArrayBufferSlice":"ArrayBufferSlice.ts","../WasmMemoryManager":"WasmMemoryManager.ts"}],"ui.ts":[function(require,module,exports) {
"use strict";
// New UI system

var __extends = this && this.__extends || function () {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
        d.__proto__ = b;
    } || function (d, b) {
        for (var p in b) {
            if (b.hasOwnProperty(p)) d[p] = b[p];
        }
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __read = this && this.__read || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o),
        r,
        ar = [],
        e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {
            ar.push(r.value);
        }
    } catch (error) {
        e = { error: error };
    } finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
            if (e) throw e.error;
        }
    }
    return ar;
};
var __spread = this && this.__spread || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) {
        ar = ar.concat(__read(arguments[i]));
    }return ar;
};
var __values = this && this.__values || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator],
        i = 0;
    if (m) return m.call(o);
    return {
        next: function next() {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("./util");
var Camera_1 = require("./Camera");
var HIGHLIGHT_COLOR = 'rgb(210, 30, 30)';
function createDOMFromString(s) {
    return document.createRange().createContextualFragment(s);
}
function setElementHighlighted(elem, highlighted, normalTextColor) {
    if (normalTextColor === void 0) {
        normalTextColor = '';
    }
    elem.classList.toggle('Highlighted', highlighted);
    if (highlighted) {
        elem.style.backgroundColor = HIGHLIGHT_COLOR;
        elem.style.color = 'black';
    } else {
        elem.style.backgroundColor = '';
        elem.style.color = normalTextColor;
    }
}
function highlightFlair(i) {
    return { index: i, background: HIGHLIGHT_COLOR, color: 'black' };
}
var ScrollSelect = /** @class */function () {
    function ScrollSelect() {
        this.flairs = [];
        this.internalFlairs = [];
        this.toplevel = document.createElement('div');
        this.scrollContainer = document.createElement('div');
        this.scrollContainer.style.height = "200px";
        this.scrollContainer.style.overflow = 'auto';
        this.scrollContainer.style.userSelect = 'none';
        this.scrollContainer.style.webkitUserSelect = 'none';
        this.toplevel.appendChild(this.scrollContainer);
        this.elem = this.toplevel;
    }
    ScrollSelect.prototype.setStrings = function (strings) {
        var _this = this;
        this.scrollContainer.style.display = strings.length > 0 ? '' : 'none';
        this.scrollContainer.innerHTML = '';
        var _loop_1 = function _loop_1(i) {
            var selector = document.createElement('div');
            selector.style.display = 'list-item';
            selector.style.cursor = 'pointer';
            var textSpan = document.createElement('span');
            textSpan.style.fontWeight = 'bold';
            textSpan.textContent = strings[i];
            selector.appendChild(textSpan);
            var index = i;
            selector.onclick = function () {
                _this.itemClicked(index);
            };
            this_1.scrollContainer.appendChild(selector);
        };
        var this_1 = this;
        for (var i = 0; i < strings.length; i++) {
            _loop_1(i);
        }
    };
    ScrollSelect.prototype.getNumItems = function () {
        return this.scrollContainer.childElementCount;
    };
    ScrollSelect.prototype.setFlairs = function (flairs) {
        this.flairs = flairs;
        this.syncFlairs();
    };
    ScrollSelect.prototype.setInternalFlairs = function (flairs) {
        this.internalFlairs = flairs;
        this.syncFlairs();
    };
    ScrollSelect.prototype.syncFlairs = function () {
        var flairs = __spread(this.internalFlairs, this.flairs);
        var _loop_2 = function _loop_2(i) {
            var selector = this_2.scrollContainer.children.item(i);
            var flair = flairs.find(function (flair) {
                return flair.index === i;
            });
            var background = flair !== undefined && flair.background !== undefined ? flair.background : '';
            selector.style.background = background;
            var textSpan = util_1.assertExists(selector.querySelector('span'));
            var color = flair !== undefined && flair.color !== undefined ? flair.color : '';
            textSpan.style.color = color;
            if (flair !== undefined && flair.bulletColor !== undefined) {
                selector.style.listStyleType = 'disc';
                selector.style.listStylePosition = 'inside';
                selector.style.marginLeft = '4px';
                selector.style.color = flair.bulletColor;
            } else {
                selector.style.listStyleType = '';
                selector.style.color = '';
                selector.style.marginLeft = '';
            }
        };
        var this_2 = this;
        for (var i = 0; i < this.getNumItems(); i++) {
            _loop_2(i);
        }
    };
    return ScrollSelect;
}();
exports.ScrollSelect = ScrollSelect;
var SingleSelect = /** @class */function (_super) {
    __extends(SingleSelect, _super);
    function SingleSelect() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    SingleSelect.prototype.itemClicked = function (index) {
        this.selectItem(index);
    };
    SingleSelect.prototype.selectItem = function (index) {
        this.onselectionchange(index);
    };
    SingleSelect.prototype.setHighlighted = function (highlightedIndex) {
        this.setInternalFlairs([highlightFlair(highlightedIndex)]);
    };
    return SingleSelect;
}(ScrollSelect);
exports.SingleSelect = SingleSelect;
var SimpleSingleSelect = /** @class */function (_super) {
    __extends(SimpleSingleSelect, _super);
    function SimpleSingleSelect() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    SimpleSingleSelect.prototype.selectItem = function (index) {
        _super.prototype.selectItem.call(this, index);
        this.setHighlighted(index);
    };
    return SimpleSingleSelect;
}(SingleSelect);
exports.SimpleSingleSelect = SimpleSingleSelect;
var MultiSelect = /** @class */function (_super) {
    __extends(MultiSelect, _super);
    function MultiSelect() {
        var _this = _super.call(this) || this;
        _this.itemIsOn = [];
        var allNone = createDOMFromString("\n<div style=\"display: grid; grid-template-columns: 1fr 1fr; grid-gap: 4px;\">\n<style>\n.AllButton, .NoneButton {\n    text-align: center;\n    line-height: 32px;\n    cursor: pointer;\n    background: #666;\n    font-weight: bold;\n}\n</style>\n<div class=\"AllButton\">All</div><div class=\"NoneButton\">None</div>\n</div>\n");
        _this.toplevel.insertBefore(allNone, _this.toplevel.firstChild);
        var allButton = _this.toplevel.querySelector('.AllButton');
        allButton.onclick = function () {
            for (var i = 0; i < _this.getNumItems(); i++) {
                _this.setItemIsOn(i, true);
            }_this.syncInternalFlairs();
        };
        var noneButton = _this.toplevel.querySelector('.NoneButton');
        noneButton.onclick = function () {
            for (var i = 0; i < _this.getNumItems(); i++) {
                _this.setItemIsOn(i, false);
            }_this.syncInternalFlairs();
        };
        return _this;
    }
    MultiSelect.prototype.setItemIsOn = function (index, v) {
        this.itemIsOn[index] = v;
        this.onitemchanged(index, this.itemIsOn[index]);
    };
    MultiSelect.prototype.itemClicked = function (index) {
        this.setItemIsOn(index, !this.itemIsOn[index]);
        this.syncInternalFlairs();
    };
    MultiSelect.prototype.syncInternalFlairs = function () {
        var flairs = __spread(this.flairs);
        for (var i = 0; i < this.getNumItems(); i++) {
            var bulletColor = !!this.itemIsOn[i] ? HIGHLIGHT_COLOR : '#aaa';
            var color = !!this.itemIsOn[i] ? 'white' : '#aaa';
            flairs.push({ index: i, bulletColor: bulletColor, color: color });
        }
        this.setInternalFlairs(flairs);
    };
    MultiSelect.prototype.setItemsSelected = function (isOn) {
        this.itemIsOn = isOn;
        this.syncInternalFlairs();
    };
    MultiSelect.prototype.setItemSelected = function (index, v) {
        this.itemIsOn[index] = v;
        this.syncInternalFlairs();
    };
    return MultiSelect;
}(ScrollSelect);
exports.MultiSelect = MultiSelect;
var Panel = /** @class */function () {
    function Panel() {
        var _this = this;
        this.toplevel = document.createElement('div');
        this.toplevel.style.color = 'white';
        this.toplevel.style.font = '16px monospace';
        this.toplevel.style.overflow = 'hidden';
        this.toplevel.style.display = 'grid';
        this.toplevel.style.gridAutoFlow = 'column';
        this.toplevel.style.gridGap = '20px';
        this.toplevel.style.transition = '.25s ease-out';
        this.toplevel.style.alignItems = 'start';
        this.mainPanel = document.createElement('div');
        this.mainPanel.style.overflow = 'hidden';
        this.mainPanel.style.transition = '.25s ease-out';
        this.mainPanel.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
        this.mainPanel.style.pointerEvents = 'auto';
        this.toplevel.appendChild(this.mainPanel);
        this.extraRack = document.createElement('div');
        this.extraRack.style.display = 'grid';
        this.extraRack.style.gridAutoFlow = 'column';
        this.extraRack.style.gridGap = '20px';
        this.extraRack.style.transition = '.15s ease-out .10s';
        this.extraRack.style.pointerEvents = 'auto';
        this.toplevel.appendChild(this.extraRack);
        this.header = document.createElement('h1');
        this.header.style.lineHeight = '28px';
        this.header.style.width = '400px';
        this.header.style.margin = '0';
        this.header.style.color = HIGHLIGHT_COLOR;
        this.header.style.fontSize = '100%';
        this.header.style.textAlign = 'center';
        this.header.style.cursor = 'pointer';
        this.header.style.userSelect = 'none';
        this.header.style.webkitUserSelect = 'none';
        this.header.style.display = 'grid';
        this.header.style.gridTemplateColumns = '28px 1fr';
        this.header.style.alignItems = 'center';
        this.header.style.justifyItems = 'center';
        this.header.style.gridAutoFlow = 'column';
        this.toplevel.onmouseover = this.syncSize.bind(this);
        this.toplevel.onmouseout = this.syncSize.bind(this);
        this.header.onclick = function () {
            _this.toggleExpanded();
        };
        this.mainPanel.appendChild(this.header);
        this.contents = document.createElement('div');
        this.contents.style.width = '400px';
        this.mainPanel.appendChild(this.contents);
        this.elem = this.toplevel;
    }
    Panel.prototype.syncSize = function () {
        var widthExpanded = this.expanded || this.mainPanel.matches(':hover');
        this.mainPanel.style.width = widthExpanded ? '400px' : '28px';
        var heightExpanded = this.expanded;
        if (heightExpanded) {
            var height = this.header.offsetHeight + this.contents.offsetHeight;
            this.toplevel.style.height = height + "px";
            this.extraRack.style.opacity = '1';
        } else {
            this.toplevel.style.transition = '.25s ease-out';
            this.toplevel.style.height = '28px';
            this.extraRack.style.opacity = '0';
        }
    };
    Panel.prototype.setVisible = function (v) {
        this.toplevel.style.display = v ? 'grid' : 'none';
    };
    Panel.prototype.setTitle = function (icon, title) {
        var svgIcon = createDOMFromString(icon).querySelector('svg');
        this.svgIcon = svgIcon;
        this.svgIcon.style.gridColumn = '1';
        this.header.textContent = title;
        this.header.appendChild(this.svgIcon);
        this.setExpanded(false);
    };
    Panel.prototype.syncHeaderStyle = function () {
        this.svgIcon.style.fill = this.expanded ? 'black' : '';
        setElementHighlighted(this.header, this.expanded, HIGHLIGHT_COLOR);
    };
    Panel.prototype.setExpanded = function (expanded) {
        this.expanded = expanded;
        this.syncHeaderStyle();
        this.syncSize();
    };
    Panel.prototype.toggleExpanded = function () {
        this.setExpanded(!this.expanded);
    };
    return Panel;
}();
exports.Panel = Panel;
var OPEN_ICON = "<svg viewBox=\"0 0 100 100\" height=\"20\" fill=\"white\"><path d=\"M84.3765045,45.2316481 L77.2336539,75.2316205 L77.2336539,75.2316205 C77.1263996,75.6820886 76.7239081,76 76.2608477,76 L17.8061496,76 C17.2538649,76 16.8061496,75.5522847 16.8061496,75 C16.8061496,74.9118841 16.817796,74.8241548 16.8407862,74.739091 L24.7487983,45.4794461 C24.9845522,44.607157 25.7758952,44.0012839 26.6794815,44.0012642 L83.4036764,44.0000276 L83.4036764,44.0000276 C83.9559612,44.0000156 84.4036862,44.4477211 84.4036982,45.0000058 C84.4036999,45.0780163 84.3945733,45.155759 84.3765045,45.2316481 L84.3765045,45.2316481 Z M15,24 L26.8277004,24 L26.8277004,24 C27.0616369,24 27.2881698,24.0820162 27.4678848,24.2317787 L31.799078,27.8411064 L31.799078,27.8411064 C32.697653,28.5899189 33.8303175,29 35,29 L75,29 C75.5522847,29 76,29.4477153 76,30 L76,38 L76,38 C76,38.5522847 75.5522847,39 75,39 L25.3280454,39 L25.3280454,39 C23.0690391,39 21.0906235,40.5146929 20.5012284,42.6954549 L14.7844016,63.8477139 L14.7844016,63.8477139 C14.7267632,64.0609761 14.5071549,64.1871341 14.2938927,64.1294957 C14.1194254,64.0823423 13.9982484,63.9240598 13.9982563,63.7433327 L13.9999561,25 L14,25 C14.0000242,24.4477324 14.4477324,24.0000439 15,24.0000439 L15,24 Z\"/></svg>";
var SceneSelect = /** @class */function (_super) {
    __extends(SceneSelect, _super);
    function SceneSelect(viewer) {
        var _this = _super.call(this) || this;
        _this.viewer = viewer;
        _this.sceneGroups = [];
        _this.sceneDescs = [];
        _this.setTitle(OPEN_ICON, 'Scenes');
        _this.sceneGroupList = new SingleSelect();
        _this.contents.appendChild(_this.sceneGroupList.elem);
        _this.sceneDescList = new SingleSelect();
        _this.sceneDescList.elem.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
        _this.sceneDescList.elem.style.width = '400px';
        _this.extraRack.appendChild(_this.sceneDescList.elem);
        _this.sceneGroupList.onselectionchange = function (i) {
            _this.selectSceneGroup(i);
        };
        _this.sceneDescList.onselectionchange = function (i) {
            _this.selectSceneDesc(i);
        };
        return _this;
    }
    SceneSelect.prototype.setProgressable = function (p) {
        var _this = this;
        this.setLoadProgress(p.progress);
        p.onProgress = function () {
            _this.setLoadProgress(p.progress);
        };
    };
    SceneSelect.prototype.setCurrentDesc = function (sceneGroup, sceneDesc) {
        this.selectedSceneGroup = sceneGroup;
        this.currentSceneGroup = sceneGroup;
        this.currentSceneDesc = sceneDesc;
        this.syncSceneDescs();
    };
    SceneSelect.prototype.setSceneGroups = function (sceneGroups) {
        this.sceneGroups = sceneGroups;
        var strings = this.sceneGroups.filter(function (g) {
            return g.sceneDescs.length > 0;
        }).map(function (g) {
            return g.name;
        });
        this.sceneGroupList.setStrings(strings);
        this.syncSceneDescs();
    };
    SceneSelect.prototype.setLoadProgress = function (pct) {
        this.loadProgress = pct;
        this.syncFlairs();
        this.syncHeaderStyle();
    };
    SceneSelect.prototype.selectSceneDesc = function (i) {
        this.onscenedescselected(this.selectedSceneGroup, this.sceneDescs[i]);
    };
    SceneSelect.prototype.getLoadingGradient = function () {
        var pct = Math.round(this.loadProgress * 100) + "%";
        return "linear-gradient(to right, " + HIGHLIGHT_COLOR + " " + pct + ", transparent " + pct + ")";
    };
    SceneSelect.prototype.syncHeaderStyle = function () {
        _super.prototype.syncHeaderStyle.call(this);
        setElementHighlighted(this.header, this.expanded);
        if (this.expanded) this.header.style.background = HIGHLIGHT_COLOR;else this.header.style.background = this.getLoadingGradient();
    };
    SceneSelect.prototype.syncFlairs = function () {
        var selectedGroupIndex = this.sceneGroups.indexOf(this.selectedSceneGroup);
        var flairs = [{ index: selectedGroupIndex, background: HIGHLIGHT_COLOR, color: 'black' }];
        var currentGroupIndex = this.sceneGroups.indexOf(this.currentSceneGroup);
        if (currentGroupIndex >= 0) flairs.push({ index: currentGroupIndex, background: '#666' });
        this.sceneGroupList.setFlairs(flairs);
        var selectedDescIndex = this.sceneDescs.indexOf(this.currentSceneDesc);
        if (selectedDescIndex >= 0) {
            var loadingGradient = this.getLoadingGradient();
            var textColor = this.loadProgress > 0.5 ? 'black' : undefined;
            this.sceneDescList.setFlairs([{ index: selectedDescIndex, background: loadingGradient, color: textColor }]);
        }
    };
    SceneSelect.prototype.selectSceneGroup = function (i) {
        var sceneGroup = this.sceneGroups[i];
        this.selectedSceneGroup = sceneGroup;
        this.syncSceneDescs();
    };
    SceneSelect.prototype.syncSceneDescs = function () {
        if (this.selectedSceneGroup) this.setSceneDescs(this.selectedSceneGroup.sceneDescs);else if (this.currentSceneGroup) this.setSceneDescs(this.currentSceneGroup.sceneDescs);else this.setSceneDescs([]);
    };
    SceneSelect.prototype.setSceneDescs = function (sceneDescs) {
        this.sceneDescs = sceneDescs;
        var strings = sceneDescs.map(function (desc) {
            return desc.name;
        });
        this.sceneDescList.setStrings(strings);
        this.syncFlairs();
    };
    return SceneSelect;
}(Panel);
function cloneCanvas(dst, src) {
    dst.width = src.width;
    dst.height = src.height;
    dst.title = src.title;
    var ctx = dst.getContext('2d');
    ctx.drawImage(src, 0, 0);
}
var CHECKERBOARD_IMAGE = 'url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAYAAACNMs+9AAAAGElEQVQYlWNgYGCQwoKxgqGgcJA5h3yFAAs8BRWVSwooAAAAAElFTkSuQmCC")';
var TEXTURES_ICON = "<svg viewBox=\"0 0 512 512\" height=\"20\" fill=\"white\"><path d=\"M143.5,143.5v300h300v-300H143.5z M274.8,237.2c10.3,0,18.7,8.4,18.7,18.9c0,10.3-8.4,18.7-18.7,18.7   c-10.3,0-18.7-8.4-18.7-18.7C256,245.6,264.4,237.2,274.8,237.2z M406,406H181v-56.2l56.2-56.1l37.5,37.3l75-74.8l56.2,56.1V406z\"/><polygon points=\"387.2,68.6 68.5,68.6 68.5,368.5 106,368.5 106,106 387.2,106\"/></svg>";
var TextureViewer = /** @class */function (_super) {
    __extends(TextureViewer, _super);
    function TextureViewer() {
        var _this = _super.call(this) || this;
        _this.textureList = [];
        _this.setTitle(TEXTURES_ICON, 'Textures');
        _this.extraRack.style.pointerEvents = 'none';
        _this.scrollList = new SingleSelect();
        _this.scrollList.elem.style.height = "200px";
        _this.scrollList.elem.style.overflow = 'auto';
        _this.scrollList.onselectionchange = function (i) {
            _this.selectTexture(i);
        };
        _this.contents.appendChild(_this.scrollList.elem);
        _this.surfaceView = document.createElement('div');
        _this.surfaceView.style.width = '100%';
        _this.surfaceView.style.height = '200px';
        // TODO(jstpierre): Explicit icons.
        _this.surfaceView.onmouseover = function () {
            // Checkerboard
            _this.surfaceView.style.backgroundColor = 'white';
            _this.surfaceView.style.backgroundImage = CHECKERBOARD_IMAGE;
        };
        _this.surfaceView.onmouseout = function () {
            _this.surfaceView.style.backgroundColor = 'black';
            _this.surfaceView.style.backgroundImage = '';
        };
        _this.surfaceView.onmouseout(null);
        _this.contents.appendChild(_this.surfaceView);
        _this.properties = document.createElement('div');
        _this.contents.appendChild(_this.properties);
        _this.fullSurfaceView = document.createElement('div');
        _this.fullSurfaceView.style.backgroundColor = 'rgba(0, 0, 0, 0.2)';
        _this.fullSurfaceView.style.padding = '20px';
        _this.extraRack.appendChild(_this.fullSurfaceView);
        return _this;
    }
    TextureViewer.prototype.showInSurfaceView = function (surface) {
        this.surfaceView.innerHTML = '';
        surface.style.width = '100%';
        surface.style.height = '100%';
        surface.style.objectFit = 'scale-down';
        this.surfaceView.appendChild(surface);
    };
    TextureViewer.prototype.showInFullSurfaceView = function (surfaces) {
        var e_1, _a;
        this.fullSurfaceView.innerHTML = '';
        try {
            for (var surfaces_1 = __values(surfaces), surfaces_1_1 = surfaces_1.next(); !surfaces_1_1.done; surfaces_1_1 = surfaces_1.next()) {
                var surface = surfaces_1_1.value;
                var newCanvas = document.createElement('canvas');
                cloneCanvas(newCanvas, surface);
                newCanvas.style.display = 'block';
                newCanvas.style.backgroundColor = 'white';
                newCanvas.style.backgroundImage = CHECKERBOARD_IMAGE;
                this.fullSurfaceView.appendChild(newCanvas);
            }
        } catch (e_1_1) {
            e_1 = { error: e_1_1 };
        } finally {
            try {
                if (surfaces_1_1 && !surfaces_1_1.done && (_a = surfaces_1.return)) _a.call(surfaces_1);
            } finally {
                if (e_1) throw e_1.error;
            }
        }
    };
    TextureViewer.prototype.selectTexture = function (i) {
        var texture = this.textureList[i];
        this.scrollList.setHighlighted(i);
        var properties = new Map();
        properties.set('Name', texture.name);
        properties.set('Mipmaps', '' + texture.surfaces.length);
        properties.set('Width', '' + texture.surfaces[0].width);
        properties.set('Height', '' + texture.surfaces[0].height);
        if (texture.extraInfo) {
            texture.extraInfo.forEach(function (value, key) {
                return properties.set(key, value);
            });
        }
        this.properties.innerHTML = "<div style=\"display: grid; grid-template-columns: 1fr 1fr\"></div>";
        var div = this.properties.firstElementChild;
        properties.forEach(function (value, name) {
            var nameSpan = document.createElement('span');
            nameSpan.textContent = name;
            div.appendChild(nameSpan);
            var valueSpan = document.createElement('span');
            valueSpan.style.textAlign = 'right';
            valueSpan.textContent = value;
            div.appendChild(valueSpan);
        });
        this.showInSurfaceView(texture.surfaces[0]);
        this.showInFullSurfaceView(texture.surfaces);
    };
    TextureViewer.prototype.setTextureList = function (textures) {
        this.setVisible(textures.length > 0);
        if (textures.length === 0) return;
        var strings = textures.map(function (texture) {
            return texture.name;
        });
        this.scrollList.setStrings(strings);
        this.textureList = textures;
    };
    return TextureViewer;
}(Panel);
exports.TextureViewer = TextureViewer;
var FRUSTUM_ICON = "<svg viewBox=\"0 0 100 100\" height=\"20\" fill=\"white\"><polygon points=\"48.2573,19.8589 33.8981,15.0724 5,67.8384 48.2573,90.3684\" /><polygon points=\"51.5652,19.8738 51.5652,90.3734 95,67.8392 65.9366,15.2701\" /><polygon points=\"61.3189,13.2756 49.9911,9.6265 38.5411,13.1331 49.9213,16.9268\" /></svg>";
var ViewerSettings = /** @class */function (_super) {
    __extends(ViewerSettings, _super);
    function ViewerSettings(viewer) {
        var _this = _super.call(this) || this;
        _this.viewer = viewer;
        _this.setTitle(FRUSTUM_ICON, 'Viewer Settings');
        // TODO(jstpierre): make css not leak
        _this.contents.innerHTML = "\n<style>\n.Slider {\n    -webkit-appearance: none;\n    width: 100%;\n    height: 24px;\n    margin: 0;\n}\n.Slider::-moz-range-thumb {\n    width: 16px;\n    height: 24px;\n    cursor: pointer;\n    background: " + HIGHLIGHT_COLOR + ";\n    border-radius: 0;\n    border: none;\n}\n.Slider::-webkit-slider-thumb {\n    width: 16px;\n    height: 24px;\n    cursor: pointer;\n    background: " + HIGHLIGHT_COLOR + ";\n    border-radius: 0;\n    border: none;\n}\n.Slider::-moz-range-track {\n    height: 24px;\n    cursor: pointer;\n    background: #444;\n}\n.Slider::-webkit-slider-runnable-track {\n    height: 24px;\n    cursor: pointer;\n    background: #444;\n}\n.Slider::-moz-range-progress {\n    height: 24px;\n    cursor: pointer;\n    background: #aaa;\n}\n.SettingsHeader, .CameraControllerWASD, .CameraControllerOrbit {\n    text-align: center;\n    font-weight: bold;\n    line-height: 24px;\n}\n.CameraControllerWASD, .CameraControllerOrbit {\n    background: #444;\n    line-height: 32px;\n    cursor: pointer;\n}\n</style>\n<div class=\"SettingsHeader\">Field of View</div>\n<div><input class=\"Slider FoVSlider\" type=\"range\" min=\"1\" max=\"100\"></div>\n<div class=\"SettingsHeader\">Camera Controller</div>\n<div style=\"display: grid; grid-template-columns: 1fr 1fr;\">\n<div class=\"CameraControllerWASD\">WASD</div><div class=\"CameraControllerOrbit\">Orbit</div>\n</div>\n";
        _this.fovSlider = _this.contents.querySelector('.FoVSlider');
        _this.fovSlider.oninput = _this.onFovSliderChange.bind(_this);
        _this.cameraControllerWASD = _this.contents.querySelector('.CameraControllerWASD');
        _this.cameraControllerWASD.onclick = function () {
            _this.setCameraControllerClass(Camera_1.FPSCameraController);
        };
        _this.cameraControllerOrbit = _this.contents.querySelector('.CameraControllerOrbit');
        _this.cameraControllerOrbit.onclick = function () {
            _this.setCameraControllerClass(Camera_1.OrbitCameraController);
        };
        return _this;
    }
    ViewerSettings.prototype._getSliderT = function (slider) {
        return (+slider.value - +slider.min) / (+slider.max - +slider.min);
    };
    ViewerSettings.prototype.onFovSliderChange = function (e) {
        var slider = e.target;
        var value = this._getSliderT(slider);
        this.viewer.renderState.fov = value * (Math.PI * 0.995);
    };
    ViewerSettings.prototype.setCameraControllerClass = function (cameraControllerClass) {
        this.viewer.setCameraController(new cameraControllerClass());
        this.cameraControllerSelected(cameraControllerClass);
    };
    ViewerSettings.prototype.cameraControllerSelected = function (cameraControllerClass) {
        setElementHighlighted(this.cameraControllerWASD, cameraControllerClass === Camera_1.FPSCameraController);
        setElementHighlighted(this.cameraControllerOrbit, cameraControllerClass === Camera_1.OrbitCameraController);
    };
    return ViewerSettings;
}(Panel);
var ABOUT_ICON = "\n<svg viewBox=\"0 0 100 100\" height=\"16\" fill=\"white\"><path d=\"M50,1.1C23,1.1,1.1,23,1.1,50S23,98.9,50,98.9C77,98.9,98.9,77,98.9,50S77,1.1,50,1.1z M55.3,77.7c0,1.7-1.4,3.1-3.1,3.1  h-7.9c-1.7,0-3.1-1.4-3.1-3.1v-5.1c0-1.7,1.4-3.1,3.1-3.1h7.9c1.7,0,3.1,1.4,3.1,3.1V77.7z M67.8,47.3c-2.1,2.9-4.7,5.2-7.9,6.9  c-1.8,1.2-3,2.4-3.6,3.8c-0.4,0.9-0.7,2.1-0.9,3.5c-0.1,1.1-1.1,1.9-2.2,1.9h-9.7c-1.3,0-2.3-1.1-2.2-2.3c0.2-2.7,0.9-4.8,2-6.4  c1.4-1.9,3.9-4.2,7.5-6.7c1.9-1.2,3.3-2.6,4.4-4.3c1.1-1.7,1.6-3.7,1.6-6c0-2.3-0.6-4.2-1.9-5.6c-1.3-1.4-3-2.1-5.3-2.1  c-1.9,0-3.4,0.6-4.7,1.7c-0.8,0.7-1.3,1.6-1.6,2.8c-0.4,1.4-1.7,2.3-3.2,2.3l-9-0.2c-1.1,0-2-1-1.9-2.1c0.3-4.8,2.2-8.4,5.5-11  c3.8-2.9,8.7-4.4,14.9-4.4c6.6,0,11.8,1.7,15.6,5c3.8,3.3,5.7,7.8,5.7,13.5C70.9,41.2,69.8,44.4,67.8,47.3z\"/></svg>";
var About = /** @class */function (_super) {
    __extends(About, _super);
    function About() {
        var _this = _super.call(this) || this;
        _this.setTitle(ABOUT_ICON, 'About');
        _this.contents.innerHTML = "\n<div id=\"About\">\n<style>\n#About {\n    padding: 12px;\n    line-height: 1.2;\n}\n#About a {\n    color: white;\n}\n#About li span {\n    color: #aaa;\n}\n#About h2 {\n    vertical-align: middle;\n    font-size: 2em;\n    text-align: center;\n    margin: 0px;\n}\n</style>\n\n<h2><img style=\"vertical-align: middle;\" src=\"logo.png\">MODEL VIEWER</h2>\n\n<p> <strong>CLICK AND DRAG</strong> to look around and use <strong>WASD</strong> to move the camera </p>\n<p> Hold <strong>SHIFT</strong> to go faster, and use <strong>MOUSE WHEEL</strong> to go faster than that.\n<strong>B</strong> resets the camera, and <strong>Z</strong> toggles the UI. </p>\n\n<p><strong>CODE PRIMARILY WRITTEN</strong> by <a href=\"https://github.com/magcius\">Jasper</a></p>\n\n<p><strong>MODELS</strong> \xA9 Nintendo, SEGA, Retro Studios, FROM Software, Konami</p>\n\n<p><strong>CODE HELP AND FRIENDSHIP</strong> from\n<a href=\"https://twitter.com/beholdnec\">N.E.C.</a>,\n<a href=\"https://twitter.com/LordNed\">LordNed</a>,\n<a href=\"https://twitter.com/SageOfMirrors\">SageOfMirrors</a>,\n<a href=\"https://github.com/blank63\">blank63</a>,\n<a href=\"https://twitter.com/StapleButter\">StapleButter</a>,\n<a href=\"https://twitter.com/xdanieldzd\">xdanieldzd</a>,\n<a href=\"https://github.com/vlad001\">vlad001</a>,\n<a href=\"https://twitter.com/Jewelots_\">Jewel</a>,\n<a href=\"https://twitter.com/instant_grat\">Instant Grat</a>,\nand <a href=\"https://twitter.com/__Aruki\">Aruki</a></p>\n\n<p><strong>ICONS</strong> from <a href=\"https://thenounproject.com/\">The Noun Project</a>, used under Creative Commons CC-BY:</p>\n<ul>\n<li> Truncated Pyramid <span>by</span> Bohdan Burmich\n<li> Images <span>by</span> Creative Stall\n<li> Help <span>by</span> Gregor Cresnar\n<li> Open <span>by</span> Landan Lloyd\n<li> Nightshift <span>by</span> mikicon\n<li> Layer <span>by</span> Chameleon Design\n<li> Sand Clock <span>by</span> James\n</ul>\n</div>\n";
        return _this;
    }
    return About;
}(Panel);
var LAYER_ICON = "<svg viewBox=\"0 0 16 16\" height=\"20\" fill=\"white\"><g transform=\"translate(0,-1036.3622)\"><path d=\"m 8,1039.2486 -0.21875,0.125 -4.90625,2.4375 5.125,2.5625 5.125,-2.5625 L 8,1039.2486 z m -3,4.5625 -2.125,0.9688 5.125,2.5625 5.125,-2.5625 -2.09375,-0.9688 -3.03125,1.5 -1,-0.5 -0.90625,-0.4375 L 5,1043.8111 z m 0,3 -2.125,0.9688 5.125,2.5625 5.125,-2.5625 -2.09375,-0.9688 -3.03125,1.5 -1,-0.5 -0.90625,-0.4375 L 5,1046.8111 z\"/></g></svg>";
var LayerPanel = /** @class */function (_super) {
    __extends(LayerPanel, _super);
    function LayerPanel() {
        var _this = _super.call(this) || this;
        _this.setTitle(LAYER_ICON, 'Layers');
        _this.multiSelect = new MultiSelect();
        _this.multiSelect.onitemchanged = _this._onItemChanged.bind(_this);
        _this.contents.appendChild(_this.multiSelect.elem);
        return _this;
    }
    LayerPanel.prototype._onItemChanged = function (index, visible) {
        this.layers[index].setVisible(visible);
    };
    LayerPanel.prototype.syncLayerVisibility = function () {
        var isOn = this.layers.map(function (layer) {
            return layer.visible;
        });
        this.multiSelect.setItemsSelected(isOn);
    };
    LayerPanel.prototype.setLayers = function (layers) {
        this.layers = layers;
        var strings = layers.map(function (layer) {
            return layer.name;
        });
        this.multiSelect.setStrings(strings);
        this.syncLayerVisibility();
    };
    return LayerPanel;
}(Panel);
exports.LayerPanel = LayerPanel;
var UI = /** @class */function () {
    function UI(viewer) {
        this.viewer = viewer;
        this.toplevel = document.createElement('div');
        this.toplevel.style.display = 'grid';
        this.toplevel.style.gridTemplateColumns = '1fr';
        this.toplevel.style.gridGap = '20px';
        this.toplevel.style.pointerEvents = 'none';
        this.sceneSelect = new SceneSelect(viewer);
        this.textureViewer = new TextureViewer();
        this.viewerSettings = new ViewerSettings(viewer);
        this.about = new About();
        this.setScenePanels([]);
        this.elem = this.toplevel;
    }
    UI.prototype.sceneChanged = function () {
        var scene = this.viewer.scene;
        var cameraControllerClass = this.viewer.cameraController.constructor;
        // Set up UI.
        this.viewerSettings.cameraControllerSelected(cameraControllerClass);
        this.textureViewer.setTextureList(scene !== null ? scene.textures : []);
    };
    UI.prototype.setPanels = function (panels) {
        var e_2, _a;
        this.toplevel.innerHTML = '';
        try {
            for (var panels_1 = __values(panels), panels_1_1 = panels_1.next(); !panels_1_1.done; panels_1_1 = panels_1.next()) {
                var panel = panels_1_1.value;
                this.toplevel.appendChild(panel.elem);
            }
        } catch (e_2_1) {
            e_2 = { error: e_2_1 };
        } finally {
            try {
                if (panels_1_1 && !panels_1_1.done && (_a = panels_1.return)) _a.call(panels_1);
            } finally {
                if (e_2) throw e_2.error;
            }
        }
    };
    UI.prototype.setScenePanels = function (panels) {
        this.setPanels(__spread([this.sceneSelect], panels, [this.textureViewer, this.viewerSettings, this.about]));
    };
    return UI;
}();
exports.UI = UI;
},{"./util":"util.ts","./Camera":"Camera.ts"}],"gx\\gx_enum.ts":[function(require,module,exports) {
"use strict";
// GX constants. Mostly taken from libogc.

Object.defineProperty(exports, "__esModule", { value: true });
var TexFormat;
(function (TexFormat) {
    TexFormat[TexFormat["I4"] = 0] = "I4";
    TexFormat[TexFormat["I8"] = 1] = "I8";
    TexFormat[TexFormat["IA4"] = 2] = "IA4";
    TexFormat[TexFormat["IA8"] = 3] = "IA8";
    TexFormat[TexFormat["RGB565"] = 4] = "RGB565";
    TexFormat[TexFormat["RGB5A3"] = 5] = "RGB5A3";
    TexFormat[TexFormat["RGBA8"] = 6] = "RGBA8";
    TexFormat[TexFormat["C4"] = 8] = "C4";
    TexFormat[TexFormat["C8"] = 9] = "C8";
    TexFormat[TexFormat["C14X2"] = 10] = "C14X2";
    TexFormat[TexFormat["CMPR"] = 14] = "CMPR";
})(TexFormat = exports.TexFormat || (exports.TexFormat = {}));
var TexPalette;
(function (TexPalette) {
    TexPalette[TexPalette["IA8"] = 0] = "IA8";
    TexPalette[TexPalette["RGB565"] = 1] = "RGB565";
    TexPalette[TexPalette["RGB5A3"] = 2] = "RGB5A3";
})(TexPalette = exports.TexPalette || (exports.TexPalette = {}));
var TexFilter;
(function (TexFilter) {
    TexFilter[TexFilter["NEAR"] = 0] = "NEAR";
    TexFilter[TexFilter["LINEAR"] = 1] = "LINEAR";
    TexFilter[TexFilter["NEAR_MIP_NEAR"] = 2] = "NEAR_MIP_NEAR";
    TexFilter[TexFilter["LIN_MIP_NEAR"] = 3] = "LIN_MIP_NEAR";
    TexFilter[TexFilter["NEAR_MIP_LIN"] = 4] = "NEAR_MIP_LIN";
    TexFilter[TexFilter["LIN_MIP_LIN"] = 5] = "LIN_MIP_LIN";
})(TexFilter = exports.TexFilter || (exports.TexFilter = {}));
var Command;
(function (Command) {
    Command[Command["NOOP"] = 0] = "NOOP";
    Command[Command["DRAW_QUADS"] = 128] = "DRAW_QUADS";
    // Early code for GX_DRAW_QUADS? Seen in Luigi's Mansion.
    Command[Command["DRAW_QUADS_2"] = 136] = "DRAW_QUADS_2";
    Command[Command["DRAW_TRIANGLES"] = 144] = "DRAW_TRIANGLES";
    Command[Command["DRAW_TRIANGLE_STRIP"] = 152] = "DRAW_TRIANGLE_STRIP";
    Command[Command["DRAW_TRIANGLE_FAN"] = 160] = "DRAW_TRIANGLE_FAN";
    Command[Command["DRAW_LINES"] = 168] = "DRAW_LINES";
    Command[Command["DRAW_LINE_STRIP"] = 176] = "DRAW_LINE_STRIP";
    Command[Command["DRAW_POINTS"] = 184] = "DRAW_POINTS";
    Command[Command["LOAD_BP_REG"] = 97] = "LOAD_BP_REG";
    Command[Command["LOAD_CP_REG"] = 8] = "LOAD_CP_REG";
    Command[Command["LOAD_XF_REG"] = 16] = "LOAD_XF_REG";
})(Command = exports.Command || (exports.Command = {}));
var VertexAttribute;
(function (VertexAttribute) {
    VertexAttribute[VertexAttribute["PNMTXIDX"] = 0] = "PNMTXIDX";
    VertexAttribute[VertexAttribute["TEX0MTXIDX"] = 1] = "TEX0MTXIDX";
    VertexAttribute[VertexAttribute["TEX1MTXIDX"] = 2] = "TEX1MTXIDX";
    VertexAttribute[VertexAttribute["TEX2MTXIDX"] = 3] = "TEX2MTXIDX";
    VertexAttribute[VertexAttribute["TEX3MTXIDX"] = 4] = "TEX3MTXIDX";
    VertexAttribute[VertexAttribute["TEX4MTXIDX"] = 5] = "TEX4MTXIDX";
    VertexAttribute[VertexAttribute["TEX5MTXIDX"] = 6] = "TEX5MTXIDX";
    VertexAttribute[VertexAttribute["TEX6MTXIDX"] = 7] = "TEX6MTXIDX";
    VertexAttribute[VertexAttribute["TEX7MTXIDX"] = 8] = "TEX7MTXIDX";
    VertexAttribute[VertexAttribute["POS"] = 9] = "POS";
    VertexAttribute[VertexAttribute["NRM"] = 10] = "NRM";
    VertexAttribute[VertexAttribute["CLR0"] = 11] = "CLR0";
    VertexAttribute[VertexAttribute["CLR1"] = 12] = "CLR1";
    VertexAttribute[VertexAttribute["TEX0"] = 13] = "TEX0";
    VertexAttribute[VertexAttribute["TEX1"] = 14] = "TEX1";
    VertexAttribute[VertexAttribute["TEX2"] = 15] = "TEX2";
    VertexAttribute[VertexAttribute["TEX3"] = 16] = "TEX3";
    VertexAttribute[VertexAttribute["TEX4"] = 17] = "TEX4";
    VertexAttribute[VertexAttribute["TEX5"] = 18] = "TEX5";
    VertexAttribute[VertexAttribute["TEX6"] = 19] = "TEX6";
    VertexAttribute[VertexAttribute["TEX7"] = 20] = "TEX7";
    VertexAttribute[VertexAttribute["MAX"] = 20] = "MAX";
    // NBT is an "API convenience" and practically shouldn't exist...
    VertexAttribute[VertexAttribute["NBT"] = 25] = "NBT";
    VertexAttribute[VertexAttribute["NULL"] = 255] = "NULL";
})(VertexAttribute = exports.VertexAttribute || (exports.VertexAttribute = {}));
var CompCnt;
(function (CompCnt) {
    // Position
    CompCnt[CompCnt["POS_XY"] = 0] = "POS_XY";
    CompCnt[CompCnt["POS_XYZ"] = 1] = "POS_XYZ";
    // Normal
    CompCnt[CompCnt["NRM_XYZ"] = 0] = "NRM_XYZ";
    CompCnt[CompCnt["NRM_NBT"] = 1] = "NRM_NBT";
    CompCnt[CompCnt["NRM_NBT3"] = 2] = "NRM_NBT3";
    // Color
    CompCnt[CompCnt["CLR_RGB"] = 0] = "CLR_RGB";
    CompCnt[CompCnt["CLR_RGBA"] = 1] = "CLR_RGBA";
    // TexCoord
    CompCnt[CompCnt["TEX_S"] = 0] = "TEX_S";
    CompCnt[CompCnt["TEX_ST"] = 1] = "TEX_ST";
})(CompCnt = exports.CompCnt || (exports.CompCnt = {}));
var CompType;
(function (CompType) {
    CompType[CompType["U8"] = 0] = "U8";
    CompType[CompType["S8"] = 1] = "S8";
    CompType[CompType["U16"] = 2] = "U16";
    CompType[CompType["S16"] = 3] = "S16";
    CompType[CompType["F32"] = 4] = "F32";
    CompType[CompType["RGBA8"] = 5] = "RGBA8";
})(CompType = exports.CompType || (exports.CompType = {}));
var CompareType;
(function (CompareType) {
    CompareType[CompareType["NEVER"] = 0] = "NEVER";
    CompareType[CompareType["LESS"] = 1] = "LESS";
    CompareType[CompareType["EQUAL"] = 2] = "EQUAL";
    CompareType[CompareType["LEQUAL"] = 3] = "LEQUAL";
    CompareType[CompareType["GREATER"] = 4] = "GREATER";
    CompareType[CompareType["NEQUAL"] = 5] = "NEQUAL";
    CompareType[CompareType["GEQUAL"] = 6] = "GEQUAL";
    CompareType[CompareType["ALWAYS"] = 7] = "ALWAYS";
})(CompareType = exports.CompareType || (exports.CompareType = {}));
var AlphaOp;
(function (AlphaOp) {
    AlphaOp[AlphaOp["AND"] = 0] = "AND";
    AlphaOp[AlphaOp["OR"] = 1] = "OR";
    AlphaOp[AlphaOp["XOR"] = 2] = "XOR";
    AlphaOp[AlphaOp["XNOR"] = 3] = "XNOR";
})(AlphaOp = exports.AlphaOp || (exports.AlphaOp = {}));
var CullMode;
(function (CullMode) {
    CullMode[CullMode["NONE"] = 0] = "NONE";
    CullMode[CullMode["FRONT"] = 1] = "FRONT";
    CullMode[CullMode["BACK"] = 2] = "BACK";
    CullMode[CullMode["ALL"] = 3] = "ALL";
})(CullMode = exports.CullMode || (exports.CullMode = {}));
var BlendMode;
(function (BlendMode) {
    BlendMode[BlendMode["NONE"] = 0] = "NONE";
    BlendMode[BlendMode["BLEND"] = 1] = "BLEND";
    BlendMode[BlendMode["LOGIC"] = 2] = "LOGIC";
    BlendMode[BlendMode["SUBTRACT"] = 3] = "SUBTRACT";
})(BlendMode = exports.BlendMode || (exports.BlendMode = {}));
var BlendFactor;
(function (BlendFactor) {
    BlendFactor[BlendFactor["ZERO"] = 0] = "ZERO";
    BlendFactor[BlendFactor["ONE"] = 1] = "ONE";
    BlendFactor[BlendFactor["SRCCLR"] = 2] = "SRCCLR";
    BlendFactor[BlendFactor["INVSRCCLR"] = 3] = "INVSRCCLR";
    BlendFactor[BlendFactor["SRCALPHA"] = 4] = "SRCALPHA";
    BlendFactor[BlendFactor["INVSRCALPHA"] = 5] = "INVSRCALPHA";
    BlendFactor[BlendFactor["DSTALPHA"] = 6] = "DSTALPHA";
    BlendFactor[BlendFactor["INVDSTALPHA"] = 7] = "INVDSTALPHA";
})(BlendFactor = exports.BlendFactor || (exports.BlendFactor = {}));
var LogicOp;
(function (LogicOp) {
    LogicOp[LogicOp["CLEAR"] = 0] = "CLEAR";
    LogicOp[LogicOp["AND"] = 1] = "AND";
    LogicOp[LogicOp["REVAND"] = 2] = "REVAND";
    LogicOp[LogicOp["COPY"] = 3] = "COPY";
    LogicOp[LogicOp["INVAND"] = 4] = "INVAND";
    LogicOp[LogicOp["NOOP"] = 5] = "NOOP";
    LogicOp[LogicOp["XOR"] = 6] = "XOR";
    LogicOp[LogicOp["OR"] = 7] = "OR";
    LogicOp[LogicOp["NOR"] = 8] = "NOR";
    LogicOp[LogicOp["EQUIV"] = 9] = "EQUIV";
    LogicOp[LogicOp["INV"] = 10] = "INV";
    LogicOp[LogicOp["REVOR"] = 11] = "REVOR";
    LogicOp[LogicOp["INVCOPY"] = 12] = "INVCOPY";
    LogicOp[LogicOp["INVOR"] = 13] = "INVOR";
    LogicOp[LogicOp["NAND"] = 14] = "NAND";
    LogicOp[LogicOp["SET"] = 15] = "SET";
})(LogicOp = exports.LogicOp || (exports.LogicOp = {}));
var TevOp;
(function (TevOp) {
    TevOp[TevOp["ADD"] = 0] = "ADD";
    TevOp[TevOp["SUB"] = 1] = "SUB";
    TevOp[TevOp["COMP_R8_GT"] = 8] = "COMP_R8_GT";
    TevOp[TevOp["COMP_R8_EQ"] = 9] = "COMP_R8_EQ";
    TevOp[TevOp["COMP_GR16_GT"] = 10] = "COMP_GR16_GT";
    TevOp[TevOp["COMP_GR16_EQ"] = 11] = "COMP_GR16_EQ";
    TevOp[TevOp["COMP_BGR24_GT"] = 12] = "COMP_BGR24_GT";
    TevOp[TevOp["COMP_BGR24_EQ"] = 13] = "COMP_BGR24_EQ";
    TevOp[TevOp["COMP_RGB8_GT"] = 14] = "COMP_RGB8_GT";
    TevOp[TevOp["COMP_RGB8_EQ"] = 15] = "COMP_RGB8_EQ";
})(TevOp = exports.TevOp || (exports.TevOp = {}));
var TevBias;
(function (TevBias) {
    TevBias[TevBias["ZERO"] = 0] = "ZERO";
    TevBias[TevBias["ADDHALF"] = 1] = "ADDHALF";
    TevBias[TevBias["SUBHALF"] = 2] = "SUBHALF";
    // Used to denote the compare ops to the HW.
    TevBias[TevBias["$HWB_COMPARE"] = 3] = "$HWB_COMPARE";
})(TevBias = exports.TevBias || (exports.TevBias = {}));
var TevScale;
(function (TevScale) {
    TevScale[TevScale["SCALE_1"] = 0] = "SCALE_1";
    TevScale[TevScale["SCALE_2"] = 1] = "SCALE_2";
    TevScale[TevScale["SCALE_4"] = 2] = "SCALE_4";
    TevScale[TevScale["DIVIDE_2"] = 3] = "DIVIDE_2";
    // Used to denote the width of the compare op.
    TevScale[TevScale["$HWB_R8"] = 0] = "$HWB_R8";
    TevScale[TevScale["$HWB_GR16"] = 1] = "$HWB_GR16";
    TevScale[TevScale["$HWB_BGR24"] = 2] = "$HWB_BGR24";
    TevScale[TevScale["$HWB_RGB8"] = 3] = "$HWB_RGB8";
})(TevScale = exports.TevScale || (exports.TevScale = {}));
var CombineColorInput;
(function (CombineColorInput) {
    CombineColorInput[CombineColorInput["CPREV"] = 0] = "CPREV";
    CombineColorInput[CombineColorInput["APREV"] = 1] = "APREV";
    CombineColorInput[CombineColorInput["C0"] = 2] = "C0";
    CombineColorInput[CombineColorInput["A0"] = 3] = "A0";
    CombineColorInput[CombineColorInput["C1"] = 4] = "C1";
    CombineColorInput[CombineColorInput["A1"] = 5] = "A1";
    CombineColorInput[CombineColorInput["C2"] = 6] = "C2";
    CombineColorInput[CombineColorInput["A2"] = 7] = "A2";
    CombineColorInput[CombineColorInput["TEXC"] = 8] = "TEXC";
    CombineColorInput[CombineColorInput["TEXA"] = 9] = "TEXA";
    CombineColorInput[CombineColorInput["RASC"] = 10] = "RASC";
    CombineColorInput[CombineColorInput["RASA"] = 11] = "RASA";
    CombineColorInput[CombineColorInput["ONE"] = 12] = "ONE";
    CombineColorInput[CombineColorInput["HALF"] = 13] = "HALF";
    CombineColorInput[CombineColorInput["KONST"] = 14] = "KONST";
    CombineColorInput[CombineColorInput["ZERO"] = 15] = "ZERO";
})(CombineColorInput = exports.CombineColorInput || (exports.CombineColorInput = {}));
var CombineAlphaInput;
(function (CombineAlphaInput) {
    CombineAlphaInput[CombineAlphaInput["APREV"] = 0] = "APREV";
    CombineAlphaInput[CombineAlphaInput["A0"] = 1] = "A0";
    CombineAlphaInput[CombineAlphaInput["A1"] = 2] = "A1";
    CombineAlphaInput[CombineAlphaInput["A2"] = 3] = "A2";
    CombineAlphaInput[CombineAlphaInput["TEXA"] = 4] = "TEXA";
    CombineAlphaInput[CombineAlphaInput["RASA"] = 5] = "RASA";
    CombineAlphaInput[CombineAlphaInput["KONST"] = 6] = "KONST";
    CombineAlphaInput[CombineAlphaInput["ZERO"] = 7] = "ZERO";
})(CombineAlphaInput = exports.CombineAlphaInput || (exports.CombineAlphaInput = {}));
var KonstColorSel;
(function (KonstColorSel) {
    KonstColorSel[KonstColorSel["KCSEL_1"] = 0] = "KCSEL_1";
    KonstColorSel[KonstColorSel["KCSEL_7_8"] = 1] = "KCSEL_7_8";
    KonstColorSel[KonstColorSel["KCSEL_3_4"] = 2] = "KCSEL_3_4";
    KonstColorSel[KonstColorSel["KCSEL_5_8"] = 3] = "KCSEL_5_8";
    KonstColorSel[KonstColorSel["KCSEL_1_2"] = 4] = "KCSEL_1_2";
    KonstColorSel[KonstColorSel["KCSEL_3_8"] = 5] = "KCSEL_3_8";
    KonstColorSel[KonstColorSel["KCSEL_1_4"] = 6] = "KCSEL_1_4";
    KonstColorSel[KonstColorSel["KCSEL_1_8"] = 7] = "KCSEL_1_8";
    KonstColorSel[KonstColorSel["KCSEL_K0"] = 12] = "KCSEL_K0";
    KonstColorSel[KonstColorSel["KCSEL_K1"] = 13] = "KCSEL_K1";
    KonstColorSel[KonstColorSel["KCSEL_K2"] = 14] = "KCSEL_K2";
    KonstColorSel[KonstColorSel["KCSEL_K3"] = 15] = "KCSEL_K3";
    KonstColorSel[KonstColorSel["KCSEL_K0_R"] = 16] = "KCSEL_K0_R";
    KonstColorSel[KonstColorSel["KCSEL_K1_R"] = 17] = "KCSEL_K1_R";
    KonstColorSel[KonstColorSel["KCSEL_K2_R"] = 18] = "KCSEL_K2_R";
    KonstColorSel[KonstColorSel["KCSEL_K3_R"] = 19] = "KCSEL_K3_R";
    KonstColorSel[KonstColorSel["KCSEL_K0_G"] = 20] = "KCSEL_K0_G";
    KonstColorSel[KonstColorSel["KCSEL_K1_G"] = 21] = "KCSEL_K1_G";
    KonstColorSel[KonstColorSel["KCSEL_K2_G"] = 22] = "KCSEL_K2_G";
    KonstColorSel[KonstColorSel["KCSEL_K3_G"] = 23] = "KCSEL_K3_G";
    KonstColorSel[KonstColorSel["KCSEL_K0_B"] = 24] = "KCSEL_K0_B";
    KonstColorSel[KonstColorSel["KCSEL_K1_B"] = 25] = "KCSEL_K1_B";
    KonstColorSel[KonstColorSel["KCSEL_K2_B"] = 26] = "KCSEL_K2_B";
    KonstColorSel[KonstColorSel["KCSEL_K3_B"] = 27] = "KCSEL_K3_B";
    KonstColorSel[KonstColorSel["KCSEL_K0_A"] = 28] = "KCSEL_K0_A";
    KonstColorSel[KonstColorSel["KCSEL_K1_A"] = 29] = "KCSEL_K1_A";
    KonstColorSel[KonstColorSel["KCSEL_K2_A"] = 30] = "KCSEL_K2_A";
    KonstColorSel[KonstColorSel["KCSEL_K3_A"] = 31] = "KCSEL_K3_A";
})(KonstColorSel = exports.KonstColorSel || (exports.KonstColorSel = {}));
var KonstAlphaSel;
(function (KonstAlphaSel) {
    KonstAlphaSel[KonstAlphaSel["KASEL_1"] = 0] = "KASEL_1";
    KonstAlphaSel[KonstAlphaSel["KASEL_7_8"] = 1] = "KASEL_7_8";
    KonstAlphaSel[KonstAlphaSel["KASEL_3_4"] = 2] = "KASEL_3_4";
    KonstAlphaSel[KonstAlphaSel["KASEL_5_8"] = 3] = "KASEL_5_8";
    KonstAlphaSel[KonstAlphaSel["KASEL_1_2"] = 4] = "KASEL_1_2";
    KonstAlphaSel[KonstAlphaSel["KASEL_3_8"] = 5] = "KASEL_3_8";
    KonstAlphaSel[KonstAlphaSel["KASEL_1_4"] = 6] = "KASEL_1_4";
    KonstAlphaSel[KonstAlphaSel["KASEL_1_8"] = 7] = "KASEL_1_8";
    KonstAlphaSel[KonstAlphaSel["KASEL_K0_R"] = 16] = "KASEL_K0_R";
    KonstAlphaSel[KonstAlphaSel["KASEL_K1_R"] = 17] = "KASEL_K1_R";
    KonstAlphaSel[KonstAlphaSel["KASEL_K2_R"] = 18] = "KASEL_K2_R";
    KonstAlphaSel[KonstAlphaSel["KASEL_K3_R"] = 19] = "KASEL_K3_R";
    KonstAlphaSel[KonstAlphaSel["KASEL_K0_G"] = 20] = "KASEL_K0_G";
    KonstAlphaSel[KonstAlphaSel["KASEL_K1_G"] = 21] = "KASEL_K1_G";
    KonstAlphaSel[KonstAlphaSel["KASEL_K2_G"] = 22] = "KASEL_K2_G";
    KonstAlphaSel[KonstAlphaSel["KASEL_K3_G"] = 23] = "KASEL_K3_G";
    KonstAlphaSel[KonstAlphaSel["KASEL_K0_B"] = 24] = "KASEL_K0_B";
    KonstAlphaSel[KonstAlphaSel["KASEL_K1_B"] = 25] = "KASEL_K1_B";
    KonstAlphaSel[KonstAlphaSel["KASEL_K2_B"] = 26] = "KASEL_K2_B";
    KonstAlphaSel[KonstAlphaSel["KASEL_K3_B"] = 27] = "KASEL_K3_B";
    KonstAlphaSel[KonstAlphaSel["KASEL_K0_A"] = 28] = "KASEL_K0_A";
    KonstAlphaSel[KonstAlphaSel["KASEL_K1_A"] = 29] = "KASEL_K1_A";
    KonstAlphaSel[KonstAlphaSel["KASEL_K2_A"] = 30] = "KASEL_K2_A";
    KonstAlphaSel[KonstAlphaSel["KASEL_K3_A"] = 31] = "KASEL_K3_A";
})(KonstAlphaSel = exports.KonstAlphaSel || (exports.KonstAlphaSel = {}));
var WrapMode;
(function (WrapMode) {
    WrapMode[WrapMode["CLAMP"] = 0] = "CLAMP";
    WrapMode[WrapMode["REPEAT"] = 1] = "REPEAT";
    WrapMode[WrapMode["MIRROR"] = 2] = "MIRROR";
})(WrapMode = exports.WrapMode || (exports.WrapMode = {}));
var ColorSrc;
(function (ColorSrc) {
    ColorSrc[ColorSrc["REG"] = 0] = "REG";
    ColorSrc[ColorSrc["VTX"] = 1] = "VTX";
})(ColorSrc = exports.ColorSrc || (exports.ColorSrc = {}));
var TexGenSrc;
(function (TexGenSrc) {
    TexGenSrc[TexGenSrc["POS"] = 0] = "POS";
    TexGenSrc[TexGenSrc["NRM"] = 1] = "NRM";
    TexGenSrc[TexGenSrc["BINRM"] = 2] = "BINRM";
    TexGenSrc[TexGenSrc["TANGENT"] = 3] = "TANGENT";
    TexGenSrc[TexGenSrc["TEX0"] = 4] = "TEX0";
    TexGenSrc[TexGenSrc["TEX1"] = 5] = "TEX1";
    TexGenSrc[TexGenSrc["TEX2"] = 6] = "TEX2";
    TexGenSrc[TexGenSrc["TEX3"] = 7] = "TEX3";
    TexGenSrc[TexGenSrc["TEX4"] = 8] = "TEX4";
    TexGenSrc[TexGenSrc["TEX5"] = 9] = "TEX5";
    TexGenSrc[TexGenSrc["TEX6"] = 10] = "TEX6";
    TexGenSrc[TexGenSrc["TEX7"] = 11] = "TEX7";
    TexGenSrc[TexGenSrc["TEXCOORD0"] = 12] = "TEXCOORD0";
    TexGenSrc[TexGenSrc["TEXCOORD1"] = 13] = "TEXCOORD1";
    TexGenSrc[TexGenSrc["TEXCOORD2"] = 14] = "TEXCOORD2";
    TexGenSrc[TexGenSrc["TEXCOORD3"] = 15] = "TEXCOORD3";
    TexGenSrc[TexGenSrc["TEXCOORD4"] = 16] = "TEXCOORD4";
    TexGenSrc[TexGenSrc["TEXCOORD5"] = 17] = "TEXCOORD5";
    TexGenSrc[TexGenSrc["TEXCOORD6"] = 18] = "TEXCOORD6";
    TexGenSrc[TexGenSrc["COLOR0"] = 19] = "COLOR0";
    TexGenSrc[TexGenSrc["COLOR1"] = 20] = "COLOR1";
})(TexGenSrc = exports.TexGenSrc || (exports.TexGenSrc = {}));
var TexGenType;
(function (TexGenType) {
    TexGenType[TexGenType["MTX3x4"] = 0] = "MTX3x4";
    TexGenType[TexGenType["MTX2x4"] = 1] = "MTX2x4";
    TexGenType[TexGenType["BUMP0"] = 2] = "BUMP0";
    TexGenType[TexGenType["BUMP1"] = 3] = "BUMP1";
    TexGenType[TexGenType["BUMP2"] = 4] = "BUMP2";
    TexGenType[TexGenType["BUMP3"] = 5] = "BUMP3";
    TexGenType[TexGenType["BUMP4"] = 6] = "BUMP4";
    TexGenType[TexGenType["BUMP5"] = 7] = "BUMP5";
    TexGenType[TexGenType["BUMP6"] = 8] = "BUMP6";
    TexGenType[TexGenType["BUMP7"] = 9] = "BUMP7";
    TexGenType[TexGenType["SRTG"] = 10] = "SRTG";
})(TexGenType = exports.TexGenType || (exports.TexGenType = {}));
var PosNrmMatrix;
(function (PosNrmMatrix) {
    PosNrmMatrix[PosNrmMatrix["PNMTX0"] = 0] = "PNMTX0";
    PosNrmMatrix[PosNrmMatrix["PNMTX1"] = 3] = "PNMTX1";
    PosNrmMatrix[PosNrmMatrix["PNMTX2"] = 6] = "PNMTX2";
    PosNrmMatrix[PosNrmMatrix["PNMTX3"] = 9] = "PNMTX3";
    PosNrmMatrix[PosNrmMatrix["PNMTX4"] = 12] = "PNMTX4";
    PosNrmMatrix[PosNrmMatrix["PNMTX5"] = 15] = "PNMTX5";
    PosNrmMatrix[PosNrmMatrix["PNMTX6"] = 18] = "PNMTX6";
    PosNrmMatrix[PosNrmMatrix["PNMTX7"] = 21] = "PNMTX7";
    PosNrmMatrix[PosNrmMatrix["PNMTX8"] = 24] = "PNMTX8";
    PosNrmMatrix[PosNrmMatrix["PNMTX9"] = 27] = "PNMTX9";
})(PosNrmMatrix = exports.PosNrmMatrix || (exports.PosNrmMatrix = {}));
var TexGenMatrix;
(function (TexGenMatrix) {
    TexGenMatrix[TexGenMatrix["IDENTITY"] = 60] = "IDENTITY";
    TexGenMatrix[TexGenMatrix["TEXMTX0"] = 30] = "TEXMTX0";
    TexGenMatrix[TexGenMatrix["TEXMTX1"] = 33] = "TEXMTX1";
    TexGenMatrix[TexGenMatrix["TEXMTX2"] = 36] = "TEXMTX2";
    TexGenMatrix[TexGenMatrix["TEXMTX3"] = 39] = "TEXMTX3";
    TexGenMatrix[TexGenMatrix["TEXMTX4"] = 42] = "TEXMTX4";
    TexGenMatrix[TexGenMatrix["TEXMTX5"] = 45] = "TEXMTX5";
    TexGenMatrix[TexGenMatrix["TEXMTX6"] = 48] = "TEXMTX6";
    TexGenMatrix[TexGenMatrix["TEXMTX7"] = 51] = "TEXMTX7";
    TexGenMatrix[TexGenMatrix["TEXMTX8"] = 54] = "TEXMTX8";
    TexGenMatrix[TexGenMatrix["TEXMTX9"] = 57] = "TEXMTX9";
    /* Clever games can use PNMTX as inputs to texgen. */
    TexGenMatrix[TexGenMatrix["PNMTX0"] = 0] = "PNMTX0";
    TexGenMatrix[TexGenMatrix["PNMTX1"] = 3] = "PNMTX1";
    TexGenMatrix[TexGenMatrix["PNMTX2"] = 6] = "PNMTX2";
    TexGenMatrix[TexGenMatrix["PNMTX3"] = 9] = "PNMTX3";
    TexGenMatrix[TexGenMatrix["PNMTX4"] = 12] = "PNMTX4";
    TexGenMatrix[TexGenMatrix["PNMTX5"] = 15] = "PNMTX5";
    TexGenMatrix[TexGenMatrix["PNMTX6"] = 18] = "PNMTX6";
    TexGenMatrix[TexGenMatrix["PNMTX7"] = 21] = "PNMTX7";
    TexGenMatrix[TexGenMatrix["PNMTX8"] = 24] = "PNMTX8";
    TexGenMatrix[TexGenMatrix["PNMTX9"] = 27] = "PNMTX9";
})(TexGenMatrix = exports.TexGenMatrix || (exports.TexGenMatrix = {}));
var PostTexGenMatrix;
(function (PostTexGenMatrix) {
    PostTexGenMatrix[PostTexGenMatrix["PTTEXMTX0"] = 64] = "PTTEXMTX0";
    PostTexGenMatrix[PostTexGenMatrix["PTTEXMTX1"] = 67] = "PTTEXMTX1";
    PostTexGenMatrix[PostTexGenMatrix["PTTEXMTX2"] = 70] = "PTTEXMTX2";
    PostTexGenMatrix[PostTexGenMatrix["PTTEXMTX3"] = 73] = "PTTEXMTX3";
    PostTexGenMatrix[PostTexGenMatrix["PTTEXMTX4"] = 76] = "PTTEXMTX4";
    PostTexGenMatrix[PostTexGenMatrix["PTTEXMTX5"] = 79] = "PTTEXMTX5";
    PostTexGenMatrix[PostTexGenMatrix["PTTEXMTX6"] = 82] = "PTTEXMTX6";
    PostTexGenMatrix[PostTexGenMatrix["PTTEXMTX7"] = 85] = "PTTEXMTX7";
    PostTexGenMatrix[PostTexGenMatrix["PTTEXMTX8"] = 88] = "PTTEXMTX8";
    PostTexGenMatrix[PostTexGenMatrix["PTTEXMTX9"] = 91] = "PTTEXMTX9";
    PostTexGenMatrix[PostTexGenMatrix["PTTEXMTX10"] = 94] = "PTTEXMTX10";
    PostTexGenMatrix[PostTexGenMatrix["PTTEXMTX11"] = 97] = "PTTEXMTX11";
    PostTexGenMatrix[PostTexGenMatrix["PTTEXMTX12"] = 100] = "PTTEXMTX12";
    PostTexGenMatrix[PostTexGenMatrix["PTTEXMTX13"] = 103] = "PTTEXMTX13";
    PostTexGenMatrix[PostTexGenMatrix["PTTEXMTX14"] = 106] = "PTTEXMTX14";
    PostTexGenMatrix[PostTexGenMatrix["PTTEXMTX15"] = 109] = "PTTEXMTX15";
    PostTexGenMatrix[PostTexGenMatrix["PTTEXMTX16"] = 112] = "PTTEXMTX16";
    PostTexGenMatrix[PostTexGenMatrix["PTTEXMTX17"] = 115] = "PTTEXMTX17";
    PostTexGenMatrix[PostTexGenMatrix["PTTEXMTX18"] = 118] = "PTTEXMTX18";
    PostTexGenMatrix[PostTexGenMatrix["PTTEXMTX19"] = 121] = "PTTEXMTX19";
    PostTexGenMatrix[PostTexGenMatrix["PTIDENTITY"] = 125] = "PTIDENTITY";
})(PostTexGenMatrix = exports.PostTexGenMatrix || (exports.PostTexGenMatrix = {}));
var Register;
(function (Register) {
    Register[Register["PREV"] = 0] = "PREV";
    Register[Register["REG0"] = 1] = "REG0";
    Register[Register["REG1"] = 2] = "REG1";
    Register[Register["REG2"] = 3] = "REG2";
})(Register = exports.Register || (exports.Register = {}));
var TexCoordID;
(function (TexCoordID) {
    TexCoordID[TexCoordID["TEXCOORD0"] = 0] = "TEXCOORD0";
    TexCoordID[TexCoordID["TEXCOORD1"] = 1] = "TEXCOORD1";
    TexCoordID[TexCoordID["TEXCOORD2"] = 2] = "TEXCOORD2";
    TexCoordID[TexCoordID["TEXCOORD3"] = 3] = "TEXCOORD3";
    TexCoordID[TexCoordID["TEXCOORD4"] = 4] = "TEXCOORD4";
    TexCoordID[TexCoordID["TEXCOORD5"] = 5] = "TEXCOORD5";
    TexCoordID[TexCoordID["TEXCOORD6"] = 6] = "TEXCOORD6";
    TexCoordID[TexCoordID["TEXCOORD7"] = 7] = "TEXCOORD7";
    TexCoordID[TexCoordID["NULL"] = 255] = "NULL";
})(TexCoordID = exports.TexCoordID || (exports.TexCoordID = {}));
var ColorChannelId;
(function (ColorChannelId) {
    ColorChannelId[ColorChannelId["COLOR0"] = 0] = "COLOR0";
    ColorChannelId[ColorChannelId["COLOR1"] = 1] = "COLOR1";
    ColorChannelId[ColorChannelId["ALPHA0"] = 2] = "ALPHA0";
    ColorChannelId[ColorChannelId["ALPHA1"] = 3] = "ALPHA1";
    ColorChannelId[ColorChannelId["COLOR0A0"] = 4] = "COLOR0A0";
    ColorChannelId[ColorChannelId["COLOR1A1"] = 5] = "COLOR1A1";
    ColorChannelId[ColorChannelId["COLOR_ZERO"] = 6] = "COLOR_ZERO";
    ColorChannelId[ColorChannelId["ALPHA_BUMP"] = 7] = "ALPHA_BUMP";
    ColorChannelId[ColorChannelId["ALPHA_BUMP_N"] = 8] = "ALPHA_BUMP_N";
    ColorChannelId[ColorChannelId["COLOR_NULL"] = 255] = "COLOR_NULL";
})(ColorChannelId = exports.ColorChannelId || (exports.ColorChannelId = {}));
var RasColorChannelID;
(function (RasColorChannelID) {
    RasColorChannelID[RasColorChannelID["COLOR0A0"] = 0] = "COLOR0A0";
    RasColorChannelID[RasColorChannelID["COLOR1A1"] = 1] = "COLOR1A1";
    RasColorChannelID[RasColorChannelID["ALPHA_BUMP"] = 5] = "ALPHA_BUMP";
    RasColorChannelID[RasColorChannelID["ALPHA_BUMP_N"] = 6] = "ALPHA_BUMP_N";
    RasColorChannelID[RasColorChannelID["COLOR_ZERO"] = 7] = "COLOR_ZERO";
})(RasColorChannelID = exports.RasColorChannelID || (exports.RasColorChannelID = {}));
var VtxFmt;
(function (VtxFmt) {
    VtxFmt[VtxFmt["VTXFMT0"] = 0] = "VTXFMT0";
    VtxFmt[VtxFmt["VTXFMT1"] = 1] = "VTXFMT1";
    VtxFmt[VtxFmt["VTXFMT2"] = 2] = "VTXFMT2";
    VtxFmt[VtxFmt["VTXFMT3"] = 3] = "VTXFMT3";
    VtxFmt[VtxFmt["VTXFMT4"] = 4] = "VTXFMT4";
    VtxFmt[VtxFmt["VTXFMT5"] = 5] = "VTXFMT5";
    VtxFmt[VtxFmt["VTXFMT6"] = 6] = "VTXFMT6";
    VtxFmt[VtxFmt["VTXFMT7"] = 7] = "VTXFMT7";
})(VtxFmt = exports.VtxFmt || (exports.VtxFmt = {}));
var AttrType;
(function (AttrType) {
    AttrType[AttrType["NONE"] = 0] = "NONE";
    AttrType[AttrType["DIRECT"] = 1] = "DIRECT";
    AttrType[AttrType["INDEX8"] = 2] = "INDEX8";
    AttrType[AttrType["INDEX16"] = 3] = "INDEX16";
})(AttrType = exports.AttrType || (exports.AttrType = {}));
var TexMapID;
(function (TexMapID) {
    TexMapID[TexMapID["TEXMAP0"] = 0] = "TEXMAP0";
    TexMapID[TexMapID["TEXMAP1"] = 1] = "TEXMAP1";
    TexMapID[TexMapID["TEXMAP2"] = 2] = "TEXMAP2";
    TexMapID[TexMapID["TEXMAP3"] = 3] = "TEXMAP3";
    TexMapID[TexMapID["TEXMAP4"] = 4] = "TEXMAP4";
    TexMapID[TexMapID["TEXMAP5"] = 5] = "TEXMAP5";
    TexMapID[TexMapID["TEXMAP6"] = 6] = "TEXMAP6";
    TexMapID[TexMapID["TEXMAP7"] = 7] = "TEXMAP7";
    TexMapID[TexMapID["TEXMAP_NULL"] = 255] = "TEXMAP_NULL";
})(TexMapID = exports.TexMapID || (exports.TexMapID = {}));
var IndTexScale;
(function (IndTexScale) {
    IndTexScale[IndTexScale["_1"] = 0] = "_1";
    IndTexScale[IndTexScale["_2"] = 1] = "_2";
    IndTexScale[IndTexScale["_4"] = 2] = "_4";
    IndTexScale[IndTexScale["_8"] = 3] = "_8";
    IndTexScale[IndTexScale["_16"] = 4] = "_16";
    IndTexScale[IndTexScale["_32"] = 5] = "_32";
    IndTexScale[IndTexScale["_64"] = 6] = "_64";
    IndTexScale[IndTexScale["_128"] = 7] = "_128";
    IndTexScale[IndTexScale["_256"] = 8] = "_256";
})(IndTexScale = exports.IndTexScale || (exports.IndTexScale = {}));
var IndTexBiasSel;
(function (IndTexBiasSel) {
    IndTexBiasSel[IndTexBiasSel["NONE"] = 0] = "NONE";
    IndTexBiasSel[IndTexBiasSel["S"] = 1] = "S";
    IndTexBiasSel[IndTexBiasSel["T"] = 2] = "T";
    IndTexBiasSel[IndTexBiasSel["ST"] = 3] = "ST";
    IndTexBiasSel[IndTexBiasSel["U"] = 4] = "U";
    IndTexBiasSel[IndTexBiasSel["SU"] = 5] = "SU";
    IndTexBiasSel[IndTexBiasSel["TU"] = 6] = "TU";
    IndTexBiasSel[IndTexBiasSel["STU"] = 7] = "STU";
})(IndTexBiasSel = exports.IndTexBiasSel || (exports.IndTexBiasSel = {}));
var IndTexFormat;
(function (IndTexFormat) {
    IndTexFormat[IndTexFormat["_8"] = 0] = "_8";
    IndTexFormat[IndTexFormat["_5"] = 1] = "_5";
    IndTexFormat[IndTexFormat["_4"] = 2] = "_4";
    IndTexFormat[IndTexFormat["_3"] = 3] = "_3";
})(IndTexFormat = exports.IndTexFormat || (exports.IndTexFormat = {}));
var IndTexWrap;
(function (IndTexWrap) {
    IndTexWrap[IndTexWrap["OFF"] = 0] = "OFF";
    IndTexWrap[IndTexWrap["_256"] = 1] = "_256";
    IndTexWrap[IndTexWrap["_128"] = 2] = "_128";
    IndTexWrap[IndTexWrap["_64"] = 3] = "_64";
    IndTexWrap[IndTexWrap["_32"] = 4] = "_32";
    IndTexWrap[IndTexWrap["_16"] = 5] = "_16";
    IndTexWrap[IndTexWrap["_0"] = 6] = "_0";
})(IndTexWrap = exports.IndTexWrap || (exports.IndTexWrap = {}));
var IndTexStageID;
(function (IndTexStageID) {
    IndTexStageID[IndTexStageID["STAGE0"] = 0] = "STAGE0";
    IndTexStageID[IndTexStageID["STAGE1"] = 1] = "STAGE1";
    IndTexStageID[IndTexStageID["STAGE2"] = 2] = "STAGE2";
    IndTexStageID[IndTexStageID["STAGE3"] = 3] = "STAGE3";
})(IndTexStageID = exports.IndTexStageID || (exports.IndTexStageID = {}));
var IndTexMtxID;
(function (IndTexMtxID) {
    IndTexMtxID[IndTexMtxID["OFF"] = 0] = "OFF";
    IndTexMtxID[IndTexMtxID["_0"] = 1] = "_0";
    IndTexMtxID[IndTexMtxID["_1"] = 2] = "_1";
    IndTexMtxID[IndTexMtxID["_2"] = 3] = "_2";
    IndTexMtxID[IndTexMtxID["S0"] = 5] = "S0";
    IndTexMtxID[IndTexMtxID["S1"] = 6] = "S1";
    IndTexMtxID[IndTexMtxID["S2"] = 7] = "S2";
    IndTexMtxID[IndTexMtxID["T0"] = 9] = "T0";
    IndTexMtxID[IndTexMtxID["T1"] = 10] = "T1";
    IndTexMtxID[IndTexMtxID["T2"] = 11] = "T2";
})(IndTexMtxID = exports.IndTexMtxID || (exports.IndTexMtxID = {}));
var XFRegister;
(function (XFRegister) {
    XFRegister[XFRegister["XF_INVTXSPEC_ID"] = 4104] = "XF_INVTXSPEC_ID";
    XFRegister[XFRegister["XF_NUMCOLORS_ID"] = 4105] = "XF_NUMCOLORS_ID";
    XFRegister[XFRegister["XF_NUMTEX_ID"] = 4159] = "XF_NUMTEX_ID";
    XFRegister[XFRegister["XF_TEX0_ID"] = 4160] = "XF_TEX0_ID";
    XFRegister[XFRegister["XF_DUALTEX0_ID"] = 4176] = "XF_DUALTEX0_ID";
})(XFRegister = exports.XFRegister || (exports.XFRegister = {}));
var BPRegister;
(function (BPRegister) {
    // GEN (Graphics ENgine)
    BPRegister[BPRegister["GEN_MODE_ID"] = 0] = "GEN_MODE_ID";
    // IND (INDirect Texture Hardware)
    // SetTevIndirect
    BPRegister[BPRegister["IND_MTXA0_ID"] = 6] = "IND_MTXA0_ID";
    BPRegister[BPRegister["IND_MTXB0_ID"] = 7] = "IND_MTXB0_ID";
    BPRegister[BPRegister["IND_MTXC0_ID"] = 8] = "IND_MTXC0_ID";
    BPRegister[BPRegister["IND_CMD0_ID"] = 16] = "IND_CMD0_ID";
    // RAS1 (RASterization)
    // SetIndTexScale
    BPRegister[BPRegister["RAS1_SS0_ID"] = 37] = "RAS1_SS0_ID";
    // SetIndTexOrder
    BPRegister[BPRegister["RAS1_IREF_ID"] = 39] = "RAS1_IREF_ID";
    // SetTevOrder
    BPRegister[BPRegister["RAS1_TREF_0_ID"] = 40] = "RAS1_TREF_0_ID";
    // PE (ROP / Pixel Engine)
    // SetZMode
    BPRegister[BPRegister["PE_ZMODE_ID"] = 64] = "PE_ZMODE_ID";
    // SetBlendMode
    BPRegister[BPRegister["PE_CMODE0_ID"] = 65] = "PE_CMODE0_ID";
    // TEV (Texture EnVironments)
    // SetTev
    BPRegister[BPRegister["TEV_COLOR_ENV_0_ID"] = 192] = "TEV_COLOR_ENV_0_ID";
    BPRegister[BPRegister["TEV_ALPHA_ENV_0_ID"] = 193] = "TEV_ALPHA_ENV_0_ID";
    // SetTevColor / SetTevKColor
    BPRegister[BPRegister["TEV_REGISTERL_0_ID"] = 224] = "TEV_REGISTERL_0_ID";
    BPRegister[BPRegister["TEV_REGISTERH_0_ID"] = 225] = "TEV_REGISTERH_0_ID";
    BPRegister[BPRegister["TEV_FOG_PARAM_0_ID"] = 238] = "TEV_FOG_PARAM_0_ID";
    BPRegister[BPRegister["TEV_FOG_PARAM_1_ID"] = 239] = "TEV_FOG_PARAM_1_ID";
    BPRegister[BPRegister["TEV_FOG_PARAM_2_ID"] = 240] = "TEV_FOG_PARAM_2_ID";
    BPRegister[BPRegister["TEV_FOG_PARAM_3_ID"] = 241] = "TEV_FOG_PARAM_3_ID";
    BPRegister[BPRegister["TEV_FOG_COLOR_ID"] = 242] = "TEV_FOG_COLOR_ID";
    // SetAlphaCompare
    BPRegister[BPRegister["TEV_ALPHAFUNC_ID"] = 243] = "TEV_ALPHAFUNC_ID";
    // SetTevKColorSel
    BPRegister[BPRegister["TEV_KSEL_0_ID"] = 246] = "TEV_KSEL_0_ID";
    BPRegister[BPRegister["SS_MASK"] = 254] = "SS_MASK";
})(BPRegister = exports.BPRegister || (exports.BPRegister = {}));
var CPRegister;
(function (CPRegister) {
    CPRegister[CPRegister["MATINDEX_A_ID"] = 48] = "MATINDEX_A_ID";
    CPRegister[CPRegister["MATINDEX_B_ID"] = 64] = "MATINDEX_B_ID";
    CPRegister[CPRegister["VCD_LO_ID"] = 80] = "VCD_LO_ID";
    CPRegister[CPRegister["VCD_HI_ID"] = 96] = "VCD_HI_ID";
    CPRegister[CPRegister["VAT_A_ID"] = 112] = "VAT_A_ID";
    CPRegister[CPRegister["VAT_B_ID"] = 128] = "VAT_B_ID";
    CPRegister[CPRegister["VAT_C_ID"] = 144] = "VAT_C_ID";
})(CPRegister = exports.CPRegister || (exports.CPRegister = {}));
},{}],"gx\\gx_displaylist.ts":[function(require,module,exports) {
"use strict";
// GX Display List parsing.

var __extends = this && this.__extends || function () {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
        d.__proto__ = b;
    } || function (d, b) {
        for (var p in b) {
            if (b.hasOwnProperty(p)) d[p] = b[p];
        }
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __values = this && this.__values || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator],
        i = 0;
    if (m) return m.call(o);
    return {
        next: function next() {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
var __read = this && this.__read || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o),
        r,
        ar = [],
        e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {
            ar.push(r.value);
        }
    } catch (error) {
        e = { error: error };
    } finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
            if (e) throw e.error;
        }
    }
    return ar;
};
var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
};
var __importStar = this && this.__importStar || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) {
        if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    }result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var MemoizeCache_1 = __importDefault(require("../MemoizeCache"));
var util_1 = require("../util");
var GX = __importStar(require("./gx_enum"));
var endian_1 = require("../endian");
function getComponentSizeRaw(compType) {
    switch (compType) {
        case GX.CompType.U8:
        case GX.CompType.S8:
        case GX.CompType.RGBA8:
            return 1;
        case GX.CompType.U16:
        case GX.CompType.S16:
            return 2;
        case GX.CompType.F32:
            return 4;
    }
}
exports.getComponentSizeRaw = getComponentSizeRaw;
// PNMTXIDX, TEXnMTXIDX are special cases in GX.
function isVtxAttribMtxIdx(vtxAttrib) {
    switch (vtxAttrib) {
        case GX.VertexAttribute.PNMTXIDX:
        case GX.VertexAttribute.TEX0MTXIDX:
        case GX.VertexAttribute.TEX1MTXIDX:
        case GX.VertexAttribute.TEX2MTXIDX:
        case GX.VertexAttribute.TEX3MTXIDX:
        case GX.VertexAttribute.TEX4MTXIDX:
        case GX.VertexAttribute.TEX5MTXIDX:
        case GX.VertexAttribute.TEX6MTXIDX:
        case GX.VertexAttribute.TEX7MTXIDX:
            return true;
        default:
            return false;
    }
}
function getComponentSize(vtxAttrib, vatFormat) {
    // MTXIDX fields don't have VAT entries.
    if (isVtxAttribMtxIdx(vtxAttrib)) return 1;
    return getComponentSizeRaw(vatFormat.compType);
}
function getComponentCountRaw(vtxAttrib, compCnt) {
    switch (vtxAttrib) {
        case GX.VertexAttribute.POS:
            if (compCnt === GX.CompCnt.POS_XY) return 2;else if (compCnt === GX.CompCnt.POS_XYZ) return 3;
        case GX.VertexAttribute.NRM:
            if (compCnt === GX.CompCnt.NRM_XYZ) return 3;
            // NBT*XYZ
            else if (compCnt === GX.CompCnt.NRM_NBT) return 9;
                // Separated NBT has three components per index.
                else if (compCnt === GX.CompCnt.NRM_NBT3) return 3;
        case GX.VertexAttribute.CLR0:
        case GX.VertexAttribute.CLR1:
            if (compCnt === GX.CompCnt.CLR_RGB) return 3;else if (compCnt === GX.CompCnt.CLR_RGBA) return 4;
        case GX.VertexAttribute.TEX0:
        case GX.VertexAttribute.TEX1:
        case GX.VertexAttribute.TEX2:
        case GX.VertexAttribute.TEX3:
        case GX.VertexAttribute.TEX4:
        case GX.VertexAttribute.TEX5:
        case GX.VertexAttribute.TEX6:
        case GX.VertexAttribute.TEX7:
            if (compCnt === GX.CompCnt.TEX_S) return 1;else if (compCnt === GX.CompCnt.TEX_ST) return 2;
        case GX.VertexAttribute.NULL:
        default:
            // Shouldn't ever happen
            throw new Error("whoops");
    }
}
exports.getComponentCountRaw = getComponentCountRaw;
function getComponentCount(vtxAttrib, vatFormat) {
    // MTXIDX fields don't have VAT entries.
    if (isVtxAttribMtxIdx(vtxAttrib)) return 1;
    return getComponentCountRaw(vtxAttrib, vatFormat.compCnt);
}
function getComponentShiftRaw(compType, compShift) {
    switch (compType) {
        case GX.CompType.F32:
        case GX.CompType.RGBA8:
            return 0;
        case GX.CompType.U8:
        case GX.CompType.U16:
        case GX.CompType.S8:
        case GX.CompType.S16:
            return compShift;
    }
}
function getComponentShift(vtxAttrib, vatFormat) {
    // MTXIDX fields don't have VAT entries.
    if (isVtxAttribMtxIdx(vtxAttrib)) return 0;
    return getComponentShiftRaw(vatFormat.compType, vatFormat.compShift);
}
function getComponentType(vtxAttrib, vatFormat) {
    if (isVtxAttribMtxIdx(vtxAttrib)) return GX.CompType.U8;
    return vatFormat.compType;
}
function getIndexNumComponents(vtxAttrib, vatFormat) {
    switch (vtxAttrib) {
        case GX.VertexAttribute.NRM:
            if (vatFormat.compCnt === GX.CompCnt.NRM_NBT3) return 3;
        // Fallthrough
        default:
            return 1;
    }
}
function getAttrName(vtxAttrib) {
    switch (vtxAttrib) {
        case GX.VertexAttribute.PNMTXIDX:
            return "PNMTXIDX";
        case GX.VertexAttribute.TEX0MTXIDX:
            return "TEX0MTXIDX";
        case GX.VertexAttribute.TEX1MTXIDX:
            return "TEX1MTXIDX";
        case GX.VertexAttribute.TEX2MTXIDX:
            return "TEX2MTXIDX";
        case GX.VertexAttribute.TEX3MTXIDX:
            return "TEX3MTXIDX";
        case GX.VertexAttribute.TEX4MTXIDX:
            return "TEX4MTXIDX";
        case GX.VertexAttribute.TEX5MTXIDX:
            return "TEX5MTXIDX";
        case GX.VertexAttribute.TEX6MTXIDX:
            return "TEX6MTXIDX";
        case GX.VertexAttribute.TEX7MTXIDX:
            return "TEX7MTXIDX";
        case GX.VertexAttribute.POS:
            return "POS";
        case GX.VertexAttribute.NRM:
            return "NRM";
        case GX.VertexAttribute.CLR0:
            return "CLR0";
        case GX.VertexAttribute.CLR1:
            return "CLR1";
        case GX.VertexAttribute.TEX0:
            return "TEX0";
        case GX.VertexAttribute.TEX1:
            return "TEX1";
        case GX.VertexAttribute.TEX2:
            return "TEX2";
        case GX.VertexAttribute.TEX3:
            return "TEX3";
        case GX.VertexAttribute.TEX4:
            return "TEX4";
        case GX.VertexAttribute.TEX5:
            return "TEX5";
        case GX.VertexAttribute.TEX6:
            return "TEX6";
        case GX.VertexAttribute.TEX7:
            return "TEX7";
        default:
            throw new Error("whoops");
    }
}
// TODO(jstpierre): Make this a core utility?
var AttributeFormat;
(function (AttributeFormat) {
    AttributeFormat[AttributeFormat["U8"] = 0] = "U8";
    AttributeFormat[AttributeFormat["U16"] = 1] = "U16";
    AttributeFormat[AttributeFormat["F32"] = 2] = "F32";
})(AttributeFormat = exports.AttributeFormat || (exports.AttributeFormat = {}));
function getAttributeFormat(vtxAttrib) {
    if (isVtxAttribMtxIdx(vtxAttrib)) return AttributeFormat.U8;
    return AttributeFormat.F32;
}
function getAttributeFormatSize(attributeFormat) {
    switch (attributeFormat) {
        case AttributeFormat.U8:
            return 1;
        case AttributeFormat.U16:
            return 2;
        case AttributeFormat.F32:
            return 4;
    }
}
function translateVatLayout(vatFormat, vcd) {
    if (vatFormat === undefined) return undefined;
    var srcVertexSize = 0;
    for (var vtxAttrib = 0; vtxAttrib < vcd.length; vtxAttrib++) {
        // Describes packed vertex layout.
        var vtxAttrDesc = vcd[vtxAttrib];
        // Describes format of pointed-to data.
        var vtxAttrFmt = vatFormat[vtxAttrib];
        if (!vtxAttrDesc || vtxAttrDesc.type === GX.AttrType.NONE) continue;
        // TODO(jstpierre): Find a better way to do NBT3.
        var srcIndexComponentCount = getIndexNumComponents(vtxAttrib, vtxAttrFmt);
        // MTXIDX entries can only be DIRECT if they exist.
        if (isVtxAttribMtxIdx(vtxAttrib)) util_1.assert(vtxAttrDesc.type === GX.AttrType.DIRECT);
        switch (vtxAttrDesc.type) {
            case GX.AttrType.DIRECT:
                {
                    var srcAttrCompSize = getComponentSize(vtxAttrib, vtxAttrFmt);
                    var srcAttrCompCount = getComponentCount(vtxAttrib, vtxAttrFmt);
                    var srcAttrByteSize = srcAttrCompSize * srcAttrCompCount;
                    srcVertexSize += srcAttrByteSize;
                    break;
                }
            case GX.AttrType.INDEX8:
                srcVertexSize += 1 * srcIndexComponentCount;
                break;
            case GX.AttrType.INDEX16:
                srcVertexSize += 2 * srcIndexComponentCount;
                break;
        }
    }
    return { srcVertexSize: srcVertexSize, vatFormat: vatFormat, vcd: vcd };
}
function translateVertexLayout(vat, vcd) {
    // Create source VAT layouts.
    var vatLayouts = vat.map(function (vatFormat) {
        return translateVatLayout(vatFormat, vcd);
    });
    // Create destination vertex layout.
    var dstVertexSize = 0;
    var dstVertexAttributeLayouts = [];
    var _loop_1 = function _loop_1(vtxAttrib) {
        var vtxAttrDesc = vcd[vtxAttrib];
        if (!vtxAttrDesc || vtxAttrDesc.type === GX.AttrType.NONE) return "continue";
        var enableOutput = vtxAttrDesc.enableOutput === undefined || vtxAttrDesc.enableOutput;
        if (!enableOutput) return "continue";
        // TODO(jstpierre): Worth supporting other component types?
        var format = getAttributeFormat(vtxAttrib);
        var formatComponentSize = getAttributeFormatSize(format);
        dstVertexSize = util_1.align(dstVertexSize, formatComponentSize);
        var offset = dstVertexSize;
        // Find our maximum component count by choosing from a maximum of all the VAT formats.
        var componentCount = 0;
        vatLayouts.forEach(function (vatLayout) {
            var fmtComponentCount = getComponentCount(vtxAttrib, vatLayout.vatFormat[vtxAttrib]);
            componentCount = Math.max(componentCount, fmtComponentCount);
        });
        dstVertexSize += formatComponentSize * componentCount;
        dstVertexAttributeLayouts.push({ vtxAttrib: vtxAttrib, offset: offset, format: format, componentCount: componentCount });
    };
    for (var vtxAttrib = 0; vtxAttrib < vcd.length; vtxAttrib++) {
        _loop_1(vtxAttrib);
    }
    // Align the whole thing to our minimum required alignment (F32).
    dstVertexSize = util_1.align(dstVertexSize, 4);
    return { dstVertexSize: dstVertexSize, dstVertexAttributeLayouts: dstVertexAttributeLayouts, vatLayouts: vatLayouts };
}
function _compileVtxLoader(vat, vcd) {
    var loadedVertexLayout = translateVertexLayout(vat, vcd);
    function makeLoaderName() {
        var name = 'VtxLoader';
        // TODO(jstpierre): Re-enable this at some point. Right now it's not so easy...
        /*
        for (let vtxAttrib: GX.VertexAttribute = 0; vtxAttrib < vat.length; vtxAttrib++) {
            if (!vtxDescs[vtxAttrib] || vtxDescs[vtxAttrib].type === GX.AttrType.NONE)
                continue;
              const attrName = getAttrName(vtxAttrib);
              const compSizeSuffix = vat[vtxAttrib] ? getComponentSize(vat[vtxAttrib].compType) : '';
            const compCntSuffix = vat[vtxAttrib] ? getComponentCount(vtxAttrib, vat[vtxAttrib].compCnt) : '';
              const attrTypeSuffixes = ['', 'D', 'I8', 'I16'];
            const attrTypeSuffix = attrTypeSuffixes[vtxDescs[vtxAttrib].type];
            name += `_${attrName}$${attrTypeSuffix}$${compSizeSuffix}x${compCntSuffix}`;
        }
        */
        return name;
    }
    function compileVtxArrayViewName(vtxAttrib) {
        return "srcAttrArrayView" + vtxAttrib;
    }
    function compileVtxArrayViews() {
        var sources = [];
        var _loop_2 = function _loop_2(vtxAttrib) {
            var dstAttribLayout = loadedVertexLayout.dstVertexAttributeLayouts.find(function (layout) {
                return layout.vtxAttrib === vtxAttrib;
            });
            var outputEnabled = !!dstAttribLayout;
            if (!outputEnabled) return "continue";
            var attrType = vcd[vtxAttrib].type;
            if (attrType === GX.AttrType.INDEX16 || attrType === GX.AttrType.INDEX8) {
                var viewName = compileVtxArrayViewName(vtxAttrib);
                sources.push("const " + viewName + " = vtxArrays[" + vtxAttrib + "].buffer.createDataView(vtxArrays[" + vtxAttrib + "].offs);");
            }
        };
        for (var vtxAttrib = 0; vtxAttrib < GX.VertexAttribute.MAX; vtxAttrib++) {
            _loop_2(vtxAttrib);
        }
        return sources.join('\n');
    }
    // Loads a single vertex layout.
    function compileVatLayoutAttribute(vatLayout, vtxAttrib) {
        var vtxAttrFmt = vatLayout.vatFormat[vtxAttrib];
        var vtxAttrDesc = vatLayout.vcd[vtxAttrib];
        var dstAttribLayout = loadedVertexLayout.dstVertexAttributeLayouts.find(function (layout) {
            return layout.vtxAttrib === vtxAttrib;
        });
        if (!vtxAttrDesc || vtxAttrDesc.type === GX.AttrType.NONE) return '';
        // If we don't have a destination for the data, then don't bother outputting.
        var outputEnabled = !!dstAttribLayout;
        var srcAttrCompSize;
        var srcAttrCompCount;
        var srcAttrByteSize;
        // We only need vtxAttrFmt if we're going to read the data.
        if (vtxAttrDesc.type === GX.AttrType.DIRECT || outputEnabled) {
            srcAttrCompSize = getComponentSize(vtxAttrib, vtxAttrFmt);
            srcAttrCompCount = getComponentCount(vtxAttrib, vtxAttrFmt);
            srcAttrByteSize = srcAttrCompSize * srcAttrCompCount;
        }
        function compileShift(n) {
            // Instead of just doing `${n} >> srcAttrCompShift`, we use division
            // to get us the fractional components...
            var srcAttrCompShift = getComponentShift(vtxAttrib, vtxAttrFmt);
            var divisor = 1 << srcAttrCompShift;
            if (divisor === 1) return n;else return "(" + n + " / " + divisor + ")";
        }
        function compileReadOneComponent(viewName, attrOffset) {
            switch (getComponentType(vtxAttrib, vtxAttrFmt)) {
                case GX.CompType.F32:
                    return viewName + ".getFloat32(" + attrOffset + ")";
                case GX.CompType.RGBA8:
                    // This gets four components.
                    return "(" + viewName + ".getUint8(" + attrOffset + ") / 0xFF)";
                case GX.CompType.U8:
                    return compileShift(viewName + ".getUint8(" + attrOffset + ")");
                case GX.CompType.U16:
                    return compileShift(viewName + ".getUint16(" + attrOffset + ")");
                case GX.CompType.S8:
                    return compileShift(viewName + ".getInt8(" + attrOffset + ")");
                case GX.CompType.S16:
                    return compileShift(viewName + ".getInt16(" + attrOffset + ")");
                default:
                    throw "whoops";
            }
        }
        function compileWriteOneComponentF32(dstOffs, value) {
            var littleEndian = endian_1.getSystemEndianness() === endian_1.Endianness.LITTLE_ENDIAN;
            return "dstVertexDataView.setFloat32(" + dstOffs + ", " + value + ", " + littleEndian + ")";
        }
        function compileWriteOneComponentU8(dstOffs, value) {
            return "dstVertexDataView.setUint8(" + dstOffs + ", " + value + ")";
        }
        function compileWriteOneComponent(offs, value) {
            var dstOffs = "dstVertexDataOffs + " + offs;
            if (dstAttribLayout.format === AttributeFormat.F32) return compileWriteOneComponentF32(dstOffs, value);else if (dstAttribLayout.format === AttributeFormat.U8) return compileWriteOneComponentU8(dstOffs, value);else throw "whoops";
        }
        function compileOneAttrib(viewName, attrOffsetBase, drawCallIdxIncr) {
            var S = "";
            if (outputEnabled) {
                var dstComponentSize = getAttributeFormatSize(dstAttribLayout.format);
                for (var i = 0; i < dstAttribLayout.componentCount; i++) {
                    var dstOffs = dstAttribLayout.offset + i * dstComponentSize;
                    var srcOffs = attrOffsetBase + " + " + i * srcAttrCompSize;
                    // Fill in components not in the source with zero.
                    var value = void 0;
                    if (i < srcAttrCompCount) value = compileReadOneComponent(viewName, srcOffs);else value = "0";
                    S += "\n        " + compileWriteOneComponent(dstOffs, value) + ";";
                }
            }
            S += "\n        drawCallIdx += " + drawCallIdxIncr + ";\n";
            return S;
        }
        function compileOneIndex(viewName, readIndex, drawCallIdxIncr, uniqueSuffix) {
            if (uniqueSuffix === void 0) {
                uniqueSuffix = '';
            }
            // TODO(jstpierre): Stride.
            var attrOffsetBase = "(" + readIndex + ") * " + srcAttrByteSize;
            var arrayOffsetVarName = "arrayOffset" + vtxAttrib + uniqueSuffix;
            var S = '';
            if (outputEnabled) {
                return "const " + arrayOffsetVarName + " = " + attrOffsetBase + ";" + compileOneAttrib(viewName, arrayOffsetVarName, drawCallIdxIncr);
            } else {
                return compileOneAttrib('', '', drawCallIdxIncr);
            }
        }
        function compileAttribIndex(viewName, readIndex, drawCallIdxIncr) {
            if (vtxAttrib === GX.VertexAttribute.NRM && vtxAttrFmt.compCnt === GX.CompCnt.NRM_NBT3) {
                // Special case: NBT3.
                return "\n        // NBT Normal\n        " + compileOneIndex(viewName, readIndex + " + 0", drawCallIdxIncr, "_N") + "\n        // NBT Bitangent\n        " + compileOneIndex(viewName, readIndex + " + 3", drawCallIdxIncr, "_B") + "\n        // NBT Tangent\n        " + compileOneIndex(viewName, readIndex + " + 6", drawCallIdxIncr, "_T");
            } else {
                return "\n        // " + getAttrName(vtxAttrib) + "\n        " + compileOneIndex(viewName, readIndex, drawCallIdxIncr);
            }
        }
        switch (vtxAttrDesc.type) {
            case GX.AttrType.DIRECT:
                return compileOneAttrib("dlView", "drawCallIdx", srcAttrByteSize);
            case GX.AttrType.INDEX8:
                return compileAttribIndex(compileVtxArrayViewName(vtxAttrib), "dlView.getUint8(drawCallIdx)", 1);
            case GX.AttrType.INDEX16:
                return compileAttribIndex(compileVtxArrayViewName(vtxAttrib), "dlView.getUint16(drawCallIdx)", 2);
            default:
                throw "whoops";
        }
    }
    function compileVatFormats() {
        var e_1, _a;
        var sources = [];
        var vatLayoutSources = new Map();
        for (var i = 0; i < GX.VtxFmt.VTXFMT7; i++) {
            var vatLayout = loadedVertexLayout.vatLayouts[i];
            if (!vatLayout) continue;
            util_1.assert(vatLayout.vcd === vcd);
            var S_1 = '';
            for (var vtxAttrib = 0; vtxAttrib < GX.VertexAttribute.MAX; vtxAttrib++) {
                S_1 += compileVatLayoutAttribute(vatLayout, vtxAttrib);
            }
            vatLayoutSources.set(i, S_1);
        }
        if (vatLayoutSources.size === 0) throw "whoops";
        if (vatLayoutSources.size === 1) return vatLayoutSources.values().next().value;
        // Dynamic dispatch.
        var S = "\n        ";
        try {
            for (var _b = __values(vatLayoutSources.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {
                var _d = __read(_c.value, 2),
                    vtxFmt = _d[0],
                    vatLayoutSource = _d[1];
                S += "if (drawCall.vertexFormat === " + vtxFmt + ") {\n\n            " + vatLayoutSource + "\n\n        } else ";
            }
        } catch (e_1_1) {
            e_1 = { error: e_1_1 };
        } finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally {
                if (e_1) throw e_1.error;
            }
        }
        S += "{\n            throw new Error(\"Invalid vertex format \" + vertexFormat);\n        }";
        return S;
    }
    function compileSrcVertexSizes() {
        return JSON.stringify(loadedVertexLayout.vatLayouts.map(function (vatLayout) {
            return vatLayout && vatLayout.srcVertexSize;
        }));
    }
    var loaderName = makeLoaderName();
    var source = "\n\"use strict\";\n\nreturn function " + loaderName + "(vtxArrays, srcBuffer) {\n// Parse display list.\nconst dlView = srcBuffer.createDataView();\nconst drawCalls = [];\nconst srcVertexSizes = " + compileSrcVertexSizes() + ";\nlet totalVertexCount = 0;\nlet totalTriangleCount = 0;\nlet drawCallIdx = 0;\nwhile (true) {\n    if (drawCallIdx >= srcBuffer.byteLength)\n        break;\n    const cmd = dlView.getUint8(drawCallIdx);\n    if (cmd === 0)\n        break;\n\n    const primType = cmd & 0xF8;\n    const vertexFormat = cmd & 0x07;\n\n    const vertexCount = dlView.getUint16(drawCallIdx + 0x01);\n    drawCallIdx += 0x03;\n    const srcOffs = drawCallIdx;\n    const first = totalVertexCount;\n    totalVertexCount += vertexCount;\n\n    switch (primType) {\n    case " + GX.Command.DRAW_TRIANGLES + ":\n        totalTriangleCount += (vertexCount / 3);\n        break;\n    case " + GX.Command.DRAW_TRIANGLE_FAN + ":\n    case " + GX.Command.DRAW_TRIANGLE_STRIP + ":\n        totalTriangleCount += (vertexCount - 2);\n        break;\n    case " + GX.Command.DRAW_QUADS + ":\n    case " + GX.Command.DRAW_QUADS_2 + ":\n        totalTriangleCount += (vertexCount * 6) / 4;\n        break;\n    default:\n        throw new Error(\"Invalid data at \" + srcBuffer.byteOffset.toString(16) + \"/\" + drawCallIdx.toString(16) + \" primType \" + primType.toString(16));\n    }\n\n    drawCalls.push({ primType, vertexFormat, srcOffs, vertexCount });\n\n    // Skip over the index data.\n    drawCallIdx += srcVertexSizes[vertexFormat] * vertexCount;\n}\n\n// Now make the data.\nlet indexDataIdx = 0;\nconst dstIndexData = new Uint16Array(totalTriangleCount * 3);\nlet vertexId = 0;\n\nconst dstVertexDataSize = " + loadedVertexLayout.dstVertexSize + " * totalVertexCount;\nconst dstVertexData = new ArrayBuffer(dstVertexDataSize);\nconst dstVertexDataView = new DataView(dstVertexData);\nlet dstVertexDataOffs = 0;\n\n" + compileVtxArrayViews() + "\n\nfor (let z = 0; z < drawCalls.length; z++) {\n    const drawCall = drawCalls[z];\n\n    // Convert topology to triangles.\n    switch (drawCall.primType) {\n    case " + GX.Command.DRAW_TRIANGLES + ":\n        // Copy vertices.\n        for (let i = 0; i < drawCall.vertexCount; i++) {\n            dstIndexData[indexDataIdx++] = vertexId++;\n        }\n        break;\n    case " + GX.Command.DRAW_TRIANGLE_STRIP + ":\n        // First vertex defines original triangle.\n        for (let i = 0; i < 3; i++) {\n            dstIndexData[indexDataIdx++] = vertexId++;\n        }\n\n        for (let i = 3; i < drawCall.vertexCount; i++) {\n            dstIndexData[indexDataIdx++] = vertexId - ((i & 1) ? 1 : 2);\n            dstIndexData[indexDataIdx++] = vertexId - ((i & 1) ? 2 : 1);\n            dstIndexData[indexDataIdx++] = vertexId++;\n        }\n        break;\n    case " + GX.Command.DRAW_TRIANGLE_FAN + ":\n        // First vertex defines original triangle.\n        const firstVertex = vertexId;\n\n        for (let i = 0; i < 3; i++) {\n            dstIndexData[indexDataIdx++] = vertexId++;\n        }\n\n        for (let i = 3; i < drawCall.vertexCount; i++) {\n            dstIndexData[indexDataIdx++] = firstVertex;\n            dstIndexData[indexDataIdx++] = vertexId - 1;\n            dstIndexData[indexDataIdx++] = vertexId++;\n        }\n        break;\n    case " + GX.Command.DRAW_QUADS + ":\n    case " + GX.Command.DRAW_QUADS_2 + ":\n        // Each quad (4 vertices) is split into 2 triangles (6 vertices)\n        for (let i = 0; i < drawCall.vertexCount; i += 4) {\n            dstIndexData[indexDataIdx++] = vertexId + 0;\n            dstIndexData[indexDataIdx++] = vertexId + 1;\n            dstIndexData[indexDataIdx++] = vertexId + 2;\n\n            dstIndexData[indexDataIdx++] = vertexId + 1;\n            dstIndexData[indexDataIdx++] = vertexId + 3;\n            dstIndexData[indexDataIdx++] = vertexId + 2;\n            vertexId += 4;\n        }\n    }\n\n    let drawCallIdx = drawCall.srcOffs;\n    for (let j = 0; j < drawCall.vertexCount; j++) {\n" + compileVatFormats() + "\n        dstVertexDataOffs += " + loadedVertexLayout.dstVertexSize + ";\n    }\n}\n\nif (dstIndexData.length !== totalTriangleCount * 3)\n    throw new Error(\"Number of indexes does not match triangle count\");\n\nreturn { indexFormat: " + AttributeFormat.U16 + ", indexData: dstIndexData.buffer, packedVertexData: dstVertexData, totalVertexCount: totalVertexCount, totalTriangleCount: totalTriangleCount };\n\n};\n";
    var runVerticesGenerator = new Function(source);
    var runVertices = runVerticesGenerator();
    return { loadedVertexLayout: loadedVertexLayout, runVertices: runVertices };
}
var VtxLoaderCache = /** @class */function (_super) {
    __extends(VtxLoaderCache, _super);
    function VtxLoaderCache() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.compileVtxLoader = function (vatFormat, vcd) {
            var vat = [vatFormat];
            return _this.get({ vat: vat, vcd: vcd });
        };
        _this.compileVtxLoaderMultiVat = function (vat, vcd) {
            return _this.get({ vat: vat, vcd: vcd });
        };
        return _this;
    }
    VtxLoaderCache.prototype.make = function (key) {
        return _compileVtxLoader(key.vat, key.vcd);
    };
    VtxLoaderCache.prototype.makeKey = function (key) {
        return JSON.stringify(key);
    };
    return VtxLoaderCache;
}(MemoizeCache_1.default);
var cache = new VtxLoaderCache();
exports.compileVtxLoader = cache.compileVtxLoader;
exports.compileVtxLoaderMultiVat = cache.compileVtxLoaderMultiVat;
},{"../MemoizeCache":"MemoizeCache.ts","../util":"util.ts","./gx_enum":"gx\\gx_enum.ts","../endian":"endian.ts"}],"Color.ts":[function(require,module,exports) {
"use strict";
// Color utilities

Object.defineProperty(exports, "__esModule", { value: true });
function lerp(a, b, t) {
    return a + (b - a) * t;
}
function colorLerp(dst, k0, k1, t) {
    dst.r = lerp(k0.r, k1.r, t);
    dst.g = lerp(k0.g, k1.g, t);
    dst.b = lerp(k0.b, k1.b, t);
    dst.a = lerp(k0.a, k1.a, t);
}
exports.colorLerp = colorLerp;
function colorCopy(dst, src, a) {
    if (a === void 0) {
        a = src.a;
    }
    dst.r = src.r;
    dst.g = src.g;
    dst.b = src.b;
    dst.a = a;
}
exports.colorCopy = colorCopy;
function colorFromRGBA8(dst, n) {
    dst.r = (n >>> 24 & 0xFF) / 0xFF;
    dst.g = (n >>> 16 & 0xFF) / 0xFF;
    dst.b = (n >>> 8 & 0xFF) / 0xFF;
    dst.a = (n >>> 0 & 0xFF) / 0xFF;
}
exports.colorFromRGBA8 = colorFromRGBA8;
function colorFromARGB8(dst, n) {
    dst.a = (n >>> 24 & 0xFF) / 0xFF;
    dst.r = (n >>> 16 & 0xFF) / 0xFF;
    dst.g = (n >>> 8 & 0xFF) / 0xFF;
    dst.b = (n >>> 0 & 0xFF) / 0xFF;
}
exports.colorFromARGB8 = colorFromARGB8;
function colorToRGBA8(src) {
    return src.r * 0xFF << 24 | src.g * 0xFF << 16 | src.b * 0xFF << 8 | src.a * 0xFF << 0;
}
exports.colorToRGBA8 = colorToRGBA8;
function colorToARGB8(src) {
    return src.a * 0xFF << 24 | src.r * 0xFF << 16 | src.g * 0xFF << 8 | src.b * 0xFF << 0;
}
exports.colorToARGB8 = colorToARGB8;
function colorToCSS(src) {
    return "rgba(" + src.r * 255 + ", " + src.g * 255 + ", " + src.b * 255 + ", " + src.a + ")";
}
exports.colorToCSS = colorToCSS;
},{}],"gx\\gx_material.ts":[function(require,module,exports) {
"use strict";
// GX materials.

var __extends = this && this.__extends || function () {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
        d.__proto__ = b;
    } || function (d, b) {
        for (var p in b) {
            if (b.hasOwnProperty(p)) d[p] = b[p];
        }
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __importStar = this && this.__importStar || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) {
        if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    }result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var GX = __importStar(require("./gx_enum"));
var render_1 = require("../render");
var Program_1 = require("../Program");
var Color_1 = require("../Color");
// TODO(jstpierre): Move somewhere better...
exports.EFB_WIDTH = 640;
exports.EFB_HEIGHT = 528;
var Color = /** @class */function () {
    function Color(r, g, b, a) {
        if (r === void 0) {
            r = 0;
        }
        if (g === void 0) {
            g = 0;
        }
        if (b === void 0) {
            b = 0;
        }
        if (a === void 0) {
            a = 0;
        }
        this.r = r;
        this.g = g;
        this.b = b;
        this.a = a;
    }
    Color.prototype.set = function (r, g, b, a) {
        this.r = r;
        this.g = g;
        this.b = b;
        this.a = a;
    };
    Color.prototype.copy = function (c, a) {
        if (a === void 0) {
            a = c.a;
        }
        return Color_1.colorCopy(this, c, a);
    };
    Color.prototype.copy32 = function (c) {
        return Color_1.colorFromRGBA8(this, c);
    };
    Color.prototype.get32 = function () {
        return Color_1.colorToRGBA8(this);
    };
    return Color;
}();
exports.Color = Color;
var vtxAttributeGenDefs = [{ attrib: GX.VertexAttribute.PNMTXIDX, name: "PosMtxIdx", storage: "uint" }, { attrib: GX.VertexAttribute.POS, name: "Position", storage: "vec3" }, { attrib: GX.VertexAttribute.NRM, name: "Normal", storage: "vec3" }, { attrib: GX.VertexAttribute.CLR0, name: "Color0", storage: "vec4" }, { attrib: GX.VertexAttribute.CLR1, name: "Color1", storage: "vec4" }, { attrib: GX.VertexAttribute.TEX0, name: "Tex0", storage: "vec2" }, { attrib: GX.VertexAttribute.TEX1, name: "Tex1", storage: "vec2" }, { attrib: GX.VertexAttribute.TEX2, name: "Tex2", storage: "vec2" }, { attrib: GX.VertexAttribute.TEX3, name: "Tex3", storage: "vec2" }, { attrib: GX.VertexAttribute.TEX4, name: "Tex4", storage: "vec2" }, { attrib: GX.VertexAttribute.TEX5, name: "Tex5", storage: "vec2" }, { attrib: GX.VertexAttribute.TEX6, name: "Tex6", storage: "vec2" }, { attrib: GX.VertexAttribute.TEX7, name: "Tex7", storage: "vec2" }];
function getVertexAttribLocation(vtxAttrib) {
    return vtxAttributeGenDefs.findIndex(function (genDef) {
        return genDef.attrib === vtxAttrib;
    });
}
exports.getVertexAttribLocation = getVertexAttribLocation;
function getVertexAttribGenDef(vtxAttrib) {
    return vtxAttributeGenDefs.find(function (genDef) {
        return genDef.attrib === vtxAttrib;
    });
}
exports.getVertexAttribGenDef = getVertexAttribGenDef;
var textureSamplerIdentities = Int32Array.of(0, 1, 2, 3, 4, 5, 6, 7);
var GX_Program = /** @class */function (_super) {
    __extends(GX_Program, _super);
    function GX_Program(material, hacks) {
        if (hacks === void 0) {
            hacks = null;
        }
        var _this = _super.call(this) || this;
        _this.material = material;
        _this.hacks = hacks;
        _this.generateShaders();
        return _this;
    }
    GX_Program.prototype.bind = function (gl, prog) {
        gl.uniformBlockBinding(prog, gl.getUniformBlockIndex(prog, "ub_SceneParams"), GX_Program.ub_SceneParams);
        gl.uniformBlockBinding(prog, gl.getUniformBlockIndex(prog, "ub_MaterialParams"), GX_Program.ub_MaterialParams);
        gl.uniformBlockBinding(prog, gl.getUniformBlockIndex(prog, "ub_PacketParams"), GX_Program.ub_PacketParams);
        this.u_Texture = gl.getUniformLocation(prog, "u_Texture");
    };
    GX_Program.prototype.bindTextureSamplerIdentities = function (gl) {
        gl.uniform1iv(this.u_Texture, textureSamplerIdentities);
    };
    GX_Program.prototype.generateFloat = function (v) {
        var s = v.toString();
        if (!s.includes('.')) s += '.0';
        return s;
    };
    GX_Program.prototype.generateColorConstant = function (c) {
        return "vec4(" + c.r + ", " + c.g + ", " + c.b + ", " + c.a + ")";
    };
    // Color Channels
    GX_Program.prototype.generateMaterialSource = function (chan, i) {
        switch (chan.matColorSource) {
            case GX.ColorSrc.VTX:
                return "a_Color" + i;
            case GX.ColorSrc.REG:
                return "u_ColorMatReg[" + i + "]";
        }
    };
    GX_Program.prototype.generateAmbientSource = function (chan, i) {
        switch (chan.ambColorSource) {
            case GX.ColorSrc.VTX:
                return "a_Color" + i;
            case GX.ColorSrc.REG:
                return "u_ColorAmbReg[" + i + "]";
        }
    };
    GX_Program.prototype.generateColorChannel = function (chan, i, isAlpha) {
        // TODO(jstpierre): amb & lighting
        var matSource = this.generateMaterialSource(chan, i);
        if (chan.lightingEnabled) {
            var ambSource = this.generateAmbientSource(chan, i);
            // HACK.
            if (this.hacks) {
                var fudger = isAlpha ? this.hacks.alphaLightingFudge : this.hacks.colorLightingFudge;
                if (fudger) {
                    var vtx = "a_Color" + i;
                    var amb = "u_ColorAmbReg[" + i + "]";
                    var mat = "u_ColorMatReg[" + i + "]";
                    var fudged = fudger({ vtx: vtx, amb: amb, mat: mat, ambSource: ambSource, matSource: matSource });
                    return "vec4(" + fudged + ")";
                }
            }
            // XXX(jstpierre): This is awful but seems to work.
            return "(0.5 * (" + ambSource + " + 0.6) * " + matSource + ")";
        } else {
            // If lighting is off, it's the material color.
            return matSource;
        }
    };
    GX_Program.prototype.generateLightChannel = function (lightChannel, i) {
        return "vec4(" + this.generateColorChannel(lightChannel.colorChannel, i, false) + ".rgb, " + this.generateColorChannel(lightChannel.alphaChannel, i, true) + ".a)";
    };
    GX_Program.prototype.generateLightChannels = function () {
        var _this = this;
        return this.material.lightChannels.map(function (lightChannel, i) {
            return "    v_Color" + i + " = " + _this.generateLightChannel(lightChannel, i) + ";";
        }).join('\n');
    };
    // TexGen
    GX_Program.prototype.generateTexGenSource = function (src) {
        switch (src) {
            case GX.TexGenSrc.POS:
                return "vec4(a_Position, 1.0)";
            case GX.TexGenSrc.NRM:
                return "vec4(a_Normal, 1.0)";
            case GX.TexGenSrc.COLOR0:
                return "a_Color0";
            case GX.TexGenSrc.COLOR1:
                return "a_Color1";
            case GX.TexGenSrc.TEX0:
                return "vec4(a_Tex0, 1.0, 1.0)";
            case GX.TexGenSrc.TEX1:
                return "vec4(a_Tex1, 1.0, 1.0)";
            case GX.TexGenSrc.TEX2:
                return "vec4(a_Tex2, 1.0, 1.0)";
            case GX.TexGenSrc.TEX3:
                return "vec4(a_Tex3, 1.0, 1.0)";
            case GX.TexGenSrc.TEX4:
                return "vec4(a_Tex4, 1.0, 1.0)";
            case GX.TexGenSrc.TEX5:
                return "vec4(a_Tex5, 1.0, 1.0)";
            case GX.TexGenSrc.TEX6:
                return "vec4(a_Tex6, 1.0, 1.0)";
            case GX.TexGenSrc.TEX7:
                return "vec4(a_Tex7, 1.0, 1.0)";
            // Use a previously generated texcoordgen.
            case GX.TexGenSrc.TEXCOORD0:
                return "vec4(v_TexCoord0, 1.0)";
            case GX.TexGenSrc.TEXCOORD1:
                return "vec4(v_TexCoord1, 1.0)";
            case GX.TexGenSrc.TEXCOORD2:
                return "vec4(v_TexCoord2, 1.0)";
            case GX.TexGenSrc.TEXCOORD3:
                return "vec4(v_TexCoord3, 1.0)";
            case GX.TexGenSrc.TEXCOORD4:
                return "vec4(v_TexCoord4, 1.0)";
            case GX.TexGenSrc.TEXCOORD5:
                return "vec4(v_TexCoord5, 1.0)";
            case GX.TexGenSrc.TEXCOORD6:
                return "vec4(v_TexCoord6, 1.0)";
            default:
                throw new Error("whoops");
        }
    };
    GX_Program.prototype.generateTexGenMatrix = function (src, texCoordGen) {
        var matrix = texCoordGen.matrix;
        if (matrix === GX.TexGenMatrix.IDENTITY) {
            return src + ".xyz";
        } else if (matrix >= GX.TexGenMatrix.TEXMTX0) {
            var texMtxIdx = (matrix - GX.TexGenMatrix.TEXMTX0) / 3;
            return "(u_TexMtx[" + texMtxIdx + "] * " + src + ")";
        } else if (matrix >= GX.TexGenMatrix.PNMTX0) {
            var pnMtxIdx = (matrix - GX.TexGenMatrix.PNMTX0) / 3;
            return "(u_PosMtx[" + pnMtxIdx + "] * " + src + ")";
        } else {
            throw "whoops";
        }
    };
    GX_Program.prototype.generateTexGenType = function (texCoordGen) {
        var src = this.generateTexGenSource(texCoordGen.source);
        switch (texCoordGen.type) {
            case GX.TexGenType.SRTG:
                // Expected to be used with colors, I suspect...
                return src + ".xyz";
            case GX.TexGenType.MTX2x4:
                if (texCoordGen.matrix === GX.TexGenMatrix.IDENTITY) return src + ".xyz";
                return "vec3(" + this.generateTexGenMatrix(src, texCoordGen) + ".xy, 1.0)";
            case GX.TexGenType.MTX3x4:
                return "" + this.generateTexGenMatrix(src, texCoordGen);
            default:
                throw new Error("whoops");
        }
    };
    GX_Program.prototype.generateTexGenNrm = function (texCoordGen) {
        var type = this.generateTexGenType(texCoordGen);
        if (texCoordGen.normalize) return "normalize(" + type + ")";else return type;
    };
    GX_Program.prototype.generateTexGenPost = function (texCoordGen) {
        var tex = this.generateTexGenNrm(texCoordGen);
        if (texCoordGen.postMatrix === GX.PostTexGenMatrix.PTIDENTITY) {
            return tex;
        } else {
            var matrixIdx = (texCoordGen.postMatrix - GX.PostTexGenMatrix.PTTEXMTX0) / 3;
            return "u_PostTexMtx[" + matrixIdx + "] * vec4(" + tex + ", 1.0)";
        }
    };
    GX_Program.prototype.generateTexGen = function (texCoordGen) {
        var i = texCoordGen.index;
        return "\n    // TexGen " + i + "  Type: " + texCoordGen.type + " Source: " + texCoordGen.source + " Matrix: " + texCoordGen.matrix + "\n    v_TexCoord" + i + " = " + this.generateTexGenPost(texCoordGen) + ";";
    };
    GX_Program.prototype.generateTexGens = function (texGens) {
        var _this = this;
        return texGens.map(function (tg) {
            return _this.generateTexGen(tg);
        }).join('');
    };
    GX_Program.prototype.generateTexCoordGetters = function () {
        return this.material.texGens.map(function (n, i) {
            return "vec2 ReadTexCoord" + i + "() { return v_TexCoord" + i + ".xy / v_TexCoord" + i + ".z; }\n";
        }).join('');
    };
    // IndTex
    GX_Program.prototype.generateIndTexStageScaleN = function (scale) {
        switch (scale) {
            case GX.IndTexScale._1:
                return "1.0";
            case GX.IndTexScale._2:
                return "1.0/2.0";
            case GX.IndTexScale._4:
                return "1.0/4.0";
            case GX.IndTexScale._8:
                return "1.0/8.0";
            case GX.IndTexScale._16:
                return "1.0/16.0";
            case GX.IndTexScale._32:
                return "1.0/32.0";
            case GX.IndTexScale._64:
                return "1.0/64.0";
            case GX.IndTexScale._128:
                return "1.0/128.0";
            case GX.IndTexScale._256:
                return "1.0/256.0";
        }
    };
    GX_Program.prototype.generateIndTexStageScale = function (stage) {
        var baseCoord = "ReadTexCoord" + stage.texCoordId + "()";
        if (stage.scaleS === GX.IndTexScale._1 && stage.scaleT === GX.IndTexScale._1) return baseCoord;else return baseCoord + " * vec2(" + this.generateIndTexStageScaleN(stage.scaleS) + ", " + this.generateIndTexStageScaleN(stage.scaleT) + ")";
    };
    GX_Program.prototype.generateIndTexStage = function (stage) {
        var i = stage.index;
        return "\n    // Indirect " + i + "\n    vec3 t_IndTexCoord" + i + " = TextureSample(" + stage.texture + ", " + this.generateIndTexStageScale(stage) + ").abg;";
    };
    GX_Program.prototype.generateIndTexStages = function (stages) {
        var _this = this;
        return stages.map(function (stage) {
            return _this.generateIndTexStage(stage);
        }).join('');
    };
    // TEV
    GX_Program.prototype.generateKonstColorSel = function (konstColor) {
        switch (konstColor) {
            case GX.KonstColorSel.KCSEL_1:
                return 'vec3(8.0/8.0)';
            case GX.KonstColorSel.KCSEL_7_8:
                return 'vec3(7.0/8.0)';
            case GX.KonstColorSel.KCSEL_3_4:
                return 'vec3(6.0/8.0)';
            case GX.KonstColorSel.KCSEL_5_8:
                return 'vec3(5.0/8.0)';
            case GX.KonstColorSel.KCSEL_1_2:
                return 'vec3(4.0/8.0)';
            case GX.KonstColorSel.KCSEL_3_8:
                return 'vec3(3.0/8.0)';
            case GX.KonstColorSel.KCSEL_1_4:
                return 'vec3(2.0/8.0)';
            case GX.KonstColorSel.KCSEL_1_8:
                return 'vec3(1.0/8.0)';
            case GX.KonstColorSel.KCSEL_K0:
                return 's_kColor0.rgb';
            case GX.KonstColorSel.KCSEL_K0_R:
                return 's_kColor0.rrr';
            case GX.KonstColorSel.KCSEL_K0_G:
                return 's_kColor0.ggg';
            case GX.KonstColorSel.KCSEL_K0_B:
                return 's_kColor0.bbb';
            case GX.KonstColorSel.KCSEL_K0_A:
                return 's_kColor0.aaa';
            case GX.KonstColorSel.KCSEL_K1:
                return 's_kColor1.rgb';
            case GX.KonstColorSel.KCSEL_K1_R:
                return 's_kColor1.rrr';
            case GX.KonstColorSel.KCSEL_K1_G:
                return 's_kColor1.ggg';
            case GX.KonstColorSel.KCSEL_K1_B:
                return 's_kColor1.bbb';
            case GX.KonstColorSel.KCSEL_K1_A:
                return 's_kColor1.aaa';
            case GX.KonstColorSel.KCSEL_K2:
                return 's_kColor2.rgb';
            case GX.KonstColorSel.KCSEL_K2_R:
                return 's_kColor2.rrr';
            case GX.KonstColorSel.KCSEL_K2_G:
                return 's_kColor2.ggg';
            case GX.KonstColorSel.KCSEL_K2_B:
                return 's_kColor2.bbb';
            case GX.KonstColorSel.KCSEL_K2_A:
                return 's_kColor2.aaa';
            case GX.KonstColorSel.KCSEL_K3:
                return 's_kColor3.rgb';
            case GX.KonstColorSel.KCSEL_K3_R:
                return 's_kColor3.rrr';
            case GX.KonstColorSel.KCSEL_K3_G:
                return 's_kColor3.ggg';
            case GX.KonstColorSel.KCSEL_K3_B:
                return 's_kColor3.bbb';
            case GX.KonstColorSel.KCSEL_K3_A:
                return 's_kColor3.aaa';
        }
    };
    GX_Program.prototype.generateKonstAlphaSel = function (konstAlpha) {
        switch (konstAlpha) {
            case GX.KonstAlphaSel.KASEL_1:
                return '(8.0/8.0)';
            case GX.KonstAlphaSel.KASEL_7_8:
                return '(7.0/8.0)';
            case GX.KonstAlphaSel.KASEL_3_4:
                return '(6.0/8.0)';
            case GX.KonstAlphaSel.KASEL_5_8:
                return '(5.0/8.0)';
            case GX.KonstAlphaSel.KASEL_1_2:
                return '(4.0/8.0)';
            case GX.KonstAlphaSel.KASEL_3_8:
                return '(3.0/8.0)';
            case GX.KonstAlphaSel.KASEL_1_4:
                return '(2.0/8.0)';
            case GX.KonstAlphaSel.KASEL_1_8:
                return '(1.0/8.0)';
            case GX.KonstAlphaSel.KASEL_K0_R:
                return 's_kColor0.r';
            case GX.KonstAlphaSel.KASEL_K0_G:
                return 's_kColor0.g';
            case GX.KonstAlphaSel.KASEL_K0_B:
                return 's_kColor0.b';
            case GX.KonstAlphaSel.KASEL_K0_A:
                return 's_kColor0.a';
            case GX.KonstAlphaSel.KASEL_K1_R:
                return 's_kColor1.r';
            case GX.KonstAlphaSel.KASEL_K1_G:
                return 's_kColor1.g';
            case GX.KonstAlphaSel.KASEL_K1_B:
                return 's_kColor1.b';
            case GX.KonstAlphaSel.KASEL_K1_A:
                return 's_kColor1.a';
            case GX.KonstAlphaSel.KASEL_K2_R:
                return 's_kColor2.r';
            case GX.KonstAlphaSel.KASEL_K2_G:
                return 's_kColor2.g';
            case GX.KonstAlphaSel.KASEL_K2_B:
                return 's_kColor2.b';
            case GX.KonstAlphaSel.KASEL_K2_A:
                return 's_kColor2.a';
            case GX.KonstAlphaSel.KASEL_K3_R:
                return 's_kColor3.r';
            case GX.KonstAlphaSel.KASEL_K3_G:
                return 's_kColor3.g';
            case GX.KonstAlphaSel.KASEL_K3_B:
                return 's_kColor3.b';
            case GX.KonstAlphaSel.KASEL_K3_A:
                return 's_kColor3.a';
        }
    };
    GX_Program.prototype.generateRas = function (stage) {
        switch (stage.channelId) {
            case GX.RasColorChannelID.COLOR0A0:
                return "v_Color0";
            case GX.RasColorChannelID.COLOR1A1:
                return "v_Color1";
            case GX.RasColorChannelID.COLOR_ZERO:
                return "vec4(0, 0, 0, 0)";
            default:
                throw new Error("whoops " + stage.channelId);
        }
    };
    GX_Program.prototype.generateTexAccess = function (stage) {
        // Skyward Sword is amazing sometimes. I hope you're happy...
        // assert(stage.texMap !== GX.TexMapID.TEXMAP_NULL);
        if (stage.texMap === GX.TexMapID.TEXMAP_NULL) return 'vec4(1.0, 1.0, 1.0, 1.0)';
        return "TextureSample(" + stage.texMap + ", t_TexCoord)";
    };
    GX_Program.prototype.generateColorIn = function (stage, colorIn) {
        var i = stage.index;
        switch (colorIn) {
            case GX.CombineColorInput.CPREV:
                return "t_ColorPrev.rgb";
            case GX.CombineColorInput.APREV:
                return "t_ColorPrev.aaa";
            case GX.CombineColorInput.C0:
                return "t_Color0.rgb";
            case GX.CombineColorInput.A0:
                return "t_Color0.aaa";
            case GX.CombineColorInput.C1:
                return "t_Color1.rgb";
            case GX.CombineColorInput.A1:
                return "t_Color1.aaa";
            case GX.CombineColorInput.C2:
                return "t_Color2.rgb";
            case GX.CombineColorInput.A2:
                return "t_Color2.aaa";
            case GX.CombineColorInput.TEXC:
                return this.generateTexAccess(stage) + ".rgb";
            case GX.CombineColorInput.TEXA:
                return this.generateTexAccess(stage) + ".aaa";
            case GX.CombineColorInput.RASC:
                return this.generateRas(stage) + ".rgb";
            case GX.CombineColorInput.RASA:
                return this.generateRas(stage) + ".aaa";
            case GX.CombineColorInput.ONE:
                return "vec3(1)";
            case GX.CombineColorInput.HALF:
                return "vec3(1.0/2.0)";
            case GX.CombineColorInput.KONST:
                return "" + this.generateKonstColorSel(stage.konstColorSel);
            case GX.CombineColorInput.ZERO:
                return "vec3(0)";
        }
    };
    GX_Program.prototype.generateAlphaIn = function (stage, alphaIn) {
        var i = stage.index;
        switch (alphaIn) {
            case GX.CombineAlphaInput.APREV:
                return "t_ColorPrev.a";
            case GX.CombineAlphaInput.A0:
                return "t_Color0.a";
            case GX.CombineAlphaInput.A1:
                return "t_Color1.a";
            case GX.CombineAlphaInput.A2:
                return "t_Color2.a";
            case GX.CombineAlphaInput.TEXA:
                return this.generateTexAccess(stage) + ".a";
            case GX.CombineAlphaInput.RASA:
                return this.generateRas(stage) + ".a";
            case GX.CombineAlphaInput.KONST:
                return "" + this.generateKonstAlphaSel(stage.konstAlphaSel);
            case GX.CombineAlphaInput.ZERO:
                return "0.0";
        }
    };
    GX_Program.prototype.generateTevInputs = function (stage) {
        return ("\n    t_TevA = TevOverflow(vec4(" + this.generateColorIn(stage, stage.colorInA) + ", " + this.generateAlphaIn(stage, stage.alphaInA) + "));\n    t_TevB = TevOverflow(vec4(" + this.generateColorIn(stage, stage.colorInB) + ", " + this.generateAlphaIn(stage, stage.alphaInB) + "));\n    t_TevC = TevOverflow(vec4(" + this.generateColorIn(stage, stage.colorInC) + ", " + this.generateAlphaIn(stage, stage.alphaInC) + "));\n    t_TevD = TevOverflow(vec4(" + this.generateColorIn(stage, stage.colorInD) + ", " + this.generateAlphaIn(stage, stage.alphaInD) + "));\n").trim();
    };
    GX_Program.prototype.generateTevRegister = function (regId) {
        switch (regId) {
            case GX.Register.PREV:
                return "t_ColorPrev";
            case GX.Register.REG0:
                return "t_Color0";
            case GX.Register.REG1:
                return "t_Color1";
            case GX.Register.REG2:
                return "t_Color2";
        }
    };
    GX_Program.prototype.generateTevOpBiasScaleClamp = function (value, bias, scale) {
        var v = value;
        if (bias === GX.TevBias.ADDHALF) v = "TevBias(" + v + ", 0.5)";else if (bias === GX.TevBias.SUBHALF) v = "TevBias(" + v + ", -0.5)";
        if (scale === GX.TevScale.SCALE_2) v = "(" + v + ") * 2.0";else if (scale === GX.TevScale.SCALE_4) v = "(" + v + ") * 4.0";else if (scale === GX.TevScale.DIVIDE_2) v = "(" + v + ") * 0.5";
        return v;
    };
    GX_Program.prototype.generateTevOp = function (op, bias, scale, a, b, c, d, zero) {
        switch (op) {
            case GX.TevOp.ADD:
            case GX.TevOp.SUB:
                var neg = op === GX.TevOp.SUB ? '-' : '';
                var v = neg + "mix(" + a + ", " + b + ", " + c + ") + " + d;
                return this.generateTevOpBiasScaleClamp(v, bias, scale);
            case GX.TevOp.COMP_R8_GT:
                return "((t_TevA.r >  t_TevB.r) ? " + c + " : " + zero + ") + " + d;
            case GX.TevOp.COMP_R8_EQ:
                return "((t_TevA.r == t_TevB.r) ? " + c + " : " + zero + ") + " + d;
            case GX.TevOp.COMP_GR16_GT:
                return "((TevPack16(t_TevA.rg) >  TevPack16(t_TevB.rg)) ? " + c + " : " + zero + ") + " + d;
            case GX.TevOp.COMP_GR16_EQ:
                return "((TevPack16(t_TevA.rg) == TevPack16(t_TevB.rg)) ? " + c + " : " + zero + ") + " + d;
            case GX.TevOp.COMP_RGB8_GT:
                return "(TevPerCompGT(" + a + ", " + b + ") * " + c + ") + " + d;
            case GX.TevOp.COMP_RGB8_EQ:
                return "(TevPerCompEQ(" + a + ", " + b + ") * " + c + ") + " + d;
            default:
                throw new Error("whoops");
        }
    };
    GX_Program.prototype.generateTevOpValue = function (op, bias, scale, clamp, a, b, c, d, zero) {
        var expr = this.generateTevOp(op, bias, scale, a, b, c, d, zero);
        if (clamp) return "TevSaturate(" + expr + ")";else return expr;
    };
    GX_Program.prototype.generateColorOp = function (stage) {
        var a = "t_TevA.rgb",
            b = "t_TevB.rgb",
            c = "t_TevC.rgb",
            d = "t_TevD.rgb",
            zero = "vec3(0)";
        var value = this.generateTevOpValue(stage.colorOp, stage.colorBias, stage.colorScale, stage.colorClamp, a, b, c, d, zero);
        return this.generateTevRegister(stage.colorRegId) + ".rgb = " + value + ";";
    };
    GX_Program.prototype.generateAlphaOp = function (stage) {
        var a = "t_TevA.a",
            b = "t_TevB.a",
            c = "t_TevC.a",
            d = "t_TevD.a",
            zero = '0.0';
        var value = this.generateTevOpValue(stage.alphaOp, stage.alphaBias, stage.alphaScale, stage.alphaClamp, a, b, c, d, zero);
        return this.generateTevRegister(stage.alphaRegId) + ".a = " + value + ";";
    };
    GX_Program.prototype.generateTevTexCoordWrapN = function (texCoord, wrap) {
        switch (wrap) {
            case GX.IndTexWrap.OFF:
                return texCoord;
            case GX.IndTexWrap._0:
                return '0.0';
            case GX.IndTexWrap._256:
                return "mod(" + texCoord + ", 256.0)";
            case GX.IndTexWrap._128:
                return "mod(" + texCoord + ", 128.0)";
            case GX.IndTexWrap._64:
                return "mod(" + texCoord + ", 64.0)";
            case GX.IndTexWrap._32:
                return "mod(" + texCoord + ", 32.0)";
            case GX.IndTexWrap._16:
                return "mod(" + texCoord + ", 16.0)";
        }
    };
    GX_Program.prototype.generateTevTexCoordWrap = function (stage) {
        var lastTexGenId = this.material.texGens.length - 1;
        var texGenId = stage.texCoordId;
        if (texGenId >= lastTexGenId) texGenId = lastTexGenId;
        if (texGenId < 0) return "vec2(0.0, 0.0)";
        var baseCoord = "ReadTexCoord" + texGenId + "()";
        if (stage.indTexWrapS === GX.IndTexWrap.OFF && stage.indTexWrapT === GX.IndTexWrap.OFF) return baseCoord;else return "vec2(" + this.generateTevTexCoordWrapN(baseCoord + ".x", stage.indTexWrapS) + ", " + this.generateTevTexCoordWrapN(baseCoord + ".y", stage.indTexWrapT) + ")";
    };
    GX_Program.prototype.generateTevTexCoordIndTexCoordBias = function (stage) {
        var bias = stage.indTexFormat === GX.IndTexFormat._8 ? '-128.0' : "1.0";
        switch (stage.indTexBiasSel) {
            case GX.IndTexBiasSel.NONE:
                return "";
            case GX.IndTexBiasSel.S:
                return " + vec3(" + bias + ", 0.0, 0.0)";
            case GX.IndTexBiasSel.ST:
                return " + vec3(" + bias + ", " + bias + ", 0.0)";
            case GX.IndTexBiasSel.SU:
                return " + vec3(" + bias + ", 0.0, " + bias + ")";
            case GX.IndTexBiasSel.T:
                return " + vec3(0.0, " + bias + ", 0.0)";
            case GX.IndTexBiasSel.TU:
                return " + vec3(0.0, " + bias + ", " + bias + ")";
            case GX.IndTexBiasSel.U:
                return " + vec3(0.0, 0.0, " + bias + ")";
            case GX.IndTexBiasSel.STU:
                return " + vec3(" + bias + ")";
        }
    };
    GX_Program.prototype.generateTevTexCoordIndTexCoord = function (stage) {
        var baseCoord = "(t_IndTexCoord" + stage.indTexStage + " * 255.0)";
        switch (stage.indTexFormat) {
            case GX.IndTexFormat._8:
                return baseCoord;
            default:
            case GX.IndTexFormat._5:
                throw new Error("whoops");
        }
    };
    GX_Program.prototype.generateTevTexCoordIndirectMtx = function (stage) {
        var indTevCoord = "(" + this.generateTevTexCoordIndTexCoord(stage) + this.generateTevTexCoordIndTexCoordBias(stage) + ")";
        switch (stage.indTexMatrix) {
            case GX.IndTexMtxID._0:
                return "(u_IndTexMtx[0] * vec4(" + indTevCoord + ", 0.0))";
            case GX.IndTexMtxID._1:
                return "(u_IndTexMtx[1] * vec4(" + indTevCoord + ", 0.0))";
            case GX.IndTexMtxID._2:
                return "(u_IndTexMtx[2] * vec4(" + indTevCoord + ", 0.0))";
            default:
            case GX.IndTexMtxID.OFF:
                throw new Error("whoops");
        }
    };
    GX_Program.prototype.generateTevTexCoordIndirectTranslation = function (stage) {
        return "(" + this.generateTevTexCoordIndirectMtx(stage) + " / TextureSize(" + stage.texCoordId + "))";
    };
    GX_Program.prototype.generateTevTexCoordIndirect = function (stage) {
        var baseCoord = this.generateTevTexCoordWrap(stage);
        if (stage.indTexMatrix !== GX.IndTexMtxID.OFF && stage.indTexStage < this.material.indTexStages.length) return baseCoord + " + " + this.generateTevTexCoordIndirectTranslation(stage);else return baseCoord;
    };
    GX_Program.prototype.generateTevTexCoord = function (stage) {
        if (stage.texCoordId === GX.TexCoordID.NULL) return '';
        var finalCoord = this.generateTevTexCoordIndirect(stage);
        if (stage.indTexAddPrev) {
            return "t_TexCoord += " + finalCoord + ";";
        } else {
            return "t_TexCoord = " + finalCoord + ";";
        }
    };
    GX_Program.prototype.generateTevStage = function (stage) {
        var i = stage.index;
        return "\n    // TEV Stage " + i + "\n    " + this.generateTevTexCoord(stage) + "\n    // Color Combine\n    // colorIn: " + stage.colorInA + " " + stage.colorInB + " " + stage.colorInC + " " + stage.colorInD + "  colorOp: " + stage.colorOp + " colorBias: " + stage.colorBias + " colorScale: " + stage.colorScale + " colorClamp: " + stage.colorClamp + " colorRegId: " + stage.colorRegId + "\n    // alphaIn: " + stage.alphaInA + " " + stage.alphaInB + " " + stage.alphaInC + " " + stage.alphaInD + "  alphaOp: " + stage.alphaOp + " alphaBias: " + stage.alphaBias + " alphaScale: " + stage.alphaScale + " alphaClamp: " + stage.alphaClamp + " alphaRegId: " + stage.alphaRegId + "\n    // texCoordId: " + stage.texCoordId + " texMap: " + stage.texMap + " channelId: " + stage.channelId + "\n    " + this.generateTevInputs(stage) + "\n    " + this.generateColorOp(stage) + "\n    " + this.generateAlphaOp(stage);
    };
    GX_Program.prototype.generateTevStages = function (tevStages) {
        var _this = this;
        return tevStages.map(function (s) {
            return _this.generateTevStage(s);
        }).join("\n");
    };
    GX_Program.prototype.generateTevStagesLastMinuteFixup = function (tevStages) {
        // Despite having a destination register, the output of the last stage
        // is what gets output from the color combinations...
        var lastTevStage = tevStages[tevStages.length - 1];
        var colorReg = this.generateTevRegister(lastTevStage.colorRegId);
        var alphaReg = this.generateTevRegister(lastTevStage.alphaRegId);
        if (colorReg === alphaReg) {
            return "\n    vec4 t_TevOutput = " + colorReg + ";";
        } else {
            return "\n    vec4 t_TevOutput = vec4(" + colorReg + ".rgb, " + alphaReg + ".a);";
        }
    };
    GX_Program.prototype.generateAlphaTestCompare = function (compare, reference) {
        var ref = this.generateFloat(reference);
        switch (compare) {
            case GX.CompareType.NEVER:
                return "false";
            case GX.CompareType.LESS:
                return "t_TevOutput.a <  " + ref;
            case GX.CompareType.EQUAL:
                return "t_TevOutput.a == " + ref;
            case GX.CompareType.LEQUAL:
                return "t_TevOutput.a <= " + ref;
            case GX.CompareType.GREATER:
                return "t_TevOutput.a >  " + ref;
            case GX.CompareType.NEQUAL:
                return "t_TevOutput.a != " + ref;
            case GX.CompareType.GEQUAL:
                return "t_TevOutput.a >= " + ref;
            case GX.CompareType.ALWAYS:
                return "true";
        }
    };
    GX_Program.prototype.generateAlphaTestOp = function (op) {
        switch (op) {
            case GX.AlphaOp.AND:
                return "t_AlphaTestA && t_AlphaTestB";
            case GX.AlphaOp.OR:
                return "t_AlphaTestA || t_AlphaTestB";
            case GX.AlphaOp.XOR:
                return "t_AlphaTestA != t_AlphaTestB";
            case GX.AlphaOp.XNOR:
                return "t_AlphaTestA == t_AlphaTestB";
        }
    };
    GX_Program.prototype.generateAlphaTest = function (alphaTest) {
        return "\n    // Alpha Test: Op " + alphaTest.op + "\n    // Compare A: " + alphaTest.compareA + " Reference A: " + this.generateFloat(alphaTest.referenceA) + "\n    // Compare B: " + alphaTest.compareB + " Reference B: " + this.generateFloat(alphaTest.referenceB) + "\n    bool t_AlphaTestA = " + this.generateAlphaTestCompare(alphaTest.compareA, alphaTest.referenceA) + ";\n    bool t_AlphaTestB = " + this.generateAlphaTestCompare(alphaTest.compareB, alphaTest.referenceB) + ";\n    if (!(" + this.generateAlphaTestOp(alphaTest.op) + "))\n        discard;\n";
    };
    GX_Program.prototype.generateVertAttributeDefs = function () {
        return vtxAttributeGenDefs.map(function (a, i) {
            return "layout(location = " + i + ") in " + a.storage + " a_" + a.name + ";";
        }).join('\n');
    };
    GX_Program.prototype.generateUBO = function () {
        return "\n// Expected to be constant across the entire scene.\nlayout(row_major, std140) uniform ub_SceneParams {\n    mat4 u_Projection;\n    vec4 u_Misc0;\n};\n\n#define u_SceneTextureLODBias u_Misc0[0]\n\n// Expected to change with each material.\nlayout(row_major, std140) uniform ub_MaterialParams {\n    vec4 u_ColorMatReg[2];\n    vec4 u_ColorAmbReg[2];\n    vec4 u_KonstColor[4];\n    vec4 u_Color[4];\n    mat4x3 u_TexMtx[10];\n    mat4x3 u_PostTexMtx[20];\n    mat4x2 u_IndTexMtx[3];\n    // SizeX, SizeY, 0, Bias\n    vec4 u_TextureParams[8];\n};\n\n// Expected to change with each shape packet.\nlayout(row_major, std140) uniform ub_PacketParams {\n    mat4x3 u_PosMtx[10];\n};\n";
    };
    GX_Program.prototype.generateShaders = function () {
        var ubo = this.generateUBO();
        this.vert = "\n// " + this.material.name + "\nprecision mediump float;\n" + ubo + "\n" + this.generateVertAttributeDefs() + "\nout vec3 v_Position;\nout vec3 v_Normal;\nout vec4 v_Color0;\nout vec4 v_Color1;\nout vec3 v_TexCoord0;\nout vec3 v_TexCoord1;\nout vec3 v_TexCoord2;\nout vec3 v_TexCoord3;\nout vec3 v_TexCoord4;\nout vec3 v_TexCoord5;\nout vec3 v_TexCoord6;\nout vec3 v_TexCoord7;\n\nmat4 GetPosTexMatrix(uint mtxid) {\n    if (mtxid == " + GX.TexGenMatrix.IDENTITY + "u)\n        return mat4(1.0);\n    else if (mtxid >= " + GX.TexGenMatrix.TEXMTX0 + "u)\n        return mat4(u_TexMtx[(mtxid - 30u) / 3u]);\n    else\n        return mat4(u_PosMtx[mtxid / 3u]);\n}\n\nvoid main() {\n    mat4 t_PosMtx = GetPosTexMatrix(a_PosMtxIdx);\n    mat4 t_PosModelView = t_PosMtx;\n    vec4 t_Position = t_PosModelView * vec4(a_Position, 1.0);\n    v_Position = t_Position.xyz;\n    v_Normal = a_Normal;\n" + this.generateLightChannels() + "\n" + this.generateTexGens(this.material.texGens) + "\n    gl_Position = u_Projection * t_Position;\n}\n";
        var tevStages = this.material.tevStages;
        var indTexStages = this.material.indTexStages;
        var alphaTest = this.material.alphaTest;
        var kColors = this.material.colorConstants;
        var rColors = this.material.colorRegisters;
        this.frag = "\n// " + this.material.name + "\nprecision mediump float;\n" + ubo + "\nuniform sampler2D u_Texture[8];\n\nin vec3 v_Position;\nin vec3 v_Normal;\nin vec4 v_Color0;\nin vec4 v_Color1;\nin vec3 v_TexCoord0;\nin vec3 v_TexCoord1;\nin vec3 v_TexCoord2;\nin vec3 v_TexCoord3;\nin vec3 v_TexCoord4;\nin vec3 v_TexCoord5;\nin vec3 v_TexCoord6;\nin vec3 v_TexCoord7;\n" + this.generateTexCoordGetters() + "\n\nfloat TextureLODBias(int index) { return u_SceneTextureLODBias + u_TextureParams[index].w; }\nvec2 TextureSize(int index) { return u_TextureParams[index].xy; }\nvec4 TextureSample(int index, vec2 coord) { return texture(u_Texture[index], coord, TextureLODBias(index)); }\n\nvec3 TevBias(vec3 a, float b) { return a + vec3(b); }\nfloat TevBias(float a, float b) { return a + b; }\nvec3 TevSaturate(vec3 a) { return clamp(a, vec3(0), vec3(1)); }\nfloat TevSaturate(float a) { return clamp(a, 0.0, 1.0); }\nfloat TevOverflow(float a) { return float(int(a * 255.0) % 256) / 255.0; }\nvec4 TevOverflow(vec4 a) { return vec4(TevOverflow(a.r), TevOverflow(a.g), TevOverflow(a.b), TevOverflow(a.a)); }\nfloat TevPack16(vec2 a) { return dot(a, vec2(1.0, 256.0)); }\nfloat TevPack24(vec3 a) { return dot(a, vec3(1.0, 256.0, 256.0 * 256.0)); }\nfloat TevPerCompGT(float a, float b) { return float(a >  b); }\nfloat TevPerCompEQ(float a, float b) { return float(a == b); }\nvec3 TevPerCompGT(vec3 a, vec3 b) { return vec3(greaterThan(a, b)); }\nvec3 TevPerCompEQ(vec3 a, vec3 b) { return vec3(greaterThan(a, b)); }\n\nvoid main() {\n    vec4 s_kColor0   = u_KonstColor[0]; // " + this.generateColorConstant(kColors[0]) + "\n    vec4 s_kColor1   = u_KonstColor[1]; // " + this.generateColorConstant(kColors[1]) + "\n    vec4 s_kColor2   = u_KonstColor[2]; // " + this.generateColorConstant(kColors[2]) + "\n    vec4 s_kColor3   = u_KonstColor[3]; // " + this.generateColorConstant(kColors[3]) + "\n\n    vec4 t_ColorPrev = u_Color[0]; // " + this.generateColorConstant(rColors[GX.Register.PREV]) + "\n    vec4 t_Color0    = u_Color[1]; // " + this.generateColorConstant(rColors[GX.Register.REG0]) + "\n    vec4 t_Color1    = u_Color[2]; // " + this.generateColorConstant(rColors[GX.Register.REG1]) + "\n    vec4 t_Color2    = u_Color[3]; // " + this.generateColorConstant(rColors[GX.Register.REG2]) + "\n\n    vec2 t_TexCoord = vec2(0.0, 0.0);\n" + this.generateIndTexStages(indTexStages) + "\n    vec4 t_TevA, t_TevB, t_TevC, t_TevD;\n" + this.generateTevStages(tevStages) + "\n\n" + this.generateTevStagesLastMinuteFixup(tevStages) + "\n    t_TevOutput = TevOverflow(t_TevOutput);\n" + this.generateAlphaTest(alphaTest) + "\n    gl_FragColor = t_TevOutput;\n}\n";
    };
    GX_Program.ub_SceneParams = 0;
    GX_Program.ub_MaterialParams = 1;
    GX_Program.ub_PacketParams = 2;
    return GX_Program;
}(Program_1.BaseProgram);
exports.GX_Program = GX_Program;
// #endregion
// #region Material flags generation.
function translateCullMode(cullMode) {
    switch (cullMode) {
        case GX.CullMode.ALL:
            return render_1.CullMode.FRONT_AND_BACK;
        case GX.CullMode.FRONT:
            return render_1.CullMode.FRONT;
        case GX.CullMode.BACK:
            return render_1.CullMode.BACK;
        case GX.CullMode.NONE:
            return render_1.CullMode.NONE;
    }
}
function translateBlendFactorCommon(blendFactor) {
    switch (blendFactor) {
        case GX.BlendFactor.ZERO:
            return render_1.BlendFactor.ZERO;
        case GX.BlendFactor.ONE:
            return render_1.BlendFactor.ONE;
        case GX.BlendFactor.SRCALPHA:
            return render_1.BlendFactor.SRC_ALPHA;
        case GX.BlendFactor.INVSRCALPHA:
            return render_1.BlendFactor.ONE_MINUS_SRC_ALPHA;
        case GX.BlendFactor.DSTALPHA:
            return render_1.BlendFactor.DST_ALPHA;
        case GX.BlendFactor.INVDSTALPHA:
            return render_1.BlendFactor.ONE_MINUS_DST_ALPHA;
        default:
            throw new Error("whoops");
    }
}
function translateBlendSrcFactor(blendFactor) {
    switch (blendFactor) {
        case GX.BlendFactor.SRCCLR:
            return render_1.BlendFactor.DST_COLOR;
        case GX.BlendFactor.INVSRCCLR:
            return render_1.BlendFactor.ONE_MINUS_DST_COLOR;
        default:
            return translateBlendFactorCommon(blendFactor);
    }
}
function translateBlendDstFactor(blendFactor) {
    switch (blendFactor) {
        case GX.BlendFactor.SRCCLR:
            return render_1.BlendFactor.SRC_COLOR;
        case GX.BlendFactor.INVSRCCLR:
            return render_1.BlendFactor.ONE_MINUS_SRC_COLOR;
        default:
            return translateBlendFactorCommon(blendFactor);
    }
}
function translateCompareType(compareType) {
    switch (compareType) {
        case GX.CompareType.NEVER:
            return render_1.CompareMode.NEVER;
        case GX.CompareType.LESS:
            return render_1.CompareMode.LESS;
        case GX.CompareType.EQUAL:
            return render_1.CompareMode.EQUAL;
        case GX.CompareType.LEQUAL:
            return render_1.CompareMode.LEQUAL;
        case GX.CompareType.GREATER:
            return render_1.CompareMode.GREATER;
        case GX.CompareType.NEQUAL:
            return render_1.CompareMode.NEQUAL;
        case GX.CompareType.GEQUAL:
            return render_1.CompareMode.GEQUAL;
        case GX.CompareType.ALWAYS:
            return render_1.CompareMode.ALWAYS;
    }
}
function translateRenderFlags(material) {
    var renderFlags = new render_1.RenderFlags();
    renderFlags.cullMode = translateCullMode(material.cullMode);
    renderFlags.depthWrite = material.ropInfo.depthWrite;
    renderFlags.depthTest = material.ropInfo.depthTest;
    renderFlags.depthFunc = translateCompareType(material.ropInfo.depthFunc);
    renderFlags.frontFace = render_1.FrontFaceMode.CW;
    if (material.ropInfo.blendMode.type === GX.BlendMode.NONE) {
        renderFlags.blendMode = render_1.BlendMode.NONE;
    } else if (material.ropInfo.blendMode.type === GX.BlendMode.BLEND) {
        renderFlags.blendMode = render_1.BlendMode.ADD;
        renderFlags.blendSrc = translateBlendSrcFactor(material.ropInfo.blendMode.srcFactor);
        renderFlags.blendDst = translateBlendDstFactor(material.ropInfo.blendMode.dstFactor);
    } else if (material.ropInfo.blendMode.type === GX.BlendMode.SUBTRACT) {
        renderFlags.blendMode = render_1.BlendMode.REVERSE_SUBTRACT;
        renderFlags.blendSrc = render_1.BlendFactor.ONE;
        renderFlags.blendDst = render_1.BlendFactor.ONE;
    } else if (material.ropInfo.blendMode.type === GX.BlendMode.LOGIC) {
        throw new Error("whoops");
    }
    return renderFlags;
}
exports.translateRenderFlags = translateRenderFlags;
// #endregion
function getRasColorChannelID(v) {
    switch (v) {
        case GX.ColorChannelId.COLOR0:
        case GX.ColorChannelId.ALPHA0:
        case GX.ColorChannelId.COLOR0A0:
            return GX.RasColorChannelID.COLOR0A0;
        case GX.ColorChannelId.COLOR1:
        case GX.ColorChannelId.ALPHA1:
        case GX.ColorChannelId.COLOR1A1:
            return GX.RasColorChannelID.COLOR1A1;
        case GX.ColorChannelId.ALPHA_BUMP:
            return GX.RasColorChannelID.ALPHA_BUMP;
        case GX.ColorChannelId.ALPHA_BUMP_N:
            return GX.RasColorChannelID.ALPHA_BUMP_N;
        case GX.ColorChannelId.COLOR_ZERO:
        case GX.ColorChannelId.COLOR_NULL:
            return GX.RasColorChannelID.COLOR_ZERO;
        default:
            throw "whoops";
    }
}
exports.getRasColorChannelID = getRasColorChannelID;
},{"./gx_enum":"gx\\gx_enum.ts","../render":"render.ts","../Program":"Program.ts","../Color":"Color.ts"}],"gx\\gx_texture.ts":[function(require,module,exports) {
"use strict";
// GX texture decoding

var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
};
var __importStar = this && this.__importStar || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) {
        if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    }result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var ArrayBufferSlice_1 = __importDefault(require("../ArrayBufferSlice"));
var GX = __importStar(require("./gx_enum"));
var util_1 = require("../util");
var wat_modules_1 = require("../wat_modules");
var WasmMemoryManager_1 = __importDefault(require("../WasmMemoryManager"));
function calcPaletteSize(format, palette) {
    var paletteSize = 0;
    switch (format) {
        case GX.TexFormat.C4:
            paletteSize = 16;
            break;
        case GX.TexFormat.C8:
            paletteSize = 256;
            break;
        case GX.TexFormat.C14X2:
        default:
            throw new Error("whoops");
    }
    // All palette-formats are 16-bit.
    return paletteSize * 2;
}
exports.calcPaletteSize = calcPaletteSize;
function calcTextureSize(format, width, height) {
    var numPixels = width * height;
    switch (format) {
        case GX.TexFormat.I4:
            return numPixels / 2;
        case GX.TexFormat.I8:
            return numPixels;
        case GX.TexFormat.IA4:
            return numPixels;
        case GX.TexFormat.IA8:
            return numPixels * 2;
        case GX.TexFormat.C4:
            return numPixels / 2;
        case GX.TexFormat.C8:
            return numPixels;
        case GX.TexFormat.RGB565:
            return numPixels * 2;
        case GX.TexFormat.RGB5A3:
            return numPixels * 2;
        case GX.TexFormat.RGBA8:
            return numPixels * 4;
        case GX.TexFormat.CMPR:
            return numPixels / 2;
        default:
            throw new Error("whoops");
    }
}
exports.calcTextureSize = calcTextureSize;
function calcMipChain(texture, mipCount) {
    if (mipCount === void 0) {
        mipCount = 0xFF;
    }
    var mipLevels = [];
    var name = texture.name;
    var textureSize = 0;
    var mipLevel = 0;
    var format = texture.format;
    var width = texture.width;
    var height = texture.height;
    while (width > 0 && height > 0 && mipLevel < mipCount) {
        var mipSize = calcTextureSize(format, width, height);
        var data = texture.data !== null ? texture.data.subarray(textureSize) : null;
        mipLevels.push({ name: texture.name + " mip level " + mipLevel, format: format, width: width, height: height, data: data });
        mipLevel++;
        textureSize += mipSize;
        width /= 2;
        height /= 2;
    }
    return { name: name, mipLevels: mipLevels, fullTextureSize: textureSize };
}
exports.calcMipChain = calcMipChain;
// XXX(jstpierre): Firefox has GC pressure when constructing new WebAssembly.Memory instances
// on 64-bit machines. Construct a global WebAssembly.Memory and use it. Remove this when the
// bug is fixed. https://bugzilla.mozilla.org/show_bug.cgi?id=1459761#c5
var _wasmInstance = wat_modules_1.gx_texture_asInstance();
function decode_Wasm(wasmInstance, texture, decoder, scratchSize) {
    if (scratchSize === void 0) {
        scratchSize = 0;
    }
    var dstSize = texture.width * texture.height * 4;
    var srcSize = texture.data.byteLength;
    var pScratch = 0;
    var pDst = util_1.align(pScratch + scratchSize, 0x10);
    var pSrc = util_1.align(pDst + dstSize, 0x10);
    var heapSize = util_1.align(pSrc + srcSize, 0x10);
    var wasmMemory = new WasmMemoryManager_1.default(wasmInstance.memory);
    var heap = wasmMemory.resize(heapSize);
    // Copy src buffer.
    heap.set(texture.data.createTypedArray(Uint8Array), pSrc);
    decoder(pScratch, pDst, pSrc, texture.width, texture.height);
    // Copy the result buffer to a new buffer for memory usage purposes.
    var pixelsBuffer = new ArrayBufferSlice_1.default(heap.buffer).copyToBuffer(pDst, dstSize);
    var pixels = new Uint8Array(pixelsBuffer);
    return { pixels: pixels };
}
function decode_Dummy(texture) {
    var pixels = new Uint8Array(texture.width * texture.height * 4);
    pixels.fill(0xFF);
    return { pixels: pixels };
}
function getFormatName(format) {
    switch (format) {
        case GX.TexFormat.I4:
            return "I4";
        case GX.TexFormat.I8:
            return "I8";
        case GX.TexFormat.IA4:
            return "IA4";
        case GX.TexFormat.IA8:
            return "IA8";
        case GX.TexFormat.RGB565:
            return "RGB565";
        case GX.TexFormat.RGB5A3:
            return "RGB5A3";
        case GX.TexFormat.RGBA8:
            return "RGBA8";
        case GX.TexFormat.CMPR:
            return "CMPR";
        case GX.TexFormat.C4:
            return "C4 (TODO)";
        case GX.TexFormat.C8:
            return "C8 (TODO)";
        case GX.TexFormat.C14X2:
            return "C14X2 (TODO)";
        default:
            return "invalid";
    }
}
exports.getFormatName = getFormatName;
function decodeTexture(texture) {
    if (texture.data === null) return Promise.resolve(decode_Dummy(texture));
    return _wasmInstance.then(function (wasmInstance) {
        switch (texture.format) {
            case GX.TexFormat.I4:
                return decode_Wasm(wasmInstance, texture, wasmInstance.decode_I4);
            case GX.TexFormat.I8:
                return decode_Wasm(wasmInstance, texture, wasmInstance.decode_I8);
            case GX.TexFormat.IA4:
                return decode_Wasm(wasmInstance, texture, wasmInstance.decode_IA4);
            case GX.TexFormat.IA8:
                return decode_Wasm(wasmInstance, texture, wasmInstance.decode_IA8);
            case GX.TexFormat.RGB565:
                return decode_Wasm(wasmInstance, texture, wasmInstance.decode_RGB565);
            case GX.TexFormat.RGB5A3:
                return decode_Wasm(wasmInstance, texture, wasmInstance.decode_RGB5A3);
            case GX.TexFormat.RGBA8:
                return decode_Wasm(wasmInstance, texture, wasmInstance.decode_RGBA8);
            case GX.TexFormat.CMPR:
                return decode_Wasm(wasmInstance, texture, wasmInstance.decode_CMPR, 16);
            case GX.TexFormat.C4:
            case GX.TexFormat.C8:
            case GX.TexFormat.C14X2:
            default:
                console.error("Unsupported texture format " + texture.format + " on texture " + texture.name);
                return decode_Dummy(texture);
        }
    });
}
exports.decodeTexture = decodeTexture;
},{"../ArrayBufferSlice":"ArrayBufferSlice.ts","./gx_enum":"gx\\gx_enum.ts","../util":"util.ts","../wat_modules":"wat_modules.ts","../WasmMemoryManager":"WasmMemoryManager.ts"}],"BufferCoalescer.ts":[function(require,module,exports) {
"use strict";
// Helper utility to combine buffers together for performance reasons.

var __values = this && this.__values || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator],
        i = 0;
    if (m) return m.call(o);
    return {
        next: function next() {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("./util");
function coalesceBuffer(gl, target, datas) {
    var e_1, _a, e_2, _b;
    var dataLength = 0;
    try {
        for (var datas_1 = __values(datas), datas_1_1 = datas_1.next(); !datas_1_1.done; datas_1_1 = datas_1.next()) {
            var data = datas_1_1.value;
            dataLength += data.byteLength;
            dataLength = util_1.align(dataLength, 4);
        }
    } catch (e_1_1) {
        e_1 = { error: e_1_1 };
    } finally {
        try {
            if (datas_1_1 && !datas_1_1.done && (_a = datas_1.return)) _a.call(datas_1);
        } finally {
            if (e_1) throw e_1.error;
        }
    }
    var buffer = gl.createBuffer();
    gl.bindBuffer(target, buffer);
    gl.bufferData(target, dataLength, gl.STATIC_DRAW);
    var coalescedBuffers = [];
    var offset = 0;
    try {
        for (var datas_2 = __values(datas), datas_2_1 = datas_2.next(); !datas_2_1.done; datas_2_1 = datas_2.next()) {
            var data = datas_2_1.value;
            var size = data.byteLength;
            coalescedBuffers.push({ buffer: buffer, offset: offset });
            gl.bufferSubData(target, offset, data.createTypedArray(Uint8Array));
            offset += size;
            offset = util_1.align(offset, 4);
        }
    } catch (e_2_1) {
        e_2 = { error: e_2_1 };
    } finally {
        try {
            if (datas_2_1 && !datas_2_1.done && (_b = datas_2.return)) _b.call(datas_2);
        } finally {
            if (e_2) throw e_2.error;
        }
    }
    return coalescedBuffers;
}
exports.coalesceBuffer = coalesceBuffer;
// For debugging. Should be identical to just using the original buffers.
var FakeBufferCoalescer = /** @class */function () {
    function FakeBufferCoalescer(gl, vertexDatas, indexDatas) {
        this.vertexBuffers = [];
        this.indexBuffers = [];
        util_1.assert(vertexDatas.length === indexDatas.length);
        var coalescedBuffers = [];
        for (var i = 0; i < vertexDatas.length; i++) {
            var vertexCoalescedBuffers = coalesceBuffer(gl, gl.ARRAY_BUFFER, [vertexDatas[i]]);
            var indexCoalescedBuffers = coalesceBuffer(gl, gl.ELEMENT_ARRAY_BUFFER, [indexDatas[i]]);
            var vertexBuffer = vertexCoalescedBuffers[0];
            var indexBuffer = indexCoalescedBuffers[0];
            this.vertexBuffers.push(vertexBuffer.buffer);
            this.indexBuffers.push(indexBuffer.buffer);
            coalescedBuffers.push({ vertexBuffer: vertexBuffer, indexBuffer: indexBuffer });
        }
        this.coalescedBuffers = coalescedBuffers;
    }
    FakeBufferCoalescer.prototype.destroy = function (gl) {
        var e_3, _a, e_4, _b;
        try {
            for (var _c = __values(this.vertexBuffers), _d = _c.next(); !_d.done; _d = _c.next()) {
                var vertexBuffer = _d.value;
                gl.deleteBuffer(vertexBuffer);
            }
        } catch (e_3_1) {
            e_3 = { error: e_3_1 };
        } finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            } finally {
                if (e_3) throw e_3.error;
            }
        }
        try {
            for (var _e = __values(this.indexBuffers), _f = _e.next(); !_f.done; _f = _e.next()) {
                var indexBuffer = _f.value;
                gl.deleteBuffer(indexBuffer);
            }
        } catch (e_4_1) {
            e_4 = { error: e_4_1 };
        } finally {
            try {
                if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
            } finally {
                if (e_4) throw e_4.error;
            }
        }
    };
    return FakeBufferCoalescer;
}();
exports.FakeBufferCoalescer = FakeBufferCoalescer;
var BufferCoalescer = /** @class */function () {
    function BufferCoalescer(gl, vertexDatas, indexDatas) {
        this.vertexBuffer = null;
        this.indexBuffer = null;
        util_1.assert(vertexDatas.length === indexDatas.length);
        // Don't do anything if we have no data to care about.
        if (vertexDatas.length === 0) return;
        var vertexCoalescedBuffers = coalesceBuffer(gl, gl.ARRAY_BUFFER, vertexDatas);
        var indexCoalescedBuffers = coalesceBuffer(gl, gl.ELEMENT_ARRAY_BUFFER, indexDatas);
        var coalescedBuffers = [];
        for (var i = 0; i < vertexCoalescedBuffers.length; i++) {
            var vertexBuffer = vertexCoalescedBuffers[i];
            var indexBuffer = indexCoalescedBuffers[i];
            coalescedBuffers.push({ vertexBuffer: vertexBuffer, indexBuffer: indexBuffer });
        }
        this.coalescedBuffers = coalescedBuffers;
        this.vertexBuffer = this.coalescedBuffers[0].vertexBuffer.buffer;
        this.indexBuffer = this.coalescedBuffers[0].indexBuffer.buffer;
    }
    BufferCoalescer.prototype.destroy = function (gl) {
        if (this.vertexBuffer !== null) gl.deleteBuffer(this.vertexBuffer);
        if (this.indexBuffer !== null) gl.deleteBuffer(this.indexBuffer);
    };
    return BufferCoalescer;
}();
exports.default = BufferCoalescer;
},{"./util":"util.ts"}],"gx\\gx_render.ts":[function(require,module,exports) {
"use strict";
// Common helpers for GX rendering.

var __values = this && this.__values || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator],
        i = 0;
    if (m) return m.call(o);
    return {
        next: function next() {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
var __importStar = this && this.__importStar || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) {
        if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    }result["default"] = mod;
    return result;
};
var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var gl_matrix_1 = require("gl-matrix");
var GX = __importStar(require("../gx/gx_enum"));
var GX_Material = __importStar(require("../gx/gx_material"));
var GX_Texture = __importStar(require("../gx/gx_texture"));
var util_1 = require("../util");
var gx_displaylist_1 = require("./gx_displaylist");
var BufferCoalescer_1 = __importDefault(require("../BufferCoalescer"));
var ArrayBufferSlice_1 = __importDefault(require("../ArrayBufferSlice"));
var SceneParams = /** @class */function () {
    function SceneParams() {
        this.u_Projection = gl_matrix_1.mat4.create();
        // u_Misc0
        this.u_SceneTextureLODBias = 0;
    }
    return SceneParams;
}();
exports.SceneParams = SceneParams;
var TextureMapping = /** @class */function () {
    function TextureMapping() {
        this.glTexture = null;
        this.glSampler = null;
        this.width = 0;
        this.height = 0;
        this.lodBias = 0;
        // GL fucking sucks. This is a convenience when building texture matrices.
        // gx_render does *not* use this parameter at all!
        this.flipY = false;
    }
    return TextureMapping;
}();
exports.TextureMapping = TextureMapping;
var MaterialParams = /** @class */function () {
    function MaterialParams() {
        this.m_TextureMapping = util_1.nArray(8, function () {
            return new TextureMapping();
        });
        this.u_ColorMatReg = util_1.nArray(2, function () {
            return new GX_Material.Color();
        });
        this.u_ColorAmbReg = util_1.nArray(2, function () {
            return new GX_Material.Color();
        });
        this.u_KonstColor = util_1.nArray(4, function () {
            return new GX_Material.Color();
        });
        this.u_Color = util_1.nArray(4, function () {
            return new GX_Material.Color();
        });
        this.u_TexMtx = util_1.nArray(10, function () {
            return gl_matrix_1.mat4.create();
        }); // mat4x3
        this.u_PostTexMtx = util_1.nArray(20, function () {
            return gl_matrix_1.mat4.create();
        }); // mat4x3
        this.u_IndTexMtx = util_1.nArray(3, function () {
            return gl_matrix_1.mat2d.create();
        }); // mat4x2
    }
    return MaterialParams;
}();
exports.MaterialParams = MaterialParams;
var PacketParams = /** @class */function () {
    function PacketParams() {
        this.u_PosMtx = util_1.nArray(10, function () {
            return gl_matrix_1.mat4.create();
        });
    }
    return PacketParams;
}();
exports.PacketParams = PacketParams;
exports.u_PacketParamsBufferSize = 4 * 3 * 10;
exports.u_MaterialParamsBufferSize = 4 * 2 + 4 * 2 + 4 * 4 + 4 * 4 + 4 * 3 * 10 + 4 * 3 * 20 + 4 * 2 * 3 + 4 * 8;
exports.u_SceneParamsBufferSize = 4 * 4 + 4;
function fillVec4(d, offs, v0, v1, v2, v3) {
    if (v1 === void 0) {
        v1 = 0;
    }
    if (v2 === void 0) {
        v2 = 0;
    }
    if (v3 === void 0) {
        v3 = 0;
    }
    d[offs + 0] = v0;
    d[offs + 1] = v1;
    d[offs + 2] = v2;
    d[offs + 3] = v3;
    return 4;
}
function fillColor(d, offs, c) {
    d[offs + 0] = c.r;
    d[offs + 1] = c.g;
    d[offs + 2] = c.b;
    d[offs + 3] = c.a;
    return 4;
}
// All of our matrices are row-major.
function fillMatrix4x4(d, offs, m) {
    d[offs + 0] = m[0];
    d[offs + 1] = m[4];
    d[offs + 2] = m[8];
    d[offs + 3] = m[12];
    d[offs + 4] = m[1];
    d[offs + 5] = m[5];
    d[offs + 6] = m[9];
    d[offs + 7] = m[13];
    d[offs + 8] = m[2];
    d[offs + 9] = m[6];
    d[offs + 10] = m[10];
    d[offs + 11] = m[14];
    d[offs + 12] = m[3];
    d[offs + 13] = m[7];
    d[offs + 14] = m[11];
    d[offs + 15] = m[15];
    return 4 * 4;
}
function fillMatrix4x3(d, offs, m) {
    d[offs + 0] = m[0];
    d[offs + 1] = m[4];
    d[offs + 2] = m[8];
    d[offs + 3] = m[12];
    d[offs + 4] = m[1];
    d[offs + 5] = m[5];
    d[offs + 6] = m[9];
    d[offs + 7] = m[13];
    d[offs + 8] = m[2];
    d[offs + 9] = m[6];
    d[offs + 10] = m[10];
    d[offs + 11] = m[14];
    return 4 * 3;
}
function fillMatrix3x2(d, offs, m) {
    // 3x2 matrices are actually sent across as 4x2.
    var ma = m[0],
        mb = m[1];
    var mc = m[2],
        md = m[3];
    var mx = m[4],
        my = m[5];
    d[offs + 0] = ma;
    d[offs + 1] = mc;
    d[offs + 2] = mx;
    d[offs + 3] = 0;
    d[offs + 4] = mb;
    d[offs + 5] = md;
    d[offs + 6] = my;
    d[offs + 7] = 0;
    return 4 * 2;
}
function fillSceneParamsData(d, sceneParams) {
    var offs = 0;
    offs += fillMatrix4x4(d, offs, sceneParams.u_Projection);
    // u_Misc0
    offs += fillVec4(d, offs, sceneParams.u_SceneTextureLODBias);
    util_1.assert(offs === exports.u_SceneParamsBufferSize);
    util_1.assert(d.length >= offs);
}
exports.fillSceneParamsData = fillSceneParamsData;
function fillMaterialParamsData(d, materialParams) {
    // Texture mapping requires special effort.
    var offs = 0;
    for (var i = 0; i < 2; i++) {
        offs += fillColor(d, offs, materialParams.u_ColorMatReg[i]);
    }for (var i = 0; i < 2; i++) {
        offs += fillColor(d, offs, materialParams.u_ColorAmbReg[i]);
    }for (var i = 0; i < 4; i++) {
        offs += fillColor(d, offs, materialParams.u_KonstColor[i]);
    }for (var i = 0; i < 4; i++) {
        offs += fillColor(d, offs, materialParams.u_Color[i]);
    }for (var i = 0; i < 10; i++) {
        offs += fillMatrix4x3(d, offs, materialParams.u_TexMtx[i]);
    }for (var i = 0; i < 20; i++) {
        offs += fillMatrix4x3(d, offs, materialParams.u_PostTexMtx[i]);
    }for (var i = 0; i < 3; i++) {
        offs += fillMatrix3x2(d, offs, materialParams.u_IndTexMtx[i]);
    }for (var i = 0; i < 8; i++) {
        offs += fillVec4(d, offs, materialParams.m_TextureMapping[i].width, materialParams.m_TextureMapping[i].height, 0, materialParams.m_TextureMapping[i].lodBias);
    }util_1.assert(offs === exports.u_MaterialParamsBufferSize);
    util_1.assert(d.length >= offs);
}
exports.fillMaterialParamsData = fillMaterialParamsData;
function fillPacketParamsData(d, packetParams) {
    var offs = 0;
    for (var i = 0; i < 10; i++) {
        offs += fillMatrix4x3(d, offs, packetParams.u_PosMtx[i]);
    }util_1.assert(offs === exports.u_PacketParamsBufferSize);
    util_1.assert(d.length >= offs);
}
exports.fillPacketParamsData = fillPacketParamsData;
var bufferDataScratchSize = Math.max(exports.u_PacketParamsBufferSize, exports.u_MaterialParamsBufferSize, exports.u_SceneParamsBufferSize);
var GXRenderHelper = /** @class */function () {
    function GXRenderHelper(gl) {
        this.bufferDataScratch = new Float32Array(bufferDataScratchSize);
        this.sceneParamsBuffer = gl.createBuffer();
        this.materialParamsBuffer = gl.createBuffer();
        this.packetParamsBuffer = gl.createBuffer();
    }
    GXRenderHelper.prototype.bindSceneParams = function (state, params) {
        var gl = state.gl;
        fillSceneParamsData(this.bufferDataScratch, params);
        gl.bindBuffer(gl.UNIFORM_BUFFER, this.sceneParamsBuffer);
        gl.bufferData(gl.UNIFORM_BUFFER, this.bufferDataScratch, gl.DYNAMIC_DRAW);
    };
    GXRenderHelper.prototype.bindMaterialParams = function (state, params) {
        var gl = state.gl;
        fillMaterialParamsData(this.bufferDataScratch, params);
        gl.bindBuffer(gl.UNIFORM_BUFFER, this.materialParamsBuffer);
        gl.bufferData(gl.UNIFORM_BUFFER, this.bufferDataScratch, gl.DYNAMIC_DRAW);
    };
    GXRenderHelper.prototype.bindPacketParams = function (state, params) {
        var gl = state.gl;
        fillPacketParamsData(this.bufferDataScratch, params);
        gl.bindBuffer(gl.UNIFORM_BUFFER, this.packetParamsBuffer);
        gl.bufferData(gl.UNIFORM_BUFFER, this.bufferDataScratch, gl.DYNAMIC_DRAW);
    };
    GXRenderHelper.prototype.bindMaterialTextureMapping = function (state, textureMapping, prog) {
        var gl = state.gl;
        util_1.assert(prog === state.currentProgram);
        for (var i = 0; i < 8; i++) {
            var m = textureMapping[i];
            if (m.glTexture === null) continue;
            gl.activeTexture(gl.TEXTURE0 + i);
            gl.bindTexture(gl.TEXTURE_2D, m.glTexture);
            gl.bindSampler(i, m.glSampler);
        }
        prog.bindTextureSamplerIdentities(gl);
    };
    GXRenderHelper.prototype.bindMaterialTextures = function (state, materialParams, prog) {
        var gl = state.gl;
        this.bindMaterialTextureMapping(state, materialParams.m_TextureMapping, prog);
    };
    GXRenderHelper.prototype.bindUniformBuffers = function (state) {
        var gl = state.gl;
        gl.bindBufferBase(gl.UNIFORM_BUFFER, GX_Material.GX_Program.ub_SceneParams, this.sceneParamsBuffer);
        gl.bindBufferBase(gl.UNIFORM_BUFFER, GX_Material.GX_Program.ub_MaterialParams, this.materialParamsBuffer);
        gl.bindBufferBase(gl.UNIFORM_BUFFER, GX_Material.GX_Program.ub_PacketParams, this.packetParamsBuffer);
    };
    GXRenderHelper.prototype.destroy = function (gl) {
        gl.deleteBuffer(this.packetParamsBuffer);
        gl.deleteBuffer(this.materialParamsBuffer);
        gl.deleteBuffer(this.sceneParamsBuffer);
    };
    return GXRenderHelper;
}();
exports.GXRenderHelper = GXRenderHelper;
function translateAttribType(gl, attribFormat) {
    switch (attribFormat) {
        case gx_displaylist_1.AttributeFormat.U8:
            return { type: gl.UNSIGNED_BYTE, normalized: false };
        case gx_displaylist_1.AttributeFormat.U16:
            return { type: gl.UNSIGNED_SHORT, normalized: false };
        case gx_displaylist_1.AttributeFormat.F32:
            return { type: gl.FLOAT, normalized: false };
        default:
            throw "whoops";
    }
}
var GXShapeHelper = /** @class */function () {
    function GXShapeHelper(gl, coalescedBuffers, loadedVertexLayout, loadedVertexData) {
        this.coalescedBuffers = coalescedBuffers;
        this.loadedVertexLayout = loadedVertexLayout;
        this.loadedVertexData = loadedVertexData;
        util_1.assert(this.loadedVertexData.indexFormat === gx_displaylist_1.AttributeFormat.U16);
        this.vao = gl.createVertexArray();
        gl.bindVertexArray(this.vao);
        gl.bindBuffer(gl.ARRAY_BUFFER, coalescedBuffers.vertexBuffer.buffer);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, coalescedBuffers.indexBuffer.buffer);
        var _loop_1 = function _loop_1(vtxAttrib) {
            var attribLocation = GX_Material.getVertexAttribLocation(vtxAttrib);
            // TODO(jstpierre): Handle TEXMTXIDX attributes.
            if (attribLocation === -1) return "continue";
            var attribGenDef = GX_Material.getVertexAttribGenDef(vtxAttrib);
            var attrib = this_1.loadedVertexLayout.dstVertexAttributeLayouts.find(function (attrib) {
                return attrib.vtxAttrib === vtxAttrib;
            });
            if (attrib !== undefined) {
                var _a = translateAttribType(gl, attrib.format),
                    type = _a.type,
                    normalized = _a.normalized;
                var stride = this_1.loadedVertexLayout.dstVertexSize;
                var offset = coalescedBuffers.vertexBuffer.offset + attrib.offset;
                gl.enableVertexAttribArray(attribLocation);
                switch (attribGenDef.storage) {
                    case 'uint':
                        gl.vertexAttribIPointer(attribLocation, attrib.componentCount, type, stride, offset);
                        break;
                    case 'vec2':
                    case 'vec3':
                    case 'vec4':
                        gl.vertexAttribPointer(attribLocation, attrib.componentCount, type, normalized, stride, offset);
                        break;
                    default:
                        throw "whoops";
                }
            } else {
                // Set default.
                switch (attribGenDef.storage) {
                    case 'uint':
                        gl.vertexAttribI4ui(attribLocation, 0, 0, 0, 0);
                    case 'vec2':
                    case 'vec3':
                    case 'vec4':
                        // Float defaults don't need to be initialized in GLES.
                        break;
                    default:
                        throw "whoops";
                }
            }
        };
        var this_1 = this;
        for (var vtxAttrib = 0; vtxAttrib < GX.VertexAttribute.MAX; vtxAttrib++) {
            _loop_1(vtxAttrib);
        }
        gl.bindVertexArray(null);
    }
    GXShapeHelper.prototype.destroy = function (gl) {
        gl.deleteVertexArray(this.vao);
    };
    GXShapeHelper.prototype.drawPrologue = function (gl) {
        gl.bindVertexArray(this.vao);
    };
    GXShapeHelper.prototype.drawEpilogue = function (gl) {
        gl.bindVertexArray(null);
    };
    GXShapeHelper.prototype.drawTriangles = function (gl, firstTriangle, numTriangles) {
        var firstVertex = firstTriangle * 3;
        var numVertices = numTriangles * 3;
        var indexType = gl.UNSIGNED_SHORT,
            indexByteSize = 2;
        var indexBufferOffset = this.coalescedBuffers.indexBuffer.offset + firstVertex * indexByteSize;
        gl.drawElements(gl.TRIANGLES, numVertices, indexType, indexBufferOffset);
    };
    GXShapeHelper.prototype.drawSimple = function (gl) {
        this.drawPrologue(gl);
        this.drawTriangles(gl, 0, this.loadedVertexData.totalTriangleCount);
        this.drawEpilogue(gl);
    };
    return GXShapeHelper;
}();
exports.GXShapeHelper = GXShapeHelper;
// Mip levels in GX are assumed to be relative to the GameCube's embedded framebuffer (EFB) size,
// which is hardcoded to be 640x528. We need to bias our mipmap LOD selection by this amount to
// make sure textures are sampled correctly...
function getTextureLODBias(state) {
    var viewportWidth = state.onscreenColorTarget.width;
    var viewportHeight = state.onscreenColorTarget.height;
    var textureLODBias = Math.log2(Math.min(viewportWidth / GX_Material.EFB_WIDTH, viewportHeight / GX_Material.EFB_HEIGHT));
    return textureLODBias;
}
exports.getTextureLODBias = getTextureLODBias;
function fillSceneParamsFromRenderState(sceneParams, state) {
    gl_matrix_1.mat4.copy(sceneParams.u_Projection, state.camera.projectionMatrix);
    sceneParams.u_SceneTextureLODBias = getTextureLODBias(state);
}
exports.fillSceneParamsFromRenderState = fillSceneParamsFromRenderState;
function loadedDataCoalescer(gl, loadedVertexDatas) {
    return new BufferCoalescer_1.default(gl, loadedVertexDatas.map(function (data) {
        return new ArrayBufferSlice_1.default(data.packedVertexData);
    }), loadedVertexDatas.map(function (data) {
        return new ArrayBufferSlice_1.default(data.indexData);
    }));
}
exports.loadedDataCoalescer = loadedDataCoalescer;
function loadTextureFromMipChain(gl, mipChain) {
    var glTexture = gl.createTexture();
    glTexture.name = mipChain.name;
    gl.bindTexture(gl.TEXTURE_2D, glTexture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAX_LEVEL, mipChain.mipLevels.length - 1);
    var surfaces = [];
    var _loop_2 = function _loop_2(i) {
        var level = i;
        var mipLevel = mipChain.mipLevels[i];
        var canvas = document.createElement('canvas');
        canvas.width = mipLevel.width;
        canvas.height = mipLevel.height;
        canvas.title = mipLevel.name;
        surfaces.push(canvas);
        GX_Texture.decodeTexture(mipLevel).then(function (rgbaTexture) {
            gl.bindTexture(gl.TEXTURE_2D, glTexture);
            gl.texImage2D(gl.TEXTURE_2D, level, gl.RGBA8, mipLevel.width, mipLevel.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, rgbaTexture.pixels);
            var ctx = canvas.getContext('2d');
            var imgData = new ImageData(mipLevel.width, mipLevel.height);
            imgData.data.set(new Uint8Array(rgbaTexture.pixels.buffer));
            ctx.putImageData(imgData, 0, 0);
        });
    };
    for (var i = 0; i < mipChain.mipLevels.length; i++) {
        _loop_2(i);
    }
    var viewerExtraInfo = new Map();
    viewerExtraInfo.set('Format', GX_Texture.getFormatName(mipChain.mipLevels[0].format));
    var viewerTexture = { name: mipChain.name, surfaces: surfaces, extraInfo: viewerExtraInfo };
    return { glTexture: glTexture, viewerTexture: viewerTexture };
}
exports.loadTextureFromMipChain = loadTextureFromMipChain;
function translateTexFilter(gl, texFilter) {
    switch (texFilter) {
        case GX.TexFilter.LIN_MIP_NEAR:
            return gl.LINEAR_MIPMAP_NEAREST;
        case GX.TexFilter.LIN_MIP_LIN:
            return gl.LINEAR_MIPMAP_LINEAR;
        case GX.TexFilter.LINEAR:
            return gl.LINEAR;
        case GX.TexFilter.NEAR_MIP_NEAR:
            return gl.NEAREST_MIPMAP_NEAREST;
        case GX.TexFilter.NEAR_MIP_LIN:
            return gl.NEAREST_MIPMAP_LINEAR;
        case GX.TexFilter.NEAR:
            return gl.NEAREST;
    }
}
exports.translateTexFilter = translateTexFilter;
function translateWrapMode(gl, wrapMode) {
    switch (wrapMode) {
        case GX.WrapMode.CLAMP:
            return gl.CLAMP_TO_EDGE;
        case GX.WrapMode.MIRROR:
            return gl.MIRRORED_REPEAT;
        case GX.WrapMode.REPEAT:
            return gl.REPEAT;
    }
}
exports.translateWrapMode = translateWrapMode;
var TextureHolder = /** @class */function () {
    function TextureHolder() {
        this.viewerTextures = [];
        this.glTextures = [];
        this.textureEntries = [];
        this.textureOverrides = new Map();
    }
    TextureHolder.prototype.destroy = function (gl) {
        this.glTextures.forEach(function (texture) {
            return gl.deleteTexture(texture);
        });
    };
    // TODO(jstpierre): Optimize interface to not require an array construct every frame...
    TextureHolder.prototype.tryTextureNameVariants = function (name) {
        // Default implementation.
        return null;
    };
    TextureHolder.prototype.findTextureEntryIndex = function (name) {
        var nameVariants = this.tryTextureNameVariants(name);
        if (nameVariants !== null) {
            for (var j = 0; j < nameVariants.length; j++) {
                for (var i = 0; i < this.textureEntries.length; i++) {
                    if (this.textureEntries[i].name === nameVariants[j]) return i;
                }
            }
        } else {
            for (var i = 0; i < this.textureEntries.length; i++) {
                if (this.textureEntries[i].name === name) return i;
            }
        }
        // console.error("Cannot find texture", name);
        return -1;
    };
    TextureHolder.prototype.hasTexture = function (name) {
        return this.findTextureEntryIndex(name) >= 0;
    };
    TextureHolder.prototype.fillTextureMapping = function (textureMapping, name) {
        var textureOverride = this.textureOverrides.get(name);
        if (textureOverride) {
            textureMapping.glTexture = textureOverride.glTexture;
            textureMapping.width = textureOverride.width;
            textureMapping.height = textureOverride.height;
            textureMapping.flipY = textureOverride.flipY;
            return true;
        }
        var textureEntryIndex = this.findTextureEntryIndex(name);
        if (textureEntryIndex >= 0) {
            textureMapping.glTexture = this.glTextures[textureEntryIndex];
            var tex0Entry = this.textureEntries[textureEntryIndex];
            textureMapping.width = tex0Entry.width;
            textureMapping.height = tex0Entry.height;
            textureMapping.flipY = false;
            return true;
        }
        return false;
    };
    TextureHolder.prototype.setTextureOverride = function (name, textureOverride) {
        // Only allow setting texture overrides for textures that exist.
        // TODO(jstpierre): Bring this back when I fix ZTP scene loader.
        // if (!this.hasTexture(name))
        //    throw new Error(`Trying to override non-existent texture ${name}`);
        this.textureOverrides.set(name, textureOverride);
    };
    TextureHolder.prototype.addTextures = function (gl, textureEntries) {
        var e_1, _a;
        var _loop_3 = function _loop_3(texture) {
            // Don't add textures without data.
            if (texture.data === null) return "continue";
            // Don't add dupes for the same name.
            if (this_2.textureEntries.find(function (entry) {
                return entry.name === texture.name;
            }) !== undefined) return "continue";
            var mipChain = GX_Texture.calcMipChain(texture, texture.mipCount);
            var _a = loadTextureFromMipChain(gl, mipChain),
                glTexture = _a.glTexture,
                viewerTexture = _a.viewerTexture;
            this_2.textureEntries.push(texture);
            this_2.glTextures.push(glTexture);
            this_2.viewerTextures.push(viewerTexture);
        };
        var this_2 = this;
        try {
            for (var textureEntries_1 = __values(textureEntries), textureEntries_1_1 = textureEntries_1.next(); !textureEntries_1_1.done; textureEntries_1_1 = textureEntries_1.next()) {
                var texture = textureEntries_1_1.value;
                _loop_3(texture);
            }
        } catch (e_1_1) {
            e_1 = { error: e_1_1 };
        } finally {
            try {
                if (textureEntries_1_1 && !textureEntries_1_1.done && (_a = textureEntries_1.return)) _a.call(textureEntries_1);
            } finally {
                if (e_1) throw e_1.error;
            }
        }
    };
    return TextureHolder;
}();
exports.TextureHolder = TextureHolder;
},{"gl-matrix":"..\\node_modules\\gl-matrix\\src\\gl-matrix.js","../gx/gx_enum":"gx\\gx_enum.ts","../gx/gx_material":"gx\\gx_material.ts","../gx/gx_texture":"gx\\gx_texture.ts","../util":"util.ts","./gx_displaylist":"gx\\gx_displaylist.ts","../BufferCoalescer":"BufferCoalescer.ts","../ArrayBufferSlice":"ArrayBufferSlice.ts"}],"j3d\\render.ts":[function(require,module,exports) {
"use strict";

var __extends = this && this.__extends || function () {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
        d.__proto__ = b;
    } || function (d, b) {
        for (var p in b) {
            if (b.hasOwnProperty(p)) d[p] = b[p];
        }
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __values = this && this.__values || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator],
        i = 0;
    if (m) return m.call(o);
    return {
        next: function next() {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
var __importStar = this && this.__importStar || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) {
        if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    }result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var gl_matrix_1 = require("gl-matrix");
var j3d_1 = require("./j3d");
var GX_Material = __importStar(require("../gx/gx_material"));
var gx_render_1 = require("../gx/gx_render");
var Camera_1 = require("../Camera");
var J3DTextureHolder = /** @class */function (_super) {
    __extends(J3DTextureHolder, _super);
    function J3DTextureHolder() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    J3DTextureHolder.prototype.addJ3DTextures = function (gl, bmd, bmt) {
        if (bmt === void 0) {
            bmt = null;
        }
        this.addTextures(gl, bmd.tex1.textureDatas);
        if (bmt) this.addTextures(gl, bmt.tex1.textureDatas);
    };
    return J3DTextureHolder;
}(gx_render_1.TextureHolder);
exports.J3DTextureHolder = J3DTextureHolder;
function texProjPerspMtx(dst, fov, aspect, scaleS, scaleT, transS, transT) {
    var cot = 1 / Math.tan(fov / 2);
    dst[0] = cot / aspect * scaleS;
    dst[4] = 0.0;
    dst[8] = -transS;
    dst[12] = 0.0;
    dst[1] = 0.0;
    dst[5] = cot * scaleT;
    dst[9] = -transT;
    dst[13] = 0.0;
    dst[2] = 0.0;
    dst[6] = 0.0;
    dst[10] = -1.0;
    dst[14] = 0.0;
    // Fill with junk to try and signal when something has gone horribly wrong. This should go unused,
    // since this is supposed to generate a mat4x3 matrix.
    dst[3] = 9999.0;
    dst[7] = 9999.0;
    dst[11] = 9999.0;
    dst[15] = 9999.0;
}
function texProjOrthoMtx(dst, t, b, l, r, scaleS, scaleT, transS, transT) {
    var h = 1 / (r - l);
    dst[0] = 2.0 * h * scaleS;
    dst[4] = 0.0;
    dst[8] = 0.0;
    dst[12] = -(r + l) * h * scaleS + transS;
    var v = 1 / (t - b);
    dst[1] = 0.0;
    dst[5] = 2.0 * v * scaleT;
    dst[9] = -transT;
    dst[13] = -(t + b) * v * scaleT + transT;
    dst[2] = 0.0;
    dst[6] = 0.0;
    dst[10] = -1.0;
    dst[14] = 0.0;
    dst[3] = 0.0;
    dst[7] = 0.0;
    dst[11] = 0.0;
    dst[15] = 1.0;
}
var scratchModelMatrix = gl_matrix_1.mat4.create();
var scratchViewMatrix = gl_matrix_1.mat4.create();
var Command_Shape = /** @class */function () {
    function Command_Shape(gl, sceneLoader, scene, shape, coalescedBuffers) {
        this.scene = scene;
        this.shape = shape;
        this.packetParams = new gx_render_1.PacketParams();
        this.bboxScratch = new Camera_1.AABB();
        this.bmd = sceneLoader.bmd;
        this.shapeHelper = new gx_render_1.GXShapeHelper(gl, coalescedBuffers, this.shape.loadedVertexLayout, this.shape.loadedVertexData);
    }
    Command_Shape.prototype.computeModelView = function (state) {
        gl_matrix_1.mat4.copy(scratchModelMatrix, this.scene.modelMatrix);
        switch (this.shape.displayFlags) {
            case j3d_1.ShapeDisplayFlags.NORMAL:
            case j3d_1.ShapeDisplayFlags.USE_PNMTXIDX:
                // We should already be using PNMTXIDX in the normal case -- it's hardwired to 0.
                break;
            case j3d_1.ShapeDisplayFlags.BILLBOARD:
                Camera_1.computeModelMatrixBillboard(scratchModelMatrix, state.camera);
                gl_matrix_1.mat4.mul(scratchModelMatrix, this.scene.modelMatrix, scratchModelMatrix);
                break;
            case j3d_1.ShapeDisplayFlags.Y_BILLBOARD:
                Camera_1.computeModelMatrixYBillboard(scratchModelMatrix, state.camera);
                gl_matrix_1.mat4.mul(scratchModelMatrix, this.scene.modelMatrix, scratchModelMatrix);
                break;
            default:
                throw new Error("whoops");
        }
        if (this.scene.isSkybox) {
            Camera_1.computeViewMatrixSkybox(scratchViewMatrix, state.camera);
        } else {
            Camera_1.computeViewMatrix(scratchViewMatrix, state.camera);
        }
        gl_matrix_1.mat4.mul(scratchViewMatrix, scratchViewMatrix, scratchModelMatrix);
        return scratchViewMatrix;
    };
    Command_Shape.prototype.exec = function (state) {
        if (!this.scene.currentMaterialCommand.visible) return;
        var gl = state.gl;
        this.shapeHelper.drawPrologue(gl);
        var modelView = this.computeModelView(state);
        var needsUpload = false;
        var posMtxVisibility = new Array(10);
        for (var p = 0; p < this.shape.packets.length; p++) {
            var packet = this.shape.packets[p];
            // Update our matrix table.
            for (var i = 0; i < packet.matrixTable.length; i++) {
                var matrixIndex = packet.matrixTable[i];
                // Leave existing matrix.
                if (matrixIndex === 0xFFFF) continue;
                var posMtx = this.scene.weightedJointMatrices[matrixIndex];
                posMtxVisibility[i] = this.scene.matrixVisibility[matrixIndex];
                gl_matrix_1.mat4.mul(this.packetParams.u_PosMtx[i], modelView, posMtx);
                needsUpload = true;
            }
            // If all matrices are invisible, we can cull.
            var frustumCull = true;
            for (var i = 0; i < posMtxVisibility.length; i++) {
                if (posMtxVisibility[i] !== Camera_1.IntersectionState.FULLY_OUTSIDE) {
                    frustumCull = false;
                    break;
                }
            }
            if (frustumCull) return;
            if (needsUpload) {
                this.scene.renderHelper.bindPacketParams(state, this.packetParams);
                needsUpload = false;
            }
            this.shapeHelper.drawTriangles(gl, packet.firstTriangle, packet.numTriangles);
        }
        this.shapeHelper.drawEpilogue(gl);
    };
    Command_Shape.prototype.destroy = function (gl) {
        this.shapeHelper.destroy(gl);
    };
    return Command_Shape;
}();
var Command_Material = /** @class */function () {
    function Command_Material(gl, scene, material) {
        this.visible = true;
        this.name = material.name;
        this.scene = scene;
        this.material = material;
        this.program = new GX_Material.GX_Program(material.gxMaterial);
        this.program.name = this.name;
        this.renderFlags = GX_Material.translateRenderFlags(this.material.gxMaterial);
    }
    Command_Material.prototype.exec = function (state) {
        this.scene.currentMaterialCommand = this;
        if (!this.scene.currentMaterialCommand.visible) return;
        state.useProgram(this.program);
        state.useFlags(this.renderFlags);
        var materialParams = Command_Material.materialParams;
        this.fillMaterialParams(materialParams, state);
        this.scene.renderHelper.bindMaterialParams(state, materialParams);
        this.scene.renderHelper.bindMaterialTextures(state, materialParams, this.program);
    };
    Command_Material.prototype.destroy = function (gl) {
        this.program.destroy(gl);
    };
    Command_Material.prototype.fillMaterialParams = function (materialParams, state) {
        var _this = this;
        var animationFrame = this.scene.getTimeInFrames(state.time);
        var copyColor = function copyColor(i, dst, fallbackColor) {
            // First, check for a color animation.
            if (_this.scene.brk !== null) {
                if (_this.scene.brk.calcColorOverride(dst, _this.material.name, i, animationFrame)) return;
            }
            var color;
            if (_this.scene.colorOverrides[i]) {
                color = _this.scene.colorOverrides[i];
            } else {
                color = fallbackColor;
            }
            var alpha;
            if (_this.scene.alphaOverrides[i] !== undefined) {
                alpha = _this.scene.alphaOverrides[i];
            } else {
                alpha = fallbackColor.a;
            }
            dst.copy(color, alpha);
        };
        copyColor(ColorOverride.MAT0, materialParams.u_ColorMatReg[0], this.material.colorMatRegs[0]);
        copyColor(ColorOverride.MAT1, materialParams.u_ColorMatReg[1], this.material.colorMatRegs[1]);
        copyColor(ColorOverride.AMB0, materialParams.u_ColorAmbReg[0], this.material.colorAmbRegs[0]);
        copyColor(ColorOverride.AMB1, materialParams.u_ColorAmbReg[1], this.material.colorAmbRegs[1]);
        copyColor(ColorOverride.K0, materialParams.u_KonstColor[0], this.material.gxMaterial.colorConstants[0]);
        copyColor(ColorOverride.K1, materialParams.u_KonstColor[1], this.material.gxMaterial.colorConstants[1]);
        copyColor(ColorOverride.K2, materialParams.u_KonstColor[2], this.material.gxMaterial.colorConstants[2]);
        copyColor(ColorOverride.K3, materialParams.u_KonstColor[3], this.material.gxMaterial.colorConstants[3]);
        copyColor(ColorOverride.CPREV, materialParams.u_Color[0], this.material.gxMaterial.colorRegisters[0]);
        copyColor(ColorOverride.C0, materialParams.u_Color[1], this.material.gxMaterial.colorRegisters[1]);
        copyColor(ColorOverride.C1, materialParams.u_Color[2], this.material.gxMaterial.colorRegisters[2]);
        copyColor(ColorOverride.C2, materialParams.u_Color[3], this.material.gxMaterial.colorRegisters[3]);
        // Bind textures.
        for (var i = 0; i < this.material.textureIndexes.length; i++) {
            var texIndex = this.material.textureIndexes[i];
            if (texIndex >= 0) {
                this.scene.fillTextureMapping(materialParams.m_TextureMapping[i], texIndex);
            } else {
                materialParams.m_TextureMapping[i].glTexture = null;
            }
        }
        // Bind our texture matrices.
        var scratch = Command_Material.matrixScratch;
        for (var i = 0; i < this.material.texMatrices.length; i++) {
            var texMtx = this.material.texMatrices[i];
            if (texMtx === null) continue;
            var dst = materialParams.u_TexMtx[i];
            var flipY = materialParams.m_TextureMapping[i].flipY;
            var flipYScale = flipY ? -1.0 : 1.0;
            // First, compute input matrix.
            switch (texMtx.type) {
                case 0x00:
                case 0x01: // Delfino Plaza
                case 0x0B: // Luigi Circuit
                case 0x08:
                    // Peach Beach.
                    // No mapping.
                    gl_matrix_1.mat4.identity(dst);
                    break;
                case 0x06: // Rainbow Road
                case 0x07:
                    // Rainbow Road
                    // Environment mapping. Uses the normal matrix.
                    // Normal matrix. Emulated here by the view matrix with the translation lopped off...
                    gl_matrix_1.mat4.copy(dst, state.view);
                    dst[12] = 0;
                    dst[13] = 0;
                    dst[14] = 0;
                    break;
                case 0x09:
                    // Projection. Used for indtexwater, mostly.
                    gl_matrix_1.mat4.copy(dst, state.view);
                    break;
                default:
                    throw "whoops";
            }
            // Now apply effects.
            switch (texMtx.type) {
                case 0x00:
                case 0x01:
                case 0x0B:
                    break;
                case 0x06:
                    // Rainbow Road
                    // Environment mapping
                    Camera_1.texEnvMtx(scratch, -0.5, -0.5 * flipYScale, 0.5, 0.5);
                    gl_matrix_1.mat4.mul(dst, scratch, dst);
                    gl_matrix_1.mat4.mul(dst, texMtx.effectMatrix, dst);
                    break;
                case 0x07: // Rainbow Road
                case 0x08:
                    // Peach Beach
                    gl_matrix_1.mat4.mul(dst, texMtx.effectMatrix, dst);
                    texProjPerspMtx(scratch, state.fov, state.getAspect(), 0.5, -0.5 * flipYScale, 0.5, 0.5);
                    gl_matrix_1.mat4.mul(dst, scratch, dst);
                    break;
                case 0x09:
                    // Rainbow Road
                    // Perspective.
                    // Don't apply effectMatrix to perspective. It appears to be
                    // a projection matrix preconfigured for GC.
                    // mat4.mul(dst, texMtx.effectMatrix, dst);
                    texProjPerspMtx(scratch, state.fov, state.getAspect(), 0.5, -0.5 * flipYScale, 0.5, 0.5);
                    gl_matrix_1.mat4.mul(dst, scratch, dst);
                    break;
                default:
                    throw "whoops";
            }
            // Apply SRT.
            gl_matrix_1.mat4.copy(scratch, texMtx.matrix);
            if (this.scene.btk !== null) this.scene.btk.calcAnimatedTexMtx(scratch, this.material.name, i, animationFrame);
            // SRT matrices have translation in fourth component, but we want our matrix to have translation
            // in third component. Swap.
            var tx = scratch[12];
            scratch[12] = scratch[8];
            scratch[8] = tx;
            var ty = scratch[13];
            scratch[13] = scratch[9];
            scratch[9] = ty;
            gl_matrix_1.mat4.mul(dst, scratch, dst);
        }
        for (var i = 0; i < this.material.postTexMatrices.length; i++) {
            var postTexMtx = this.material.postTexMatrices[i];
            if (postTexMtx === null) continue;
            var finalMatrix = postTexMtx.matrix;
            gl_matrix_1.mat4.copy(materialParams.u_PostTexMtx[i], finalMatrix);
        }
        for (var i = 0; i < this.material.indTexMatrices.length; i++) {
            var indTexMtx = this.material.indTexMatrices[i];
            if (indTexMtx === null) continue;
            var a = indTexMtx[0],
                c = indTexMtx[1],
                tx = indTexMtx[2];
            var b = indTexMtx[3],
                d = indTexMtx[4],
                ty = indTexMtx[5];
            gl_matrix_1.mat2d.set(materialParams.u_IndTexMtx[i], a, b, c, d, tx, ty);
        }
    };
    Command_Material.matrixScratch = gl_matrix_1.mat4.create();
    Command_Material.materialParams = new gx_render_1.MaterialParams();
    return Command_Material;
}();
exports.Command_Material = Command_Material;
var ColorOverride;
(function (ColorOverride) {
    ColorOverride[ColorOverride["MAT0"] = 0] = "MAT0";
    ColorOverride[ColorOverride["MAT1"] = 1] = "MAT1";
    ColorOverride[ColorOverride["AMB0"] = 2] = "AMB0";
    ColorOverride[ColorOverride["AMB1"] = 3] = "AMB1";
    ColorOverride[ColorOverride["K0"] = 4] = "K0";
    ColorOverride[ColorOverride["K1"] = 5] = "K1";
    ColorOverride[ColorOverride["K2"] = 6] = "K2";
    ColorOverride[ColorOverride["K3"] = 7] = "K3";
    ColorOverride[ColorOverride["CPREV"] = 8] = "CPREV";
    ColorOverride[ColorOverride["C0"] = 9] = "C0";
    ColorOverride[ColorOverride["C1"] = 10] = "C1";
    ColorOverride[ColorOverride["C2"] = 11] = "C2";
})(ColorOverride = exports.ColorOverride || (exports.ColorOverride = {}));
var matrixScratch = gl_matrix_1.mat4.create(),
    matrixScratch2 = gl_matrix_1.mat4.create();
// SceneLoaderToken is a private class that's passed to Scene.
// Basically, this emulates an internal constructor by making
// it impossible to call...
var SceneLoaderToken = /** @class */function () {
    function SceneLoaderToken(gl) {
        this.gl = gl;
    }
    return SceneLoaderToken;
}();
var SceneLoader = /** @class */function () {
    function SceneLoader(textureHolder, bmd, bmt) {
        if (bmt === void 0) {
            bmt = null;
        }
        this.textureHolder = textureHolder;
        this.bmd = bmd;
        this.bmt = bmt;
    }
    SceneLoader.prototype.createScene = function (gl) {
        return new Scene(new SceneLoaderToken(gl), this);
    };
    return SceneLoader;
}();
exports.SceneLoader = SceneLoader;
var Scene = /** @class */function () {
    function Scene(sceneLoaderToken, sceneLoader) {
        this.name = '';
        this.visible = true;
        this.isSkybox = false;
        this.fps = 30;
        this.colorOverrides = [];
        this.alphaOverrides = [];
        this.sceneParams = new gx_render_1.SceneParams();
        // TODO(jstpierre): Make BMT settable after load...
        this.bmt = null;
        // Animations.
        this.bck = null;
        this.brk = null;
        this.btk = null;
        this.jointVisibility = [];
        this.matrixVisibility = [];
        this.bboxScratch = new Camera_1.AABB();
        var gl = sceneLoaderToken.gl;
        this.bmd = sceneLoader.bmd;
        this.bmt = sceneLoader.bmt;
        this.textureHolder = sceneLoader.textureHolder;
        // TODO(jstpierre): Remove textures from Scene onto MainScene.
        this.textures = this.textureHolder.viewerTextures;
        this.translateModel(gl, sceneLoader);
        this.renderHelper = new gx_render_1.GXRenderHelper(gl);
        this.modelMatrix = gl_matrix_1.mat4.create();
    }
    Scene.prototype.destroy = function (gl) {
        this.renderHelper.destroy(gl);
        this.bufferCoalescer.destroy(gl);
        this.materialCommands.forEach(function (command) {
            return command.destroy(gl);
        });
        this.shapeCommands.forEach(function (command) {
            return command.destroy(gl);
        });
        this.glSamplers.forEach(function (sampler) {
            return gl.deleteSampler(sampler);
        });
    };
    Scene.prototype.setColorOverride = function (i, color) {
        this.colorOverrides[i] = color;
    };
    Scene.prototype.setAlphaOverride = function (i, alpha) {
        this.alphaOverrides[i] = alpha;
    };
    Scene.prototype.setIsSkybox = function (v) {
        this.isSkybox = v;
    };
    Scene.prototype.setFPS = function (v) {
        this.fps = v;
    };
    Scene.prototype.setVisible = function (v) {
        this.visible = v;
    };
    Scene.prototype.setBCK = function (bck) {
        this.bck = bck;
    };
    Scene.prototype.setBRK = function (brk) {
        this.brk = brk;
    };
    Scene.prototype.setBTK = function (btk) {
        this.btk = btk;
    };
    Scene.prototype.fillTextureMapping = function (m, texIndex) {
        var tex1Sampler = this.tex1Samplers[texIndex];
        this.textureHolder.fillTextureMapping(m, tex1Sampler.name);
        m.glSampler = this.glSamplers[tex1Sampler.index];
        m.lodBias = tex1Sampler.lodBias;
    };
    Scene.prototype.getTimeInFrames = function (milliseconds) {
        return milliseconds / 1000 * this.fps;
    };
    Scene.prototype.bindState = function (state) {
        if (!this.visible) return false;
        state.setClipPlanes(20, 500000);
        // XXX(jstpierre): Is this the right place to do this? Need an explicit update call...
        this.updateJointMatrices(state);
        this.renderHelper.bindUniformBuffers(state);
        gx_render_1.fillSceneParamsFromRenderState(this.sceneParams, state);
        this.renderHelper.bindSceneParams(state, this.sceneParams);
        return true;
    };
    Scene.prototype.renderOpaque = function (state) {
        this.execCommands(state, this.opaqueCommands);
    };
    Scene.prototype.renderTransparent = function (state) {
        this.execCommands(state, this.transparentCommands);
    };
    Scene.prototype.render = function (state) {
        if (!this.bindState(state)) return;
        this.renderOpaque(state);
        this.renderTransparent(state);
    };
    Scene.prototype.execCommands = function (state, commands) {
        commands.forEach(function (command, i) {
            command.exec(state);
        });
    };
    Scene.translateSampler = function (gl, sampler) {
        var glSampler = gl.createSampler();
        gl.samplerParameteri(glSampler, gl.TEXTURE_MIN_FILTER, gx_render_1.translateTexFilter(gl, sampler.minFilter));
        gl.samplerParameteri(glSampler, gl.TEXTURE_MAG_FILTER, gx_render_1.translateTexFilter(gl, sampler.magFilter));
        gl.samplerParameteri(glSampler, gl.TEXTURE_WRAP_S, gx_render_1.translateWrapMode(gl, sampler.wrapS));
        gl.samplerParameteri(glSampler, gl.TEXTURE_WRAP_T, gx_render_1.translateWrapMode(gl, sampler.wrapT));
        gl.samplerParameterf(glSampler, gl.TEXTURE_MIN_LOD, sampler.minLOD);
        gl.samplerParameterf(glSampler, gl.TEXTURE_MAX_LOD, sampler.maxLOD);
        return glSampler;
    };
    Scene.prototype.translateTextures = function (gl, sceneLoader) {
        var e_1, _a;
        var tex1 = sceneLoader.bmt !== null ? sceneLoader.bmt.tex1 : sceneLoader.bmd.tex1;
        // TODO(jstpierre): How does separable textureData / sampler work with external
        // texture resolve?
        this.glSamplers = [];
        try {
            for (var _b = __values(tex1.samplers), _c = _b.next(); !_c.done; _c = _b.next()) {
                var sampler = _c.value;
                this.glSamplers.push(Scene.translateSampler(gl, sampler));
            }
        } catch (e_1_1) {
            e_1 = { error: e_1_1 };
        } finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally {
                if (e_1) throw e_1.error;
            }
        }
        this.tex1Samplers = tex1.samplers;
    };
    Scene.prototype.translateModel = function (gl, sceneLoader) {
        var _this = this;
        var e_2, _a;
        var bmd = sceneLoader.bmd;
        var bmt = sceneLoader.bmt;
        var mat3 = bmt !== null && bmt.mat3 !== null ? bmt.mat3 : bmd.mat3;
        this.opaqueCommands = [];
        this.transparentCommands = [];
        this.jointMatrices = [];
        for (var i = 0; i < bmd.jnt1.bones.length; i++) {
            this.jointMatrices[i] = gl_matrix_1.mat4.create();
        }this.weightedJointMatrices = [];
        try {
            for (var _b = __values(bmd.drw1.drw1Joints), _c = _b.next(); !_c.done; _c = _b.next()) {
                var drw1Joint = _c.value;
                this.weightedJointMatrices.push(gl_matrix_1.mat4.create());
            }
        } catch (e_2_1) {
            e_2 = { error: e_2_1 };
        } finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally {
                if (e_2) throw e_2.error;
            }
        }
        this.translateTextures(gl, sceneLoader);
        this.materialCommands = mat3.materialEntries.map(function (material) {
            return new Command_Material(gl, _this, material);
        });
        this.bufferCoalescer = gx_render_1.loadedDataCoalescer(gl, bmd.shp1.shapes.map(function (shape) {
            return shape.loadedVertexData;
        }));
        this.shapeCommands = bmd.shp1.shapes.map(function (shape, i) {
            return new Command_Shape(gl, sceneLoader, _this, shape, _this.bufferCoalescer.coalescedBuffers[i]);
        });
        // Iterate through scene graph.
        this.translateSceneGraph(bmd.inf1.sceneGraph, null);
    };
    Scene.prototype.translateSceneGraph = function (node, commandList) {
        var e_3, _a;
        switch (node.type) {
            case j3d_1.HierarchyType.Shape:
                commandList.push(this.shapeCommands[node.shapeIdx]);
                break;
            case j3d_1.HierarchyType.Material:
                var materialCommand = this.materialCommands[node.materialIdx];
                commandList = materialCommand.material.translucent ? this.transparentCommands : this.opaqueCommands;
                commandList.push(materialCommand);
                break;
        }
        try {
            for (var _b = __values(node.children), _c = _b.next(); !_c.done; _c = _b.next()) {
                var child = _c.value;
                this.translateSceneGraph(child, commandList);
            }
        } catch (e_3_1) {
            e_3 = { error: e_3_1 };
        } finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally {
                if (e_3) throw e_3.error;
            }
        }
    };
    Scene.prototype.updateJointMatrixHierarchy = function (state, node, parentJointMatrix) {
        // TODO(jstpierre): Don't pointer chase when traversing hierarchy every frame...
        var jnt1 = this.bmd.jnt1;
        var bbox = this.bboxScratch;
        switch (node.type) {
            case j3d_1.HierarchyType.Joint:
                var jointIndex = node.jointIdx;
                var boneMatrix = jnt1.bones[jointIndex].matrix;
                if (this.bck !== null) {
                    boneMatrix = matrixScratch2;
                    this.bck.calcJointMatrix(boneMatrix, jointIndex, this.getTimeInFrames(state.time));
                }
                var jointMatrix = this.jointMatrices[jointIndex];
                gl_matrix_1.mat4.mul(jointMatrix, parentJointMatrix, boneMatrix);
                bbox.transform(jnt1.bones[jointIndex].bbox, jointMatrix);
                this.jointVisibility[jointIndex] = state.camera.frustum.intersect(bbox);
                parentJointMatrix = jointMatrix;
                break;
        }
        for (var i = 0; i < node.children.length; i++) {
            this.updateJointMatrixHierarchy(state, node.children[i], parentJointMatrix);
        }
    };
    Scene.prototype.updateJointMatrices = function (state) {
        // First, update joint matrices from hierarchy.
        gl_matrix_1.mat4.identity(matrixScratch);
        this.updateJointMatrixHierarchy(state, this.bmd.inf1.sceneGraph, matrixScratch);
        // Update weighted joint matrices.
        for (var i = 0; i < this.bmd.drw1.drw1Joints.length; i++) {
            var joint = this.bmd.drw1.drw1Joints[i];
            var destMtx = this.weightedJointMatrices[i];
            if (joint.kind === j3d_1.DRW1JointKind.NormalJoint) {
                gl_matrix_1.mat4.copy(destMtx, this.jointMatrices[joint.jointIndex]);
                this.matrixVisibility[i] = this.jointVisibility[joint.jointIndex];
            } else if (joint.kind === j3d_1.DRW1JointKind.WeightedJoint) {
                destMtx.fill(0);
                var envelope = this.bmd.evp1.envelopes[joint.envelopeIndex];
                for (var i_1 = 0; i_1 < envelope.weightedBones.length; i_1++) {
                    var weightedBone = envelope.weightedBones[i_1];
                    var inverseBindPose = this.bmd.evp1.inverseBinds[weightedBone.index];
                    gl_matrix_1.mat4.mul(matrixScratch, this.jointMatrices[weightedBone.index], inverseBindPose);
                    gl_matrix_1.mat4.multiplyScalarAndAdd(destMtx, destMtx, matrixScratch, weightedBone.weight);
                }
                // TODO(jstpierre): Frustum cull weighted joints.
                this.matrixVisibility[i] = Camera_1.IntersectionState.FULLY_INSIDE;
            }
        }
    };
    return Scene;
}();
exports.Scene = Scene;
},{"gl-matrix":"..\\node_modules\\gl-matrix\\src\\gl-matrix.js","./j3d":"j3d\\j3d.ts","../gx/gx_material":"gx\\gx_material.ts","../gx/gx_render":"gx\\gx_render.ts","../Camera":"Camera.ts"}],"j3d\\j3d.ts":[function(require,module,exports) {
"use strict";
// Implements Nintendo's J3D formats (BMD, BDL, BTK, etc.)

var __values = this && this.__values || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator],
        i = 0;
    if (m) return m.call(o);
    return {
        next: function next() {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
var __read = this && this.__read || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o),
        r,
        ar = [],
        e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {
            ar.push(r.value);
        }
    } catch (error) {
        e = { error: error };
    } finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
            if (e) throw e.error;
        }
    }
    return ar;
};
var __importStar = this && this.__importStar || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) {
        if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    }result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var gl_matrix_1 = require("gl-matrix");
var endian_1 = require("../endian");
var util_1 = require("../util");
var gx_displaylist_1 = require("../gx/gx_displaylist");
var GX = __importStar(require("../gx/gx_enum"));
var GX_Material = __importStar(require("../gx/gx_material"));
var render_1 = require("./render");
var Camera_1 = require("../Camera");
function readStringTable(buffer, offs) {
    var view = buffer.createDataView(offs);
    var stringCount = view.getUint16(0x00);
    var tableIdx = 0x06;
    var strings = [];
    for (var i = 0; i < stringCount; i++) {
        var stringOffs = view.getUint16(tableIdx);
        var str = util_1.readString(buffer, offs + stringOffs, 255);
        strings.push(str);
        tableIdx += 0x04;
    }
    return strings;
}
//#region INF1
var HierarchyType;
(function (HierarchyType) {
    HierarchyType[HierarchyType["End"] = 0] = "End";
    HierarchyType[HierarchyType["Open"] = 1] = "Open";
    HierarchyType[HierarchyType["Close"] = 2] = "Close";
    HierarchyType[HierarchyType["Joint"] = 16] = "Joint";
    HierarchyType[HierarchyType["Material"] = 17] = "Material";
    HierarchyType[HierarchyType["Shape"] = 18] = "Shape";
})(HierarchyType = exports.HierarchyType || (exports.HierarchyType = {}));
function readINF1Chunk(buffer) {
    var view = buffer.createDataView();
    // unk
    var packetCount = view.getUint32(0x0C);
    var vertexCount = view.getUint32(0x10);
    var hierarchyOffs = view.getUint32(0x14);
    var node = { type: HierarchyType.End, children: [] };
    var parentStack = [node];
    var offs = hierarchyOffs;
    outer: while (true) {
        var type = view.getUint16(offs + 0x00);
        var value = view.getUint16(offs + 0x02);
        offs += 0x04;
        switch (type) {
            case HierarchyType.End:
                break outer;
            case HierarchyType.Open:
                parentStack.unshift(node);
                break;
            case HierarchyType.Close:
                node = parentStack.shift();
                break;
            case HierarchyType.Joint:
                node = { type: type, children: [], jointIdx: value };
                parentStack[0].children.unshift(node);
                break;
            case HierarchyType.Material:
                node = { type: type, children: [], materialIdx: value };
                parentStack[0].children.unshift(node);
                break;
            case HierarchyType.Shape:
                node = { type: type, children: [], shapeIdx: value };
                parentStack[0].children.unshift(node);
                break;
        }
    }
    util_1.assert(parentStack.length === 1);
    return { sceneGraph: parentStack.pop() };
}
function readVTX1Chunk(buffer) {
    var view = buffer.createDataView();
    var formatOffs = view.getUint32(0x08);
    var dataOffsLookupTable = 0x0C;
    // Data tables are stored in this order. Assumed to be hardcoded in a
    // struct somewhere inside JSystem.
    var dataTables = [GX.VertexAttribute.POS, GX.VertexAttribute.NRM, GX.VertexAttribute.NBT, GX.VertexAttribute.CLR0, GX.VertexAttribute.CLR1, GX.VertexAttribute.TEX0, GX.VertexAttribute.TEX1, GX.VertexAttribute.TEX2, GX.VertexAttribute.TEX3, GX.VertexAttribute.TEX4, GX.VertexAttribute.TEX5, GX.VertexAttribute.TEX6, GX.VertexAttribute.TEX7];
    var offs = formatOffs;
    var vertexArrays = new Map();
    while (true) {
        var vtxAttrib = view.getUint32(offs + 0x00);
        if (vtxAttrib === GX.VertexAttribute.NULL) break;
        var compCnt = view.getUint32(offs + 0x04);
        var compType = view.getUint32(offs + 0x08);
        var compShift = view.getUint8(offs + 0x0C);
        offs += 0x10;
        var formatIdx = dataTables.indexOf(vtxAttrib);
        if (formatIdx < 0) continue;
        // Each attrib in the VTX1 chunk also has a corresponding data chunk containing
        // the data for that attribute, in the format stored above.
        // BMD doesn't tell us how big each data chunk is, but we need to know to figure
        // out how much data to upload. We assume the data offset lookup table is sorted
        // in order, and can figure it out by finding the next offset above us.
        var dataOffsLookupTableEntry = dataOffsLookupTable + formatIdx * 0x04;
        var dataOffsLookupTableEnd = dataOffsLookupTable + dataTables.length * 0x04;
        var dataStart = view.getUint32(dataOffsLookupTableEntry);
        var dataEnd = getDataEnd(dataOffsLookupTableEntry, dataOffsLookupTableEnd);
        var dataOffs = dataStart;
        var dataSize = dataEnd - dataStart;
        var vtxDataBuffer = buffer.subarray(dataOffs, dataSize);
        var vertexArray = { vtxAttrib: vtxAttrib, compType: compType, compCnt: compCnt, compShift: compShift, dataOffs: dataOffs, dataSize: dataSize, buffer: vtxDataBuffer };
        vertexArrays.set(vtxAttrib, vertexArray);
    }
    function getDataEnd(dataOffsLookupTableEntry, dataOffsLookupTableEnd) {
        var offs = dataOffsLookupTableEntry + 0x04;
        while (offs < dataOffsLookupTableEnd) {
            var dataOffs = view.getUint32(offs);
            if (dataOffs !== 0) return dataOffs;
            offs += 0x04;
        }
        return buffer.byteLength;
    }
    return { vertexArrays: vertexArrays };
}
function readEVP1Chunk(buffer) {
    var view = buffer.createDataView();
    var envelopeTableCount = view.getUint16(0x08);
    var weightedBoneCountTableOffs = view.getUint32(0x0C);
    var weightedBoneIndexTableOffs = view.getUint32(0x10);
    var weightedBoneWeightTableOffs = view.getUint32(0x14);
    var inverseBindPoseTableOffs = view.getUint32(0x18);
    var weightedBoneId = 0;
    var maxBoneIndex = -1;
    var envelopes = [];
    for (var i = 0; i < envelopeTableCount; i++) {
        var numWeightedBones = view.getUint8(weightedBoneCountTableOffs + i);
        var weightedBones = [];
        for (var j = 0; j < numWeightedBones; j++) {
            var index = view.getUint16(weightedBoneIndexTableOffs + weightedBoneId * 0x02);
            var weight = view.getFloat32(weightedBoneWeightTableOffs + weightedBoneId * 0x04);
            weightedBones.push({ index: index, weight: weight });
            maxBoneIndex = Math.max(maxBoneIndex, index);
            weightedBoneId++;
        }
        envelopes.push({ weightedBones: weightedBones });
    }
    var inverseBinds = [];
    for (var i = 0; i < maxBoneIndex + 1; i++) {
        var offs = inverseBindPoseTableOffs + i * 0x30;
        var m00 = view.getFloat32(offs + 0x00);
        var m10 = view.getFloat32(offs + 0x04);
        var m20 = view.getFloat32(offs + 0x08);
        var m30 = view.getFloat32(offs + 0x0C);
        var m01 = view.getFloat32(offs + 0x10);
        var m11 = view.getFloat32(offs + 0x14);
        var m21 = view.getFloat32(offs + 0x18);
        var m31 = view.getFloat32(offs + 0x1C);
        var m02 = view.getFloat32(offs + 0x20);
        var m12 = view.getFloat32(offs + 0x24);
        var m22 = view.getFloat32(offs + 0x28);
        var m32 = view.getFloat32(offs + 0x2C);
        inverseBinds.push(gl_matrix_1.mat4.fromValues(m00, m01, m02, 0, m10, m11, m12, 0, m20, m21, m22, 0, m30, m31, m32, 1));
    }
    return { envelopes: envelopes, inverseBinds: inverseBinds };
}
//#endregion
//#region DRW1
var DRW1JointKind;
(function (DRW1JointKind) {
    DRW1JointKind[DRW1JointKind["NormalJoint"] = 0] = "NormalJoint";
    DRW1JointKind[DRW1JointKind["WeightedJoint"] = 1] = "WeightedJoint";
})(DRW1JointKind = exports.DRW1JointKind || (exports.DRW1JointKind = {}));
function readDRW1Chunk(buffer) {
    var view = buffer.createDataView();
    var weightedJointCount = view.getUint16(0x08);
    var isWeightedTableOffs = view.getUint32(0x0C);
    var jointIndexTableOffs = view.getUint32(0x10);
    var drw1Joints = [];
    for (var i = 0; i < weightedJointCount; i++) {
        var kind = view.getUint8(isWeightedTableOffs + i);
        var param = view.getUint16(jointIndexTableOffs + i * 0x02);
        if (kind === DRW1JointKind.NormalJoint) {
            drw1Joints.push({ kind: kind, jointIndex: param });
        } else if (kind === DRW1JointKind.WeightedJoint) {
            drw1Joints.push({ kind: kind, envelopeIndex: param });
        }
    }
    return { drw1Joints: drw1Joints };
}
var quatScratch = gl_matrix_1.quat.create();
function createJointMatrix(m, sx, sy, sz, rx, ry, rz, tx, ty, tz) {
    gl_matrix_1.quat.fromEuler(quatScratch, rx, ry, rz);
    gl_matrix_1.mat4.fromRotationTranslationScale(m, quatScratch, [tx, ty, tz], [sx, sy, sz]);
}
function readJNT1Chunk(buffer) {
    var view = buffer.createDataView();
    var boneDataCount = view.getUint16(0x08);
    util_1.assert(view.getUint16(0x0A) === 0xFFFF);
    var boneDataTableOffs = view.getUint32(0x0C);
    var remapTableOffs = view.getUint32(0x10);
    var remapTable = [];
    for (var i = 0; i < boneDataCount; i++) {
        remapTable[i] = view.getUint16(remapTableOffs + i * 0x02);
    }var nameTableOffs = view.getUint32(0x14);
    var nameTable = readStringTable(buffer, nameTableOffs);
    var bones = [];
    for (var i = 0; i < boneDataCount; i++) {
        var name = nameTable[i];
        var boneDataTableIdx = boneDataTableOffs + remapTable[i] * 0x40;
        var scaleX = view.getFloat32(boneDataTableIdx + 0x04);
        var scaleY = view.getFloat32(boneDataTableIdx + 0x08);
        var scaleZ = view.getFloat32(boneDataTableIdx + 0x0C);
        var rotationX = view.getInt16(boneDataTableIdx + 0x10) / 0x7FFF * 180;
        var rotationY = view.getInt16(boneDataTableIdx + 0x12) / 0x7FFF * 180;
        var rotationZ = view.getInt16(boneDataTableIdx + 0x14) / 0x7FFF * 180;
        var translationX = view.getFloat32(boneDataTableIdx + 0x18);
        var translationY = view.getFloat32(boneDataTableIdx + 0x1C);
        var translationZ = view.getFloat32(boneDataTableIdx + 0x20);
        var boundingSphereRadius = view.getFloat32(boneDataTableIdx + 0x24);
        var bboxMinX = view.getFloat32(boneDataTableIdx + 0x28);
        var bboxMinY = view.getFloat32(boneDataTableIdx + 0x2C);
        var bboxMinZ = view.getFloat32(boneDataTableIdx + 0x30);
        var bboxMaxX = view.getFloat32(boneDataTableIdx + 0x34);
        var bboxMaxY = view.getFloat32(boneDataTableIdx + 0x38);
        var bboxMaxZ = view.getFloat32(boneDataTableIdx + 0x3C);
        var bbox = new Camera_1.AABB(bboxMinX, bboxMinY, bboxMinZ, bboxMaxX, bboxMaxY, bboxMaxZ);
        var matrix = gl_matrix_1.mat4.create();
        createJointMatrix(matrix, scaleX, scaleY, scaleZ, rotationX, rotationY, rotationZ, translationX, translationY, translationZ);
        bones.push({ name: name, matrix: matrix, scaleX: scaleX, scaleY: scaleY, scaleZ: scaleZ, bbox: bbox });
    }
    return { bones: bones };
}
var ShapeDisplayFlags;
(function (ShapeDisplayFlags) {
    ShapeDisplayFlags[ShapeDisplayFlags["NORMAL"] = 0] = "NORMAL";
    ShapeDisplayFlags[ShapeDisplayFlags["BILLBOARD"] = 1] = "BILLBOARD";
    ShapeDisplayFlags[ShapeDisplayFlags["Y_BILLBOARD"] = 2] = "Y_BILLBOARD";
    ShapeDisplayFlags[ShapeDisplayFlags["USE_PNMTXIDX"] = 3] = "USE_PNMTXIDX";
})(ShapeDisplayFlags = exports.ShapeDisplayFlags || (exports.ShapeDisplayFlags = {}));
function readSHP1Chunk(buffer, bmd) {
    var e_1, _a;
    var view = buffer.createDataView();
    var shapeCount = view.getUint16(0x08);
    var shapeTableOffs = view.getUint32(0x0C);
    var attribTableOffs = view.getUint32(0x18);
    var matrixTableOffs = view.getUint32(0x1C);
    var primDataOffs = view.getUint32(0x20);
    var matrixDataOffs = view.getUint32(0x24);
    var packetTableOffs = view.getUint32(0x28);
    // We have a number of "shapes". Each shape has a number of vertex attributes
    // (e.g. pos, nrm, txc) and a list of packets. Each packet has a list of draw
    // calls, and each draw call has a list of indices into *each* of the vertex
    // arrays, one per vertex.
    //
    // Instead of one global index per draw call like OGL and some amount of packed
    // vertex data, the GX instead allows specifying separate indices per attribute.
    // So you can have POS's indexes be 0 1 2 3 and NRM's indexes be 0 0 0 0.
    //
    // What we end up doing is similar to what Dolphin does with its vertex loader
    // JIT. We construct buffers for each of the components that are shape-specific.
    // Build vattrs for VTX1.
    var vat = [];
    var vtxArrays = [];
    try {
        // J3D only uses VTXFMT0.
        for (var _b = __values(bmd.vtx1.vertexArrays.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {
            var _d = __read(_c.value, 2),
                attr = _d[0],
                vertexArray = _d[1];
            vat[attr] = { compCnt: vertexArray.compCnt, compType: vertexArray.compType, compShift: vertexArray.compShift };
            vtxArrays[attr] = { buffer: vertexArray.buffer, offs: 0 };
        }
    } catch (e_1_1) {
        e_1 = { error: e_1_1 };
    } finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        } finally {
            if (e_1) throw e_1.error;
        }
    }
    var shapes = [];
    var shapeIdx = shapeTableOffs;
    for (var i = 0; i < shapeCount; i++) {
        var displayFlags = view.getUint8(shapeIdx + 0x00);
        util_1.assert(view.getUint8(shapeIdx + 0x01) == 0xFF);
        var packetCount = view.getUint16(shapeIdx + 0x02);
        var attribOffs = view.getUint16(shapeIdx + 0x04);
        var firstMatrix = view.getUint16(shapeIdx + 0x06);
        var firstPacket = view.getUint16(shapeIdx + 0x08);
        var vcd = [];
        var attribIdx = attribTableOffs + attribOffs;
        while (true) {
            var vtxAttrib = view.getUint32(attribIdx + 0x00);
            if (vtxAttrib === GX.VertexAttribute.NULL) break;
            var indexDataType = view.getUint32(attribIdx + 0x04);
            vcd[vtxAttrib] = { type: indexDataType };
            attribIdx += 0x08;
        }
        var vtxLoader = gx_displaylist_1.compileVtxLoader(vat, vcd);
        // Now parse out the packets.
        var packetIdx = packetTableOffs + firstPacket * 0x08;
        var packets = [];
        var loadedDatas = [];
        util_1.assert(packetCount === 1);
        var totalTriangleCount = 0;
        for (var j = 0; j < packetCount; j++) {
            var packetSize = view.getUint32(packetIdx + 0x00);
            var packetStart = primDataOffs + view.getUint32(packetIdx + 0x04);
            var packetMatrixDataOffs = matrixDataOffs + (firstMatrix + j) * 0x08;
            var matrixCount = view.getUint16(packetMatrixDataOffs + 0x02);
            var matrixFirstIndex = view.getUint32(packetMatrixDataOffs + 0x04);
            var packetMatrixTableOffs = matrixTableOffs + matrixFirstIndex * 0x02;
            var packetMatrixTableSize = matrixCount;
            var matrixTable = buffer.createTypedArray(Uint16Array, packetMatrixTableOffs, packetMatrixTableSize, endian_1.Endianness.BIG_ENDIAN);
            var srcOffs = packetStart;
            var subBuffer = buffer.subarray(srcOffs, packetSize);
            var loadedSubData = vtxLoader.runVertices(vtxArrays, subBuffer);
            loadedDatas.push(loadedSubData);
            var firstTriangle = 0; // totalTriangleCount;
            var numTriangles = loadedSubData.totalTriangleCount;
            totalTriangleCount += numTriangles;
            packets.push({ matrixTable: matrixTable, firstTriangle: firstTriangle, numTriangles: numTriangles });
            packetIdx += 0x08;
        }
        var boundingSphereRadius = view.getFloat32(shapeIdx + 0x0C);
        var bboxMinX = view.getFloat32(shapeIdx + 0x10);
        var bboxMinY = view.getFloat32(shapeIdx + 0x14);
        var bboxMinZ = view.getFloat32(shapeIdx + 0x18);
        var bboxMaxX = view.getFloat32(shapeIdx + 0x1C);
        var bboxMaxY = view.getFloat32(shapeIdx + 0x20);
        var bboxMaxZ = view.getFloat32(shapeIdx + 0x24);
        var bbox = new Camera_1.AABB(bboxMinX, bboxMinY, bboxMinZ, bboxMaxX, bboxMaxY, bboxMaxZ);
        // Coalesce shape data.
        // TODO(jstpierre): coalesceLoadedData is basically completely busted.
        util_1.assert(loadedDatas.length === 1);
        var loadedVertexData = loadedDatas[0];
        var loadedVertexLayout = vtxLoader.loadedVertexLayout;
        // Now we should have a complete shape. Onto the next!
        shapes.push({ displayFlags: displayFlags, loadedVertexData: loadedVertexData, loadedVertexLayout: loadedVertexLayout, packets: packets, bbox: bbox });
        shapeIdx += 0x28;
    }
    return { vat: vat, shapes: shapes };
}
//#endregion
//#region MAT3
var TexMtxProjection;
(function (TexMtxProjection) {
    TexMtxProjection[TexMtxProjection["ST"] = 0] = "ST";
    TexMtxProjection[TexMtxProjection["STQ"] = 1] = "STQ";
})(TexMtxProjection = exports.TexMtxProjection || (exports.TexMtxProjection = {}));
// temp, center, center inverse
var t = gl_matrix_1.mat4.create(),
    c = gl_matrix_1.mat4.create(),
    ci = gl_matrix_1.mat4.create();
function createTexMtx(m, scaleS, scaleT, rotation, translationS, translationT, centerS, centerT, centerQ) {
    // TODO(jstpierre): Remove these.
    gl_matrix_1.mat4.fromTranslation(c, [centerS, centerT, centerQ]);
    gl_matrix_1.mat4.fromTranslation(ci, [-centerS, -centerT, -centerQ]);
    gl_matrix_1.mat4.fromTranslation(m, [translationS, translationT, 0]);
    gl_matrix_1.mat4.fromScaling(t, [scaleS, scaleT, 1]);
    gl_matrix_1.mat4.rotateZ(t, t, rotation * Math.PI);
    gl_matrix_1.mat4.mul(t, t, ci);
    gl_matrix_1.mat4.mul(t, c, t);
    gl_matrix_1.mat4.mul(m, m, t);
    return m;
}
function readColor32(view, srcOffs) {
    var r = view.getUint8(srcOffs + 0x00) / 255;
    var g = view.getUint8(srcOffs + 0x01) / 255;
    var b = view.getUint8(srcOffs + 0x02) / 255;
    var a = view.getUint8(srcOffs + 0x03) / 255;
    return new GX_Material.Color(r, g, b, a);
}
function readColorShort(view, srcOffs) {
    var r = view.getInt16(srcOffs + 0x00) / 255;
    var g = view.getInt16(srcOffs + 0x02) / 255;
    var b = view.getInt16(srcOffs + 0x04) / 255;
    var a = view.getInt16(srcOffs + 0x06) / 255;
    return new GX_Material.Color(r, g, b, a);
}
function readMAT3Chunk(buffer) {
    var view = buffer.createDataView();
    var materialCount = view.getUint16(0x08);
    var remapTableOffs = view.getUint32(0x10);
    var remapTable = [];
    for (var i = 0; i < materialCount; i++) {
        remapTable[i] = view.getUint16(remapTableOffs + i * 0x02);
    }var nameTableOffs = view.getUint32(0x14);
    var nameTable = readStringTable(buffer, nameTableOffs);
    var indirectTableOffset = view.getUint32(0x18);
    var cullModeTableOffs = view.getUint32(0x1C);
    var materialColorTableOffs = view.getUint32(0x20);
    var colorChanCountTableOffs = view.getUint32(0x24);
    var colorChanTableOffs = view.getUint32(0x28);
    var ambientColorTableOffs = view.getUint32(0x2C);
    var texGenTableOffs = view.getUint32(0x38);
    var postTexGenTableOffs = view.getUint32(0x3C);
    var textureTableOffs = view.getUint32(0x48);
    var texMtxTableOffs = view.getUint32(0x40);
    var postTexMtxTableOffs = view.getUint32(0x44);
    var tevOrderTableOffs = view.getUint32(0x4C);
    var colorRegisterTableOffs = view.getUint32(0x50);
    var colorConstantTableOffs = view.getUint32(0x54);
    var tevStageTableOffs = view.getUint32(0x5C);
    var alphaTestTableOffs = view.getUint32(0x6C);
    var blendModeTableOffs = view.getUint32(0x70);
    var depthModeTableOffs = view.getUint32(0x74);
    var materialEntries = [];
    var materialEntryTableOffs = view.getUint32(0x0C);
    for (var i = 0; i < materialCount; i++) {
        var index = i;
        var name = nameTable[i];
        var materialEntryIdx = materialEntryTableOffs + 0x014C * remapTable[i];
        var flags = view.getUint8(materialEntryIdx + 0x00);
        var cullModeIndex = view.getUint8(materialEntryIdx + 0x01);
        var colorChanCountIndex = view.getUint8(materialEntryIdx + 0x02);
        var texGenCountIndex = view.getUint8(materialEntryIdx + 0x03);
        var tevCountIndex = view.getUint8(materialEntryIdx + 0x04);
        // unk
        var depthModeIndex = view.getUint8(materialEntryIdx + 0x06);
        // unk
        var colorMatRegs = [null, null];
        for (var j = 0; j < 2; j++) {
            var matColorIndex = view.getUint16(materialEntryIdx + 0x08 + j * 0x02);
            var matColorOffs = materialColorTableOffs + matColorIndex * 0x04;
            var matColorReg = readColor32(view, matColorOffs);
            colorMatRegs[j] = matColorReg;
        }
        var colorAmbRegs = [null, null];
        for (var j = 0; j < 2; j++) {
            var ambColorIndex = view.getUint16(materialEntryIdx + 0x14 + j * 0x02);
            var ambColorOffs = ambientColorTableOffs + ambColorIndex * 0x04;
            var ambColorReg = readColor32(view, ambColorOffs);
            colorAmbRegs[j] = ambColorReg;
        }
        var lightChannelCount = view.getUint8(colorChanCountTableOffs + colorChanCountIndex);
        var lightChannels = [];
        for (var j = 0; j < lightChannelCount; j++) {
            var colorChannelIndex = view.getInt16(materialEntryIdx + 0x0C + (j * 2 + 0) * 0x02);
            var colorChannel = readColorChannel(colorChanTableOffs, colorChannelIndex);
            var alphaChannelIndex = view.getInt16(materialEntryIdx + 0x0C + (j * 2 + 1) * 0x02);
            var alphaChannel = readColorChannel(colorChanTableOffs, alphaChannelIndex);
            lightChannels.push({ colorChannel: colorChannel, alphaChannel: alphaChannel });
        }
        var texGens = [];
        for (var j = 0; j < 8; j++) {
            var texGenIndex = view.getInt16(materialEntryIdx + 0x28 + j * 0x02);
            if (texGenIndex < 0) continue;
            var index_1 = j;
            var type = view.getUint8(texGenTableOffs + texGenIndex * 0x04 + 0x00);
            var source = view.getUint8(texGenTableOffs + texGenIndex * 0x04 + 0x01);
            var matrixCheck = view.getUint8(texGenTableOffs + texGenIndex * 0x04 + 0x02);
            util_1.assert(view.getUint8(texGenTableOffs + texGenIndex * 0x04 + 0x03) === 0xFF);
            var postMatrix = GX.PostTexGenMatrix.PTIDENTITY;
            var postTexGenIndex = view.getInt16(materialEntryIdx + 0x38 + j * 0x02);
            if (postTexGenTableOffs > 0 && postTexGenIndex >= 0) {
                postMatrix = view.getUint8(postTexGenTableOffs + texGenIndex * 0x04 + 0x02);
                util_1.assert(view.getUint8(postTexGenTableOffs + postTexGenIndex * 0x04 + 0x03) === 0xFF);
            }
            // BTK can apply texture animations to materials that have the matrix set to IDENTITY.
            // For this reason, we always assign a texture matrix. In theory, the file should
            // have an identity texture matrix in the texMatrices section, so it should render correctly.
            var matrix = GX.TexGenMatrix.TEXMTX0 + j * 3;
            // If we ever find a counter-example for this, I'll have to rethink the scheme, but I
            // *believe* that texture matrices should always be paired with TexGens in order.
            util_1.assert(matrixCheck === GX.TexGenMatrix.IDENTITY || matrixCheck === matrix);
            var normalize = false;
            var texGen = { index: index_1, type: type, source: source, matrix: matrix, normalize: normalize, postMatrix: postMatrix };
            texGens[j] = texGen;
        }
        var texMatrices = [];
        for (var j = 0; j < 10; j++) {
            texMatrices[j] = null;
            var texMtxIndex = view.getInt16(materialEntryIdx + 0x48 + j * 0x02);
            if (texMtxIndex < 0) continue;
            texMatrices[j] = readTexMatrix(texMtxTableOffs, j, texMtxIndex);
        }
        // Since texture matrices are assigned in order, we should never actually have more than 8 of these.
        util_1.assert(texMatrices[8] === null);
        util_1.assert(texMatrices[9] === null);
        var postTexMatrices = [];
        for (var j = 0; j < 20; j++) {
            postTexMatrices[j] = null;
            var postTexMtxIndex = view.getInt16(materialEntryIdx + 0x5C + j * 0x02);
            if (postTexMtxIndex < 0) continue;
            postTexMatrices[j] = readTexMatrix(postTexMtxTableOffs, j, postTexMtxIndex);
        }
        var colorConstants = [];
        for (var j = 0; j < 4; j++) {
            var colorIndex = view.getUint16(materialEntryIdx + 0x94 + j * 0x02);
            var color = readColor32(view, colorConstantTableOffs + colorIndex * 0x04);
            colorConstants.push(color);
        }
        var colorRegisters = [];
        for (var j = 0; j < 4; j++) {
            var colorIndex = view.getUint16(materialEntryIdx + 0xDC + j * 0x02);
            var color = readColorShort(view, colorRegisterTableOffs + colorIndex * 0x08);
            colorRegisters.push(color);
        }
        // BMD stores CPREV at the end. We store CPREV at the beginning.
        colorRegisters.unshift(colorRegisters.pop());
        var textureIndexTableIdx = materialEntryIdx + 0x84;
        var textureIndexes = [];
        for (var j = 0; j < 8; j++) {
            var textureTableIndex = view.getInt16(textureIndexTableIdx);
            if (textureTableIndex >= 0) {
                var textureIndex = view.getUint16(textureTableOffs + textureTableIndex * 0x02);
                textureIndexes.push(textureIndex);
            } else {
                textureIndexes.push(-1);
            }
            textureIndexTableIdx += 0x02;
        }
        var indirectEntryOffs = indirectTableOffset + i * 0x138;
        var indirectStageCount = view.getUint8(indirectEntryOffs + 0x00);
        util_1.assert(indirectStageCount <= 4);
        var indTexStages = [];
        for (var j = 0; j < indirectStageCount; j++) {
            var index_2 = j;
            // SetIndTexOrder
            var indTexOrderOffs = indirectEntryOffs + 0x04 + j * 0x04;
            var texCoordId = view.getUint8(indTexOrderOffs + 0x00);
            var texture = view.getUint8(indTexOrderOffs + 0x01);
            // SetIndTexCoordScale
            var indTexScaleOffs = indirectEntryOffs + 0x04 + 0x04 * 4 + 0x1C * 3 + j * 0x04;
            var scaleS = view.getUint8(indTexScaleOffs + 0x00);
            var scaleT = view.getUint8(indTexScaleOffs + 0x01);
            indTexStages.push({ index: index_2, texCoordId: texCoordId, texture: texture, scaleS: scaleS, scaleT: scaleT });
        }
        // SetIndTexMatrix
        var indTexMatrices = [];
        for (var j = 0; j < 3; j++) {
            var indTexMatrixOffs = indirectEntryOffs + 0x04 + 0x04 * 4 + j * 0x1C;
            var p00 = view.getFloat32(indTexMatrixOffs + 0x00);
            var p01 = view.getFloat32(indTexMatrixOffs + 0x04);
            var p02 = view.getFloat32(indTexMatrixOffs + 0x08);
            var p10 = view.getFloat32(indTexMatrixOffs + 0x0C);
            var p11 = view.getFloat32(indTexMatrixOffs + 0x10);
            var p12 = view.getFloat32(indTexMatrixOffs + 0x14);
            var scale = Math.pow(2, view.getInt8(indTexMatrixOffs + 0x18));
            var m = new Float32Array([p00 * scale, p01 * scale, p02 * scale, p10 * scale, p11 * scale, p12 * scale]);
            indTexMatrices.push(m);
        }
        var tevStages = [];
        for (var j = 0; j < 16; j++) {
            // TevStage
            var tevStageIndex = view.getInt16(materialEntryIdx + 0xE4 + j * 0x02);
            if (tevStageIndex < 0) continue;
            var index_3 = j;
            var tevStageOffs = tevStageTableOffs + tevStageIndex * 0x14;
            // const unknown0 = view.getUint8(tevStageOffs + 0x00);
            var colorInA = view.getUint8(tevStageOffs + 0x01);
            var colorInB = view.getUint8(tevStageOffs + 0x02);
            var colorInC = view.getUint8(tevStageOffs + 0x03);
            var colorInD = view.getUint8(tevStageOffs + 0x04);
            var colorOp = view.getUint8(tevStageOffs + 0x05);
            var colorBias = view.getUint8(tevStageOffs + 0x06);
            var colorScale = view.getUint8(tevStageOffs + 0x07);
            var colorClamp = !!view.getUint8(tevStageOffs + 0x08);
            var colorRegId = view.getUint8(tevStageOffs + 0x09);
            var alphaInA = view.getUint8(tevStageOffs + 0x0A);
            var alphaInB = view.getUint8(tevStageOffs + 0x0B);
            var alphaInC = view.getUint8(tevStageOffs + 0x0C);
            var alphaInD = view.getUint8(tevStageOffs + 0x0D);
            var alphaOp = view.getUint8(tevStageOffs + 0x0E);
            var alphaBias = view.getUint8(tevStageOffs + 0x0F);
            var alphaScale = view.getUint8(tevStageOffs + 0x10);
            var alphaClamp = !!view.getUint8(tevStageOffs + 0x11);
            var alphaRegId = view.getUint8(tevStageOffs + 0x12);
            // const unknown1 = view.getUint8(tevStageOffs + 0x13);
            // TevOrder
            var tevOrderIndex = view.getUint16(materialEntryIdx + 0xBC + j * 0x02);
            var tevOrderOffs = tevOrderTableOffs + tevOrderIndex * 0x04;
            var texCoordId = view.getUint8(tevOrderOffs + 0x00);
            var texMap = view.getUint8(tevOrderOffs + 0x01);
            var channelId = GX_Material.getRasColorChannelID(view.getUint8(tevOrderOffs + 0x02));
            util_1.assert(view.getUint8(tevOrderOffs + 0x03) === 0xFF);
            // KonstSel
            var konstColorSel = view.getUint8(materialEntryIdx + 0x9C + j);
            var konstAlphaSel = view.getUint8(materialEntryIdx + 0xAC + j);
            // SetTevIndirect
            var indTexStageOffs = indirectEntryOffs + 0x04 + 0x04 * 4 + 0x1C * 3 + 0x04 * 4 + j * 0x0C;
            var indTexStage = view.getUint8(indTexStageOffs + 0x00);
            var indTexFormat = view.getUint8(indTexStageOffs + 0x01);
            var indTexBiasSel = view.getUint8(indTexStageOffs + 0x02);
            var indTexMatrix = view.getUint8(indTexStageOffs + 0x03);
            util_1.assert(indTexMatrix <= GX.IndTexMtxID.T2);
            var indTexWrapS = view.getUint8(indTexStageOffs + 0x04);
            var indTexWrapT = view.getUint8(indTexStageOffs + 0x05);
            var indTexAddPrev = !!view.getUint8(indTexStageOffs + 0x06);
            var indTexUseOrigLOD = !!view.getUint8(indTexStageOffs + 0x07);
            // bumpAlpha
            var tevStage = {
                index: index_3,
                colorInA: colorInA, colorInB: colorInB, colorInC: colorInC, colorInD: colorInD, colorOp: colorOp, colorBias: colorBias, colorScale: colorScale, colorClamp: colorClamp, colorRegId: colorRegId,
                alphaInA: alphaInA, alphaInB: alphaInB, alphaInC: alphaInC, alphaInD: alphaInD, alphaOp: alphaOp, alphaBias: alphaBias, alphaScale: alphaScale, alphaClamp: alphaClamp, alphaRegId: alphaRegId,
                texCoordId: texCoordId, texMap: texMap, channelId: channelId,
                konstColorSel: konstColorSel, konstAlphaSel: konstAlphaSel,
                indTexStage: indTexStage,
                indTexFormat: indTexFormat,
                indTexBiasSel: indTexBiasSel,
                indTexMatrix: indTexMatrix,
                indTexWrapS: indTexWrapS,
                indTexWrapT: indTexWrapT,
                indTexAddPrev: indTexAddPrev,
                indTexUseOrigLOD: indTexUseOrigLOD
            };
            tevStages.push(tevStage);
        }
        // SetAlphaCompare
        var alphaTestIndex = view.getUint16(materialEntryIdx + 0x146);
        var blendModeIndex = view.getUint16(materialEntryIdx + 0x148);
        var alphaTestOffs = alphaTestTableOffs + alphaTestIndex * 0x08;
        var compareA = view.getUint8(alphaTestOffs + 0x00);
        var referenceA = view.getUint8(alphaTestOffs + 0x01) / 0xFF;
        var op = view.getUint8(alphaTestOffs + 0x02);
        var compareB = view.getUint8(alphaTestOffs + 0x03);
        var referenceB = view.getUint8(alphaTestOffs + 0x04) / 0xFF;
        var alphaTest = { compareA: compareA, referenceA: referenceA, op: op, compareB: compareB, referenceB: referenceB };
        // SetBlendMode
        var blendModeOffs = blendModeTableOffs + blendModeIndex * 0x04;
        var blendType = view.getUint8(blendModeOffs + 0x00);
        var blendSrc = view.getUint8(blendModeOffs + 0x01);
        var blendDst = view.getUint8(blendModeOffs + 0x02);
        var blendLogicOp = view.getUint8(blendModeOffs + 0x03);
        var blendMode = { type: blendType, srcFactor: blendSrc, dstFactor: blendDst, logicOp: blendLogicOp };
        var cullMode = view.getUint32(cullModeTableOffs + cullModeIndex * 0x04);
        var depthModeOffs = depthModeTableOffs + depthModeIndex * 4;
        var depthTest = !!view.getUint8(depthModeOffs + 0x00);
        var depthFunc = view.getUint8(depthModeOffs + 0x01);
        var depthWrite = !!view.getUint8(depthModeOffs + 0x02);
        var ropInfo = { blendMode: blendMode, depthTest: depthTest, depthFunc: depthFunc, depthWrite: depthWrite };
        var translucent = !(flags & 0x03);
        var gxMaterial = {
            index: index, name: name,
            cullMode: cullMode,
            lightChannels: lightChannels,
            texGens: texGens,
            colorRegisters: colorRegisters,
            colorConstants: colorConstants,
            tevStages: tevStages,
            indTexStages: indTexStages,
            alphaTest: alphaTest,
            ropInfo: ropInfo
        };
        materialEntries.push({
            index: index, name: name,
            translucent: translucent,
            textureIndexes: textureIndexes,
            texMatrices: texMatrices,
            postTexMatrices: postTexMatrices,
            gxMaterial: gxMaterial,
            colorMatRegs: colorMatRegs,
            colorAmbRegs: colorAmbRegs,
            indTexMatrices: indTexMatrices
        });
    }
    function readColorChannel(tableOffs, colorChanIndex) {
        var colorChanOffs = colorChanTableOffs + colorChanIndex * 0x08;
        var lightingEnabled = !!view.getUint8(colorChanOffs + 0x00);
        util_1.assert(view.getUint8(colorChanOffs + 0x00) < 2);
        var matColorSource = view.getUint8(colorChanOffs + 0x01);
        var litMask = view.getUint8(colorChanOffs + 0x02);
        var diffuseFunction = view.getUint8(colorChanOffs + 0x03);
        var attenuationFunction = view.getUint8(colorChanOffs + 0x04);
        var ambColorSource = view.getUint8(colorChanOffs + 0x05);
        var colorChan = { lightingEnabled: lightingEnabled, matColorSource: matColorSource, ambColorSource: ambColorSource };
        return colorChan;
    }
    function readTexMatrix(tableOffs, j, texMtxIndex) {
        if (tableOffs === 0) return null;
        var texMtxOffs = tableOffs + texMtxIndex * 0x64;
        var projection = view.getUint8(texMtxOffs + 0x00);
        var type = view.getUint8(texMtxOffs + 0x01);
        util_1.assert(view.getUint16(texMtxOffs + 0x02) === 0xFFFF);
        var centerS = view.getFloat32(texMtxOffs + 0x04);
        var centerT = view.getFloat32(texMtxOffs + 0x08);
        var centerQ = view.getFloat32(texMtxOffs + 0x0C);
        var scaleS = view.getFloat32(texMtxOffs + 0x10);
        var scaleT = view.getFloat32(texMtxOffs + 0x14);
        var rotation = view.getInt16(texMtxOffs + 0x18) / 0x7FFF;
        util_1.assert(view.getUint16(texMtxOffs + 0x1A) === 0xFFFF);
        var translationS = view.getFloat32(texMtxOffs + 0x1C);
        var translationT = view.getFloat32(texMtxOffs + 0x20);
        // A second matrix?
        var p00 = view.getFloat32(texMtxOffs + 0x24);
        var p01 = view.getFloat32(texMtxOffs + 0x28);
        var p02 = view.getFloat32(texMtxOffs + 0x2C);
        var p03 = view.getFloat32(texMtxOffs + 0x30);
        var p10 = view.getFloat32(texMtxOffs + 0x34);
        var p11 = view.getFloat32(texMtxOffs + 0x38);
        var p12 = view.getFloat32(texMtxOffs + 0x3C);
        var p13 = view.getFloat32(texMtxOffs + 0x40);
        var p20 = view.getFloat32(texMtxOffs + 0x44);
        var p21 = view.getFloat32(texMtxOffs + 0x48);
        var p22 = view.getFloat32(texMtxOffs + 0x4C);
        var p23 = view.getFloat32(texMtxOffs + 0x50);
        var p30 = view.getFloat32(texMtxOffs + 0x54);
        var p31 = view.getFloat32(texMtxOffs + 0x58);
        var p32 = view.getFloat32(texMtxOffs + 0x5C);
        var p33 = view.getFloat32(texMtxOffs + 0x60);
        var effectMatrix = gl_matrix_1.mat4.fromValues(p00, p10, p20, p30, p01, p11, p21, p31, p02, p12, p22, p32, p03, p13, p23, p33);
        var matrix = gl_matrix_1.mat4.create();
        createTexMtx(matrix, scaleS, scaleT, rotation, translationS, translationT, centerS, centerT, centerQ);
        var texMtx = { type: type, projection: projection, effectMatrix: effectMatrix, matrix: matrix };
        return texMtx;
    }
    return { materialEntries: materialEntries };
}
function readBTI_Texture(buffer, name) {
    var view = buffer.createDataView();
    var format = view.getUint8(0x00);
    var width = view.getUint16(0x02);
    var height = view.getUint16(0x04);
    var wrapS = view.getUint8(0x06);
    var wrapT = view.getUint8(0x07);
    var paletteFormat = view.getUint8(0x09);
    var paletteNumEntries = view.getUint16(0x0A);
    var paletteOffs = view.getUint32(0x0C);
    var minFilter = view.getUint8(0x14);
    var magFilter = view.getUint8(0x15);
    var minLOD = view.getInt8(0x16) * 1 / 8;
    var maxLOD = view.getInt8(0x17) * 1 / 8;
    var mipCount = view.getUint8(0x18);
    var lodBias = view.getInt16(0x1A) * 1 / 100;
    var dataOffs = view.getUint32(0x1C);
    util_1.assert(minLOD === 0);
    var data = null;
    if (dataOffs !== 0) data = buffer.slice(dataOffs);
    return { name: name, format: format, width: width, height: height, wrapS: wrapS, wrapT: wrapT, minFilter: minFilter, magFilter: magFilter, minLOD: minLOD, maxLOD: maxLOD, mipCount: mipCount, lodBias: lodBias, data: data };
}
function readTEX1Chunk(buffer) {
    var view = buffer.createDataView();
    var textureCount = view.getUint16(0x08);
    var textureHeaderOffs = view.getUint32(0x0C);
    var nameTableOffs = view.getUint32(0x10);
    var nameTable = readStringTable(buffer, nameTableOffs);
    var samplers = [];
    var textureDatas = [];
    var _loop_1 = function _loop_1(i) {
        var textureIdx = textureHeaderOffs + i * 0x20;
        var name = nameTable[i];
        var btiTexture = readBTI_Texture(buffer.slice(textureIdx), name);
        var textureDataIndex = -1;
        // Try to find existing texture data.
        if (btiTexture.data !== null) {
            textureDataIndex = textureDatas.findIndex(function (tex) {
                return tex.data && tex.data.byteOffset === btiTexture.data.byteOffset;
            });
        }
        if (textureDataIndex < 0) {
            var textureData = {
                name: btiTexture.name,
                width: btiTexture.width,
                height: btiTexture.height,
                format: btiTexture.format,
                mipCount: btiTexture.mipCount,
                data: btiTexture.data
            };
            textureDatas.push(textureData);
            textureDataIndex = textureDatas.length - 1;
        }
        // Sampler.
        var sampler = {
            index: i,
            name: btiTexture.name,
            wrapS: btiTexture.wrapS,
            wrapT: btiTexture.wrapT,
            minFilter: btiTexture.minFilter,
            magFilter: btiTexture.magFilter,
            minLOD: btiTexture.minLOD,
            maxLOD: btiTexture.maxLOD,
            lodBias: btiTexture.lodBias,
            textureDataIndex: textureDataIndex
        };
        samplers.push(sampler);
    };
    for (var i = 0; i < textureCount; i++) {
        _loop_1(i);
    }
    return { textureDatas: textureDatas, samplers: samplers };
}
var J3DFileReaderHelper = /** @class */function () {
    function J3DFileReaderHelper(buffer) {
        this.buffer = buffer;
        this.offs = 0x20;
        this.view = this.buffer.createDataView();
        this.magic = util_1.readString(this.buffer, 0, 8);
        this.size = this.view.getUint32(0x08);
        this.numChunks = this.view.getUint32(0x0C);
        this.offs = 0x20;
    }
    J3DFileReaderHelper.prototype.maybeNextChunk = function (maybeChunkId) {
        var chunkStart = this.offs;
        var chunkId = util_1.readString(this.buffer, chunkStart + 0x00, 4);
        var chunkSize = this.view.getUint32(chunkStart + 0x04);
        if (chunkId === maybeChunkId) {
            this.offs += chunkSize;
            return this.buffer.subarray(chunkStart, chunkSize);
        } else {
            return null;
        }
    };
    J3DFileReaderHelper.prototype.nextChunk = function (expectedChunkId) {
        var chunkStart = this.offs;
        var chunkId = util_1.readString(this.buffer, chunkStart + 0x00, 4);
        var chunkSize = this.view.getUint32(chunkStart + 0x04);
        util_1.assert(chunkId === expectedChunkId);
        this.offs += chunkSize;
        return this.buffer.subarray(chunkStart, chunkSize);
    };
    return J3DFileReaderHelper;
}();
//#endregion
//#region BMD
var BMD = /** @class */function () {
    function BMD() {}
    BMD.parse = function (buffer) {
        var bmd = new BMD();
        var j3d = new J3DFileReaderHelper(buffer);
        util_1.assert(j3d.magic === 'J3D2bmd3' || j3d.magic === 'J3D2bdl4');
        bmd.inf1 = readINF1Chunk(j3d.nextChunk('INF1'));
        bmd.vtx1 = readVTX1Chunk(j3d.nextChunk('VTX1'));
        bmd.evp1 = readEVP1Chunk(j3d.nextChunk('EVP1'));
        bmd.drw1 = readDRW1Chunk(j3d.nextChunk('DRW1'));
        bmd.jnt1 = readJNT1Chunk(j3d.nextChunk('JNT1'));
        bmd.shp1 = readSHP1Chunk(j3d.nextChunk('SHP1'), bmd);
        bmd.mat3 = readMAT3Chunk(j3d.nextChunk('MAT3'));
        var mdl3 = j3d.maybeNextChunk('MDL3');
        bmd.tex1 = readTEX1Chunk(j3d.nextChunk('TEX1'));
        return bmd;
    };
    return BMD;
}();
exports.BMD = BMD;
//#endregion
//#region BMT
var BMT = /** @class */function () {
    function BMT() {}
    BMT.parse = function (buffer) {
        var bmt = new BMT();
        var j3d = new J3DFileReaderHelper(buffer);
        util_1.assert(j3d.magic === 'J3D2bmt3');
        var mat3Chunk = j3d.maybeNextChunk('MAT3');
        if (mat3Chunk !== null) bmt.mat3 = readMAT3Chunk(mat3Chunk);else bmt.mat3 = null;
        bmt.tex1 = readTEX1Chunk(j3d.nextChunk('TEX1'));
        return bmt;
    };
    return BMT;
}();
exports.BMT = BMT;
//#endregion
//#region BTI
var BTI = /** @class */function () {
    function BTI() {}
    BTI.parse = function (buffer, name) {
        if (name === void 0) {
            name = null;
        }
        var bti = new BTI();
        bti.texture = readBTI_Texture(buffer, name);
        return bti;
    };
    return BTI;
}();
exports.BTI = BTI;
//#endregion
//#region Animation
var LoopMode;
(function (LoopMode) {
    LoopMode[LoopMode["ONCE"] = 0] = "ONCE";
    LoopMode[LoopMode["REPEAT"] = 2] = "REPEAT";
    LoopMode[LoopMode["MIRRORED_ONCE"] = 3] = "MIRRORED_ONCE";
    LoopMode[LoopMode["MIRRORED_REPEAT"] = 4] = "MIRRORED_REPEAT";
})(LoopMode = exports.LoopMode || (exports.LoopMode = {}));
var TangentType;
(function (TangentType) {
    TangentType[TangentType["IN"] = 0] = "IN";
    TangentType[TangentType["IN_OUT"] = 1] = "IN_OUT";
})(TangentType || (TangentType = {}));
function applyLoopMode(t, loopMode) {
    switch (loopMode) {
        case LoopMode.ONCE:
            return Math.min(t, 1);
        case LoopMode.REPEAT:
            return t % 1;
        case LoopMode.MIRRORED_ONCE:
            return 1 - Math.abs(Math.min(t, 2) - 1);
        case LoopMode.MIRRORED_REPEAT:
            return 1 - Math.abs(t % 2 - 1);
    }
}
function getAnimFrame(anim, frame) {
    var lastFrame = anim.duration - 1;
    var normTime = frame / lastFrame;
    var animFrame = applyLoopMode(normTime, anim.loopMode) * lastFrame;
    return animFrame;
}
function cubicEval(cf0, cf1, cf2, cf3, t) {
    return ((cf0 * t + cf1) * t + cf2) * t + cf3;
}
function lerp(k0, k1, t) {
    return k0.value + (k1.value - k0.value) * t;
}
function hermiteInterpolate(k0, k1, t) {
    var length = k1.time - k0.time;
    var p0 = k0.value;
    var p1 = k1.value;
    var s0 = k0.tangentOut * length;
    var s1 = k1.tangentIn * length;
    var cf0 = p0 * 2 + p1 * -2 + s0 * 1 + s1 * 1;
    var cf1 = p0 * -3 + p1 * 3 + s0 * -2 + s1 * -1;
    var cf2 = p0 * 0 + p1 * 0 + s0 * 1 + s1 * 0;
    var cf3 = p0 * 1 + p1 * 0 + s0 * 0 + s1 * 0;
    return cubicEval(cf0, cf1, cf2, cf3, t);
}
function sampleAnimationData(track, frame) {
    var frames = track.frames;
    if (frames.length === 1) return frames[0].value;
    // Find the first frame.
    var idx1 = frames.findIndex(function (key) {
        return frame < key.time;
    });
    if (idx1 < 0) return frames[frames.length - 1].value;
    var idx0 = idx1 - 1;
    var k0 = frames[idx0];
    var k1 = frames[idx1];
    // HACK(jstpierre): Nintendo sometimes uses weird "reset" tangents
    // which aren't supposed to be visible. They are visible for us because
    // "frame" can have a non-zero fractional component. In this case, pick
    // a value completely.
    if (k1.time - k0.time === 1) return k0.value;
    var t = (frame - k0.time) / (k1.time - k0.time);
    return hermiteInterpolate(k0, k1, t);
}
function translateAnimationTrack(data, scale, count, index, tangent) {
    // Special exception.
    if (count === 1) {
        var value = data[index];
        var frames = [{ time: 0, value: value * scale, tangentIn: 0, tangentOut: 0 }];
        return { frames: frames };
    } else {
        var frames = [];
        if (tangent === TangentType.IN) {
            for (var i = index; i < index + 3 * count; i += 3) {
                var time = data[i + 0],
                    value = data[i + 1] * scale,
                    tangentIn = data[i + 2] * scale,
                    tangentOut = tangentIn;
                frames.push({ time: time, value: value, tangentIn: tangentIn, tangentOut: tangentOut });
            }
        } else if (tangent === TangentType.IN_OUT) {
            for (var i = index; i < index + 4 * count; i += 4) {
                var time = data[i + 0],
                    value = data[i + 1] * scale,
                    tangentIn = data[i + 2] * scale,
                    tangentOut = data[i + 3] * scale;
                frames.push({ time: time, value: value, tangentIn: tangentIn, tangentOut: tangentOut });
            }
        }
        return { frames: frames };
    }
}
function readTTK1Chunk(buffer) {
    var view = buffer.createDataView();
    var loopMode = view.getUint8(0x08);
    var rotationDecimal = view.getUint8(0x09);
    var duration = view.getUint16(0x0A);
    var animationCount = view.getUint16(0x0C) / 3;
    var sCount = view.getUint16(0x0E);
    var rCount = view.getUint16(0x10);
    var tCount = view.getUint16(0x12);
    var animationTableOffs = view.getUint32(0x14);
    var remapTableOffs = view.getUint32(0x18);
    var materialNameTableOffs = view.getUint32(0x1C);
    var texMtxIndexTableOffs = view.getUint32(0x20);
    var textureCenterTableOffs = view.getUint32(0x24);
    var sTableOffs = view.getUint32(0x28);
    var rTableOffs = view.getUint32(0x2C);
    var tTableOffs = view.getUint32(0x30);
    var rotationScale = Math.pow(2, rotationDecimal) / 32767;
    var sTable = buffer.createTypedArray(Float32Array, sTableOffs, sCount, endian_1.Endianness.BIG_ENDIAN);
    var rTable = buffer.createTypedArray(Int16Array, rTableOffs, rCount, endian_1.Endianness.BIG_ENDIAN);
    var tTable = buffer.createTypedArray(Float32Array, tTableOffs, tCount, endian_1.Endianness.BIG_ENDIAN);
    var materialNameTable = readStringTable(buffer, materialNameTableOffs);
    var animationTableIdx = animationTableOffs;
    function readAnimationTrack(data, scale) {
        var count = view.getUint16(animationTableIdx + 0x00);
        var index = view.getUint16(animationTableIdx + 0x02);
        var tangent = view.getUint16(animationTableIdx + 0x04);
        animationTableIdx += 0x06;
        return translateAnimationTrack(data, scale, count, index, tangent);
    }
    var uvAnimationEntries = [];
    for (var i = 0; i < animationCount; i++) {
        var materialName = materialNameTable[i];
        var remapIndex = view.getUint16(remapTableOffs + i * 0x02);
        var texGenIndex = view.getUint8(texMtxIndexTableOffs + i);
        var centerS = view.getFloat32(textureCenterTableOffs + i * 0x0C + 0x00);
        var centerT = view.getFloat32(textureCenterTableOffs + i * 0x0C + 0x04);
        var centerQ = view.getFloat32(textureCenterTableOffs + i * 0x0C + 0x08);
        var scaleS = readAnimationTrack(sTable, 1);
        var rotationS = readAnimationTrack(rTable, rotationScale);
        var translationS = readAnimationTrack(tTable, 1);
        var scaleT = readAnimationTrack(sTable, 1);
        var rotationT = readAnimationTrack(rTable, rotationScale);
        var translationT = readAnimationTrack(tTable, 1);
        var scaleQ = readAnimationTrack(sTable, 1);
        var rotationQ = readAnimationTrack(rTable, rotationScale);
        var translationQ = readAnimationTrack(tTable, 1);
        uvAnimationEntries.push({
            materialName: materialName, remapIndex: remapIndex, texGenIndex: texGenIndex,
            centerS: centerS, centerT: centerT, centerQ: centerQ,
            scaleS: scaleS, rotationS: rotationS, translationS: translationS,
            scaleT: scaleT, rotationT: rotationT, translationT: translationT,
            scaleQ: scaleQ, rotationQ: rotationQ, translationQ: translationQ
        });
    }
    return { duration: duration, loopMode: loopMode, uvAnimationEntries: uvAnimationEntries };
}
//#endregion
//#region BTK
var BTK = /** @class */function () {
    function BTK() {}
    BTK.parse = function (buffer) {
        var btk = new BTK();
        var j3d = new J3DFileReaderHelper(buffer);
        util_1.assert(j3d.magic === 'J3D1btk1');
        btk.ttk1 = readTTK1Chunk(j3d.nextChunk('TTK1'));
        return btk;
    };
    BTK.prototype.calcAnimatedTexMtx = function (dst, materialName, texMtxIndex, frame) {
        var animationEntry = this.findAnimationEntry(materialName, texMtxIndex);
        if (!animationEntry) return false;
        var animFrame = getAnimFrame(this.ttk1, frame);
        var centerS = animationEntry.centerS;
        var centerT = animationEntry.centerT;
        var centerQ = animationEntry.centerQ;
        var scaleS = sampleAnimationData(animationEntry.scaleS, animFrame);
        var scaleT = sampleAnimationData(animationEntry.scaleT, animFrame);
        var rotation = sampleAnimationData(animationEntry.rotationQ, animFrame);
        var translationS = sampleAnimationData(animationEntry.translationS, animFrame);
        var translationT = sampleAnimationData(animationEntry.translationT, animFrame);
        createTexMtx(dst, scaleS, scaleT, rotation, translationS, translationT, centerS, centerT, centerQ);
        return true;
    };
    BTK.prototype.findAnimationEntry = function (materialName, texGenIndex) {
        return this.ttk1.uvAnimationEntries.find(function (e) {
            return e.materialName === materialName && e.texGenIndex === texGenIndex;
        });
    };
    return BTK;
}();
exports.BTK = BTK;
function readTRK1Chunk(buffer) {
    var view = buffer.createDataView();
    var loopMode = view.getUint8(0x08);
    var duration = view.getUint16(0x0A);
    var registerColorAnimationTableCount = view.getUint16(0x0C);
    var konstantColorAnimationTableCount = view.getUint16(0x0E);
    var registerRCount = view.getUint16(0x10);
    var registerGCount = view.getUint16(0x12);
    var registerBCount = view.getUint16(0x14);
    var registerACount = view.getUint16(0x16);
    var konstantRCount = view.getUint16(0x18);
    var konstantGCount = view.getUint16(0x1A);
    var konstantBCount = view.getUint16(0x1C);
    var konstantACount = view.getUint16(0x1E);
    var registerColorAnimationTableOffs = view.getUint32(0x20);
    var konstantColorAnimationTableOffs = view.getUint32(0x24);
    var registerRemapTableOffs = view.getUint32(0x28);
    var konstantRemapTableOffs = view.getUint32(0x2C);
    var registerNameTableOffs = view.getUint32(0x30);
    var konstantNameTableOffs = view.getUint32(0x34);
    var registerROffs = view.getUint32(0x38);
    var registerGOffs = view.getUint32(0x3C);
    var registerBOffs = view.getUint32(0x40);
    var registerAOffs = view.getUint32(0x44);
    var konstantROffs = view.getUint32(0x48);
    var konstantGOffs = view.getUint32(0x4C);
    var konstantBOffs = view.getUint32(0x50);
    var konstantAOffs = view.getUint32(0x54);
    var registerNameTable = readStringTable(buffer, registerNameTableOffs);
    var konstantNameTable = readStringTable(buffer, konstantNameTableOffs);
    var animationTableIdx;
    function readAnimationTrack(data) {
        var count = view.getUint16(animationTableIdx + 0x00);
        var index = view.getUint16(animationTableIdx + 0x02);
        var tangent = view.getUint16(animationTableIdx + 0x04);
        animationTableIdx += 0x06;
        return translateAnimationTrack(data, 1 / 0xFF, count, index, tangent);
    }
    var animationEntries = [];
    var registerRTable = buffer.createTypedArray(Int16Array, registerROffs, registerRCount, endian_1.Endianness.BIG_ENDIAN);
    var registerGTable = buffer.createTypedArray(Int16Array, registerGOffs, registerGCount, endian_1.Endianness.BIG_ENDIAN);
    var registerBTable = buffer.createTypedArray(Int16Array, registerBOffs, registerBCount, endian_1.Endianness.BIG_ENDIAN);
    var registerATable = buffer.createTypedArray(Int16Array, registerAOffs, registerACount, endian_1.Endianness.BIG_ENDIAN);
    animationTableIdx = registerColorAnimationTableOffs;
    for (var i = 0; i < registerColorAnimationTableCount; i++) {
        var materialName = registerNameTable[i];
        var remapIndex = view.getUint16(registerRemapTableOffs + i * 0x02);
        var r = readAnimationTrack(registerRTable);
        var g = readAnimationTrack(registerGTable);
        var b = readAnimationTrack(registerBTable);
        var a = readAnimationTrack(registerATable);
        var colorId = view.getUint8(animationTableIdx);
        var colorOverride = render_1.ColorOverride.C0 + colorId;
        animationTableIdx += 0x04;
        animationEntries.push({ materialName: materialName, remapIndex: remapIndex, colorOverride: colorOverride, r: r, g: g, b: b, a: a });
    }
    var konstantRTable = buffer.createTypedArray(Int16Array, konstantROffs, konstantRCount, endian_1.Endianness.BIG_ENDIAN);
    var konstantGTable = buffer.createTypedArray(Int16Array, konstantGOffs, konstantGCount, endian_1.Endianness.BIG_ENDIAN);
    var konstantBTable = buffer.createTypedArray(Int16Array, konstantBOffs, konstantBCount, endian_1.Endianness.BIG_ENDIAN);
    var konstantATable = buffer.createTypedArray(Int16Array, konstantAOffs, konstantACount, endian_1.Endianness.BIG_ENDIAN);
    animationTableIdx = konstantColorAnimationTableOffs;
    for (var i = 0; i < konstantColorAnimationTableCount; i++) {
        var materialName = konstantNameTable[i];
        var remapIndex = view.getUint16(konstantRemapTableOffs + i * 0x02);
        var r = readAnimationTrack(konstantRTable);
        var g = readAnimationTrack(konstantGTable);
        var b = readAnimationTrack(konstantBTable);
        var a = readAnimationTrack(konstantATable);
        var colorId = view.getUint8(animationTableIdx);
        var colorOverride = render_1.ColorOverride.K0 + colorId;
        animationTableIdx += 0x04;
        animationEntries.push({ materialName: materialName, remapIndex: remapIndex, colorOverride: colorOverride, r: r, g: g, b: b, a: a });
    }
    return { duration: duration, loopMode: loopMode, animationEntries: animationEntries };
}
//#endregion
//#region BRK
var BRK = /** @class */function () {
    function BRK() {}
    BRK.parse = function (buffer) {
        var brk = new BRK();
        var j3d = new J3DFileReaderHelper(buffer);
        util_1.assert(j3d.magic === 'J3D1brk1');
        brk.trk1 = readTRK1Chunk(j3d.nextChunk('TRK1'));
        return brk;
    };
    BRK.prototype.calcColorOverride = function (dst, materialName, colorOverride, frame) {
        var animationEntry = this.trk1.animationEntries.find(function (e) {
            return e.materialName === materialName && e.colorOverride === colorOverride;
        });
        if (!animationEntry) return false;
        var animFrame = getAnimFrame(this.trk1, frame);
        dst.r = sampleAnimationData(animationEntry.r, animFrame);
        dst.g = sampleAnimationData(animationEntry.g, animFrame);
        dst.b = sampleAnimationData(animationEntry.b, animFrame);
        dst.a = sampleAnimationData(animationEntry.a, animFrame);
        return true;
    };
    return BRK;
}();
exports.BRK = BRK;
function readANK1Chunk(buffer) {
    var view = buffer.createDataView();
    var loopMode = view.getUint8(0x08);
    var rotationDecimal = view.getUint8(0x09);
    var duration = view.getUint16(0x0A);
    var jointAnimationTableCount = view.getUint16(0x0C);
    var sCount = view.getUint16(0x0E);
    var rCount = view.getUint16(0x10);
    var tCount = view.getUint16(0x12);
    var jointAnimationTableOffs = view.getUint32(0x14);
    var sTableOffs = view.getUint32(0x18);
    var rTableOffs = view.getUint32(0x1C);
    var tTableOffs = view.getUint32(0x20);
    var rotationScale = Math.pow(2, rotationDecimal) / 32767;
    var sTable = buffer.createTypedArray(Float32Array, sTableOffs, sCount, endian_1.Endianness.BIG_ENDIAN);
    var rTable = buffer.createTypedArray(Int16Array, rTableOffs, rCount, endian_1.Endianness.BIG_ENDIAN);
    var tTable = buffer.createTypedArray(Float32Array, tTableOffs, tCount, endian_1.Endianness.BIG_ENDIAN);
    var animationTableIdx = jointAnimationTableOffs;
    function readAnimationTrack(data, scale) {
        var count = view.getUint16(animationTableIdx + 0x00);
        var index = view.getUint16(animationTableIdx + 0x02);
        var tangent = view.getUint16(animationTableIdx + 0x04);
        animationTableIdx += 0x06;
        return translateAnimationTrack(data, scale, count, index, tangent);
    }
    var jointAnimationEntries = [];
    for (var i = 0; i < jointAnimationTableCount; i++) {
        var scaleX = readAnimationTrack(sTable, 1);
        var rotationX = readAnimationTrack(rTable, rotationScale);
        var translationX = readAnimationTrack(tTable, 1);
        var scaleY = readAnimationTrack(sTable, 1);
        var rotationY = readAnimationTrack(rTable, rotationScale);
        var translationY = readAnimationTrack(tTable, 1);
        var scaleZ = readAnimationTrack(sTable, 1);
        var rotationZ = readAnimationTrack(rTable, rotationScale);
        var translationZ = readAnimationTrack(tTable, 1);
        jointAnimationEntries.push({
            index: i,
            scaleX: scaleX, rotationX: rotationX, translationX: translationX,
            scaleY: scaleY, rotationY: rotationY, translationY: translationY,
            scaleZ: scaleZ, rotationZ: rotationZ, translationZ: translationZ
        });
    }
    return { loopMode: loopMode, duration: duration, jointAnimationEntries: jointAnimationEntries };
}
//#endregion
//#region BCK
var BCK = /** @class */function () {
    function BCK() {}
    BCK.parse = function (buffer) {
        var bck = new BCK();
        var j3d = new J3DFileReaderHelper(buffer);
        util_1.assert(j3d.magic === 'J3D1bck1');
        bck.ank1 = readANK1Chunk(j3d.nextChunk('ANK1'));
        return bck;
    };
    BCK.prototype.calcJointMatrix = function (dst, jointIndex, frame) {
        var animFrame = getAnimFrame(this.ank1, frame);
        var entry = this.ank1.jointAnimationEntries[jointIndex];
        var scaleX = sampleAnimationData(entry.scaleX, animFrame);
        var rotationX = sampleAnimationData(entry.rotationX, animFrame) * 180;
        var translationX = sampleAnimationData(entry.translationX, animFrame);
        var scaleY = sampleAnimationData(entry.scaleY, animFrame);
        var rotationY = sampleAnimationData(entry.rotationY, animFrame) * 180;
        var translationY = sampleAnimationData(entry.translationY, animFrame);
        var scaleZ = sampleAnimationData(entry.scaleZ, animFrame);
        var rotationZ = sampleAnimationData(entry.rotationZ, animFrame) * 180;
        var translationZ = sampleAnimationData(entry.translationZ, animFrame);
        createJointMatrix(dst, scaleX, scaleY, scaleZ, rotationX, rotationY, rotationZ, translationX, translationY, translationZ);
    };
    return BCK;
}();
exports.BCK = BCK;
//#endregion
},{"gl-matrix":"..\\node_modules\\gl-matrix\\src\\gl-matrix.js","../endian":"endian.ts","../util":"util.ts","../gx/gx_displaylist":"gx\\gx_displaylist.ts","../gx/gx_enum":"gx\\gx_enum.ts","../gx/gx_material":"gx\\gx_material.ts","./render":"j3d\\render.ts","../Camera":"Camera.ts"}],"j3d\\rarc.ts":[function(require,module,exports) {
"use strict";
// Nintendo RARC file format.

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var __values = this && this.__values || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator],
        i = 0;
    if (m) return m.call(o);
    return {
        next: function next() {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("../util");
var RARC = /** @class */function () {
    function RARC() {}
    RARC.prototype.findDirParts = function (parts) {
        var e_1, _a;
        var dir = this.root;
        var _loop_1 = function _loop_1(part) {
            dir = dir.subdirs.find(function (subdir) {
                return subdir.name === part;
            });
            if (dir === undefined) return { value: null };
        };
        try {
            for (var parts_1 = __values(parts), parts_1_1 = parts_1.next(); !parts_1_1.done; parts_1_1 = parts_1.next()) {
                var part = parts_1_1.value;
                var state_1 = _loop_1(part);
                if ((typeof state_1 === "undefined" ? "undefined" : _typeof(state_1)) === "object") return state_1.value;
            }
        } catch (e_1_1) {
            e_1 = { error: e_1_1 };
        } finally {
            try {
                if (parts_1_1 && !parts_1_1.done && (_a = parts_1.return)) _a.call(parts_1);
            } finally {
                if (e_1) throw e_1.error;
            }
        }
        return dir;
    };
    RARC.prototype.findDir = function (path) {
        return this.findDirParts(path.split('/'));
    };
    RARC.prototype.findFile = function (path) {
        var parts = path.split('/');
        var filename = parts.pop();
        var dir = this.findDirParts(parts);
        if (dir === null) return null;
        var file = dir.files.find(function (file) {
            return file.name === filename;
        });
        if (!file) return null;
        return file;
    };
    return RARC;
}();
exports.RARC = RARC;
function parse(buffer) {
    var view = buffer.createDataView();
    util_1.assert(util_1.readString(buffer, 0x00, 0x04) === 'RARC');
    var size = view.getUint32(0x04);
    var dataOffs = view.getUint32(0x0C) + 0x20;
    var dirCount = view.getUint32(0x20);
    var dirTableOffs = view.getUint32(0x24) + 0x20;
    var fileEntryCount = view.getUint32(0x28);
    var fileEntryTableOffs = view.getUint32(0x2C) + 0x20;
    var strTableOffs = view.getUint32(0x34) + 0x20;
    var dirTableIdx = dirTableOffs;
    var dirEntries = [];
    var allFiles = [];
    for (var i = 0; i < dirCount; i++) {
        var type = util_1.readString(buffer, dirTableIdx + 0x00, 0x04, false);
        var nameOffs = view.getUint32(dirTableIdx + 0x04);
        var name = util_1.readString(buffer, strTableOffs + nameOffs, -1, true);
        var nameHash = view.getUint16(dirTableIdx + 0x08);
        var fileEntryCount_1 = view.getUint16(dirTableIdx + 0x0A);
        var fileEntryFirstIndex = view.getUint32(dirTableIdx + 0x0C);
        var files = [];
        var subdirIndexes = [];
        // Go through and parse the file table.
        var fileEntryIdx = fileEntryTableOffs + fileEntryFirstIndex * 0x14;
        for (var i_1 = 0; i_1 < fileEntryCount_1; i_1++) {
            var id = view.getUint16(fileEntryIdx + 0x00);
            var nameHash_1 = view.getUint16(fileEntryIdx + 0x02);
            var flags = view.getUint8(fileEntryIdx + 0x04);
            var nameOffs_1 = view.getUint16(fileEntryIdx + 0x06);
            var name_1 = util_1.readString(buffer, strTableOffs + nameOffs_1, -1, true);
            var entryDataOffs = view.getUint32(fileEntryIdx + 0x08);
            var entryDataSize = view.getUint32(fileEntryIdx + 0x0C);
            fileEntryIdx += 0x14;
            if (name_1 === '.' || name_1 === '..') continue;
            var isDirectory = !!(flags & 0x02);
            if (isDirectory) {
                var subdirEntryIndex = entryDataOffs;
                subdirIndexes.push(subdirEntryIndex);
            } else {
                var offs = dataOffs + entryDataOffs;
                var fileBuffer = buffer.slice(offs, offs + entryDataSize);
                var file = { name: name_1, buffer: fileBuffer };
                files.push(file);
                allFiles.push(file);
            }
        }
        dirEntries.push({ name: name, type: type, files: files, subdirIndexes: subdirIndexes });
        dirTableIdx += 0x10;
    }
    var dirs = [];
    function translateDirEntry(i) {
        if (dirs[i] !== undefined) return dirs[i];
        var dirEntry = dirEntries[i];
        var name = dirEntry.name,
            type = dirEntry.type,
            files = dirEntry.files;
        var subdirs = dirEntry.subdirIndexes.map(function (i) {
            return translateDirEntry(i);
        });
        var dir = { name: name, type: type, files: files, subdirs: subdirs };
        dirs[i] = dir;
        return dir;
    }
    var root = translateDirEntry(0);
    util_1.assert(root.type === 'ROOT');
    var rarc = new RARC();
    rarc.files = allFiles;
    rarc.root = root;
    return rarc;
}
exports.parse = parse;
},{"../util":"util.ts"}],"j3d\\ztp_scenes.ts":[function(require,module,exports) {
"use strict";

var __extends = this && this.__extends || function () {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
        d.__proto__ = b;
    } || function (d, b) {
        for (var p in b) {
            if (b.hasOwnProperty(p)) d[p] = b[p];
        }
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __assign = this && this.__assign || Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) {
            if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
    }
    return t;
};
var __read = this && this.__read || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o),
        r,
        ar = [],
        e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {
            ar.push(r.value);
        }
    } catch (error) {
        e = { error: error };
    } finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
            if (e) throw e.error;
        }
    }
    return ar;
};
var __spread = this && this.__spread || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) {
        ar = ar.concat(__read(arguments[i]));
    }return ar;
};
var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
};
var __importStar = this && this.__importStar || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) {
        if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    }result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Progressable_1 = __importDefault(require("../Progressable"));
var util_1 = require("../util");
var Yaz0 = __importStar(require("../compression/Yaz0"));
var UI = __importStar(require("../ui"));
var j3d_1 = require("./j3d");
var RARC = __importStar(require("./rarc"));
var render_1 = require("./render");
var render_2 = require("../render");
var gx_material_1 = require("../gx/gx_material");
var ZTPTextureHolder = /** @class */function (_super) {
    __extends(ZTPTextureHolder, _super);
    function ZTPTextureHolder() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ZTPTextureHolder.prototype.tryTextureNameVariants = function (name) {
        var extraTextureName = "ExtraTex/" + name.toLowerCase().replace('.tga', '');
        return [name, extraTextureName];
    };
    ZTPTextureHolder.prototype.addExtraTextures = function (gl, extraTextures) {
        this.addTextures(gl, extraTextures.map(function (texture) {
            var name = "ExtraTex/" + texture.name.toLowerCase();
            return __assign({}, texture, { name: name });
        }));
    };
    return ZTPTextureHolder;
}(render_1.J3DTextureHolder);
function createScene(gl, textureHolder, bmdFile, btkFile, brkFile, bckFile, bmtFile) {
    var bmd = j3d_1.BMD.parse(bmdFile.buffer);
    var bmt = bmtFile ? j3d_1.BMT.parse(bmtFile.buffer) : null;
    textureHolder.addJ3DTextures(gl, bmd, bmt);
    var sceneLoader = new render_1.SceneLoader(textureHolder, bmd, bmt);
    var scene = sceneLoader.createScene(gl);
    scene.setBTK(btkFile ? j3d_1.BTK.parse(btkFile.buffer) : null);
    scene.setBRK(brkFile ? j3d_1.BRK.parse(brkFile.buffer) : null);
    scene.setBCK(bckFile ? j3d_1.BCK.parse(bckFile.buffer) : null);
    return scene;
}
function createScenesFromRARC(gl, textureHolder, rarcName, rarc) {
    var bmdFiles = rarc.files.filter(function (f) {
        return f.name.endsWith('.bmd') || f.name.endsWith('.bdl');
    });
    var scenes = bmdFiles.map(function (bmdFile) {
        var basename = bmdFile.name.split('.')[0];
        var btkFile = rarc.files.find(function (f) {
            return f.name === basename + ".btk";
        });
        var brkFile = rarc.files.find(function (f) {
            return f.name === basename + ".brk";
        });
        var bckFile = rarc.files.find(function (f) {
            return f.name === basename + ".bck";
        });
        var bmtFile = rarc.files.find(function (f) {
            return f.name === basename + ".bmt";
        });
        var scene = createScene(gl, textureHolder, bmdFile, btkFile, brkFile, bckFile, bmtFile);
        scene.name = rarcName + "/" + basename;
        return scene;
    });
    return scenes.filter(function (s) {
        return !!s;
    });
}
var TwilightPrincessRenderer = /** @class */function () {
    function TwilightPrincessRenderer(textureHolder, stageRarc, roomRarcs, skyboxScenes, roomScenes) {
        var _this = this;
        this.textureHolder = textureHolder;
        this.stageRarc = stageRarc;
        this.roomRarcs = roomRarcs;
        this.skyboxScenes = skyboxScenes;
        this.roomScenes = roomScenes;
        this.textures = [];
        this.mainColorTarget = new render_2.ColorTarget();
        this.opaqueScenes = [];
        this.indTexScenes = [];
        this.transparentScenes = [];
        this.windowScenes = [];
        this.textures = textureHolder.viewerTextures;
        this.roomScenes.forEach(function (scene) {
            if (scene.name.endsWith('model')) {
                _this.opaqueScenes.push(scene);
            } else if (scene.name.endsWith('model1')) {
                _this.indTexScenes.push(scene);
            } else if (scene.name.endsWith('model2')) {
                _this.transparentScenes.push(scene);
            } else if (scene.name.endsWith('model3')) {
                _this.windowScenes.push(scene);
            } else if (scene.name.endsWith('model4')) {
                _this.transparentScenes.push(scene);
            } else {
                throw "whoops";
            }
        });
    }
    TwilightPrincessRenderer.prototype.createPanels = function () {
        var layers = new UI.LayerPanel();
        layers.setLayers(this.roomScenes);
        return [layers];
    };
    TwilightPrincessRenderer.prototype.render = function (state) {
        var gl = state.gl;
        // Draw skybox + opaque to main RT.
        this.mainColorTarget.setParameters(gl, state.onscreenColorTarget.width, state.onscreenColorTarget.height);
        state.useRenderTarget(this.mainColorTarget);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        this.skyboxScenes.forEach(function (scene) {
            scene.render(state);
        });
        state.useFlags(render_2.depthClearFlags);
        gl.clear(gl.DEPTH_BUFFER_BIT);
        this.opaqueScenes.forEach(function (scene) {
            scene.render(state);
        });
        // Copy to main render target.
        state.useRenderTarget(state.onscreenColorTarget);
        state.blitColorTarget(this.mainColorTarget);
        // IndTex.
        if (this.indTexScenes.length) {
            var textureOverride = { glTexture: this.mainColorTarget.resolvedColorTexture, width: gx_material_1.EFB_WIDTH, height: gx_material_1.EFB_HEIGHT, flipY: true };
            this.textureHolder.setTextureOverride("fbtex_dummy", textureOverride);
        }
        this.indTexScenes.forEach(function (indirectScene) {
            indirectScene.render(state);
        });
        // Transparent.
        this.transparentScenes.forEach(function (scene) {
            scene.render(state);
        });
        // Window & Doorway fades. Separate so that the renderer can override color registers separately.
        // We don't do anything about this yet...
        this.windowScenes.forEach(function (scene) {
            scene.render(state);
        });
    };
    TwilightPrincessRenderer.prototype.destroy = function (gl) {
        this.textureHolder.destroy(gl);
        this.skyboxScenes.forEach(function (scene) {
            return scene.destroy(gl);
        });
        this.roomScenes.forEach(function (scene) {
            return scene.destroy(gl);
        });
    };
    return TwilightPrincessRenderer;
}();
var TwilightPrincessSceneDesc = /** @class */function () {
    function TwilightPrincessSceneDesc(name, folder, roomPaths) {
        this.name = name;
        this.folder = folder;
        this.roomPaths = roomPaths;
        this.id = this.folder;
    }
    TwilightPrincessSceneDesc.prototype.createScene = function (gl) {
        var _this = this;
        var basePath = "data/j3d/ztp/" + this.folder;
        var paths = __spread(["STG_00.arc"], this.roomPaths).map(function (path) {
            return basePath + "/" + path;
        });
        var textureHolder = new ZTPTextureHolder();
        return Progressable_1.default.all(paths.map(function (path) {
            return _this.fetchRarc(path);
        })).then(function (rarcs) {
            var stageRarc = rarcs.shift();
            var texcFolder = stageRarc.findDir("texc");
            var extraTextureFiles = texcFolder !== null ? texcFolder.files : [];
            var extraTextures = extraTextureFiles.map(function (file) {
                var name = file.name.split('.')[0];
                return j3d_1.BTI.parse(file.buffer, name).texture;
            });
            textureHolder.addExtraTextures(gl, extraTextures);
            var skyboxScenes = ["vrbox_sora", "vrbox_kasumim"].map(function (basename) {
                var bmdFile = stageRarc.findFile("bmdp/" + basename + ".bmd");
                if (!bmdFile) return null;
                var btkFile = stageRarc.findFile("btk/" + basename + ".btk");
                var brkFile = stageRarc.findFile("brk/" + basename + ".brk");
                var bckFile = stageRarc.findFile("bck/" + basename + ".bck");
                var scene = createScene(gl, textureHolder, bmdFile, btkFile, brkFile, bckFile, null);
                scene.setIsSkybox(true);
                return scene;
            }).filter(function (s) {
                return !!s;
            });
            var roomRarcs = rarcs;
            var roomScenes_ = roomRarcs.map(function (rarc, i) {
                var rarcBasename = _this.roomPaths[i].split('.')[0];
                return createScenesFromRARC(gl, textureHolder, rarcBasename, rarc);
            });
            var roomScenes = [];
            roomScenes_.forEach(function (scenes) {
                return roomScenes.push.apply(roomScenes, scenes);
            });
            return new TwilightPrincessRenderer(textureHolder, stageRarc, roomRarcs, skyboxScenes, roomScenes);
        });
    };
    TwilightPrincessSceneDesc.prototype.fetchRarc = function (path) {
        return util_1.fetch(path).then(function (buffer) {
            return Yaz0.decompress(buffer);
        }).then(function (buffer) {
            return RARC.parse(buffer);
        });
    };
    return TwilightPrincessSceneDesc;
}();
var id = "ztp";
var name = "The Legend of Zelda: Twilight Princess";
var sceneDescs = [new TwilightPrincessSceneDesc("Forest Temple", "D_MN05", ["R02_00.arc", "R03_00.arc", "R04_00.arc", "R05_00.arc", "R07_00.arc", "R09_00.arc", "R10_00.arc", "R11_00.arc", "R12_00.arc", "R19_00.arc", "R22_00.arc", "R00_00.arc", "R01_00.arc"]), new TwilightPrincessSceneDesc("Goron Mines", "D_MN04", ["R11_00.arc", "R12_00.arc", "R13_00.arc", "R14_00.arc", "R16_00.arc", "R17_00.arc", "R01_00.arc", "R03_00.arc", "R04_00.arc", "R05_00.arc", "R06_00.arc", "R07_00.arc", "R09_00.arc"]), new TwilightPrincessSceneDesc("Lakebed Temple", "D_MN01", ["R00_00.arc", "R01_00.arc", "R02_00.arc", "R03_00.arc", "R05_00.arc", "R06_00.arc", "R07_00.arc", "R08_00.arc", "R09_00.arc", "R10_00.arc", "R11_00.arc", "R12_00.arc", "R13_00.arc"]), new TwilightPrincessSceneDesc("Arbiter's Grounds", "D_MN10", ["R01_00.arc", "R02_00.arc", "R03_00.arc", "R04_00.arc", "R05_00.arc", "R06_00.arc", "R07_00.arc", "R08_00.arc", "R09_00.arc", "R10_00.arc", "R11_00.arc", "R12_00.arc", "R13_00.arc", "R14_00.arc", "R15_00.arc", "R16_00.arc", "R00_00.arc"]), new TwilightPrincessSceneDesc("Snowpeak Ruins", "D_MN11", ["R00_00.arc", "R01_00.arc", "R02_00.arc", "R03_00.arc", "R04_00.arc", "R05_00.arc", "R06_00.arc", "R07_00.arc", "R08_00.arc", "R09_00.arc", "R11_00.arc", "R13_00.arc"]), new TwilightPrincessSceneDesc("Temple of Time", "D_MN06", ["R08_00.arc", "R00_00.arc", "R01_00.arc", "R02_00.arc", "R03_00.arc", "R04_00.arc", "R05_00.arc", "R06_00.arc", "R07_00.arc"]), new TwilightPrincessSceneDesc("City in the Sky", "D_MN07", ["R00_00.arc", "R01_00.arc", "R02_00.arc", "R03_00.arc", "R04_00.arc", "R05_00.arc", "R06_00.arc", "R07_00.arc", "R08_00.arc", "R10_00.arc", "R11_00.arc", "R12_00.arc", "R13_00.arc", "R14_00.arc", "R15_00.arc", "R16_00.arc"]), new TwilightPrincessSceneDesc("Palace of Twilight", "D_MN08", ["R00_00.arc", "R01_00.arc", "R02_00.arc", "R04_00.arc", "R05_00.arc", "R07_00.arc", "R08_00.arc", "R09_00.arc", "R10_00.arc", "R11_00.arc"]), new TwilightPrincessSceneDesc("Hyrule Castle", "D_MN09", ["R03_00.arc", "R04_00.arc", "R05_00.arc", "R06_00.arc", "R08_00.arc", "R09_00.arc", "R11_00.arc", "R12_00.arc", "R13_00.arc", "R14_00.arc", "R15_00.arc", "R01_00.arc", "R02_00.arc"]), new TwilightPrincessSceneDesc("Hyrule Field", "F_SP102", ["R00_00.arc"]), new TwilightPrincessSceneDesc("Fishing Pond", "F_SP127", ["R00_00.arc"])];
exports.sceneGroup = { id: id, name: name, sceneDescs: sceneDescs };
},{"../Progressable":"Progressable.ts","../util":"util.ts","../compression/Yaz0":"compression\\Yaz0.ts","../ui":"ui.ts","./j3d":"j3d\\j3d.ts","./rarc":"j3d\\rarc.ts","./render":"j3d\\render.ts","../render":"render.ts","../gx/gx_material":"gx\\gx_material.ts"}],"j3d\\scenes.ts":[function(require,module,exports) {
"use strict";

var __values = this && this.__values || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator],
        i = 0;
    if (m) return m.call(o);
    return {
        next: function next() {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
var __importStar = this && this.__importStar || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) {
        if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    }result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("../util");
var UI = __importStar(require("../ui"));
var j3d_1 = require("./j3d");
var Yaz0 = __importStar(require("../compression/Yaz0"));
var RARC = __importStar(require("./rarc"));
var render_1 = require("./render");
var MultiScene = /** @class */function () {
    function MultiScene(textureHolder, scenes) {
        this.textureHolder = textureHolder;
        this.setScenes(scenes);
    }
    MultiScene.prototype.createPanels = function () {
        var layersPanel = new UI.LayerPanel();
        layersPanel.setLayers(this.scenes);
        return [layersPanel];
    };
    MultiScene.prototype.render = function (renderState) {
        this.scenes.forEach(function (scene) {
            scene.render(renderState);
        });
    };
    MultiScene.prototype.destroy = function (gl) {
        this.textureHolder.destroy(gl);
        this.scenes.forEach(function (scene) {
            return scene.destroy(gl);
        });
    };
    MultiScene.prototype.setScenes = function (scenes) {
        var e_1, _a;
        this.scenes = scenes;
        this.textures = [];
        try {
            for (var _b = __values(this.scenes), _c = _b.next(); !_c.done; _c = _b.next()) {
                var scene = _c.value;
                this.textures = this.textures.concat(scene.textures);
            }
        } catch (e_1_1) {
            e_1 = { error: e_1_1 };
        } finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally {
                if (e_1) throw e_1.error;
            }
        }
    };
    return MultiScene;
}();
exports.MultiScene = MultiScene;
function createScene(gl, textureHolder, bmdFile, btkFile, brkFile, bckFile, bmtFile) {
    var bmd = j3d_1.BMD.parse(bmdFile.buffer);
    var bmt = bmtFile ? j3d_1.BMT.parse(bmtFile.buffer) : null;
    textureHolder.addJ3DTextures(gl, bmd, bmt);
    var sceneLoader = new render_1.SceneLoader(textureHolder, bmd, bmt);
    var scene = sceneLoader.createScene(gl);
    scene.setBTK(btkFile ? j3d_1.BTK.parse(btkFile.buffer) : null);
    scene.setBRK(brkFile ? j3d_1.BRK.parse(brkFile.buffer) : null);
    scene.setBCK(bckFile ? j3d_1.BCK.parse(bckFile.buffer) : null);
    return scene;
}
exports.createScene = createScene;
function boolSort(a, b) {
    if (a && !b) return -1;else if (b && !a) return 1;else return 0;
}
function createScenesFromBuffer(gl, textureHolder, buffer) {
    return Promise.resolve(buffer).then(function (buffer) {
        if (util_1.readString(buffer, 0, 4) === 'Yaz0') return Yaz0.decompress(buffer);else return buffer;
    }).then(function (buffer) {
        if (util_1.readString(buffer, 0, 4) === 'RARC') {
            var rarc_1 = RARC.parse(buffer);
            var bmdFiles = rarc_1.files.filter(function (f) {
                return f.name.endsWith('.bmd') || f.name.endsWith('.bdl');
            });
            var scenes = bmdFiles.map(function (bmdFile) {
                // Find the corresponding btk.
                var basename = bmdFile.name.split('.')[0];
                var btkFile = rarc_1.files.find(function (f) {
                    return f.name === basename + ".btk";
                });
                var brkFile = rarc_1.files.find(function (f) {
                    return f.name === basename + ".brk";
                });
                var bckFile = rarc_1.files.find(function (f) {
                    return f.name === basename + ".bck";
                });
                var bmtFile = rarc_1.files.find(function (f) {
                    return f.name === basename + ".bmt";
                });
                var scene;
                try {
                    scene = createScene(gl, textureHolder, bmdFile, btkFile, brkFile, bckFile, bmtFile);
                } catch (e) {
                    console.warn("File " + basename + " failed to parse:", e);
                    return null;
                }
                scene.name = basename;
                if (basename.includes('_sky')) scene.setIsSkybox(true);
                return scene;
            });
            scenes = scenes.filter(function (scene) {
                return !!scene;
            });
            // Sort skyboxen before non-skyboxen.
            scenes = scenes.sort(function (a, b) {
                return boolSort(a.isSkybox, b.isSkybox);
            });
            return scenes;
        }
        if (['J3D2bmd3', 'J3D2bdl4'].includes(util_1.readString(buffer, 0, 8))) {
            var bmd = j3d_1.BMD.parse(buffer);
            textureHolder.addJ3DTextures(gl, bmd);
            var sceneLoader = new render_1.SceneLoader(textureHolder, bmd);
            var scene = sceneLoader.createScene(gl);
            return [scene];
        }
        return null;
    });
}
exports.createScenesFromBuffer = createScenesFromBuffer;
function createMultiSceneFromBuffer(gl, buffer) {
    var textureHolder = new render_1.J3DTextureHolder();
    return createScenesFromBuffer(gl, textureHolder, buffer).then(function (scenes) {
        return new MultiScene(textureHolder, scenes);
    });
}
exports.createMultiSceneFromBuffer = createMultiSceneFromBuffer;
},{"../util":"util.ts","../ui":"ui.ts","./j3d":"j3d\\j3d.ts","../compression/Yaz0":"compression\\Yaz0.ts","./rarc":"j3d\\rarc.ts","./render":"j3d\\render.ts"}],"j3d\\mkdd_scenes.ts":[function(require,module,exports) {
"use strict";

var __values = this && this.__values || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator],
        i = 0;
    if (m) return m.call(o);
    return {
        next: function next() {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
var __importStar = this && this.__importStar || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) {
        if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    }result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var scenes_1 = require("./scenes");
var util_1 = require("../util");
var gl_matrix_1 = require("gl-matrix");
var RARC = __importStar(require("./rarc"));
var render_1 = require("./render");
var j3d_1 = require("./j3d");
var id = "mkdd";
var name = "Mario Kart: Double Dash!!";
function parseBOL(buffer) {
    var view = buffer.createDataView();
    util_1.assert(util_1.readString(buffer, 0x00, 0x04) == '0015');
    var objectTableCount = view.getUint16(0x1E);
    var objectTableOffs = view.getUint32(0x54);
    var objects = [];
    var objectTableIdx = objectTableOffs;
    for (var i = 0; i < objectTableCount; i++) {
        var translationX = view.getFloat32(objectTableIdx + 0x00);
        var translationY = view.getFloat32(objectTableIdx + 0x04);
        var translationZ = view.getFloat32(objectTableIdx + 0x08);
        var scaleX = view.getFloat32(objectTableIdx + 0x0C);
        var scaleY = view.getFloat32(objectTableIdx + 0x10);
        var scaleZ = view.getFloat32(objectTableIdx + 0x14);
        var rotFaceX = view.getInt32(objectTableIdx + 0x18);
        var rotFaceZ = view.getInt32(objectTableIdx + 0x1C);
        var rotFaceN = view.getInt32(objectTableIdx + 0x20);
        var id_1 = view.getUint16(objectTableIdx + 0x24);
        var routeId = view.getInt16(objectTableIdx + 0x26);
        var modelMatrix = gl_matrix_1.mat4.create();
        var q = gl_matrix_1.quat.create();
        var rotationY = Math.atan2(rotFaceZ, rotFaceX);
        gl_matrix_1.quat.fromEuler(q, 0, -(rotationY * 180 / Math.PI) + 90, 0);
        gl_matrix_1.mat4.fromRotationTranslationScale(modelMatrix, q, [translationX, translationY, translationZ], [scaleX, scaleY, scaleZ]);
        objects.push({ id: id_1, routeId: routeId, modelMatrix: modelMatrix });
        objectTableIdx += 0x40;
    }
    return { objects: objects };
}
var MKDDSceneDesc = /** @class */function () {
    function MKDDSceneDesc(name, path) {
        this.name = name;
        this.path = path;
        this.id = this.path;
    }
    MKDDSceneDesc.prototype.spawnBMD = function (gl, textureHolder, rarc, basename, modelMatrix) {
        if (modelMatrix === void 0) {
            modelMatrix = null;
        }
        var bmdFile = rarc.findFile(basename + ".bmd");
        util_1.assertExists(bmdFile);
        var btkFile = rarc.findFile(basename + ".btk");
        var brkFile = rarc.findFile(basename + ".brk");
        var bmtFile = rarc.findFile(basename + ".bmt");
        var scene = scenes_1.createScene(gl, textureHolder, bmdFile, btkFile, brkFile, null, bmtFile);
        scene.name = basename;
        if (modelMatrix !== null) gl_matrix_1.mat4.copy(scene.modelMatrix, modelMatrix);
        return scene;
    };
    MKDDSceneDesc.prototype.createScene = function (gl) {
        var _this = this;
        var path = "data/j3d/mkdd/Course/" + this.path;
        return util_1.fetch(path).then(function (buffer) {
            var e_1, _a;
            var rarc = RARC.parse(buffer);
            // Find course name.
            var bolFile = rarc.files.find(function (f) {
                return f.name.endsWith('_course.bol');
            });
            var courseName = bolFile.name.replace('_course.bol', '');
            var textureHolder = new render_1.J3DTextureHolder();
            var scenes = [];
            if (rarc.findFile(courseName + "_sky.bmd")) scenes.push(_this.spawnBMD(gl, textureHolder, rarc, courseName + "_sky"));
            scenes.push(_this.spawnBMD(gl, textureHolder, rarc, courseName + "_course"));
            var spawnObject = function spawnObject(obj, basename, animName) {
                if (animName === void 0) {
                    animName = null;
                }
                var scene = _this.spawnBMD(gl, textureHolder, rarc, basename, obj.modelMatrix);
                var bckFile;
                if (animName !== null) {
                    bckFile = rarc.findFile(animName);
                    util_1.assertExists(bckFile);
                } else {
                    bckFile = rarc.findFile(basename + "_wait.bck");
                }
                if (bckFile !== null) {
                    var bck = j3d_1.BCK.parse(bckFile.buffer);
                    scene.setBCK(bck);
                }
                scenes.push(scene);
                return scene;
            };
            var bol = parseBOL(bolFile.buffer);
            console.log(courseName, rarc, bol);
            try {
                for (var _b = __values(bol.objects), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var obj = _c.value;
                    switch (obj.id) {
                        case 0x0001:
                        case 0x0009:
                            // Item box.
                            break;
                        case 0x0D49:
                            // Sea.
                            spawnObject(obj, "objects/sea1_spc");
                            spawnObject(obj, "objects/sea2_tex");
                            spawnObject(obj, "objects/sea3_dark");
                            spawnObject(obj, "objects/sea4_nami");
                            spawnObject(obj, "objects/sea5_sand");
                            break;
                        case 0x0D4A:
                            spawnObject(obj, "objects/poihana1");
                            break;
                        case 0x0D4D:
                            spawnObject(obj, "objects/peachtree1");
                            break;
                        case 0x0D4E:
                            spawnObject(obj, "objects/peachfountain");
                            break;
                        case 0x0D4F:
                            spawnObject(obj, "objects/marel_a");
                            break;
                        case 0x0E75:
                            spawnObject(obj, "objects/mariotree1");
                            break;
                        case 0x0E77:
                            spawnObject(obj, "objects/marioflower1", "objects/marioflower1.bck");
                            break;
                        case 0x0E78:
                            // Chain chomp. Looks awful, don't spawn.
                            // spawnObject(obj, `objects/wanwan1`); break;
                            break;
                        case 0x0E7E:
                            spawnObject(obj, 'objects/skyship1');
                            break;
                        case 0x0E7F:
                            spawnObject(obj, "objects/kuribo1");
                            break;
                        case 0x119A:
                            // Butterflies.
                            break;
                        default:
                            console.warn("Unknown object ID " + obj.id.toString(16));
                            continue;
                    }
                }
            } catch (e_1_1) {
                e_1 = { error: e_1_1 };
            } finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                } finally {
                    if (e_1) throw e_1.error;
                }
            }
            return new scenes_1.MultiScene(textureHolder, scenes);
        });
    };
    return MKDDSceneDesc;
}();
var sceneDescs = [new MKDDSceneDesc("Luigi Circuit", 'Luigi.arc'), new MKDDSceneDesc("Peach Beach", 'Peach.arc'), new MKDDSceneDesc("Baby Park", 'BabyLuigi.arc'), new MKDDSceneDesc("Dry Dry Desert", 'Desert.arc'), new MKDDSceneDesc("Mushroom Bridge", 'Nokonoko.arc'), new MKDDSceneDesc("Mario Circuit", 'Mario.arc'), new MKDDSceneDesc("Daisy Cruiser", 'Daisy.arc'), new MKDDSceneDesc("Waluigi Stadium", 'Waluigi.arc'), new MKDDSceneDesc("Sherbet Land", 'Snow.arc'), new MKDDSceneDesc("Mushroom City", 'Patapata.arc'), new MKDDSceneDesc("Yoshi Circuit", 'Yoshi.arc'), new MKDDSceneDesc("DK Mountain", 'Donkey.arc'), new MKDDSceneDesc("Wario Colosseum", 'Wario.arc'), new MKDDSceneDesc("Dino Dino Jungle", 'Diddy.arc'), new MKDDSceneDesc("Bowser's Castle", 'Koopa.arc'), new MKDDSceneDesc("Rainbow Road", 'Rainbow.arc')];
exports.sceneGroup = { id: id, name: name, sceneDescs: sceneDescs };
},{"./scenes":"j3d\\scenes.ts","../util":"util.ts","gl-matrix":"..\\node_modules\\gl-matrix\\src\\gl-matrix.js","./rarc":"j3d\\rarc.ts","./render":"j3d\\render.ts","./j3d":"j3d\\j3d.ts"}],"j3d\\zww_scenes.ts":[function(require,module,exports) {
"use strict";

var __extends = this && this.__extends || function () {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
        d.__proto__ = b;
    } || function (d, b) {
        for (var p in b) {
            if (b.hasOwnProperty(p)) d[p] = b[p];
        }
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __values = this && this.__values || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator],
        i = 0;
    if (m) return m.call(o);
    return {
        next: function next() {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
var __read = this && this.__read || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o),
        r,
        ar = [],
        e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {
            ar.push(r.value);
        }
    } catch (error) {
        e = { error: error };
    } finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
            if (e) throw e.error;
        }
    }
    return ar;
};
var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
};
var __importStar = this && this.__importStar || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) {
        if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    }result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var gl_matrix_1 = require("gl-matrix");
var Progressable_1 = __importDefault(require("../Progressable"));
var util_1 = require("../util");
var render_1 = require("../render");
var Yaz0 = __importStar(require("../compression/Yaz0"));
var UI = __importStar(require("../ui"));
var GX_Material = __importStar(require("../gx/gx_material"));
var j3d_1 = require("./j3d");
var RARC = __importStar(require("./rarc"));
var render_2 = require("./render");
var Program_1 = __importDefault(require("../Program"));
var Color_1 = require("../Color");
var CameraPos = /** @class */function () {
    function CameraPos(x, y, z, lx, ly, lz) {
        this.x = x;
        this.y = y;
        this.z = z;
        this.lx = lx;
        this.ly = ly;
        this.lz = lz;
    }
    CameraPos.prototype.set = function (m) {
        gl_matrix_1.mat4.lookAt(m, [this.x, this.y, this.z], [this.lx, this.ly, this.lz], [0, 1, 0]);
    };
    return CameraPos;
}();
var TIME_OF_DAY_ICON = "<svg viewBox=\"0 0 100 100\" height=\"20\" fill=\"white\"><path d=\"M50,93.4C74,93.4,93.4,74,93.4,50C93.4,26,74,6.6,50,6.6C26,6.6,6.6,26,6.6,50C6.6,74,26,93.4,50,93.4z M37.6,22.8  c-0.6,2.4-0.9,5-0.9,7.6c0,18.2,14.7,32.9,32.9,32.9c2.6,0,5.1-0.3,7.6-0.9c-4.7,10.3-15.1,17.4-27.1,17.4  c-16.5,0-29.9-13.4-29.9-29.9C20.3,37.9,27.4,27.5,37.6,22.8z\"/></svg>";
function getColorsFromDZS(buffer, roomIdx, timeOfDay) {
    var view = buffer.createDataView();
    var chunkCount = view.getUint32(0x00);
    var chunkOffsets = new Map();
    var chunkTableIdx = 0x04;
    for (var i = 0; i < chunkCount; i++) {
        var type = util_1.readString(buffer, chunkTableIdx + 0x00, 0x04);
        var offs = view.getUint32(chunkTableIdx + 0x08);
        chunkOffsets.set(type, offs);
        chunkTableIdx += 0x0C;
    }
    var coloIdx = view.getUint8(chunkOffsets.get('EnvR') + roomIdx * 0x08);
    var coloOffs = chunkOffsets.get('Colo') + coloIdx * 0x0C;
    var whichPale = timeOfDay;
    var paleIdx = view.getUint8(coloOffs + whichPale);
    var paleOffs = chunkOffsets.get('Pale') + paleIdx * 0x2C;
    var virtIdx = view.getUint8(paleOffs + 0x21);
    var virtOffs = chunkOffsets.get('Virt') + virtIdx * 0x24;
    var ambR = view.getUint8(paleOffs + 0x06) / 0xFF;
    var ambG = view.getUint8(paleOffs + 0x07) / 0xFF;
    var ambB = view.getUint8(paleOffs + 0x08) / 0xFF;
    var amb = new GX_Material.Color(ambR, ambG, ambB, 1);
    var lightR = view.getUint8(paleOffs + 0x09) / 0xFF;
    var lightG = view.getUint8(paleOffs + 0x0A) / 0xFF;
    var lightB = view.getUint8(paleOffs + 0x0B) / 0xFF;
    var light = new GX_Material.Color(lightR, lightG, lightB, 1);
    var waveR = view.getUint8(paleOffs + 0x0C) / 0xFF;
    var waveG = view.getUint8(paleOffs + 0x0D) / 0xFF;
    var waveB = view.getUint8(paleOffs + 0x0E) / 0xFF;
    var wave = new GX_Material.Color(waveR, waveG, waveB, 1);
    var oceanR = view.getUint8(paleOffs + 0x0F) / 0xFF;
    var oceanG = view.getUint8(paleOffs + 0x10) / 0xFF;
    var oceanB = view.getUint8(paleOffs + 0x11) / 0xFF;
    var ocean = new GX_Material.Color(oceanR, oceanG, oceanB, 1);
    var splashR = view.getUint8(paleOffs + 0x12) / 0xFF;
    var splashG = view.getUint8(paleOffs + 0x13) / 0xFF;
    var splashB = view.getUint8(paleOffs + 0x14) / 0xFF;
    var splash = new GX_Material.Color(splashR, splashG, splashB, 1);
    var splash2R = view.getUint8(paleOffs + 0x15) / 0xFF;
    var splash2G = view.getUint8(paleOffs + 0x16) / 0xFF;
    var splash2B = view.getUint8(paleOffs + 0x17) / 0xFF;
    var splash2 = new GX_Material.Color(splash2R, splash2G, splash2B, 1);
    var doorsR = view.getUint8(paleOffs + 0x18) / 0xFF;
    var doorsG = view.getUint8(paleOffs + 0x19) / 0xFF;
    var doorsB = view.getUint8(paleOffs + 0x1A) / 0xFF;
    var doors = new GX_Material.Color(doorsR, doorsG, doorsB, 1);
    var vr_back_cloudR = view.getUint8(virtOffs + 0x10) / 0xFF;
    var vr_back_cloudG = view.getUint8(virtOffs + 0x11) / 0xFF;
    var vr_back_cloudB = view.getUint8(virtOffs + 0x12) / 0xFF;
    var vr_back_cloudA = view.getUint8(virtOffs + 0x13) / 0xFF;
    var vr_back_cloud = new GX_Material.Color(vr_back_cloudR, vr_back_cloudG, vr_back_cloudB, vr_back_cloudA);
    var vr_skyR = view.getUint8(virtOffs + 0x18) / 0xFF;
    var vr_skyG = view.getUint8(virtOffs + 0x19) / 0xFF;
    var vr_skyB = view.getUint8(virtOffs + 0x1A) / 0xFF;
    var vr_sky = new GX_Material.Color(vr_skyR, vr_skyG, vr_skyB, 1);
    var vr_uso_umiR = view.getUint8(virtOffs + 0x1B) / 0xFF;
    var vr_uso_umiG = view.getUint8(virtOffs + 0x1C) / 0xFF;
    var vr_uso_umiB = view.getUint8(virtOffs + 0x1D) / 0xFF;
    var vr_uso_umi = new GX_Material.Color(vr_uso_umiR, vr_uso_umiG, vr_uso_umiB, 1);
    var vr_kasumi_maeG = view.getUint8(virtOffs + 0x1F) / 0xFF;
    var vr_kasumi_maeR = view.getUint8(virtOffs + 0x1E) / 0xFF;
    var vr_kasumi_maeB = view.getUint8(virtOffs + 0x20) / 0xFF;
    var vr_kasumi_mae = new GX_Material.Color(vr_kasumi_maeR, vr_kasumi_maeG, vr_kasumi_maeB, 1);
    return { amb: amb, light: light, wave: wave, ocean: ocean, splash: splash, splash2: splash2, doors: doors, vr_back_cloud: vr_back_cloud, vr_sky: vr_sky, vr_uso_umi: vr_uso_umi, vr_kasumi_mae: vr_kasumi_mae };
}
function createScene(gl, textureHolder, rarc, name, isSkybox) {
    if (isSkybox === void 0) {
        isSkybox = false;
    }
    var bdlFile = rarc.findFile("bdl/" + name + ".bdl");
    if (!bdlFile) return null;
    var btkFile = rarc.findFile("btk/" + name + ".btk");
    var brkFile = rarc.findFile("brk/" + name + ".brk");
    var bckFile = rarc.findFile("bck/" + name + ".bck");
    var bdl = j3d_1.BMD.parse(bdlFile.buffer);
    var sceneLoader = new render_2.SceneLoader(textureHolder, bdl, null);
    textureHolder.addJ3DTextures(gl, bdl);
    var scene = sceneLoader.createScene(gl);
    scene.setBTK(btkFile !== null ? j3d_1.BTK.parse(btkFile.buffer) : null);
    scene.setBRK(brkFile !== null ? j3d_1.BRK.parse(brkFile.buffer) : null);
    scene.setBCK(bckFile !== null ? j3d_1.BCK.parse(bckFile.buffer) : null);
    scene.setIsSkybox(isSkybox);
    return scene;
}
var WindWakerRoomRenderer = /** @class */function () {
    function WindWakerRoomRenderer(gl, textureHolder, roomIdx, roomRarc) {
        this.textureHolder = textureHolder;
        this.roomIdx = roomIdx;
        this.roomRarc = roomRarc;
        this.model = createScene(gl, textureHolder, roomRarc, "model");
        // Ocean.
        this.model1 = createScene(gl, textureHolder, roomRarc, "model1");
        // Windows / doors.
        this.model3 = createScene(gl, textureHolder, roomRarc, "model3");
        this.textures = this.textureHolder.viewerTextures;
    }
    WindWakerRoomRenderer.prototype.setModelMatrix = function (modelMatrix) {
        gl_matrix_1.mat4.copy(this.model.modelMatrix, modelMatrix);
        if (this.model1) gl_matrix_1.mat4.copy(this.model1.modelMatrix, modelMatrix);
        if (this.model3) gl_matrix_1.mat4.copy(this.model3.modelMatrix, modelMatrix);
    };
    WindWakerRoomRenderer.prototype.setColors = function (colors) {
        if (colors !== undefined) {
            this.model.setColorOverride(render_2.ColorOverride.K0, colors.light);
            this.model.setColorOverride(render_2.ColorOverride.C0, colors.amb);
            if (this.model1) {
                this.model1.setColorOverride(render_2.ColorOverride.K0, colors.ocean);
                this.model1.setColorOverride(render_2.ColorOverride.C0, colors.wave);
                this.model1.setColorOverride(render_2.ColorOverride.C1, colors.splash);
                this.model1.setColorOverride(render_2.ColorOverride.K1, colors.splash2);
            }
            if (this.model3) this.model3.setColorOverride(render_2.ColorOverride.C0, colors.doors);
        } else {
            this.model.setColorOverride(render_2.ColorOverride.K0, undefined);
            this.model.setColorOverride(render_2.ColorOverride.C0, undefined);
            if (this.model1) {
                this.model1.setColorOverride(render_2.ColorOverride.K0, undefined);
                this.model1.setColorOverride(render_2.ColorOverride.C0, undefined);
                this.model1.setColorOverride(render_2.ColorOverride.C1, undefined);
                this.model1.setColorOverride(render_2.ColorOverride.K1, undefined);
            }
            if (this.model3) this.model3.setColorOverride(render_2.ColorOverride.C0, undefined);
        }
    };
    WindWakerRoomRenderer.prototype.render = function (state) {
        this.model.render(state);
        if (this.model1) this.model1.render(state);
        if (this.model3) this.model3.render(state);
    };
    WindWakerRoomRenderer.prototype.destroy = function (gl) {
        this.model.destroy(gl);
        if (this.model1) this.model1.destroy(gl);
        if (this.model3) this.model3.destroy(gl);
    };
    return WindWakerRoomRenderer;
}();
var PlaneColorProgram = /** @class */function (_super) {
    __extends(PlaneColorProgram, _super);
    function PlaneColorProgram() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.vert = "\nprecision mediump float;\nuniform mat4 u_modelView;\nuniform mat4 u_projection;\nlayout(location = " + PlaneColorProgram.a_Position + ") in vec3 a_Position;\n\nvoid main() {\n    gl_Position = u_projection * u_modelView * vec4(a_Position, 1.0);\n}\n";
        _this.frag = "\nprecision mediump float;\nuniform vec4 u_PlaneColor;\n\nvoid main() {\n    gl_FragColor = u_PlaneColor;\n}\n";
        return _this;
    }
    PlaneColorProgram.prototype.bind = function (gl, prog) {
        _super.prototype.bind.call(this, gl, prog);
        this.u_PlaneColor = gl.getUniformLocation(prog, "u_PlaneColor");
    };
    PlaneColorProgram.a_Position = 0;
    return PlaneColorProgram;
}(Program_1.default);
var SeaPlane = /** @class */function () {
    function SeaPlane(gl) {
        this.modelMatrix = gl_matrix_1.mat4.create();
        this.color = new Float32Array(4);
        this.program = new PlaneColorProgram();
        this.createBuffers(gl);
        gl_matrix_1.mat4.fromScaling(this.modelMatrix, [200000, 1, 200000]);
    }
    SeaPlane.prototype.setColor = function (color) {
        this.color[0] = color.r;
        this.color[1] = color.g;
        this.color[2] = color.b;
        this.color[3] = color.a;
    };
    SeaPlane.prototype.render = function (state) {
        var gl = state.gl;
        state.useProgram(this.program);
        state.bindModelView(false, this.modelMatrix);
        gl.uniform4fv(this.program.u_PlaneColor, this.color);
        gl.bindVertexArray(this.vao);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        gl.bindVertexArray(null);
    };
    SeaPlane.prototype.destroy = function (gl) {
        gl.deleteVertexArray(this.vao);
        gl.deleteBuffer(this.posBuffer);
    };
    SeaPlane.prototype.createBuffers = function (gl) {
        this.vao = gl.createVertexArray();
        gl.bindVertexArray(this.vao);
        var posData = new Float32Array(4 * 3);
        posData[0] = -1;
        posData[1] = 0;
        posData[2] = -1;
        posData[3] = 1;
        posData[4] = 0;
        posData[5] = -1;
        posData[6] = -1;
        posData[7] = 0;
        posData[8] = 1;
        posData[9] = 1;
        posData[10] = 0;
        posData[11] = 1;
        this.posBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, this.posBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, posData, gl.STATIC_DRAW);
        var posAttribLocation = PlaneColorProgram.a_Position;
        gl.vertexAttribPointer(posAttribLocation, 3, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(posAttribLocation);
        gl.bindVertexArray(null);
    };
    return SeaPlane;
}();
var WindWakerRenderer = /** @class */function () {
    function WindWakerRenderer(gl, textureHolder, stageRarc, cameraPos) {
        this.textureHolder = textureHolder;
        this.stageRarc = stageRarc;
        this.cameraPos = cameraPos;
        this.roomRenderers = [];
        this.textures = textureHolder.viewerTextures;
        this.seaPlane = new SeaPlane(gl);
        this.vr_sky = createScene(gl, this.textureHolder, stageRarc, "vr_sky", true);
        this.vr_uso_umi = createScene(gl, this.textureHolder, stageRarc, "vr_uso_umi", true);
        this.vr_kasumi_mae = createScene(gl, this.textureHolder, stageRarc, "vr_kasumi_mae", true);
        this.vr_back_cloud = createScene(gl, this.textureHolder, stageRarc, "vr_back_cloud", true);
    }
    WindWakerRenderer.prototype.setTimeOfDay = function (index) {
        var e_1, _a;
        var dzsFile = this.stageRarc.findFile("dzs/stage.dzs");
        var timeOfDay = index - 1;
        var colors = timeOfDay === -1 ? undefined : getColorsFromDZS(dzsFile.buffer, 0, timeOfDay);
        if (colors !== undefined) {
            this.seaPlane.setColor(colors.ocean);
            this.vr_sky.setColorOverride(render_2.ColorOverride.K0, colors.vr_sky);
            this.vr_uso_umi.setColorOverride(render_2.ColorOverride.K0, colors.vr_uso_umi);
            this.vr_kasumi_mae.setColorOverride(render_2.ColorOverride.C0, colors.vr_kasumi_mae);
            this.vr_back_cloud.setColorOverride(render_2.ColorOverride.K0, colors.vr_back_cloud);
            this.vr_back_cloud.setAlphaOverride(render_2.ColorOverride.K0, colors.vr_back_cloud.a);
        } else {
            this.vr_sky.setColorOverride(render_2.ColorOverride.K0, undefined);
            this.vr_uso_umi.setColorOverride(render_2.ColorOverride.K0, undefined);
            this.vr_kasumi_mae.setColorOverride(render_2.ColorOverride.C0, undefined);
            this.vr_back_cloud.setColorOverride(render_2.ColorOverride.K0, undefined);
            this.vr_back_cloud.setAlphaOverride(render_2.ColorOverride.K0, undefined);
        }
        try {
            for (var _b = __values(this.roomRenderers), _c = _b.next(); !_c.done; _c = _b.next()) {
                var roomRenderer = _c.value;
                var roomColors = timeOfDay === -1 ? undefined : getColorsFromDZS(dzsFile.buffer, 0, timeOfDay);
                roomRenderer.setColors(roomColors);
            }
        } catch (e_1_1) {
            e_1 = { error: e_1_1 };
        } finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally {
                if (e_1) throw e_1.error;
            }
        }
    };
    WindWakerRenderer.prototype.createPanels = function () {
        var _this = this;
        var timeOfDayPanel = new UI.Panel();
        timeOfDayPanel.setTitle(TIME_OF_DAY_ICON, "Time of Day");
        var colorPresets = ['(no palette)', 'Dusk', 'Morning', 'Day', 'Afternoon', 'Evening', 'Night'];
        var selector = new UI.SimpleSingleSelect();
        selector.setStrings(colorPresets);
        selector.onselectionchange = function (index) {
            _this.setTimeOfDay(index);
        };
        var dzsFile = this.stageRarc.findFile("dzs/stage.dzs");
        var flairs = colorPresets.slice(1).map(function (presetName, i) {
            var elemIndex = i + 1;
            var timeOfDay = i;
            var stageColors = getColorsFromDZS(dzsFile.buffer, 0, timeOfDay);
            return { index: elemIndex, background: Color_1.colorToCSS(stageColors.vr_sky) };
        });
        selector.setFlairs(flairs);
        selector.selectItem(3); // Day
        timeOfDayPanel.contents.appendChild(selector.elem);
        return [timeOfDayPanel];
    };
    WindWakerRenderer.prototype.resetCamera = function (camera) {
        var m = gl_matrix_1.mat4.create();
        this.cameraPos.set(m);
        gl_matrix_1.mat4.invert(camera.worldMatrix, m);
        camera.worldMatrixUpdated();
    };
    WindWakerRenderer.prototype.render = function (state) {
        var gl = state.gl;
        // Render skybox.
        this.vr_sky.render(state);
        this.vr_kasumi_mae.render(state);
        this.vr_uso_umi.render(state);
        this.vr_back_cloud.render(state);
        state.useFlags(render_1.depthClearFlags);
        gl.clear(gl.DEPTH_BUFFER_BIT);
        state.useFlags(render_1.RenderFlags.default);
        // Render sea plane.
        this.seaPlane.render(state);
        for (var i = 0; i < this.roomRenderers.length; i++) {
            var roomRenderer = this.roomRenderers[i];
            roomRenderer.render(state);
        }
    };
    WindWakerRenderer.prototype.destroy = function (gl) {
        var e_2, _a;
        this.textureHolder.destroy(gl);
        this.vr_sky.destroy(gl);
        this.vr_kasumi_mae.destroy(gl);
        this.vr_uso_umi.destroy(gl);
        this.vr_back_cloud.destroy(gl);
        try {
            for (var _b = __values(this.roomRenderers), _c = _b.next(); !_c.done; _c = _b.next()) {
                var roomRenderer = _c.value;
                roomRenderer.destroy(gl);
            }
        } catch (e_2_1) {
            e_2 = { error: e_2_1 };
        } finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally {
                if (e_2) throw e_2.error;
            }
        }
    };
    return WindWakerRenderer;
}();
var WindWakerSceneDesc = /** @class */function () {
    function WindWakerSceneDesc(path, name, cameraPos) {
        this.path = path;
        this.name = name;
        this.cameraPos = cameraPos;
        this.id = path;
    }
    WindWakerSceneDesc.prototype.createScene = function (gl) {
        var _this = this;
        var roomIdx = parseInt(this.path.match(/Room(\d+)/)[1], 10);
        return Progressable_1.default.all([this.fetchRarc("data/j3d/ww/sea/Stage.arc"), this.fetchRarc(this.path)]).then(function (_a) {
            var _b = __read(_a, 2),
                stageRarc = _b[0],
                roomRarc = _b[1];
            var textureHolder = new render_2.J3DTextureHolder();
            var renderer = new WindWakerRenderer(gl, textureHolder, stageRarc, _this.cameraPos);
            renderer.roomRenderers.push(new WindWakerRoomRenderer(gl, textureHolder, roomIdx, roomRarc));
            return renderer;
        });
    };
    WindWakerSceneDesc.prototype.fetchRarc = function (path) {
        return util_1.fetch(path).then(function (buffer) {
            if (util_1.readString(buffer, 0, 4) === 'Yaz0') return Yaz0.decompress(buffer);else return buffer;
        }).then(function (buffer) {
            return RARC.parse(buffer);
        });
    };
    return WindWakerSceneDesc;
}();
var SeaSceneDesc = /** @class */function () {
    function SeaSceneDesc(name, cameraPos) {
        this.name = name;
        this.cameraPos = cameraPos;
        this.id = 'sea';
    }
    SeaSceneDesc.prototype.createScene = function (gl) {
        var _this = this;
        var rarcs = [];
        rarcs.push(this.fetchRarc("data/j3d/ww/sea/Stage.arc"));
        for (var i = 1; i <= 49; i++) {
            // Tower of the Gods is not spawned by default, and has no map model.
            if (i === 26) continue;
            rarcs.push(this.fetchRarc("data/j3d/ww/sea/Room" + i + ".arc"));
        }
        return Progressable_1.default.all(rarcs).then(function (_a) {
            var _b = __read(_a),
                stageRarc = _b[0],
                roomRarcs = _b.slice(1);
            var e_3, _c;
            var textureHolder = new render_2.J3DTextureHolder();
            var renderer = new WindWakerRenderer(gl, textureHolder, stageRarc.rarc, _this.cameraPos);
            var modelMatrix = gl_matrix_1.mat4.create();
            var scale = 0.4;
            var gridSize = 100000 * scale;
            try {
                for (var roomRarcs_1 = __values(roomRarcs), roomRarcs_1_1 = roomRarcs_1.next(); !roomRarcs_1_1.done; roomRarcs_1_1 = roomRarcs_1.next()) {
                    var roomRarc = roomRarcs_1_1.value;
                    var roomIdx = parseInt(roomRarc.path.match(/Room(\d+)/)[1], 10);
                    var roomRenderer = new WindWakerRoomRenderer(gl, textureHolder, roomIdx, roomRarc.rarc);
                    var gridX = roomIdx % 7 | 0;
                    var gridY = roomIdx / 7 | 0;
                    var tx = (gridX - 3.5) * gridSize;
                    var tz = (gridY - 3.5) * gridSize;
                    gl_matrix_1.mat4.fromTranslation(modelMatrix, [tx, 0, tz]);
                    gl_matrix_1.mat4.scale(modelMatrix, modelMatrix, [scale, scale, scale]);
                    roomRenderer.setModelMatrix(modelMatrix);
                    renderer.roomRenderers.push(roomRenderer);
                }
            } catch (e_3_1) {
                e_3 = { error: e_3_1 };
            } finally {
                try {
                    if (roomRarcs_1_1 && !roomRarcs_1_1.done && (_c = roomRarcs_1.return)) _c.call(roomRarcs_1);
                } finally {
                    if (e_3) throw e_3.error;
                }
            }
            return renderer;
        });
    };
    SeaSceneDesc.prototype.fetchRarc = function (path) {
        return util_1.fetch(path).then(function (buffer) {
            if (util_1.readString(buffer, 0, 4) === 'Yaz0') return Yaz0.decompress(buffer);else return buffer;
        }).then(function (buffer) {
            var rarc = RARC.parse(buffer);
            return { path: path, rarc: rarc };
        });
    };
    return SeaSceneDesc;
}();
var sceneDescs = [new WindWakerSceneDesc("data/j3d/ww/sea/Room11.arc", "Windfall Island", new CameraPos(-148, 1760, 7560, -1000, 1000, -5000)), new WindWakerSceneDesc("data/j3d/ww/sea/Room13.arc", "Dragon Roost Island", new CameraPos(-8000, 1760, 280, 0, 500, -1000)), new WindWakerSceneDesc("data/j3d/ww/sea/Room41.arc", "Forest Haven", new CameraPos(20000, 1760, -5500, 16000, 1000, 0)), new WindWakerSceneDesc("data/j3d/ww/sea/Room44.arc", "Outset Island", new CameraPos(6000, 6000, 6000, 0, 0, 20000)), new SeaSceneDesc("The Great Sea", new CameraPos(0, 0, 0, 0, 0, 0))];
var id = "zww";
var name = "The Legend of Zelda: The Wind Waker";
exports.sceneGroup = { id: id, name: name, sceneDescs: sceneDescs };
},{"gl-matrix":"..\\node_modules\\gl-matrix\\src\\gl-matrix.js","../Progressable":"Progressable.ts","../util":"util.ts","../render":"render.ts","../compression/Yaz0":"compression\\Yaz0.ts","../ui":"ui.ts","../gx/gx_material":"gx\\gx_material.ts","./j3d":"j3d\\j3d.ts","./rarc":"j3d\\rarc.ts","./render":"j3d\\render.ts","../Program":"Program.ts","../Color":"Color.ts"}],"j3d\\sms_scenes.ts":[function(require,module,exports) {
"use strict";

var __read = this && this.__read || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o),
        r,
        ar = [],
        e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {
            ar.push(r.value);
        }
    } catch (error) {
        e = { error: error };
    } finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
            if (e) throw e.error;
        }
    }
    return ar;
};
var __spread = this && this.__spread || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) {
        ar = ar.concat(__read(arguments[i]));
    }return ar;
};
var __values = this && this.__values || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator],
        i = 0;
    if (m) return m.call(o);
    return {
        next: function next() {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
var __importStar = this && this.__importStar || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) {
        if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    }result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("../util");
var render_1 = require("../render");
var Yaz0 = __importStar(require("../compression/Yaz0"));
var RARC = __importStar(require("./rarc"));
var render_2 = require("./render");
var scenes_1 = require("./scenes");
var gx_material_1 = require("../gx/gx_material");
var gl_matrix_1 = require("gl-matrix");
var j3d_1 = require("./j3d");
var sjisDecoder = new TextDecoder('sjis');
function unpack(buffer, sig) {
    var view = buffer.createDataView();
    var result = [];
    var offs = 0;
    var allowExtra = false;
    for (var i = 0; i < sig.length; i++) {
        switch (sig[i]) {
            case 'B':
                result.push(view.getUint8(offs));
                offs += 0x01;
                break;
            case 'I':
                result.push(view.getUint32(offs));
                offs += 0x04;
                break;
            case 'i':
                result.push(view.getInt32(offs));
                offs += 0x04;
                break;
            case 'f':
                result.push(view.getFloat32(offs));
                offs += 0x04;
                break;
            case 's':
                var size = view.getUint16(offs);
                offs += 0x02;
                result.push(util_1.readString(buffer, offs, size, false));
                offs += size;
                break;
            case '.':
                allowExtra = true;
                break;
            case ' ':
                break;
            default:
                util_1.assert(false);
        }
    }
    if (!allowExtra) {
        util_1.assert(buffer.byteLength === offs);
    }
    return __spread([offs], result);
}
function readSceneBin(buffer) {
    var offs = 0x00;
    var view_ = buffer.createDataView();
    var size = view_.getUint32(offs + 0x00);
    var view = buffer.createDataView(0x00, size);
    offs += 0x04;
    var klassHash = view.getUint16(offs + 0x00);
    var klassSize = view.getUint16(offs + 0x02);
    offs += 0x04;
    var klass = util_1.readString(buffer, offs, klassSize, false);
    offs += klassSize;
    var nameHash = view.getUint16(offs + 0x00);
    var nameSize = view.getUint16(offs + 0x02);
    offs += 0x04;
    var name = sjisDecoder.decode(buffer.copyToBuffer(offs, nameSize));
    offs += nameSize;
    function readChildren(numChildren) {
        var children = [];
        while (numChildren--) {
            var child = readSceneBin(buffer.slice(offs));
            children.push(child);
            offs += child.size;
        }
        return children;
    }
    var params = buffer.slice(offs, size);
    switch (klass) {
        case 'GroupObj':
        case 'LightAry':
        case 'Strategy':
        case 'AmbAry':
            {
                var _a = __read(unpack(params, 'I.'), 2),
                    paramsSize = _a[0],
                    numChildren = _a[1];
                offs += paramsSize;
                var children = readChildren(numChildren);
                return { type: 'Group', klass: klass, name: name, size: size, children: children };
            }
        case 'IdxGroup':
        case 'MarScene':
            {
                var _b = __read(unpack(params, 'II.'), 3),
                    paramsSize = _b[0],
                    flags = _b[1],
                    numChildren = _b[2];
                offs += paramsSize;
                var children = readChildren(numChildren);
                return { type: 'Group', klass: klass, name: name, size: size, children: children };
            }
        case 'AmbColor':
            {
                var _c = __read(unpack(params, 'BBBB'), 4),
                    r = _c[0],
                    g = _c[1],
                    b = _c[2],
                    a = _c[3];
                return { type: 'AmbColor', klass: klass, name: name, size: size, r: r, g: g, b: b, a: a };
            }
        case 'Light':
            {
                var _d = __read(unpack(params, 'fffBBBBf'), 8),
                    x = _d[0],
                    y = _d[1],
                    z = _d[2],
                    r = _d[3],
                    g = _d[4],
                    b = _d[5],
                    a = _d[6],
                    intensity = _d[7];
                return { type: 'Light', klass: klass, name: name, size: size, x: x, y: y, z: z, r: r, g: g, b: b, a: a, intensity: intensity };
            }
        // Models
        case 'BananaTree':
        case 'Coin':
        case 'CoinRed':
        case 'Fence':
        case 'FenceInner':
        case 'FenceRevolve':
        case 'FenceWaterH':
        case 'FenceWaterV':
        case 'FerrisWheel':
        case 'IceBlock':
        case 'Manhole':
        case 'MapObjBase':
        case 'MapStaticObj':
        case 'Merrygoround':
        case 'MonumentShine':
        case 'Palm':
        case 'PalmNatume':
        case 'PalmOugi':
        case 'PinnaDoor':
        case 'ShellCup':
        case 'WoodBarrel':
        case 'WoodBlock':
        case 'Viking':
            {
                // XXX(jstpierre): MapObjBase AirportPole seemingly has extra junk after it?
                var _e = __read(unpack(params, 'ffffff fffsi s.'), 13),
                    paramsSize = _e[0],
                    x = _e[1],
                    y = _e[2],
                    z = _e[3],
                    rotationX = _e[4],
                    rotationY = _e[5],
                    rotationZ = _e[6],
                    scaleX = _e[7],
                    scaleY = _e[8],
                    scaleZ = _e[9],
                    manager = _e[10],
                    flags = _e[11],
                    model = _e[12];
                return { type: 'Model', klass: klass, name: name, size: size, x: x, y: y, z: z, rotationX: rotationX, rotationY: rotationY, rotationZ: rotationZ, scaleX: scaleX, scaleY: scaleY, scaleZ: scaleZ, manager: manager, model: model };
            }
        // Extra unk junk
        case 'CoinBlue':
            {
                var _f = __read(unpack(params, 'ffffff fffsi s i'), 13),
                    paramsSize = _f[0],
                    x = _f[1],
                    y = _f[2],
                    z = _f[3],
                    rotationX = _f[4],
                    rotationY = _f[5],
                    rotationZ = _f[6],
                    scaleX = _f[7],
                    scaleY = _f[8],
                    scaleZ = _f[9],
                    manager = _f[10],
                    flags = _f[11],
                    model = _f[12];
                return { type: 'Model', klass: klass, name: name, size: size, x: x, y: y, z: z, rotationX: rotationX, rotationY: rotationY, rotationZ: rotationZ, scaleX: scaleX, scaleY: scaleY, scaleZ: scaleZ, manager: manager, model: model };
            }
        case 'NozzleBox':
            {
                var _g = __read(unpack(params, 'ffffff fffsi s ssff'), 13),
                    paramsSize = _g[0],
                    x = _g[1],
                    y = _g[2],
                    z = _g[3],
                    rotationX = _g[4],
                    rotationY = _g[5],
                    rotationZ = _g[6],
                    scaleX = _g[7],
                    scaleY = _g[8],
                    scaleZ = _g[9],
                    manager = _g[10],
                    flags = _g[11],
                    model = _g[12];
                return { type: 'Model', klass: klass, name: name, size: size, x: x, y: y, z: z, rotationX: rotationX, rotationY: rotationY, rotationZ: rotationZ, scaleX: scaleX, scaleY: scaleY, scaleZ: scaleZ, manager: manager, model: model };
            }
        case 'Shine':
            {
                var _h = __read(unpack(params, 'ffffff fffsi s sii'), 13),
                    paramsSize = _h[0],
                    x = _h[1],
                    y = _h[2],
                    z = _h[3],
                    rotationX = _h[4],
                    rotationY = _h[5],
                    rotationZ = _h[6],
                    scaleX = _h[7],
                    scaleY = _h[8],
                    scaleZ = _h[9],
                    manager = _h[10],
                    flags = _h[11],
                    model = _h[12];
                return { type: 'Model', klass: klass, name: name, size: size, x: x, y: y, z: z, rotationX: rotationX, rotationY: rotationY, rotationZ: rotationZ, scaleX: scaleX, scaleY: scaleY, scaleZ: scaleZ, manager: manager, model: model };
            }
        case 'FruitsBoat':
            {
                var _j = __read(unpack(params, 'ffffff fffsi s s'), 13),
                    paramsSize = _j[0],
                    x = _j[1],
                    y = _j[2],
                    z = _j[3],
                    rotationX = _j[4],
                    rotationY = _j[5],
                    rotationZ = _j[6],
                    scaleX = _j[7],
                    scaleY = _j[8],
                    scaleZ = _j[9],
                    manager = _j[10],
                    flags = _j[11],
                    model = _j[12];
                return { type: 'Model', klass: klass, name: name, size: size, x: x, y: y, z: z, rotationX: rotationX, rotationY: rotationY, rotationZ: rotationZ, scaleX: scaleX, scaleY: scaleY, scaleZ: scaleZ, manager: manager, model: model };
            }
        case 'Billboard':
        case 'BrickBlock':
        case 'DolWeathercock':
        case 'WoodBox':
            {
                var _k = __read(unpack(params, 'ffffff fffsI s IffI'), 13),
                    paramsSize = _k[0],
                    x = _k[1],
                    y = _k[2],
                    z = _k[3],
                    rotationX = _k[4],
                    rotationY = _k[5],
                    rotationZ = _k[6],
                    scaleX = _k[7],
                    scaleY = _k[8],
                    scaleZ = _k[9],
                    manager = _k[10],
                    flags = _k[11],
                    model = _k[12];
                return { type: 'Model', klass: klass, name: name, size: size, x: x, y: y, z: z, rotationX: rotationX, rotationY: rotationY, rotationZ: rotationZ, scaleX: scaleX, scaleY: scaleY, scaleZ: scaleZ, manager: manager, model: model };
            }
        case 'MapObjWaterSpray':
            {
                var _l = __read(unpack(params, 'ffffff fffsI s IIIIII'), 13),
                    paramsSize = _l[0],
                    x = _l[1],
                    y = _l[2],
                    z = _l[3],
                    rotationX = _l[4],
                    rotationY = _l[5],
                    rotationZ = _l[6],
                    scaleX = _l[7],
                    scaleY = _l[8],
                    scaleZ = _l[9],
                    manager = _l[10],
                    flags = _l[11],
                    model = _l[12];
                return { type: 'Model', klass: klass, name: name, size: size, x: x, y: y, z: z, rotationX: rotationX, rotationY: rotationY, rotationZ: rotationZ, scaleX: scaleX, scaleY: scaleY, scaleZ: scaleZ, manager: manager, model: model };
            }
        default:
            var warnUnknown = true;
            // Managers are internal.
            if (klass.endsWith('Manager') || klass.endsWith('Mgr')) warnUnknown = false;
            // Cube maps...
            if (klass.startsWith('Cube')) warnUnknown = false;
            if (warnUnknown) console.warn("Unknown object class " + klassHash + " " + klass + ", size " + size);
            return { type: 'Unknown', klass: klass, name: name, size: size };
    }
}
var SunshineRenderer = /** @class */function () {
    function SunshineRenderer(textureHolder, skyScene, mapScene, seaScene, seaIndirectScene, extraScenes, rarc) {
        if (rarc === void 0) {
            rarc = null;
        }
        this.textureHolder = textureHolder;
        this.skyScene = skyScene;
        this.mapScene = mapScene;
        this.seaScene = seaScene;
        this.seaIndirectScene = seaIndirectScene;
        this.extraScenes = extraScenes;
        this.rarc = rarc;
        this.textures = [];
        this.mainColorTarget = new render_1.ColorTarget();
        this.textures = textureHolder.viewerTextures;
    }
    SunshineRenderer.prototype.render = function (state) {
        var e_1, _a;
        var gl = state.gl;
        this.mainColorTarget.setParameters(gl, state.onscreenColorTarget.width, state.onscreenColorTarget.height);
        state.useRenderTarget(this.mainColorTarget);
        gl.clearColor(0, 0, 0.125, 1);
        gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT);
        if (this.skyScene) {
            this.skyScene.render(state);
            state.useFlags(render_1.depthClearFlags);
            gl.clear(gl.DEPTH_BUFFER_BIT);
        }
        if (this.mapScene) this.mapScene.render(state);
        if (this.seaScene) this.seaScene.render(state);
        try {
            for (var _b = __values(this.extraScenes), _c = _b.next(); !_c.done; _c = _b.next()) {
                var scene = _c.value;
                scene.render(state);
            }
        } catch (e_1_1) {
            e_1 = { error: e_1_1 };
        } finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally {
                if (e_1) throw e_1.error;
            }
        }
        // Copy to main render target.
        state.useRenderTarget(state.onscreenColorTarget);
        state.blitColorTarget(this.mainColorTarget);
        if (this.seaIndirectScene) {
            var indirectScene = this.seaIndirectScene;
            var textureOverride = { glTexture: this.mainColorTarget.resolvedColorTexture, width: gx_material_1.EFB_WIDTH, height: gx_material_1.EFB_HEIGHT, flipY: true };
            this.textureHolder.setTextureOverride("indirectdummy", textureOverride);
            indirectScene.render(state);
        }
    };
    SunshineRenderer.prototype.destroy = function (gl) {
        this.textureHolder.destroy(gl);
        if (this.skyScene) this.skyScene.destroy(gl);
        if (this.mapScene) this.mapScene.destroy(gl);
        if (this.seaScene) this.seaScene.destroy(gl);
        this.extraScenes.forEach(function (scene) {
            return scene.destroy(gl);
        });
    };
    return SunshineRenderer;
}();
exports.SunshineRenderer = SunshineRenderer;
var SunshineSceneDesc = /** @class */function () {
    function SunshineSceneDesc(path, name) {
        this.path = path;
        this.name = name;
        this.name = name;
        this.path = path;
        this.id = this.name;
    }
    SunshineSceneDesc.createSunshineSceneForBasename = function (gl, textureHolder, rarc, basename, isSkybox) {
        var bmdFile = rarc.findFile(basename + ".bmd");
        if (!bmdFile) return null;
        var btkFile = rarc.findFile(basename + ".btk");
        var brkFile = rarc.findFile(basename + ".brk");
        var bckFile = rarc.findFile(basename + ".bck");
        var bmtFile = rarc.findFile(basename + ".bmt");
        var scene = scenes_1.createScene(gl, textureHolder, bmdFile, btkFile, brkFile, bckFile, bmtFile);
        scene.name = basename;
        scene.setIsSkybox(isSkybox);
        return scene;
    };
    SunshineSceneDesc.prototype.createScene = function (gl) {
        var _this = this;
        return util_1.fetch(this.path).then(function (result) {
            return Yaz0.decompress(result);
        }).then(function (buffer) {
            var rarc = RARC.parse(buffer);
            var sceneBin = rarc.findFile('map/scene.bin');
            var sceneBinObj = readSceneBin(sceneBin.buffer);
            console.log(sceneBinObj);
            var textureHolder = new render_2.J3DTextureHolder();
            var skyScene = SunshineSceneDesc.createSunshineSceneForBasename(gl, textureHolder, rarc, 'map/map/sky', true);
            var mapScene = SunshineSceneDesc.createSunshineSceneForBasename(gl, textureHolder, rarc, 'map/map/map', false);
            var seaScene = SunshineSceneDesc.createSunshineSceneForBasename(gl, textureHolder, rarc, 'map/map/sea', false);
            var seaIndirectScene = SunshineSceneDesc.createSunshineSceneForBasename(gl, textureHolder, rarc, 'map/map/seaindirect', false);
            var extraScenes = _this.createSceneBinObjects(gl, textureHolder, rarc, sceneBinObj);
            return new SunshineRenderer(textureHolder, skyScene, mapScene, seaScene, seaIndirectScene, extraScenes, rarc);
        });
    };
    SunshineSceneDesc.prototype.createSceneBinObjects = function (gl, textureHolder, rarc, obj) {
        var _this = this;
        function flatten(L) {
            var e_2, _a;
            var R = [];
            try {
                for (var L_1 = __values(L), L_1_1 = L_1.next(); !L_1_1.done; L_1_1 = L_1.next()) {
                    var Ts = L_1_1.value;
                    R.push.apply(R, Ts);
                }
            } catch (e_2_1) {
                e_2 = { error: e_2_1 };
            } finally {
                try {
                    if (L_1_1 && !L_1_1.done && (_a = L_1.return)) _a.call(L_1);
                } finally {
                    if (e_2) throw e_2.error;
                }
            }
            return R;
        }
        switch (obj.type) {
            case 'Group':
                var childTs = obj.children.map(function (c) {
                    return _this.createSceneBinObjects(gl, textureHolder, rarc, c);
                });
                var flattened = flatten(childTs).filter(function (o) {
                    return !!o;
                });
                return flattened;
            case 'Model':
                return [this.createSceneForSceneBinModel(gl, textureHolder, rarc, obj)];
            default:
                // Don't care.
                return undefined;
        }
    };
    SunshineSceneDesc.prototype.createSceneForSceneBinModel = function (gl, textureHolder, rarc, obj) {
        ;
        function bmtm(bmd, bmt) {
            var bmdFile = rarc.findFile(bmd);
            var bmtFile = rarc.findFile(bmt);
            return scenes_1.createScene(gl, textureHolder, bmdFile, null, null, null, bmtFile);
        }
        function bckm(bmdFilename, bckFilename, loopMode) {
            if (loopMode === void 0) {
                loopMode = j3d_1.LoopMode.REPEAT;
            }
            var bmdFile = rarc.findFile(bmdFilename);
            var bckFile = rarc.findFile(bckFilename);
            var scene = scenes_1.createScene(gl, textureHolder, bmdFile, null, null, bckFile, null);
            scene.bck.ank1.loopMode = loopMode;
            return scene;
        }
        var modelLookup = [{ k: 'BananaTree', m: 'BananaTree', p: 'mapobj/bananatree' }, { k: 'BrickBlock', m: 'BrickBlock', p: 'mapobj/brickblock' }, { k: 'Coin', m: 'coin', p: 'mapobj/coin' }, { k: 'Coin', m: 'invisible_coin', p: 'mapobj/coin' }, { k: 'Coin', m: 'invisible_coin', p: 'mapobj/coin' }, { k: 'CoinRed', m: 'coin_red', p: 'mapobj/coin_red' }, { k: 'CoinBlue', m: 'coin_blue', p: 'mapobj/coin_blue' }, { k: 'DolWeathercock', m: 'dptWeathercock', p: 'mapobj/dptweathercock' }, { k: 'Fence', m: 'fence_normal', p: 'mapobj/fence_normal' }, { k: 'Fence', m: 'fence3x3', p: 'mapobj/fence_half' }, { k: 'FenceRevolve', m: 'fence_revolve', p: 'mapobj/fence_revolve_outer' }, { k: 'FenceInner', m: 'fenceInnerGreen', p: 'mapobj/fenceinnergreen' }, { k: 'FenceWaterH', m: 'FenceWaterH', p: 'mapobj/fencewaterh' }, { k: 'FenceWaterV', m: 'FenceWaterV', p: 'mapobj/fencewaterv' }, { k: 'FerrisWheel', m: 'FerrisWheel', p: 'mapobj/ferriswheel' }, { k: 'IceBlock', m: 'IceBlock', p: 'mapobj/iceblock' }, { k: 'Manhole', m: 'manhole', p: 'mapobj/manhole' }, { k: 'MapObjBase', m: 'DokanGate', p: 'mapobj/efdokangate' }, { k: 'MapObjBase', m: 'ArrowBoardLR', s: function s() {
                return bmtm('mapobj/arrowboardlr.bmd', 'mapobj/arrowboard.bmt');
            } }, { k: 'MapObjBase', m: 'ArrowBoardUp', s: function s() {
                return bmtm('mapobj/arrowboardup.bmd', 'mapobj/arrowboard.bmt');
            } }, { k: 'MapObjBase', m: 'ArrowBoardDown', s: function s() {
                return bmtm('mapobj/arrowboarddown.bmd', 'mapobj/arrowboard.bmt');
            } }, { k: 'MapObjBase', m: 'monte_chair', p: 'mapobj/monte_chair_model' }, { k: 'MapStaticObj', m: 'ReflectSky', s: function s() {
                return bmtm('map/map/reflectsky.bmd', 'map/map/sky.bmt');
            } },
        // Disable SeaIndirect loading...
        { k: 'MapStaticObj', m: 'SeaIndirect', s: function s() {
                return null;
            } }, { k: 'Merrygoround', m: 'merry', p: 'mapobj/merry' }, { k: 'NozzleBox', m: 'NozzleBox', p: 'mapobj/nozzlebox' }, { k: 'Palm', m: 'palmNormal', p: 'mapobj/palmnormal' }, { k: 'Palm', m: 'palmLeaf', p: 'mapobj/palmleaf' }, { k: 'PalmNatume', m: 'palmNatume', p: 'mapobj/palmnatume' }, { k: 'PalmOugi', m: 'palmOugi', p: 'mapobj/palmougi' }, { k: 'PinnaDoor', m: 'PinnaDoor', p: 'mapobj/pinnadoor' }, { k: 'ShellCup', m: 'ShellCup', p: 'mapobj/shellcup' }, { k: 'Shine', m: 'shine', s: function s() {
                return bckm('mapobj/shine.bmd', 'mapobj/shine_float.bck');
            } }, { k: 'Viking', m: 'viking', p: 'mapobj/viking' }, { k: 'WoodBox', m: 'WoodBox', p: 'mapobj/kibako' }, { k: 'WoodBarrel', m: 'wood_barrel', s: function s() {
                return bmtm('mapobj/barrel_normal.bmd', 'mapobj/barrel.bmt');
            } }];
        var modelEntry = modelLookup.find(function (lt) {
            return obj.klass === lt.k && obj.model === lt.m;
        });
        if (modelEntry === undefined) {
            // Load heuristics -- maybe should be explicit...
            var prefix = void 0;
            if (obj.klass === 'MapStaticObj') {
                prefix = "map/map/" + obj.model.toLowerCase();
            } else if (obj.klass === 'MapObjBase') {
                prefix = "mapobj/" + obj.model.toLowerCase();
            }
            if (prefix) {
                var file = rarc.findFile(prefix + ".bmd");
                if (file) modelEntry = { k: obj.klass, m: obj.model, p: prefix };
            }
        }
        if (modelEntry === undefined) {
            console.warn("No model for " + obj.klass + " " + obj.model);
            return null;
        }
        var scene = null;
        if (modelEntry.p !== undefined) {
            scene = SunshineSceneDesc.createSunshineSceneForBasename(gl, textureHolder, rarc, modelEntry.p, false);
        } else if (modelEntry.s !== undefined) {
            scene = modelEntry.s();
        }
        if (scene === null) return null;
        var q = gl_matrix_1.quat.create();
        gl_matrix_1.quat.fromEuler(q, obj.rotationX, obj.rotationY, obj.rotationZ);
        gl_matrix_1.mat4.fromRotationTranslationScale(scene.modelMatrix, q, [obj.x, obj.y, obj.z], [obj.scaleX, obj.scaleY, obj.scaleZ]);
        return scene;
    };
    return SunshineSceneDesc;
}();
exports.SunshineSceneDesc = SunshineSceneDesc;
var id = "sms";
var name = "Super Mario Sunshine";
var sceneDescs = [new SunshineSceneDesc("data/j3d/sms/dolpic0.szs", "Delfino Plaza"), new SunshineSceneDesc("data/j3d/sms/airport0.szs", "Delfino Airport"), new SunshineSceneDesc("data/j3d/sms/bianco0.szs", "Bianco Hills"), new SunshineSceneDesc("data/j3d/sms/ricco0.szs", "Ricco Harbor"), new SunshineSceneDesc("data/j3d/sms/mamma0.szs", "Gelato Beach"), new SunshineSceneDesc("data/j3d/sms/pinnaBeach0.szs", "Pinna Park Beach"), new SunshineSceneDesc("data/j3d/sms/pinnaParco0.szs", "Pinna Park"), new SunshineSceneDesc("data/j3d/sms/sirena0.szs", "Sirena Beach"), new SunshineSceneDesc("data/j3d/sms/delfino0.szs", "Delfino Hotel"), new SunshineSceneDesc("data/j3d/sms/mare0.szs", "Noki Bay"), new SunshineSceneDesc("data/j3d/sms/monte3.szs", "Pianta Village")];
exports.sceneGroup = { id: id, name: name, sceneDescs: sceneDescs };
},{"../util":"util.ts","../render":"render.ts","../compression/Yaz0":"compression\\Yaz0.ts","./rarc":"j3d\\rarc.ts","./render":"j3d\\render.ts","./scenes":"j3d\\scenes.ts","../gx/gx_material":"gx\\gx_material.ts","gl-matrix":"..\\node_modules\\gl-matrix\\src\\gl-matrix.js","./j3d":"j3d\\j3d.ts"}],"j3d\\smg_scenes.ts":[function(require,module,exports) {
"use strict";

var __extends = this && this.__extends || function () {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
        d.__proto__ = b;
    } || function (d, b) {
        for (var p in b) {
            if (b.hasOwnProperty(p)) d[p] = b[p];
        }
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __read = this && this.__read || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o),
        r,
        ar = [],
        e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {
            ar.push(r.value);
        }
    } catch (error) {
        e = { error: error };
    } finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
            if (e) throw e.error;
        }
    }
    return ar;
};
var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var Progressable_1 = __importDefault(require("../Progressable"));
var util_1 = require("../util");
var render_1 = require("../render");
var Program_1 = require("../Program");
var render_2 = require("./render");
var scenes_1 = require("./scenes");
var gx_material_1 = require("../gx/gx_material");
// Should I try to do this with GX? lol.
var BloomPassBlurProgram = /** @class */function (_super) {
    __extends(BloomPassBlurProgram, _super);
    function BloomPassBlurProgram() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.frag = "\nuniform sampler2D u_Texture;\nin vec2 v_TexCoord;\n\nvec3 TevOverflow(vec3 a) { return fract(a*(255.0/256.0))*(256.0/255.0); }\nvoid main() {\n    // Nintendo does this in two separate draws. We combine into one here...\n    vec3 c = vec3(0.0);\n    // Pass 1.\n    c += (texture(u_Texture, v_TexCoord + vec2(-0.00562, -1.0 *  0.00000)).rgb * 0.15686);\n    c += (texture(u_Texture, v_TexCoord + vec2(-0.00281, -1.0 * -0.00866)).rgb * 0.15686);\n    c += (texture(u_Texture, v_TexCoord + vec2( 0.00281, -1.0 * -0.00866)).rgb * 0.15686);\n    c += (texture(u_Texture, v_TexCoord + vec2( 0.00562, -1.0 *  0.00000)).rgb * 0.15686);\n    c += (texture(u_Texture, v_TexCoord + vec2( 0.00281, -1.0 *  0.00866)).rgb * 0.15686);\n    c += (texture(u_Texture, v_TexCoord + vec2(-0.00281, -1.0 *  0.00866)).rgb * 0.15686);\n    // Pass 2.\n    c += (texture(u_Texture, v_TexCoord + vec2(-0.00977, -1.0 * -0.00993)).rgb * 0.15686);\n    c += (texture(u_Texture, v_TexCoord + vec2(-0.00004, -1.0 * -0.02000)).rgb * 0.15686);\n    c += (texture(u_Texture, v_TexCoord + vec2( 0.00972, -1.0 * -0.01006)).rgb * 0.15686);\n    c += (texture(u_Texture, v_TexCoord + vec2( 0.00976, -1.0 *  0.00993)).rgb * 0.15686);\n    c += (texture(u_Texture, v_TexCoord + vec2( 0.00004, -1.0 *  0.02000)).rgb * 0.15686);\n    c += (texture(u_Texture, v_TexCoord + vec2(-0.00972, -1.0 *  0.01006)).rgb * 0.15686);\n    gl_FragColor = vec4(c.rgb, 1.0);\n}\n";
        return _this;
    }
    return BloomPassBlurProgram;
}(Program_1.FullscreenProgram);
var BloomPassBokehProgram = /** @class */function (_super) {
    __extends(BloomPassBokehProgram, _super);
    function BloomPassBokehProgram() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.frag = "\nuniform sampler2D u_Texture;\nin vec2 v_TexCoord;\n\nvec3 TevOverflow(vec3 a) { return fract(a*(255.0/256.0))*(256.0/255.0); }\nvoid main() {\n    vec3 f = vec3(0.0);\n    vec3 c;\n\n    // TODO(jstpierre): Double-check these passes. It seems weighted towards the top left. IS IT THE BLUR???\n\n    // Pass 1.\n    c = vec3(0.0);\n    c += (texture(u_Texture, v_TexCoord + vec2(-0.02250, -1.0 *  0.00000)).rgb) * 0.23529;\n    c += (texture(u_Texture, v_TexCoord + vec2(-0.01949, -1.0 * -0.02000)).rgb) * 0.23529;\n    c += (texture(u_Texture, v_TexCoord + vec2(-0.01125, -1.0 * -0.03464)).rgb) * 0.23529;\n    c += (texture(u_Texture, v_TexCoord + vec2( 0.00000, -1.0 * -0.04000)).rgb) * 0.23529;\n    c += (texture(u_Texture, v_TexCoord + vec2( 0.01125, -1.0 * -0.03464)).rgb) * 0.23529;\n    c += (texture(u_Texture, v_TexCoord + vec2( 0.01948, -1.0 * -0.02001)).rgb) * 0.23529;\n    c += (texture(u_Texture, v_TexCoord + vec2( 0.02250, -1.0 *  0.00000)).rgb) * 0.23529;\n    c += (texture(u_Texture, v_TexCoord + vec2( 0.01949, -1.0 *  0.02000)).rgb) * 0.23529;\n    f += TevOverflow(c);\n    // Pass 2.\n    c = vec3(0.0);\n    c += (texture(u_Texture, v_TexCoord + vec2( 0.01125, -1.0 *  0.03464)).rgb) * 0.23529;\n    c += (texture(u_Texture, v_TexCoord + vec2(-0.00000, -1.0 *  0.04000)).rgb) * 0.23529;\n    c += (texture(u_Texture, v_TexCoord + vec2(-0.01125, -1.0 *  0.03464)).rgb) * 0.23529;\n    c += (texture(u_Texture, v_TexCoord + vec2(-0.01948, -1.0 *  0.02001)).rgb) * 0.23529;\n    f += TevOverflow(c);\n    // Pass 3.\n    c = vec3(0.0);\n    c += (texture(u_Texture, v_TexCoord + vec2(-0.03937, -1.0 *  0.00000)).rgb) * 0.23529;\n    c += (texture(u_Texture, v_TexCoord + vec2(-0.03410, -1.0 * -0.03499)).rgb) * 0.23529;\n    c += (texture(u_Texture, v_TexCoord + vec2(-0.01970, -1.0 * -0.06061)).rgb) * 0.23529;\n    c += (texture(u_Texture, v_TexCoord + vec2( 0.00000, -1.0 * -0.07000)).rgb) * 0.23529;\n    c += (texture(u_Texture, v_TexCoord + vec2( 0.01968, -1.0 * -0.06063)).rgb) * 0.23529;\n    c += (texture(u_Texture, v_TexCoord + vec2( 0.03409, -1.0 * -0.03502)).rgb) * 0.23529;\n    c += (texture(u_Texture, v_TexCoord + vec2( 0.03937, -1.0 *  0.00000)).rgb) * 0.23529;\n    c += (texture(u_Texture, v_TexCoord + vec2( 0.03410, -1.0 *  0.03499)).rgb) * 0.23529;\n    f += TevOverflow(c);\n    // Pass 4.\n    c = vec3(0.0);\n    c += (texture(u_Texture, v_TexCoord + vec2( 0.01970, -1.0 *  0.06061)).rgb) * 0.23529;\n    c += (texture(u_Texture, v_TexCoord + vec2( 0.00000, -1.0 *  0.07000)).rgb) * 0.23529;\n    c += (texture(u_Texture, v_TexCoord + vec2(-0.01968, -1.0 *  0.06063)).rgb) * 0.23529;\n    c += (texture(u_Texture, v_TexCoord + vec2(-0.03409, -1.0 *  0.03502)).rgb) * 0.23529;\n    f += TevOverflow(c);\n    // Pass 5.\n    c = vec3(0.0);\n    c += (texture(u_Texture, v_TexCoord + vec2(-0.05063, -1.0 *  0.00000)).rgb) * 0.23529;\n    c += (texture(u_Texture, v_TexCoord + vec2(-0.04385, -1.0 * -0.04499)).rgb) * 0.23529;\n    c += (texture(u_Texture, v_TexCoord + vec2(-0.02532, -1.0 * -0.07793)).rgb) * 0.23529;\n    c += (texture(u_Texture, v_TexCoord + vec2( 0.00000, -1.0 * -0.09000)).rgb) * 0.23529;\n    f += TevOverflow(c);\n    // Pass 6.\n    c = vec3(0.0);\n    c += (texture(u_Texture, v_TexCoord + vec2( 0.02532, -1.0 *  0.07793)).rgb) * 0.23529;\n    c += (texture(u_Texture, v_TexCoord + vec2( 0.00000, -1.0 *  0.09000)).rgb) * 0.23529;\n    c += (texture(u_Texture, v_TexCoord + vec2(-0.02531, -1.0 *  0.07795)).rgb) * 0.23529;\n    c += (texture(u_Texture, v_TexCoord + vec2(-0.04384, -1.0 *  0.04502)).rgb) * 0.23529;\n    f += TevOverflow(c);\n\n    f = clamp(f, 0.0, 1.0);\n\n    // Combine pass.\n    vec3 g;\n    g = (texture(u_Texture, v_TexCoord).rgb * 0.43137);\n    g += f * 0.43137;\n\n    gl_FragColor = vec4(g, 1.0);\n}\n";
        return _this;
    }
    return BloomPassBokehProgram;
}(Program_1.FullscreenProgram);
var SMGRenderer = /** @class */function () {
    function SMGRenderer(gl, textureHolder, mainScene, skyboxScene, bloomScene, indirectScene) {
        this.textureHolder = textureHolder;
        this.mainScene = mainScene;
        this.skyboxScene = skyboxScene;
        this.bloomScene = bloomScene;
        this.indirectScene = indirectScene;
        this.textures = [];
        this.mainColorTarget = new render_1.ColorTarget();
        // Bloom stuff.
        this.bloomColorTarget1 = new render_1.ColorTarget();
        this.bloomColorTarget2 = new render_1.ColorTarget();
        this.bloomColorTarget3 = new render_1.ColorTarget();
        this.bloomPassBlurProgram = new BloomPassBlurProgram();
        this.bloomPassBokehProgram = new BloomPassBokehProgram();
        this.textures = textureHolder.viewerTextures;
        this.bloomCombineFlags = new render_1.RenderFlags();
        this.bloomCombineFlags.blendMode = render_1.BlendMode.ADD;
        this.bloomCombineFlags.blendSrc = render_1.BlendFactor.ONE;
        this.bloomCombineFlags.blendDst = render_1.BlendFactor.ONE;
    }
    SMGRenderer.prototype.render = function (state) {
        var gl = state.gl;
        this.mainColorTarget.setParameters(gl, state.onscreenColorTarget.width, state.onscreenColorTarget.height);
        state.useRenderTarget(this.mainColorTarget);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        this.skyboxScene.bindState(state);
        this.skyboxScene.renderOpaque(state);
        gl.clear(gl.DEPTH_BUFFER_BIT);
        this.mainScene.bindState(state);
        this.mainScene.renderOpaque(state);
        this.mainScene.renderTransparent(state);
        // Copy to main render target.
        state.useRenderTarget(state.onscreenColorTarget);
        state.blitColorTarget(this.mainColorTarget);
        if (this.indirectScene) {
            var textureOverride = { glTexture: this.mainColorTarget.resolvedColorTexture, width: gx_material_1.EFB_WIDTH, height: gx_material_1.EFB_HEIGHT, flipY: true };
            this.textureHolder.setTextureOverride("IndDummy", textureOverride);
            this.indirectScene.bindState(state);
            this.indirectScene.renderOpaque(state);
        }
        if (this.bloomScene) {
            var gl_1 = state.gl;
            var bloomColorTargetScene = this.bloomColorTarget1;
            bloomColorTargetScene.setParameters(gl_1, state.onscreenColorTarget.width, state.onscreenColorTarget.height);
            state.useRenderTarget(bloomColorTargetScene);
            gl_1.clearColor(0, 0, 0, 0);
            gl_1.clear(gl_1.COLOR_BUFFER_BIT);
            this.bloomScene.render(state);
            // First downsample.
            var bloomColorTargetDownsample = this.bloomColorTarget2;
            var bloomWidth = state.onscreenColorTarget.width >> 2;
            var bloomHeight = state.onscreenColorTarget.height >> 2;
            bloomColorTargetDownsample.setParameters(gl_1, bloomWidth, bloomHeight);
            state.useRenderTarget(bloomColorTargetDownsample, null);
            state.blitColorTarget(bloomColorTargetScene);
            // First pass is a blur.
            var bloomColorTargetBlur = this.bloomColorTarget3;
            bloomColorTargetDownsample.resolve(gl_1);
            bloomColorTargetBlur.setParameters(gl_1, bloomColorTargetDownsample.width, bloomColorTargetDownsample.height);
            state.useRenderTarget(bloomColorTargetBlur, null);
            state.useProgram(this.bloomPassBlurProgram);
            gl_1.bindTexture(gl_1.TEXTURE_2D, bloomColorTargetDownsample.resolvedColorTexture);
            state.runFullscreen();
            // TODO(jstpierre): Downsample blur / bokeh as well.
            // Second pass is bokeh-ify.
            // We can ditch the second render target now, so just reuse it.
            var bloomColorTargetBokeh = this.bloomColorTarget2;
            bloomColorTargetBlur.resolve(gl_1);
            state.useRenderTarget(bloomColorTargetBokeh, null);
            state.useProgram(this.bloomPassBokehProgram);
            gl_1.clear(gl_1.COLOR_BUFFER_BIT);
            gl_1.bindTexture(gl_1.TEXTURE_2D, bloomColorTargetBlur.resolvedColorTexture);
            state.runFullscreen();
            // Third pass combines.
            state.useRenderTarget(state.onscreenColorTarget);
            state.blitColorTarget(bloomColorTargetBokeh, this.bloomCombineFlags);
        }
    };
    SMGRenderer.prototype.destroy = function (gl) {
        this.textureHolder.destroy(gl);
        this.mainScene.destroy(gl);
        this.skyboxScene.destroy(gl);
        this.bloomScene.destroy(gl);
        this.indirectScene.destroy(gl);
        this.bloomColorTarget1.destroy(gl);
        this.bloomColorTarget2.destroy(gl);
        this.bloomColorTarget3.destroy(gl);
    };
    return SMGRenderer;
}();
var SMGSceneDesc = /** @class */function () {
    function SMGSceneDesc(name, mainScenePath, skyboxScenePath, bloomScenePath, indirectScenePath) {
        if (skyboxScenePath === void 0) {
            skyboxScenePath = null;
        }
        if (bloomScenePath === void 0) {
            bloomScenePath = null;
        }
        if (indirectScenePath === void 0) {
            indirectScenePath = null;
        }
        this.name = name;
        this.mainScenePath = mainScenePath;
        this.skyboxScenePath = skyboxScenePath;
        this.bloomScenePath = bloomScenePath;
        this.indirectScenePath = indirectScenePath;
        this.id = mainScenePath;
    }
    SMGSceneDesc.prototype.createScene = function (gl) {
        var textureHolder = new render_2.J3DTextureHolder();
        return Progressable_1.default.all([this.fetchScene(gl, textureHolder, this.mainScenePath, false), this.fetchScene(gl, textureHolder, this.skyboxScenePath, true), this.fetchScene(gl, textureHolder, this.bloomScenePath, false), this.fetchScene(gl, textureHolder, this.indirectScenePath, false)]).then(function (scenes) {
            var _a = __read(scenes, 4),
                mainScene = _a[0],
                skyboxScene = _a[1],
                bloomScene = _a[2],
                indirectScene = _a[3];
            return new SMGRenderer(gl, textureHolder, mainScene, skyboxScene, bloomScene, indirectScene);
        });
    };
    SMGSceneDesc.prototype.fetchScene = function (gl, textureHolder, filename, isSkybox) {
        var _this = this;
        if (filename === null) return new Progressable_1.default(Promise.resolve(null));
        var path = "data/j3d/smg/" + filename;
        return util_1.fetch(path).then(function (buffer) {
            return _this.createSceneFromBuffer(gl, textureHolder, buffer, isSkybox);
        });
    };
    SMGSceneDesc.prototype.createSceneFromBuffer = function (gl, textureHolder, buffer, isSkybox) {
        return scenes_1.createScenesFromBuffer(gl, textureHolder, buffer).then(function (scenes) {
            util_1.assert(scenes.length === 1);
            var scene = scenes[0];
            scene.setFPS(60);
            scene.setIsSkybox(isSkybox);
            return scene;
        });
    };
    return SMGSceneDesc;
}();
var id = "smg";
var name = "Super Mario Galaxy";
var sceneDescs = [new SMGSceneDesc("Peach's Castle Garden", "PeachCastleGardenPlanet.arc", "GalaxySky.arc", "PeachCastleGardenPlanetBloom.arc", "PeachCastleGardenPlanetIndirect.arc")];
exports.sceneGroup = { id: id, name: name, sceneDescs: sceneDescs };
},{"../Progressable":"Progressable.ts","../util":"util.ts","../render":"render.ts","../Program":"Program.ts","./render":"j3d\\render.ts","./scenes":"j3d\\scenes.ts","../gx/gx_material":"gx\\gx_material.ts"}],"byml.ts":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var _a;
var util_1 = require("./util");
var endian_1 = require("./endian");
var FileType;
(function (FileType) {
    FileType[FileType["BYML"] = 0] = "BYML";
    FileType[FileType["CRG1"] = 1] = "CRG1";
})(FileType = exports.FileType || (exports.FileType = {}));
var NodeType;
(function (NodeType) {
    NodeType[NodeType["STRING"] = 160] = "STRING";
    NodeType[NodeType["ARRAY"] = 192] = "ARRAY";
    NodeType[NodeType["DICT"] = 193] = "DICT";
    NodeType[NodeType["STRING_TABLE"] = 194] = "STRING_TABLE";
    NodeType[NodeType["BINARY_DATA"] = 203] = "BINARY_DATA";
    NodeType[NodeType["BOOL"] = 208] = "BOOL";
    NodeType[NodeType["INT"] = 209] = "INT";
    NodeType[NodeType["FLOAT"] = 210] = "FLOAT";
    NodeType[NodeType["SHORT"] = 211] = "SHORT";
    NodeType[NodeType["FLOAT_ARRAY"] = 226] = "FLOAT_ARRAY";
    NodeType[NodeType["NULL"] = 255] = "NULL";
})(NodeType || (NodeType = {}));
var fileDescriptions = (_a = {}, _a[FileType.BYML] = {
    magics: ['BY\0\x01', 'BY\0\x02', 'YB\x03\0'],
    allowedNodeTypes: [NodeType.STRING, NodeType.ARRAY, NodeType.DICT, NodeType.STRING_TABLE, NodeType.BOOL, NodeType.INT, NodeType.SHORT, NodeType.FLOAT, NodeType.NULL]
}, _a[FileType.CRG1] = {
    magics: ['CRG1'],
    allowedNodeTypes: [NodeType.STRING, NodeType.ARRAY, NodeType.DICT, NodeType.STRING_TABLE, NodeType.BOOL, NodeType.INT, NodeType.SHORT, NodeType.FLOAT, NodeType.NULL, NodeType.FLOAT_ARRAY, NodeType.BINARY_DATA]
}, _a);
var ParseContext = /** @class */function () {
    function ParseContext(fileType, endianness) {
        this.fileType = fileType;
        this.endianness = endianness;
        this.strKeyTable = null;
        this.strValueTable = null;
    }
    Object.defineProperty(ParseContext.prototype, "littleEndian", {
        get: function get() {
            return this.endianness === endian_1.Endianness.LITTLE_ENDIAN;
        },
        enumerable: true,
        configurable: true
    });
    return ParseContext;
}();
function getUint24(view, offs, littleEndian) {
    if (littleEndian) return view.getUint32(offs - 1, true) >>> 8;else return view.getUint32(offs - 1, false) & 0x00FFFFFF;
}
function parseStringTable(context, buffer, offs) {
    var view = buffer.createDataView();
    var header = view.getUint32(offs + 0x00, context.littleEndian);
    var nodeType = header >>> 24;
    var numValues = header & 0x00FFFFFF;
    util_1.assert(nodeType === NodeType.STRING_TABLE);
    var stringTableIdx = offs + 0x04;
    var strings = [];
    for (var i = 0; i < numValues; i++) {
        var strOffs = offs + view.getUint32(stringTableIdx, context.littleEndian);
        strings.push(util_1.readString(buffer, strOffs, -1, true));
        stringTableIdx += 0x04;
    }
    return strings;
}
function parseDict(context, buffer, offs) {
    var view = buffer.createDataView();
    var nodeType = view.getUint8(offs + 0x00);
    var numValues = getUint24(view, offs + 0x01, context.littleEndian);
    util_1.assert(nodeType === NodeType.DICT);
    var result = {};
    var dictIdx = offs + 0x04;
    for (var i = 0; i < numValues; i++) {
        var entryStrKeyIdx = getUint24(view, dictIdx + 0x00, context.littleEndian);
        var entryKey = context.strKeyTable[entryStrKeyIdx];
        var entryNodeType = view.getUint8(dictIdx + 0x03);
        var entryValue = parseNode(context, buffer, entryNodeType, dictIdx + 0x04);
        result[entryKey] = entryValue;
        dictIdx += 0x08;
    }
    return result;
}
function parseArray(context, buffer, offs) {
    var view = buffer.createDataView();
    var nodeType = view.getUint8(offs + 0x00);
    var numValues = getUint24(view, offs + 0x01, context.littleEndian);
    util_1.assert(nodeType === NodeType.ARRAY);
    var result = [];
    var entryTypeIdx = offs + 0x04;
    var entryOffsIdx = util_1.align(entryTypeIdx + numValues, 4);
    for (var i = 0; i < numValues; i++) {
        var entryNodeType = view.getUint8(entryTypeIdx);
        result.push(parseNode(context, buffer, entryNodeType, entryOffsIdx));
        entryTypeIdx++;
        entryOffsIdx += 0x04;
    }
    return result;
}
function parseComplexNode(context, buffer, offs, expectedNodeType) {
    var view = buffer.createDataView();
    var nodeType = view.getUint8(offs + 0x00);
    var numValues = getUint24(view, offs + 0x01, context.littleEndian);
    if (expectedNodeType !== undefined) util_1.assert(expectedNodeType === nodeType);
    switch (nodeType) {
        case NodeType.DICT:
            return parseDict(context, buffer, offs);
        case NodeType.ARRAY:
            return parseArray(context, buffer, offs);
        case NodeType.STRING_TABLE:
            return parseStringTable(context, buffer, offs);
        case NodeType.BINARY_DATA:
            return buffer.subarray(offs + 0x04, numValues);
        case NodeType.FLOAT_ARRAY:
            return buffer.createTypedArray(Float32Array, offs + 0x04, numValues, endian_1.Endianness.BIG_ENDIAN);
        default:
            throw new Error("whoops");
    }
}
function validateNodeType(context, nodeType) {
    util_1.assert(fileDescriptions[context.fileType].allowedNodeTypes.includes(nodeType));
}
function parseNode(context, buffer, nodeType, offs) {
    var view = buffer.createDataView();
    validateNodeType(context, nodeType);
    switch (nodeType) {
        case NodeType.ARRAY:
        case NodeType.DICT:
        case NodeType.STRING_TABLE:
        case NodeType.BINARY_DATA:
        case NodeType.FLOAT_ARRAY:
            {
                var complexOffs = view.getUint32(offs);
                return parseComplexNode(context, buffer, complexOffs, nodeType);
            }
        case NodeType.STRING:
            {
                var idx = view.getUint32(offs);
                return context.strValueTable[idx];
            }
        case NodeType.BOOL:
            {
                var value = view.getUint32(offs);
                util_1.assert(value === 0 || value === 1);
                return !!value;
            }
        case NodeType.INT:
        case NodeType.SHORT:
            {
                var value = view.getUint32(offs);
                return value;
            }
        case NodeType.FLOAT:
            {
                var value = view.getFloat32(offs);
                return value;
            }
        case NodeType.NULL:
            {
                return null;
            }
    }
}
function parse(buffer, fileType) {
    if (fileType === void 0) {
        fileType = FileType.BYML;
    }
    var magic = util_1.readString(buffer, 0x00, 0x04);
    var magics = fileDescriptions[fileType].magics;
    util_1.assert(magics.includes(magic));
    var view = buffer.createDataView();
    var littleEndian = magic.slice(0, 2) == 'YB';
    var endianness = littleEndian ? endian_1.Endianness.LITTLE_ENDIAN : endian_1.Endianness.BIG_ENDIAN;
    var context = new ParseContext(fileType, endianness);
    var strKeyTableOffs = view.getUint32(0x04, context.littleEndian);
    var strValueTableOffs = view.getUint32(0x08, context.littleEndian);
    var rootNodeOffs = view.getUint32(0x0C, context.littleEndian);
    if (rootNodeOffs === 0) return {};
    context.strKeyTable = strKeyTableOffs !== 0 ? parseStringTable(context, buffer, strKeyTableOffs) : null;
    context.strValueTable = strValueTableOffs !== 0 ? parseStringTable(context, buffer, strValueTableOffs) : null;
    var node = parseComplexNode(context, buffer, rootNodeOffs);
    return node;
}
exports.parse = parse;
},{"./util":"util.ts","./endian":"endian.ts"}],"compression\\CX.ts":[function(require,module,exports) {
"use strict";

var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var ArrayBufferSlice_1 = __importDefault(require("../ArrayBufferSlice"));
// Nintendo's "CX" formats.
// CX LZ format ("LZ10")
// Header (4 bytes):
//   Magic: "\x10" (1 byte)
//   Uncompressed size (3 bytes, little endian)
// Data:
//   Flags (1 byte)
//   For each bit in the flags byte, from MSB to LSB:
//     If flag is 1:
//       LZ77 (2 bytes, big endian):
//         Length: bits 0-3
//         Offset: bits 4-15
//         Copy Length+3 bytes from Offset back in the output buffer.
//     If flag is 0:
//       Literal: copy one byte from src to dest.
function decompressLZ_Normal(srcView) {
    var uncompressedSize = srcView.getUint32(0x00, true) >> 8;
    var dstBuffer = new Uint8Array(uncompressedSize);
    var srcOffs = 0x04;
    var dstOffs = 0x00;
    while (true) {
        var commandByte = srcView.getUint8(srcOffs++);
        var i = 8;
        while (i--) {
            if (commandByte & 1 << i) {
                var tmp = srcView.getUint16(srcOffs, false);
                srcOffs += 2;
                var windowOffset = (tmp & 0x0FFF) + 1;
                var windowLength = (tmp >> 12) + 3;
                var copyOffs = dstOffs - windowOffset;
                uncompressedSize -= windowLength;
                while (windowLength--) {
                    dstBuffer[dstOffs++] = dstBuffer[copyOffs++];
                }
            } else {
                // Literal.
                uncompressedSize--;
                dstBuffer[dstOffs++] = srcView.getUint8(srcOffs++);
            }
            if (uncompressedSize <= 0) return new ArrayBufferSlice_1.default(dstBuffer.buffer);
        }
    }
}
exports.decompressLZ_Normal = decompressLZ_Normal;
// CX LZ Extended format ("LZ11")
// Header (4 bytes):
//   Magic: "\x11" (1 byte)
//   Uncompressed size (3 bytes, little endian)
// Data:
//   Flags (1 byte)
//   For each bit in the flags byte, from MSB to LSB:
//     If flag is 1:
//       Fancy LZ77. See below for more details. Flag switches on 4-7 of newly read byte.
//     If flag is 0:
//       Literal: copy one byte from src to dest.
function decompressLZ_Extended(srcView) {
    var uncompressedSize = srcView.getUint32(0x00, true) >>> 8;
    var dstBuffer = new Uint8Array(uncompressedSize);
    var srcOffs = 0x04;
    var dstOffs = 0x00;
    while (true) {
        var commandByte = srcView.getUint8(srcOffs++);
        var i = 8;
        while (i--) {
            if (commandByte & 1 << i) {
                var indicator = srcView.getUint8(srcOffs) >>> 4;
                var windowOffset = void 0;
                var windowLength = void 0;
                if (indicator > 1) {
                    // Two bytes. AB CD
                    var tmp = srcView.getUint16(srcOffs, false);
                    // Length: A + 1
                    // Offset: BCD + 1
                    windowLength = indicator + 1;
                    windowOffset = (tmp & 0x0FFF) + 1;
                    srcOffs += 2;
                } else if (indicator === 0) {
                    // Three bytes: AB CD EF
                    var tmp = srcView.getUint16(srcOffs, false) << 8 | srcView.getUint8(srcOffs + 0x02);
                    // Length: BC + 0x11
                    // Offset: DEF + 1
                    windowLength = (tmp >>> 12) + 0x11;
                    windowOffset = (tmp & 0x0FFF) + 1;
                    srcOffs += 3;
                } else if (indicator === 1) {
                    // Four bytes. AB CD EF GH
                    var tmp = srcView.getUint32(srcOffs, false);
                    // Length: BCDE + 0x111
                    // Offset: FGH + 1
                    windowLength = (tmp >>> 12 & 0xFFFF) + 0x111;
                    windowOffset = (tmp & 0x0FFF) + 1;
                    srcOffs += 4;
                }
                var copyOffs = dstOffs - windowOffset;
                uncompressedSize -= windowLength;
                while (windowLength--) {
                    dstBuffer[dstOffs++] = dstBuffer[copyOffs++];
                }
            } else {
                // Literal.
                uncompressedSize--;
                dstBuffer[dstOffs++] = srcView.getUint8(srcOffs++);
            }
            if (uncompressedSize <= 0) return new ArrayBufferSlice_1.default(dstBuffer.buffer);
        }
    }
}
exports.decompressLZ_Extended = decompressLZ_Extended;
var CompressionType;
(function (CompressionType) {
    CompressionType[CompressionType["LZ"] = 16] = "LZ";
})(CompressionType || (CompressionType = {}));
function decompress(srcBuffer) {
    var srcView = srcBuffer.createDataView();
    var magic = srcView.getUint8(0x00);
    var compressionType = magic & 0xF0;
    if (compressionType === CompressionType.LZ) {
        var extendedFormat = !!(magic & 0x0F);
        if (extendedFormat) return decompressLZ_Extended(srcView);else return decompressLZ_Normal(srcView);
    } else {
        throw new Error("Unsupported CX compression type");
    }
}
exports.decompress = decompress;
},{"../ArrayBufferSlice":"ArrayBufferSlice.ts"}],"sm64ds\\lz77.ts":[function(require,module,exports) {
"use strict";
// SM64DS's LZ10 wrapper, which is just a "LZ77" prefix for the file.

Object.defineProperty(exports, "__esModule", { value: true });
var CX_1 = require("../compression/CX");
var util_1 = require("../util");
function isLZ77(srcBuffer) {
    return util_1.readString(srcBuffer, 0x00, 0x05) === 'LZ77\x10';
}
exports.isLZ77 = isLZ77;
function maybeDecompress(srcBuffer) {
    if (isLZ77(srcBuffer)) return CX_1.decompress(srcBuffer.slice(4));else return srcBuffer;
}
exports.maybeDecompress = maybeDecompress;
},{"../compression/CX":"compression\\CX.ts","../util":"util.ts"}],"sm64ds\\nitro_tex.ts":[function(require,module,exports) {
"use strict";
// Read DS texture formats.

Object.defineProperty(exports, "__esModule", { value: true });
var Format;
(function (Format) {
    Format[Format["Tex_None"] = 0] = "Tex_None";
    Format[Format["Tex_A3I5"] = 1] = "Tex_A3I5";
    Format[Format["Tex_Palette4"] = 2] = "Tex_Palette4";
    Format[Format["Tex_Palette16"] = 3] = "Tex_Palette16";
    Format[Format["Tex_Palette256"] = 4] = "Tex_Palette256";
    Format[Format["Tex_CMPR_4x4"] = 5] = "Tex_CMPR_4x4";
    Format[Format["Tex_A5I3"] = 6] = "Tex_A5I3";
    Format[Format["Tex_Direct"] = 7] = "Tex_Direct";
})(Format = exports.Format || (exports.Format = {}));
function expand3to8(n) {
    return n << 8 - 3 | n << 8 - 6 | n >>> 9 - 8;
}
function expand5to8(n) {
    return n << 8 - 5 | n >>> 10 - 8;
}
function s3tcblend(a, b) {
    // return (a*3 + b*5) / 8;
    return (a << 1) + a + ((b << 2) + b) >>> 3;
}
function bgr5(pixels, dstOffs, p) {
    pixels[dstOffs + 0] = expand5to8(p & 0x1F);
    pixels[dstOffs + 1] = expand5to8(p >>> 5 & 0x1F);
    pixels[dstOffs + 2] = expand5to8(p >>> 10 & 0x1F);
}
exports.bgr5 = bgr5;
function readTexture_A3I5(width, height, texData, palData) {
    var pixels = new Uint8Array(width * height * 4);
    var texView = texData.createDataView();
    var palView = palData.createDataView();
    var srcOffs = 0;
    for (var y = 0; y < height; y++) {
        for (var x = 0; x < width; x++) {
            var texBlock = texView.getUint8(srcOffs++);
            var palIdx = (texBlock & 0x1F) << 1;
            var alpha = texBlock >>> 5;
            var p = palView.getUint16(palIdx, true);
            var dstOffs = 4 * (y * width + x);
            bgr5(pixels, dstOffs, p);
            pixels[dstOffs + 3] = expand3to8(alpha);
        }
    }
    return pixels;
}
function readTexture_Palette16(width, height, texData, palData, color0) {
    var pixels = new Uint8Array(width * height * 4);
    var texView = texData.createDataView();
    var palView = palData.createDataView();
    var srcOffs = 0;
    for (var y = 0; y < height; y++) {
        for (var xx = 0; xx < width; xx += 4) {
            var texBlock = texView.getUint16(srcOffs, true);
            srcOffs += 2;
            for (var x = 0; x < 4; x++) {
                var palIdx = texBlock & 0x0F;
                var p = palView.getUint16(palIdx * 2, true);
                var dstOffs = 4 * (y * width + xx + x);
                bgr5(pixels, dstOffs, p);
                pixels[dstOffs + 3] = palIdx === 0 ? color0 ? 0x00 : 0xFF : 0xFF;
                texBlock >>= 4;
            }
        }
    }
    return pixels;
}
function readTexture_Palette256(width, height, texData, palData, color0) {
    var pixels = new Uint8Array(width * height * 4);
    var texView = texData.createDataView();
    var palView = palData.createDataView();
    var srcOffs = 0;
    for (var y = 0; y < height; y++) {
        for (var xx = 0; xx < width; xx++) {
            var palIdx = texView.getUint8(srcOffs++);
            var p = palView.getUint16(palIdx * 2, true);
            var dstOffs = 4 * (y * width + xx);
            bgr5(pixels, dstOffs, p);
            pixels[dstOffs + 3] = palIdx === 0 ? color0 ? 0x00 : 0xFF : 0xFF;
        }
    }
    return pixels;
}
function readTexture_CMPR_4x4(width, height, texData, palData) {
    function getPal16(offs) {
        return offs < palView.byteLength ? palView.getUint16(offs, true) : 0;
    }
    function buildColorTable(palBlock) {
        var palMode = palBlock >> 14;
        var palOffs = (palBlock & 0x3FFF) << 2;
        var colorTable = new Uint8Array(16);
        var p0 = getPal16(palOffs + 0x00);
        bgr5(colorTable, 0, p0);
        colorTable[3] = 0xFF;
        var p1 = getPal16(palOffs + 0x02);
        bgr5(colorTable, 4, p1);
        colorTable[7] = 0xFF;
        if (palMode === 0) {
            // PTY=0, A=0
            var p2 = getPal16(palOffs + 0x04);
            bgr5(colorTable, 8, p2);
            colorTable[11] = 0xFF;
            // Color4 is transparent black.
        } else if (palMode === 1) {
            // PTY=1, A=0
            // Color3 is a blend of Color1/Color2.
            colorTable[8] = colorTable[0] + colorTable[4] >>> 1;
            colorTable[9] = colorTable[1] + colorTable[5] >>> 1;
            colorTable[10] = colorTable[2] + colorTable[6] >>> 1;
            colorTable[11] = 0xFF;
            // Color4 is transparent black.
        } else if (palMode === 2) {
            // PTY=0, A=1
            var p2 = getPal16(palOffs + 0x04);
            bgr5(colorTable, 8, p2);
            colorTable[11] = 0xFF;
            var p3 = getPal16(palOffs + 0x06);
            bgr5(colorTable, 12, p3);
            colorTable[15] = 0xFF;
        } else {
            colorTable[8] = s3tcblend(colorTable[4], colorTable[0]);
            colorTable[9] = s3tcblend(colorTable[5], colorTable[1]);
            colorTable[10] = s3tcblend(colorTable[6], colorTable[2]);
            colorTable[11] = 0xFF;
            colorTable[12] = s3tcblend(colorTable[0], colorTable[4]);
            colorTable[13] = s3tcblend(colorTable[1], colorTable[5]);
            colorTable[14] = s3tcblend(colorTable[2], colorTable[6]);
            colorTable[15] = 0xFF;
        }
        return colorTable;
    }
    var pixels = new Uint8Array(width * height * 4);
    var texView = texData.createDataView();
    var palView = palData.createDataView();
    var palIdxStart = width * height / 4;
    var srcOffs = 0;
    for (var yy = 0; yy < height; yy += 4) {
        for (var xx = 0; xx < width; xx += 4) {
            var texBlock = texView.getUint32(srcOffs * 0x04, true);
            var palBlock = texView.getUint16(palIdxStart + srcOffs * 0x02, true);
            var colorTable = buildColorTable(palBlock);
            for (var y = 0; y < 4; y++) {
                for (var x = 0; x < 4; x++) {
                    var colorIdx = texBlock & 0x03;
                    var dstOffs = 4 * ((yy + y) * width + xx + x);
                    pixels[dstOffs + 0] = colorTable[colorIdx * 4 + 0];
                    pixels[dstOffs + 1] = colorTable[colorIdx * 4 + 1];
                    pixels[dstOffs + 2] = colorTable[colorIdx * 4 + 2];
                    pixels[dstOffs + 3] = colorTable[colorIdx * 4 + 3];
                    texBlock >>= 2;
                }
            }
            srcOffs++;
        }
    }
    return pixels;
}
function readTexture_A5I3(width, height, texData, palData) {
    var pixels = new Uint8Array(width * height * 4);
    var texView = texData.createDataView();
    var palView = palData.createDataView();
    var srcOffs = 0;
    for (var y = 0; y < height; y++) {
        for (var x = 0; x < width; x++) {
            var texBlock = texView.getUint8(srcOffs++);
            var palIdx = (texBlock & 0x03) << 1;
            var alpha = texBlock >>> 3;
            var p = palView.getUint16(palIdx, true);
            var dstOffs = 4 * (y * width + x);
            bgr5(pixels, dstOffs, p);
            pixels[dstOffs + 3] = expand5to8(alpha);
        }
    }
    return pixels;
}
function readTexture_Direct(width, height, texData) {
    var pixels = new Uint8Array(width * height * 4);
    var texView = texData.createDataView();
    var srcOffs = 0;
    for (var y = 0; y < height; y++) {
        for (var x = 0; x < width; x++) {
            var p = texView.getUint16(srcOffs, true);
            var dstOffs = 4 * (y * width + x);
            bgr5(pixels, dstOffs, p);
            pixels[dstOffs + 3] = 0xFF;
            srcOffs += 2;
        }
    }
    return pixels;
}
function readTexture(format, width, height, texData, palData, color0) {
    switch (format) {
        case Format.Tex_A3I5:
            return readTexture_A3I5(width, height, texData, palData);
        case Format.Tex_Palette16:
            return readTexture_Palette16(width, height, texData, palData, color0);
        case Format.Tex_Palette256:
            return readTexture_Palette256(width, height, texData, palData, color0);
        case Format.Tex_CMPR_4x4:
            return readTexture_CMPR_4x4(width, height, texData, palData);
        case Format.Tex_A5I3:
            return readTexture_A5I3(width, height, texData, palData);
        case Format.Tex_Direct:
            return readTexture_Direct(width, height, texData);
        default:
            throw new Error("Unsupported texture type! " + format);
    }
}
exports.readTexture = readTexture;
},{}],"sm64ds\\nitro_gx.ts":[function(require,module,exports) {
"use strict";
// Read DS Geometry Engine commands.

Object.defineProperty(exports, "__esModule", { value: true });
var nitro_tex_1 = require("./nitro_tex");
// tslint:disable:variable-name
var CmdType;
(function (CmdType) {
    CmdType[CmdType["MTX_RESTORE"] = 20] = "MTX_RESTORE";
    CmdType[CmdType["COLOR"] = 32] = "COLOR";
    CmdType[CmdType["NORMAL"] = 33] = "NORMAL";
    CmdType[CmdType["TEXCOORD"] = 34] = "TEXCOORD";
    CmdType[CmdType["VTX_16"] = 35] = "VTX_16";
    CmdType[CmdType["VTX_10"] = 36] = "VTX_10";
    CmdType[CmdType["VTX_XY"] = 37] = "VTX_XY";
    CmdType[CmdType["VTX_XZ"] = 38] = "VTX_XZ";
    CmdType[CmdType["VTX_YZ"] = 39] = "VTX_YZ";
    CmdType[CmdType["VTX_DIFF"] = 40] = "VTX_DIFF";
    CmdType[CmdType["DIF_AMB"] = 48] = "DIF_AMB";
    CmdType[CmdType["BEGIN_VTXS"] = 64] = "BEGIN_VTXS";
    CmdType[CmdType["END_VTXS"] = 65] = "END_VTXS";
})(CmdType || (CmdType = {}));
var PolyType;
(function (PolyType) {
    PolyType[PolyType["TRIANGLES"] = 0] = "TRIANGLES";
    PolyType[PolyType["QUADS"] = 1] = "QUADS";
    PolyType[PolyType["TRIANGLE_STRIP"] = 2] = "TRIANGLE_STRIP";
    PolyType[PolyType["QUAD_STRIP"] = 3] = "QUAD_STRIP";
})(PolyType || (PolyType = {}));
// 3 pos + 4 color + 2 uv
var VERTEX_SIZE = 9;
var VERTEX_BYTES = VERTEX_SIZE * Float32Array.BYTES_PER_ELEMENT;
var tmp = new Uint8Array(3);
function bgr5(pixel) {
    nitro_tex_1.bgr5(tmp, 0, pixel);
    var r = tmp[0],
        g = tmp[1],
        b = tmp[2];
    return { r: r, g: g, b: b };
}
exports.bgr5 = bgr5;
function cmd_MTX_RESTORE(ctx) {
    // XXX: We don't implement the matrix stack yet.
    ctx.readParam();
}
function cmd_COLOR(ctx) {
    var param = ctx.readParam();
    ctx.s_color = bgr5(param);
}
function cmd_NORMAL(ctx) {
    var param = ctx.readParam();
}
function cmd_TEXCOORD(ctx) {
    var param = ctx.readParam();
    var s = param & 0xFFFF;
    var t = param >> 16;
    // Sign extend.
    s = s << 16 >> 16;
    t = t << 16 >> 16;
    // Fixed point.
    s = s / 16.0;
    t = t / 16.0;
    ctx.s_texCoord = { s: s, t: t };
}
function cmd_VTX_16(ctx) {
    var param1 = ctx.readParam();
    var x = param1 & 0xFFFF;
    var y = param1 >> 16 & 0xFFFF;
    var param2 = ctx.readParam();
    var z = param2 & 0xFFFF;
    // Sign extend.
    x = x << 16 >> 16;
    y = y << 16 >> 16;
    z = z << 16 >> 16;
    // Fixed point.
    x = x / 4096.0;
    y = y / 4096.0;
    z = z / 4096.0;
    ctx.vtx(x, y, z);
}
function cmd_VTX_10(ctx) {
    var param = ctx.readParam();
    var x = param & 0x03FF;
    var y = param >> 10 & 0x03FF;
    var z = param >> 20 & 0x03FF;
    // Sign extend.
    x = x << 22 >> 22;
    y = y << 22 >> 22;
    z = z << 22 >> 22;
    // Fixed point.
    x = x / 64.0;
    y = y / 64.0;
    z = z / 64.0;
    ctx.vtx(x, y, z);
}
function cmd_VTX_XY(ctx) {
    var param = ctx.readParam();
    var x = param & 0xFFFF;
    var y = param >> 16 & 0xFFFF;
    // Sign extend.
    x = x << 16 >> 16;
    y = y << 16 >> 16;
    // Fixed point.
    x = x / 4096.0;
    y = y / 4096.0;
    ctx.vtx(x, y, ctx.s_vtx.z);
}
function cmd_VTX_XZ(ctx) {
    var param = ctx.readParam();
    var x = param & 0xFFFF;
    var z = param >> 16 & 0xFFFF;
    // Sign extend.
    x = x << 16 >> 16;
    z = z << 16 >> 16;
    // Fixed point.
    x = x / 4096.0;
    z = z / 4096.0;
    ctx.vtx(x, ctx.s_vtx.y, z);
}
function cmd_VTX_YZ(ctx) {
    var param = ctx.readParam();
    var y = param & 0xFFFF;
    var z = param >> 16 & 0xFFFF;
    // Sign extend.
    y = y << 16 >> 16;
    z = z << 16 >> 16;
    // Fixed point.
    y = y / 4096.0;
    z = z / 4096.0;
    ctx.vtx(ctx.s_vtx.x, y, z);
}
function cmd_VTX_DIFF(ctx) {
    var param = ctx.readParam();
    var x = param & 0x03FF;
    var y = param >> 10 & 0x03FF;
    var z = param >> 20 & 0x03FF;
    // Sign extend.
    x = x << 22 >> 22;
    y = y << 22 >> 22;
    z = z << 22 >> 22;
    // Fixed point.
    x = x / 4096.0;
    y = y / 4096.0;
    z = z / 4096.0;
    // Add on the difference...
    x += ctx.s_vtx.x;
    y += ctx.s_vtx.y;
    z += ctx.s_vtx.z;
    ctx.vtx(x, y, z);
}
function cmd_DIF_AMB(ctx) {
    var param = ctx.readParam();
    // TODO: lighting
}
function cmd_BEGIN_VTXS(ctx) {
    var param = ctx.readParam();
    var polyType = param & 0x03;
    ctx.s_polyType = polyType;
    ctx.vtxs = [];
}
function cmd_END_VTXS(ctx) {
    var nVerts = ctx.vtxs.length;
    var vtxBuffer = new Float32Array(nVerts * VERTEX_SIZE);
    for (var i = 0; i < nVerts; i++) {
        var v = ctx.vtxs[i];
        var vtxArray = new Float32Array(vtxBuffer.buffer, i * VERTEX_BYTES, VERTEX_SIZE);
        vtxArray[0] = v.pos.x;
        vtxArray[1] = v.pos.y;
        vtxArray[2] = v.pos.z;
        vtxArray[3] = v.color.r / 0xFF;
        vtxArray[4] = v.color.g / 0xFF;
        vtxArray[5] = v.color.b / 0xFF;
        vtxArray[6] = ctx.alpha / 0xFF;
        vtxArray[7] = v.uv.s;
        vtxArray[8] = v.uv.t;
    }
    var idxBuffer;
    if (ctx.s_polyType === PolyType.TRIANGLES) {
        idxBuffer = new Uint16Array(nVerts);
        for (var i = 0; i < nVerts; i++) {
            idxBuffer[i] = i;
        }
    } else if (ctx.s_polyType === PolyType.QUADS) {
        idxBuffer = new Uint16Array(nVerts / 4 * 6);
        var dst = 0;
        for (var i = 0; i < nVerts; i += 4) {
            idxBuffer[dst++] = i + 0;
            idxBuffer[dst++] = i + 1;
            idxBuffer[dst++] = i + 2;
            idxBuffer[dst++] = i + 2;
            idxBuffer[dst++] = i + 3;
            idxBuffer[dst++] = i + 0;
        }
    } else if (ctx.s_polyType === PolyType.TRIANGLE_STRIP) {
        idxBuffer = new Uint16Array((nVerts - 2) * 3);
        var dst = 0;
        for (var i = 0; i < nVerts - 2; i++) {
            if (i % 2 === 0) {
                idxBuffer[dst++] = i + 0;
                idxBuffer[dst++] = i + 1;
                idxBuffer[dst++] = i + 2;
            } else {
                idxBuffer[dst++] = i + 1;
                idxBuffer[dst++] = i + 0;
                idxBuffer[dst++] = i + 2;
            }
        }
    } else if (ctx.s_polyType === PolyType.QUAD_STRIP) {
        idxBuffer = new Uint16Array((nVerts - 2) / 2 * 6);
        var dst = 0;
        for (var i = 0; i < nVerts; i += 2) {
            idxBuffer[dst++] = i + 0;
            idxBuffer[dst++] = i + 1;
            idxBuffer[dst++] = i + 3;
            idxBuffer[dst++] = i + 3;
            idxBuffer[dst++] = i + 2;
            idxBuffer[dst++] = i + 0;
        }
    }
    var packet = { vertData: vtxBuffer, idxData: idxBuffer, polyType: ctx.s_polyType };
    ctx.packets.push(packet);
}
function runCmd(ctx, cmd) {
    switch (cmd) {
        case 0:
            return;
        case CmdType.MTX_RESTORE:
            return cmd_MTX_RESTORE(ctx);
        case CmdType.COLOR:
            return cmd_COLOR(ctx);
        case CmdType.NORMAL:
            return cmd_NORMAL(ctx);
        case CmdType.TEXCOORD:
            return cmd_TEXCOORD(ctx);
        case CmdType.VTX_16:
            return cmd_VTX_16(ctx);
        case CmdType.VTX_10:
            return cmd_VTX_10(ctx);
        case CmdType.VTX_XY:
            return cmd_VTX_XY(ctx);
        case CmdType.VTX_XZ:
            return cmd_VTX_XZ(ctx);
        case CmdType.VTX_YZ:
            return cmd_VTX_YZ(ctx);
        case CmdType.VTX_DIFF:
            return cmd_VTX_DIFF(ctx);
        case CmdType.DIF_AMB:
            return cmd_DIF_AMB(ctx);
        case CmdType.BEGIN_VTXS:
            return cmd_BEGIN_VTXS(ctx);
        case CmdType.END_VTXS:
            return cmd_END_VTXS(ctx);
        default:
            console.warn("Missing command", cmd.toString(16));
    }
}
var Context = /** @class */function () {
    function Context() {}
    return Context;
}();
exports.Context = Context;
var ContextInternal = /** @class */function () {
    function ContextInternal(buffer, baseCtx) {
        this.offs = 0;
        this.alpha = baseCtx.alpha;
        this.s_color = baseCtx.color;
        this.view = buffer.createDataView();
        this.s_texCoord = { s: 0, t: 0 };
        this.packets = [];
    }
    ContextInternal.prototype.readParam = function () {
        return this.view.getUint32((this.offs += 4) - 4, true);
    };
    ContextInternal.prototype.vtx = function (x, y, z) {
        this.s_vtx = { x: x, y: y, z: z };
        this.vtxs.push({ pos: this.s_vtx, nrm: this.s_nrm, color: this.s_color, uv: this.s_texCoord });
    };
    return ContextInternal;
}();
function readCmds(buffer, baseCtx) {
    var ctx = new ContextInternal(buffer, baseCtx);
    while (ctx.offs < buffer.byteLength) {
        // Commands are packed 4 at a time...
        var cmd0 = ctx.view.getUint8(ctx.offs++);
        var cmd1 = ctx.view.getUint8(ctx.offs++);
        var cmd2 = ctx.view.getUint8(ctx.offs++);
        var cmd3 = ctx.view.getUint8(ctx.offs++);
        runCmd(ctx, cmd0);
        runCmd(ctx, cmd1);
        runCmd(ctx, cmd2);
        runCmd(ctx, cmd3);
    }
    return ctx.packets;
}
exports.readCmds = readCmds;
},{"./nitro_tex":"sm64ds\\nitro_tex.ts"}],"sm64ds\\nitro_bmd.ts":[function(require,module,exports) {
"use strict";

var __importStar = this && this.__importStar || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) {
        if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    }result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var gl_matrix_1 = require("gl-matrix");
var NITRO_GX = __importStar(require("./nitro_gx"));
var NITRO_Tex = __importStar(require("./nitro_tex"));
var util_1 = require("../util");
var Material = /** @class */function () {
    function Material() {}
    return Material;
}();
exports.Material = Material;
var Model = /** @class */function () {
    function Model() {}
    return Model;
}();
exports.Model = Model;
function parseModel(bmd, buffer, idx) {
    var offs = bmd.modelOffsBase + idx * 0x40;
    var view = buffer.createDataView();
    var model = new Model();
    model.id = view.getUint32(offs + 0x00, true);
    model.name = util_1.readString(buffer, view.getUint32(offs + 0x04, true), 0xFF);
    model.parentID = view.getUint16(offs + 0x08, true);
    // Local transform.
    var xs = view.getUint32(offs + 0x10, true);
    var ys = view.getUint32(offs + 0x14, true);
    var zs = view.getUint32(offs + 0x18, true);
    var xr = view.getUint16(offs + 0x1C, true);
    var yr = view.getUint16(offs + 0x1E, true);
    var zr = view.getUint16(offs + 0x20, true);
    var xt = view.getUint16(offs + 0x24, true);
    var yt = view.getUint16(offs + 0x28, true);
    var zt = view.getUint16(offs + 0x2C, true);
    var flags = view.getUint32(offs + 0x3C, true);
    model.billboard = !!(flags & 0x01);
    // A "batch" is a combination of a material and a poly.
    var batchCount = view.getUint32(offs + 0x30, true);
    var batchMaterialOffs = view.getUint32(offs + 0x34, true);
    var batchPolyOffs = view.getUint32(offs + 0x38, true);
    model.batches = [];
    for (var i = 0; i < batchCount; i++) {
        var materialIdx = view.getUint8(batchMaterialOffs + i);
        var material = parseMaterial(bmd, buffer, materialIdx);
        var baseCtx = { color: material.diffuse, alpha: material.alpha };
        var polyIdx = view.getUint8(batchPolyOffs + i);
        var poly = parsePoly(bmd, buffer, polyIdx, baseCtx);
        model.batches.push({ material: material, poly: poly });
    }
    return model;
}
function parsePoly(bmd, buffer, idx, baseCtx) {
    var view = buffer.createDataView();
    var offs = view.getUint32(bmd.polyOffsBase + idx * 0x08 + 0x04, true);
    var gxCmdSize = view.getUint32(offs + 0x08, true);
    var gxCmdOffs = view.getUint32(offs + 0x0C, true);
    var gxCmdBuf = buffer.slice(gxCmdOffs, gxCmdOffs + gxCmdSize);
    var packets = NITRO_GX.readCmds(gxCmdBuf, baseCtx);
    return { packets: packets };
}
function parseMaterial(bmd, buffer, idx) {
    var view = buffer.createDataView();
    var offs = bmd.materialOffsBase + idx * 0x30;
    var material = new Material();
    material.name = util_1.readString(buffer, view.getUint32(offs + 0x00, true), 0xFF);
    material.texCoordMat = gl_matrix_1.mat2d.create();
    var textureIdx = view.getUint32(offs + 0x04, true);
    if (textureIdx !== 0xFFFFFFFF) {
        var paletteIdx = view.getUint32(offs + 0x08, true);
        var textureKey = new TextureKey(textureIdx, paletteIdx);
        material.texture = parseTexture(bmd, buffer, textureKey);
        material.texParams = material.texture.params | view.getUint32(offs + 0x20, true);
        if (material.texParams >> 30) {
            var scaleS = view.getInt32(offs + 0x0C, true) / 4096.0;
            var scaleT = view.getInt32(offs + 0x10, true) / 4096.0;
            var transS = view.getInt32(offs + 0x18, true) / 4096.0;
            var transT = view.getInt32(offs + 0x1C, true) / 4096.0;
            gl_matrix_1.mat2d.translate(material.texCoordMat, material.texCoordMat, [transS, transT, 0.0]);
            gl_matrix_1.mat2d.scale(material.texCoordMat, material.texCoordMat, [scaleS, scaleT, 1.0]);
        }
        var texScale = [1 / material.texture.width, 1 / material.texture.height, 1];
        gl_matrix_1.mat2d.scale(material.texCoordMat, material.texCoordMat, texScale);
    } else {
        material.texture = null;
        material.texParams = 0;
    }
    var polyAttribs = view.getUint32(offs + 0x24, true);
    var alpha = polyAttribs >> 16 & 0x1F;
    alpha = alpha << 8 - 5 | alpha >>> 10 - 8;
    var renderWhichFaces = polyAttribs >> 6 & 0x03;
    material.renderWhichFaces = renderWhichFaces;
    // NITRO's Rendering Engine uses two passes. Opaque, then Transparent.
    // A transparent polygon is one that has an alpha of < 0xFF, or uses
    // A5I3 / A3I5 textures.
    material.isTranslucent = alpha < 0xFF || material.texture && material.texture.isTranslucent;
    // Do transparent polys write to the depth buffer?
    var xl = polyAttribs >>> 11 & 0x01;
    if (xl) material.depthWrite = true;else material.depthWrite = !material.isTranslucent;
    var difAmb = view.getUint32(offs + 0x28, true);
    if (difAmb & 0x8000) material.diffuse = NITRO_GX.bgr5(difAmb);else material.diffuse = { r: 0xFF, g: 0xFF, b: 0xFF };
    material.alpha = alpha;
    return material;
}
var TextureKey = /** @class */function () {
    function TextureKey(texIdx, palIdx) {
        this.texIdx = texIdx;
        this.palIdx = palIdx;
    }
    TextureKey.prototype.toString = function () {
        return "TextureKey " + this.texIdx + " " + this.palIdx;
    };
    return TextureKey;
}();
var Texture = /** @class */function () {
    function Texture() {}
    return Texture;
}();
exports.Texture = Texture;
function parseTexture(bmd, buffer, key) {
    if (bmd.textureCache.has(key.toString())) return bmd.textureCache.get(key.toString());
    var view = buffer.createDataView();
    var texOffs = bmd.textureOffsBase + key.texIdx * 0x14;
    var texture = new Texture();
    texture.id = key.texIdx;
    texture.name = util_1.readString(buffer, view.getUint32(texOffs + 0x00, true), 0xFF);
    var texDataOffs = view.getUint32(texOffs + 0x04, true);
    var texDataSize = view.getUint32(texOffs + 0x08, true);
    var texData = buffer.slice(texDataOffs);
    texture.params = view.getUint32(texOffs + 0x10, true);
    texture.format = texture.params >> 26 & 0x07;
    texture.width = 8 << (texture.params >> 20 & 0x07);
    texture.height = 8 << (texture.params >> 23 & 0x07);
    var color0 = !!(texture.params >> 29 & 0x01);
    var palData = null;
    if (key.palIdx !== 0xFFFFFFFF) {
        var palOffs = bmd.paletteOffsBase + key.palIdx * 0x10;
        texture.paletteName = util_1.readString(buffer, view.getUint32(palOffs + 0x00, true), 0xFF);
        var palDataOffs = view.getUint32(palOffs + 0x04, true);
        var palDataSize = view.getUint32(palOffs + 0x08, true);
        palData = buffer.slice(palDataOffs, palDataOffs + palDataSize);
    }
    texture.pixels = NITRO_Tex.readTexture(texture.format, texture.width, texture.height, texData, palData, color0);
    texture.isTranslucent = texture.format === NITRO_Tex.Format.Tex_A5I3 || texture.format === NITRO_Tex.Format.Tex_A3I5;
    bmd.textures.push(texture);
    bmd.textureCache.set(key.toString(), texture);
    return texture;
}
var BMD = /** @class */function () {
    function BMD() {}
    return BMD;
}();
exports.BMD = BMD;
function parse(buffer) {
    var view = buffer.createDataView();
    var bmd = new BMD();
    bmd.scaleFactor = 1 << view.getUint32(0x00, true);
    bmd.modelCount = view.getUint32(0x04, true);
    bmd.modelOffsBase = view.getUint32(0x08, true);
    bmd.polyCount = view.getUint32(0x0C, true);
    bmd.polyOffsBase = view.getUint32(0x10, true);
    bmd.textureCount = view.getUint32(0x14, true);
    bmd.textureOffsBase = view.getUint32(0x18, true);
    bmd.paletteCount = view.getUint32(0x1C, true);
    bmd.paletteOffsBase = view.getUint32(0x20, true);
    bmd.materialCount = view.getUint32(0x24, true);
    bmd.materialOffsBase = view.getUint32(0x28, true);
    bmd.textureCache = new Map();
    bmd.textures = [];
    bmd.models = [];
    for (var i = 0; i < bmd.modelCount; i++) {
        bmd.models.push(parseModel(bmd, buffer, i));
    }return bmd;
}
exports.parse = parse;
},{"gl-matrix":"..\\node_modules\\gl-matrix\\src\\gl-matrix.js","./nitro_gx":"sm64ds\\nitro_gx.ts","./nitro_tex":"sm64ds\\nitro_tex.ts","../util":"util.ts"}],"RenderArena.ts":[function(require,module,exports) {
"use strict";

var __values = this && this.__values || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator],
        i = 0;
    if (m) return m.call(o);
    return {
        next: function next() {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", { value: true });
function pushAndReturn(a, v) {
    a.push(v);
    return v;
}
// Optional helper providing a lazy attempt at arena-style garbage collection.
var RenderArena = /** @class */function () {
    function RenderArena() {
        this.textures = [];
        this.samplers = [];
        this.buffers = [];
        this.vaos = [];
        this.programs = [];
    }
    RenderArena.prototype.createTexture = function (gl) {
        return pushAndReturn(this.textures, gl.createTexture());
    };
    RenderArena.prototype.createSampler = function (gl) {
        return pushAndReturn(this.samplers, gl.createSampler());
    };
    RenderArena.prototype.createBuffer = function (gl) {
        return pushAndReturn(this.buffers, gl.createBuffer());
    };
    RenderArena.prototype.createVertexArray = function (gl) {
        return pushAndReturn(this.vaos, gl.createVertexArray());
    };
    RenderArena.prototype.trackProgram = function (program) {
        this.programs.push(program);
    };
    RenderArena.prototype.destroy = function (gl) {
        var e_1, _a, e_2, _b, e_3, _c, e_4, _d, e_5, _e;
        try {
            for (var _f = __values(this.textures), _g = _f.next(); !_g.done; _g = _f.next()) {
                var texture = _g.value;
                gl.deleteTexture(texture);
            }
        } catch (e_1_1) {
            e_1 = { error: e_1_1 };
        } finally {
            try {
                if (_g && !_g.done && (_a = _f.return)) _a.call(_f);
            } finally {
                if (e_1) throw e_1.error;
            }
        }
        this.textures = [];
        try {
            for (var _h = __values(this.samplers), _j = _h.next(); !_j.done; _j = _h.next()) {
                var sampler = _j.value;
                gl.deleteSampler(sampler);
            }
        } catch (e_2_1) {
            e_2 = { error: e_2_1 };
        } finally {
            try {
                if (_j && !_j.done && (_b = _h.return)) _b.call(_h);
            } finally {
                if (e_2) throw e_2.error;
            }
        }
        this.samplers = [];
        try {
            for (var _k = __values(this.buffers), _l = _k.next(); !_l.done; _l = _k.next()) {
                var buffer = _l.value;
                gl.deleteBuffer(buffer);
            }
        } catch (e_3_1) {
            e_3 = { error: e_3_1 };
        } finally {
            try {
                if (_l && !_l.done && (_c = _k.return)) _c.call(_k);
            } finally {
                if (e_3) throw e_3.error;
            }
        }
        this.buffers = [];
        try {
            for (var _m = __values(this.vaos), _o = _m.next(); !_o.done; _o = _m.next()) {
                var vao = _o.value;
                gl.deleteVertexArray(vao);
            }
        } catch (e_4_1) {
            e_4 = { error: e_4_1 };
        } finally {
            try {
                if (_o && !_o.done && (_d = _m.return)) _d.call(_m);
            } finally {
                if (e_4) throw e_4.error;
            }
        }
        this.vaos = [];
        try {
            for (var _p = __values(this.programs), _q = _p.next(); !_q.done; _q = _p.next()) {
                var program = _q.value;
                program.destroy(gl);
            }
        } catch (e_5_1) {
            e_5 = { error: e_5_1 };
        } finally {
            try {
                if (_q && !_q.done && (_e = _p.return)) _e.call(_p);
            } finally {
                if (e_5) throw e_5.error;
            }
        }
        this.programs = [];
    };
    return RenderArena;
}();
exports.default = RenderArena;
},{}],"sm64ds\\render.ts":[function(require,module,exports) {
"use strict";

var __extends = this && this.__extends || function () {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
        d.__proto__ = b;
    } || function (d, b) {
        for (var p in b) {
            if (b.hasOwnProperty(p)) d[p] = b[p];
        }
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __values = this && this.__values || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator],
        i = 0;
    if (m) return m.call(o);
    return {
        next: function next() {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
var __read = this && this.__read || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o),
        r,
        ar = [],
        e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {
            ar.push(r.value);
        }
    } catch (error) {
        e = { error: error };
    } finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
            if (e) throw e.error;
        }
    }
    return ar;
};
var __spread = this && this.__spread || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) {
        ar = ar.concat(__read(arguments[i]));
    }return ar;
};
var __importStar = this && this.__importStar || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) {
        if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    }result["default"] = mod;
    return result;
};
var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var gl_matrix_1 = require("gl-matrix");
var BYML = __importStar(require("../byml"));
var LZ77 = __importStar(require("./lz77"));
var NITRO_BMD = __importStar(require("./nitro_bmd"));
var render_1 = require("../render");
var Program_1 = __importDefault(require("../Program"));
var RenderArena_1 = __importDefault(require("../RenderArena"));
var util_1 = require("../util");
var Camera_1 = require("../Camera");
var NITRO_Program = /** @class */function (_super) {
    __extends(NITRO_Program, _super);
    function NITRO_Program() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.vert = "\nprecision mediump float;\nuniform mat4 u_modelView;\nuniform mat4 u_projection;\nuniform mat3 u_texCoordMat;\nlayout(location = " + NITRO_Program.a_position + ") in vec3 a_position;\nlayout(location = " + NITRO_Program.a_uv + ") in vec2 a_uv;\nlayout(location = " + NITRO_Program.a_color + ") in vec4 a_color;\nout vec4 v_color;\nout vec2 v_uv;\n\nvoid main() {\n    gl_Position = u_projection * u_modelView * vec4(a_position, 1.0);\n    v_color = a_color;\n    v_uv = (u_texCoordMat * vec3(a_uv, 1.0)).st;\n}\n";
        _this.frag = "\nprecision mediump float;\nin vec2 v_uv;\nin vec4 v_color;\nuniform sampler2D u_texture;\n\nvoid main() {\n    gl_FragColor = texture2D(u_texture, v_uv);\n    gl_FragColor *= v_color;\n    if (gl_FragColor.a == 0.0)\n        discard;\n}\n";
        return _this;
    }
    NITRO_Program.prototype.bind = function (gl, prog) {
        _super.prototype.bind.call(this, gl, prog);
        this.texCoordMatLocation = gl.getUniformLocation(prog, "u_texCoordMat");
    };
    NITRO_Program.a_position = 0;
    NITRO_Program.a_uv = 1;
    NITRO_Program.a_color = 2;
    return NITRO_Program;
}(Program_1.default);
// 3 pos + 4 color + 2 uv
var VERTEX_SIZE = 9;
var VERTEX_BYTES = VERTEX_SIZE * Float32Array.BYTES_PER_ELEMENT;
function textureToCanvas(bmdTex) {
    var canvas = document.createElement("canvas");
    canvas.width = bmdTex.width;
    canvas.height = bmdTex.height;
    canvas.title = bmdTex.name + " (" + bmdTex.format + ")";
    var ctx = canvas.getContext("2d");
    var imgData = ctx.createImageData(canvas.width, canvas.height);
    imgData.data.set(bmdTex.pixels);
    ctx.putImageData(imgData, 0, 0);
    var surfaces = [canvas];
    return { name: bmdTex.name, surfaces: surfaces };
}
var YSpinAnimation = /** @class */function () {
    function YSpinAnimation(speed, phase) {
        this.speed = speed;
        this.phase = phase;
    }
    YSpinAnimation.prototype.updateModelMatrix = function (state, modelMatrix) {
        var theta = this.phase + state.time / 30 * this.speed;
        gl_matrix_1.mat4.rotateY(modelMatrix, modelMatrix, theta);
    };
    return YSpinAnimation;
}();
var scratchModelMatrix = gl_matrix_1.mat4.create();
var scratchViewMatrix = gl_matrix_1.mat4.create();
var BMDRenderer = /** @class */function () {
    function BMDRenderer(gl, bmd, crg1Level) {
        this.animation = null;
        this.opaqueCommands = [];
        this.transparentCommands = [];
        this.program = new NITRO_Program();
        this.bmd = bmd;
        this.crg1Level = crg1Level;
        this.isSkybox = false;
        this.arena = new RenderArena_1.default();
        this.textures = bmd.textures.map(function (texture) {
            return textureToCanvas(texture);
        });
        this.translateBMD(gl, this.bmd);
        var scaleFactor = this.bmd.scaleFactor;
        this.localMatrix = gl_matrix_1.mat4.create();
        gl_matrix_1.mat4.fromScaling(this.localMatrix, [scaleFactor, scaleFactor, scaleFactor]);
    }
    BMDRenderer.prototype.translatePacket = function (gl, packet) {
        var vertBuffer = this.arena.createBuffer(gl);
        gl.bindBuffer(gl.ARRAY_BUFFER, vertBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, packet.vertData, gl.STATIC_DRAW);
        var idxBuffer = this.arena.createBuffer(gl);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, idxBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, packet.idxData, gl.STATIC_DRAW);
        var vao = this.arena.createVertexArray(gl);
        gl.bindVertexArray(vao);
        gl.bindBuffer(gl.ARRAY_BUFFER, vertBuffer);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, idxBuffer);
        gl.vertexAttribPointer(NITRO_Program.a_position, 3, gl.FLOAT, false, VERTEX_BYTES, 0);
        gl.vertexAttribPointer(NITRO_Program.a_color, 4, gl.FLOAT, false, VERTEX_BYTES, 3 * Float32Array.BYTES_PER_ELEMENT);
        gl.vertexAttribPointer(NITRO_Program.a_uv, 2, gl.FLOAT, false, VERTEX_BYTES, 7 * Float32Array.BYTES_PER_ELEMENT);
        gl.enableVertexAttribArray(NITRO_Program.a_position);
        gl.enableVertexAttribArray(NITRO_Program.a_color);
        gl.enableVertexAttribArray(NITRO_Program.a_uv);
        gl.bindVertexArray(null);
        return function (renderState) {
            gl.bindVertexArray(vao);
            gl.drawElements(gl.TRIANGLES, packet.idxData.length, gl.UNSIGNED_SHORT, 0);
            gl.bindVertexArray(null);
        };
    };
    BMDRenderer.prototype.translatePoly = function (gl, poly) {
        var _this = this;
        var funcs = poly.packets.map(function (packet) {
            return _this.translatePacket(gl, packet);
        });
        return function (state) {
            funcs.forEach(function (f) {
                f(state);
            });
        };
    };
    BMDRenderer.prototype.translateCullMode = function (renderWhichFaces) {
        switch (renderWhichFaces) {
            case 0x00:
                // Render Nothing
                return render_1.CullMode.FRONT_AND_BACK;
            case 0x01:
                // Render Back
                return render_1.CullMode.FRONT;
            case 0x02:
                // Render Front
                return render_1.CullMode.BACK;
            case 0x03:
                // Render Front and Back
                return render_1.CullMode.NONE;
            default:
                throw new Error("Unknown renderWhichFaces");
        }
    };
    BMDRenderer.prototype.translateMaterial = function (gl, material) {
        var texture = material.texture;
        var texId;
        function wrapMode(repeat, flip) {
            if (repeat) return flip ? gl.MIRRORED_REPEAT : gl.REPEAT;else return gl.CLAMP_TO_EDGE;
        }
        if (texture !== null) {
            texId = this.arena.createTexture(gl);
            gl.bindTexture(gl.TEXTURE_2D, texId);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            var repeatS = !!(material.texParams >> 16 & 0x01);
            var repeatT = !!(material.texParams >> 17 & 0x01);
            var flipS = !!(material.texParams >> 18 & 0x01);
            var flipT = !!(material.texParams >> 19 & 0x01);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, wrapMode(repeatS, flipS));
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, wrapMode(repeatT, flipT));
            gl.bindTexture(gl.TEXTURE_2D, texId);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, texture.width, texture.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, texture.pixels);
        }
        // Find any possible material animations.
        var crg1mat = this.crg1Level ? this.crg1Level.TextureAnimations.find(function (c) {
            return c.MaterialName === material.name;
        }) : undefined;
        var texCoordMat = gl_matrix_1.mat3.create();
        gl_matrix_1.mat3.fromMat2d(texCoordMat, material.texCoordMat);
        var renderFlags = new render_1.RenderFlags();
        renderFlags.blendMode = render_1.BlendMode.ADD;
        renderFlags.depthTest = true;
        renderFlags.depthWrite = material.depthWrite;
        renderFlags.cullMode = this.translateCullMode(material.renderWhichFaces);
        var texAnimMat = gl_matrix_1.mat3.create();
        return function (state) {
            function selectArray(arr, time) {
                return arr[(time | 0) % arr.length];
            }
            if (crg1mat !== undefined) {
                var time = state.time / 30;
                var scale = selectArray(crg1mat.Scale, time);
                var rotation = selectArray(crg1mat.Rotation, time);
                var x = selectArray(crg1mat.X, time);
                var y = selectArray(crg1mat.Y, time);
                gl_matrix_1.mat3.identity(texAnimMat);
                gl_matrix_1.mat3.scale(texAnimMat, texAnimMat, [scale, scale]);
                gl_matrix_1.mat3.rotate(texAnimMat, texAnimMat, rotation / 180 * Math.PI);
                gl_matrix_1.mat3.translate(texAnimMat, texAnimMat, [-x, y]);
                gl_matrix_1.mat3.fromMat2d(texCoordMat, material.texCoordMat);
                gl_matrix_1.mat3.multiply(texCoordMat, texAnimMat, texCoordMat);
            }
            if (texture !== null) {
                var prog = state.currentProgram;
                gl.uniformMatrix3fv(prog.texCoordMatLocation, false, texCoordMat);
                gl.bindTexture(gl.TEXTURE_2D, texId);
            }
            state.useFlags(renderFlags);
        };
    };
    BMDRenderer.prototype.bindModelView = function (state, isBillboard) {
        var gl = state.gl;
        var prog = this.program;
        // Build model matrix
        var modelMatrix = scratchModelMatrix;
        if (isBillboard) {
            // Apply billboard model if necessary.
            Camera_1.computeModelMatrixYBillboard(modelMatrix, state.camera);
            gl_matrix_1.mat4.mul(modelMatrix, this.localMatrix, modelMatrix);
        } else {
            gl_matrix_1.mat4.copy(modelMatrix, this.localMatrix);
        }
        if (this.animation !== null) this.animation.updateModelMatrix(state, modelMatrix);
        // Build view matrix
        var viewMatrix = scratchViewMatrix;
        if (this.isSkybox) {
            Camera_1.computeViewMatrixSkybox(viewMatrix, state.camera);
        } else {
            Camera_1.computeViewMatrix(viewMatrix, state.camera);
        }
        gl_matrix_1.mat4.mul(viewMatrix, viewMatrix, modelMatrix);
        gl.uniformMatrix4fv(prog.projectionLocation, false, state.camera.projectionMatrix);
        gl.uniformMatrix4fv(prog.modelViewLocation, false, viewMatrix);
    };
    BMDRenderer.prototype.translateBatch = function (gl, model, batch) {
        var _this = this;
        var applyMaterial = this.translateMaterial(gl, batch.material);
        var renderPoly = this.translatePoly(gl, batch.poly);
        var func = function func(state) {
            state.useProgram(_this.program);
            applyMaterial(state);
            _this.bindModelView(state, model.billboard);
            renderPoly(state);
        };
        if (batch.material.isTranslucent) this.transparentCommands.push(func);else this.opaqueCommands.push(func);
    };
    BMDRenderer.prototype.translateBMD = function (gl, bmd) {
        var e_1, _a, e_2, _b;
        try {
            for (var _c = __values(bmd.models), _d = _c.next(); !_d.done; _d = _c.next()) {
                var model = _d.value;
                try {
                    for (var _e = __values(model.batches), _f = _e.next(); !_f.done; _f = _e.next()) {
                        var batch = _f.value;
                        this.translateBatch(gl, model, batch);
                    }
                } catch (e_2_1) {
                    e_2 = { error: e_2_1 };
                } finally {
                    try {
                        if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                    } finally {
                        if (e_2) throw e_2.error;
                    }
                }
            }
        } catch (e_1_1) {
            e_1 = { error: e_1_1 };
        } finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            } finally {
                if (e_1) throw e_1.error;
            }
        }
    };
    BMDRenderer.prototype.destroy = function (gl) {
        this.arena.destroy(gl);
    };
    return BMDRenderer;
}();
function collectTextures(scenes) {
    var e_3, _a;
    var textures = [];
    try {
        for (var scenes_1 = __values(scenes), scenes_1_1 = scenes_1.next(); !scenes_1_1.done; scenes_1_1 = scenes_1.next()) {
            var scene = scenes_1_1.value;
            if (scene) textures.push.apply(textures, scene.textures);
        }
    } catch (e_3_1) {
        e_3 = { error: e_3_1 };
    } finally {
        try {
            if (scenes_1_1 && !scenes_1_1.done && (_a = scenes_1.return)) _a.call(scenes_1);
        } finally {
            if (e_3) throw e_3.error;
        }
    }
    return textures;
}
var SM64DSRenderer = /** @class */function () {
    function SM64DSRenderer(mainBMD, skyboxBMD, extraBMDs) {
        this.mainBMD = mainBMD;
        this.skyboxBMD = skyboxBMD;
        this.extraBMDs = extraBMDs;
        this.textures = collectTextures(__spread([this.mainBMD, this.skyboxBMD], this.extraBMDs));
    }
    SM64DSRenderer.prototype.runCommands = function (state, funcs) {
        funcs.forEach(function (func) {
            func(state);
        });
    };
    SM64DSRenderer.prototype.render = function (renderState) {
        var _this = this;
        var gl = renderState.gl;
        if (this.skyboxBMD) {
            this.runCommands(renderState, this.skyboxBMD.opaqueCommands);
            renderState.useFlags(render_1.depthClearFlags);
            gl.clear(gl.DEPTH_BUFFER_BIT);
        } else {
            // No skybox? Black.
            gl.clearColor(0, 0, 0, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT);
        }
        // Opaque.
        this.runCommands(renderState, this.mainBMD.opaqueCommands);
        this.extraBMDs.forEach(function (bmd) {
            _this.runCommands(renderState, bmd.opaqueCommands);
        });
        // Transparent.
        this.runCommands(renderState, this.mainBMD.transparentCommands);
        this.extraBMDs.forEach(function (bmd) {
            _this.runCommands(renderState, bmd.transparentCommands);
        });
    };
    SM64DSRenderer.prototype.destroy = function (gl) {
        this.mainBMD.destroy(gl);
        if (this.skyboxBMD) this.skyboxBMD.destroy(gl);
        this.extraBMDs.forEach(function (renderer) {
            return renderer.destroy(gl);
        });
    };
    return SM64DSRenderer;
}();
var SceneDesc = /** @class */function () {
    function SceneDesc(name, levelId) {
        this.name = name;
        this.levelId = levelId;
        this.id = '' + this.levelId;
    }
    SceneDesc.prototype.createScene = function (gl) {
        var _this = this;
        return util_1.fetch('data/sm64ds/sm64ds.crg1').then(function (result) {
            var crg1 = BYML.parse(result, BYML.FileType.CRG1);
            return _this._createSceneFromCRG1(gl, crg1);
        });
    };
    SceneDesc.prototype._createBMDRenderer = function (gl, filename, scale, level, isSkybox) {
        return util_1.fetch("data/sm64ds/" + filename).then(function (result) {
            result = LZ77.maybeDecompress(result);
            var bmd = NITRO_BMD.parse(result);
            var renderer = new BMDRenderer(gl, bmd, level);
            gl_matrix_1.mat4.scale(renderer.localMatrix, renderer.localMatrix, [scale, scale, scale]);
            renderer.isSkybox = isSkybox;
            return renderer;
        });
    };
    SceneDesc.prototype._createBMDObjRenderer = function (gl, filename, translation, rotationY, scale, spinSpeed) {
        if (scale === void 0) {
            scale = 1;
        }
        if (spinSpeed === void 0) {
            spinSpeed = 0;
        }
        return util_1.fetch("data/sm64ds/" + filename).then(function (result) {
            result = LZ77.maybeDecompress(result);
            var bmd = NITRO_BMD.parse(result);
            var renderer = new BMDRenderer(gl, bmd, null);
            gl_matrix_1.vec3.scale(translation, translation, 16 / bmd.scaleFactor);
            gl_matrix_1.mat4.translate(renderer.localMatrix, renderer.localMatrix, translation);
            gl_matrix_1.mat4.rotateY(renderer.localMatrix, renderer.localMatrix, rotationY);
            gl_matrix_1.mat4.scale(renderer.localMatrix, renderer.localMatrix, [scale, scale, scale]);
            if (spinSpeed > 0) {
                var spinPhase = Math.random() * Math.PI * 2;
                renderer.animation = new YSpinAnimation(spinSpeed, spinPhase);
            }
            return renderer;
        });
    };
    SceneDesc.prototype._createBMDRendererForObject = function (gl, object) {
        var translation = gl_matrix_1.vec3.fromValues(object.Position.X, object.Position.Y, object.Position.Z);
        // WTF is with the Tau? And the object scales?
        gl_matrix_1.vec3.scale(translation, translation, Math.PI * 2);
        var rotationY = object.Rotation.Y / 180 * Math.PI;
        switch (object.ObjectId) {
            case 7: // Up/down lift thingy
            case 9: // Pathlift?
            case 10: // Chain Chomp (copy/pasted)
            case 13: // LONELY ROLLING BALL
            case 15: // Goomba
            case 19: // Bob-omb
            case 20: // Friendly Bob-omb
            case 21:
                // Koopa
                return null;
            case 23:
                // Brick Block
                return this._createBMDObjRenderer(gl, "normal_obj/obj_block/broken_block_l.bmd", translation, rotationY, 0.8);
            case 24:
                // Brick Block Larger
                return this._createBMDObjRenderer(gl, "normal_obj/obj_block/broken_block_l.bmd", translation, rotationY, 1.2);
            case 26: // Powerup inside block?
            case 29:
                // Cannon hatch
                return null;
            case 30:
                // Item Block
                return this._createBMDObjRenderer(gl, "normal_obj/obj_hatena_box/hatena_box.bmd", translation, rotationY, 0.8);
            case 36:
                // Pole
                return this._createBMDObjRenderer(gl, "normal_obj/obj_pile/pile.bmd", translation, rotationY, 0.8);
            case 37:
                // Coin
                return this._createBMDObjRenderer(gl, "normal_obj/coin/coin_poly32.bmd", translation, rotationY, 0.8, 0.1);
            case 38:
                // Red Coin
                return this._createBMDObjRenderer(gl, "normal_obj/coin/coin_red_poly32.bmd", translation, rotationY, 0.8, 0.1);
            case 39:
                // Blue Coin
                return this._createBMDObjRenderer(gl, "normal_obj/coin/coin_blue_poly32.bmd", translation, rotationY, 0.8, 0.1);
            case 41:
                {
                    // Tree
                    var treeType = object.Parameters[0] >>> 4 & 0x07;
                    var treeFilenames = ['bomb', 'toge', 'yuki', 'yashi', 'castle', 'castle', 'castle', 'castle'];
                    var filename = "normal_obj/tree/" + treeFilenames[treeType] + "_tree.bmd";
                    return this._createBMDObjRenderer(gl, filename, translation, rotationY);
                }
            case 42:
                {
                    // Castle Painting
                    var painting = object.Parameters[0] >>> 8 & 0x1F;
                    var filenames = ['for_bh', 'for_bk', 'for_ki', 'for_sm', 'for_cv_ex5', 'for_fl', 'for_dl', 'for_wl', 'for_sl', 'for_wc', 'for_hm', 'for_hs', 'for_td_tt', 'for_ct', 'for_ex_mario', 'for_ex_luigi', 'for_ex_wario', 'for_vs_cross', 'for_vs_island'];
                    var filename = "picture/" + filenames[painting] + ".bmd";
                    var scale = (object.Parameters[0] & 0xF) + 1;
                    translation[1] += scale * 0.3;
                    return this._createBMDObjRenderer(gl, filename, translation, rotationY, scale);
                }
            case 43: // Switch
            case 44: // Switch-powered Star
            case 45: // Switch-powered Trapdoor
            case 48: // Chain Chomp Unchained
            case 49: // 1-up
            case 50: // Cannon
            case 51: // Chain-chomp fence (BoB)
            case 52: // Water bombs (BoB)
            case 53: // Birds
            case 54: // Fish
            case 55: // Butterflies
            case 56: // Super Bob Fuckan Omb Bob-Omb In BoB (the summit)
            case 59: // Pirahna Plant
            case 60: // Star Camera Path
            case 61:
                // Star Target
                return null;
            case 62:
                // Silver Star
                return this._createBMDObjRenderer(gl, "normal_obj/star/obj_star_silver.bmd", translation, rotationY, 0.8, 0.08);
            case 63:
                // Star
                return this._createBMDObjRenderer(gl, "normal_obj/star/obj_star.bmd", translation, rotationY, 0.8, 0.08);
            case 64: // Whomp
            case 65: // Big Whomp
            case 66: // Thwomp
            case 67: // Boo
            case 74:
                // Minigame Cabinet Trigger (Invisible)
                return null;
            case 75:
                // Wall sign
                return this._createBMDObjRenderer(gl, "normal_obj/obj_kanban/obj_kanban.bmd", translation, rotationY, 0.8);
            case 76:
                // Signpost
                return this._createBMDObjRenderer(gl, "normal_obj/obj_tatefuda/obj_tatefuda.bmd", translation, rotationY, 0.8);
            case 79: // Heart
            case 80: // Toad
            case 167: // Peach's Castle Tippy TTC Hour Hand
            case 168: // Peach's Castle Tippy TTC Minute Hand
            case 169:
                // Peach's Castle Tippy TTC Pendulum
                return null;
            case 187:
                // Left Arrow Sign
                return this._createBMDObjRenderer(gl, "normal_obj/obj_yajirusi_l/yajirusi_l.bmd", translation, rotationY, 0.8);
            case 188:
                // Right Arrow Sign
                return this._createBMDObjRenderer(gl, "normal_obj/obj_yajirusi_r/yajirusi_r.bmd", translation, rotationY, 0.8);
            case 196: // WF
            case 197: // WF
            case 198: // WF
            case 199: // WF
            case 200: // WF
            case 201: // WF
            case 202: // WF
            case 203:
                // WF Tower
                return null;
            case 204:
                // WF Spinning Island
                return this._createBMDObjRenderer(gl, "special_obj/bk_ukisima/bk_ukisima.bmd", translation, rotationY, 1, 0.1);
            case 205: // WF
            case 206: // WF
            case 207: // WF
            case 208: // WF
            case 209: // WF
            case 228: // Switch Pillar
            case 237: // MIPS
            case 239: // That Stupid Owl™
            case 243: // Invisible pole hitbox
            case 244: // Lakitu
            case 254: // Mario's Iconic Cap
            case 264: // Red Flame
            case 265: // Blue Flame
            case 269: // 1-Up Mushroom Inside Block
            case 270: // Some brick thing?
            case 273: // Peach's Castle First Floor Trapdoor
            case 274: // Peach's Castle First Floor Light Beam
            case 275: // Peach's Castle First Floor Peach/Bowser Fade Painting
            case 281: // Koopa the Quick
            case 282:
                // Koopa the Quick Finish Flag
                return null;
            case 284:
                // Wario Block
                return this._createBMDObjRenderer(gl, "normal_obj/obj_block/broken_block_ll.bmd", translation, rotationY);
            case 293:
                // Water
                return this._createBMDObjRenderer(gl, "special_obj/mc_water/mc_water.bmd", translation, rotationY, 0.8);
            case 295:
                // Metal net
                return this._createBMDObjRenderer(gl, "special_obj/mc_metalnet/mc_metalnet.bmd", translation, rotationY, 0.8);
            case 298:
                // Flag
                return this._createBMDObjRenderer(gl, "special_obj/mc_flag/mc_flag.bmd", translation, rotationY, 0.8);
            case 303: // Castle Basement Water
            case 304:
                // Secret number thingy
                return null;
            case 305:
                // Blue Coin Switch
                return this._createBMDObjRenderer(gl, "normal_obj/b_coin_switch/b_coin_switch.bmd", translation, rotationY, 0.8);
            case 314: // Hidden Pirahna Plant
            case 315: // Enemy spawner trigger
            case 316: // Enemy spawner
            case 323: // Ambient sound effects
            case 324: // Music
            case 511:
                // Appears to be a bug in the level layout
                return null;
            default:
                console.warn("Unknown object type " + object.ObjectId);
                return null;
        }
    };
    SceneDesc.prototype._createSceneFromCRG1 = function (gl, crg1) {
        var e_4, _a;
        var level = crg1.Levels[this.levelId];
        var renderers = [this._createBMDRenderer(gl, level.MapBmdFile, 100, level, false)];
        if (level.VrboxBmdFile) renderers.push(this._createBMDRenderer(gl, level.VrboxBmdFile, 0.8, level, true));else renderers.push(Promise.resolve(null));
        try {
            for (var _b = __values(level.Objects), _c = _b.next(); !_c.done; _c = _b.next()) {
                var object = _c.value;
                var objRenderer = this._createBMDRendererForObject(gl, object);
                if (objRenderer) renderers.push(objRenderer);
            }
        } catch (e_4_1) {
            e_4 = { error: e_4_1 };
        } finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally {
                if (e_4) throw e_4.error;
            }
        }
        return Promise.all(renderers).then(function (_a) {
            var _b = __read(_a),
                mainBMD = _b[0],
                skyboxBMD = _b[1],
                extraBMDs = _b.slice(2);
            return new SM64DSRenderer(mainBMD, skyboxBMD, extraBMDs);
        });
    };
    return SceneDesc;
}();
exports.SceneDesc = SceneDesc;
},{"gl-matrix":"..\\node_modules\\gl-matrix\\src\\gl-matrix.js","../byml":"byml.ts","./lz77":"sm64ds\\lz77.ts","./nitro_bmd":"sm64ds\\nitro_bmd.ts","../render":"render.ts","../Program":"Program.ts","../RenderArena":"RenderArena.ts","../util":"util.ts","../Camera":"Camera.ts"}],"sm64ds\\scenes.ts":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var render_1 = require("./render");
var id = "sm64ds";
var name = "Super Mario 64 DS";
var sceneDescs = [{ 'id': 1, 'name': "Princess Peach's Castle - Gardens" }, { 'id': 2, 'name': "Princess Peach's Castle - 1st Floor" }, { 'id': 5, 'name': "Princess Peach's Castle - 2nd Floor" }, { 'id': 4, 'name': "Princess Peach's Castle - Basement" }, { 'id': 3, 'name': "Princess Peach's Castle - Courtyard" }, { 'id': 50, 'name': "Princess Peach's Castle - Playroom" }, { 'id': 6, 'name': 'Bob-omb Battlefield' }, { 'id': 7, 'name': "Whomp's Fortress" }, { 'id': 8, 'name': 'Jolly Roger Bay' }, { 'id': 9, 'name': 'Jolly Roger Bay - Inside the Ship' }, { 'id': 10, 'name': 'Cool, Cool Mountain' }, { 'id': 11, 'name': 'Cool, Cool Mountain - Inside the Slide' }, { 'id': 12, 'name': "Big Boo's Haunt" }, { 'id': 13, 'name': 'Hazy Maze Cave' }, { 'id': 14, 'name': 'Lethal Lava Land' }, { 'id': 15, 'name': 'Lethal Lava Land - Inside the Volcano' }, { 'id': 16, 'name': 'Shifting Sand Land' }, { 'id': 17, 'name': 'Shifting Sand Land - Inside the Pyramid' }, { 'id': 18, 'name': 'Dire, Dire Docks' }, { 'id': 19, 'name': "Snowman's Land" }, { 'id': 20, 'name': "Snowman's Land - Inside the Igloo" }, { 'id': 21, 'name': 'Wet-Dry World' }, { 'id': 22, 'name': 'Tall Tall Mountain' }, { 'id': 23, 'name': 'Tall Tall Mountain - Inside the Slide' }, { 'id': 25, 'name': 'Tiny-Huge Island - Tiny' }, { 'id': 24, 'name': 'Tiny-Huge Island - Huge' }, { 'id': 26, 'name': "Tiny-Huge Island - Inside Wiggler's Cavern" }, { 'id': 27, 'name': 'Tick Tock Clock' }, { 'id': 28, 'name': 'Rainbow Ride' }, { 'id': 35, 'name': 'Bowser in the Dark World' }, { 'id': 36, 'name': 'Bowser in the Dark World - Battle' }, { 'id': 37, 'name': 'Bowser in the Fire Sea' }, { 'id': 38, 'name': 'Bowser in the Fire Sea - Battle' }, { 'id': 39, 'name': 'Bowser in the Sky' }, { 'id': 40, 'name': 'Bowser in the Sky - Battle' }, { 'id': 29, 'name': 'The Princess\'s Secret Slide' }, { 'id': 30, 'name': 'The Secret Aquarium' }, { 'id': 34, 'name': 'Wing Mario over the Rainbow' }, { 'id': 31, 'name': 'Tower of the Wing Cap' }, { 'id': 32, 'name': 'Vanish Cap Under the Moat' }, { 'id': 33, 'name': 'Cavern of the Metal Cap' }, { 'id': 46, 'name': 'Big Boo Battle' }, { 'id': 47, 'name': 'Big Boo Battle - Battle' }, { 'id': 44, 'name': 'Goomboss Battle' }, { 'id': 45, 'name': 'Goomboss Battle - Battle' }, { 'id': 48, 'name': 'Chief Chilly Challenge' }, { 'id': 49, 'name': 'Chief Chilly Challenge - Battle' }, { 'id': 42, 'name': 'VS Map - The Secret of Battle Fort' }, { 'id': 43, 'name': 'VS Map - Sunshine Isles' }, { 'id': 51, 'name': 'VS Map - Castle Gardens' }, { 'id': 0, 'name': 'Test Map A' }, { 'id': 41, 'name': 'Test Map B' }].map(function (entry) {
    return new render_1.SceneDesc(entry.name, entry.id);
});
exports.sceneGroup = { id: id, name: name, sceneDescs: sceneDescs };
},{"./render":"sm64ds\\render.ts"}],"mdl0\\mdl0.ts":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("../util");
function parse(buffer) {
    var Flag;
    (function (Flag) {
        Flag[Flag["HAS_NORMAL"] = 1] = "HAS_NORMAL";
        Flag[Flag["HAS_UV"] = 2] = "HAS_UV";
        Flag[Flag["HAS_COLOR"] = 4] = "HAS_COLOR";
    })(Flag || (Flag = {}));
    ;
    var view = buffer.createDataView();
    util_1.assert(util_1.readString(buffer, 0, 4, false) === 'MDL\0');
    var flags = view.getUint8(0x04);
    var primType = view.getUint8(0x05);
    var vertCount = view.getUint16(0x06, true);
    var animCount = view.getUint16(0x08, true);
    var offs = 0x0A;
    if (flags & Flag.HAS_UV) {
        // XXX: How to parse UV?
        var start = offs;
        var end = start + vertCount * 8;
        offs = end;
    }
    var clrData;
    if (flags & Flag.HAS_COLOR) {
        clrData = buffer.createTypedArray(Uint8Array, offs, vertCount * 4);
        offs += clrData.byteLength;
    } else {
        clrData = new Uint8Array(vertCount * 4);
    }
    // Read in index buffer.
    var idxCount = view.getUint16(offs, true);
    offs += 0x02;
    var idxData;
    {
        var idxArr = buffer.createTypedArray(Uint16Array, offs, idxCount);
        if (primType === 3) {
            idxData = idxArr;
        } else if (primType === 4) {
            idxCount = idxCount / 4 * 6;
            idxData = new Uint16Array(idxCount);
            for (var i = 0, j = 0; i < idxCount; i += 6) {
                idxData[i + 0] = idxArr[j + 0];
                idxData[i + 1] = idxArr[j + 1];
                idxData[i + 2] = idxArr[j + 2];
                idxData[i + 3] = idxArr[j + 2];
                idxData[i + 4] = idxArr[j + 3];
                idxData[i + 5] = idxArr[j + 0];
                j += 4;
            }
        }
        offs += idxArr.byteLength;
    }
    var vtxData;
    var vertSize = 4 * (3 + (flags & Flag.HAS_NORMAL ? 3 : 0));
    var animSize = vertCount * vertSize;
    {
        vtxData = buffer.createTypedArray(Float32Array, offs, animCount * animSize / 4);
        offs += vtxData.byteLength;
    }
    util_1.assert(offs === buffer.byteLength);
    return { clrData: clrData, idxData: idxData, vtxData: vtxData, animCount: animCount, animSize: animSize, vertCount: vertCount, vertSize: vertSize };
}
exports.parse = parse;
},{"../util":"util.ts"}],"mdl0\\render.ts":[function(require,module,exports) {
"use strict";

var __extends = this && this.__extends || function () {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
        d.__proto__ = b;
    } || function (d, b) {
        for (var p in b) {
            if (b.hasOwnProperty(p)) d[p] = b[p];
        }
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __importStar = this && this.__importStar || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) {
        if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    }result["default"] = mod;
    return result;
};
var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var MDL0 = __importStar(require("./mdl0"));
var render_1 = require("../render");
var Program_1 = __importDefault(require("../Program"));
var util_1 = require("../util");
var Camera_1 = require("../Camera");
var FancyGrid_Program = /** @class */function (_super) {
    __extends(FancyGrid_Program, _super);
    function FancyGrid_Program() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.vert = "\nprecision mediump float;\n\nuniform mat4 u_modelView;\nuniform mat4 u_projection;\n\nattribute vec3 a_position;\nvarying float v_eyeFade;\nvarying vec2 v_surfCoord;\n\nvoid main() {\n    v_surfCoord = a_position.xz;\n\n    float scale = 200.0;\n    gl_Position = u_projection * u_modelView * vec4(a_position * scale, 1.0);\n\n    vec3 V = (vec4(0.0, 0.0, 1.0, 0.0) * u_modelView).xyz;\n    vec3 N = vec3(0.0, 1.0, 0.0);\n    v_eyeFade = dot(V, N);\n}\n";
        _this.frag = "\n#extension GL_EXT_frag_depth : enable\n#extension GL_OES_standard_derivatives : enable\n\nprecision highp float;\nvarying float v_eyeFade;\nvarying vec2 v_surfCoord;\n\nvoid main() {\n    float distFromCenter = distance(v_surfCoord, vec2(0.0));\n    vec2 uv = (v_surfCoord + 1.0) * 0.5;\n\n    vec4 color;\n    color.a = 1.0;\n\n    // Base Grid color.\n    color.rgb = mix(vec3(0.8, 0.0, 0.8), vec3(0.4, 0.2, 0.8), clamp(distFromCenter * 1.5, 0.0, 1.0));\n    color.a *= clamp(mix(2.0, 0.0, distFromCenter), 0.0, 1.0);\n\n    // Grid lines mask.\n    uv *= 80.0;\n    float sharpDx = clamp(1.0 / min(abs(dFdx(uv.x)), abs(dFdy(uv.y))), 2.0, 20.0);\n    float sharpMult = sharpDx * 10.0;\n    float sharpOffs = sharpDx * 4.40;\n    vec2 gridM = (abs(fract(uv) - 0.5)) * sharpMult - sharpOffs;\n    float gridMask = max(gridM.x, gridM.y);\n    color.a *= clamp(gridMask, 0.0, 1.0);\n\n    color.a += (1.0 - clamp(distFromCenter * 1.2, 0.0, 1.0)) * 0.5 * v_eyeFade;\n\n    // Eye fade.\n    color.a *= clamp(v_eyeFade, 0.3, 1.0);\n    gl_FragColor = color;\n\n    gl_FragDepth = gl_FragCoord.z + 1e-6;\n}\n";
        return _this;
    }
    FancyGrid_Program.prototype.bind = function (gl, prog) {
        _super.prototype.bind.call(this, gl, prog);
        this.positionLocation = gl.getAttribLocation(prog, "a_position");
    };
    return FancyGrid_Program;
}(Program_1.default);
var FancyGrid = /** @class */function () {
    function FancyGrid(gl) {
        this.program = new FancyGrid_Program();
        this._createBuffers(gl);
        this.renderFlags = new render_1.RenderFlags();
        this.renderFlags.blendMode = render_1.BlendMode.ADD;
    }
    FancyGrid.prototype.render = function (state) {
        var gl = state.gl;
        state.useProgram(this.program);
        state.bindModelView();
        state.useFlags(this.renderFlags);
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vtxBuffer);
        gl.vertexAttribPointer(this.program.positionLocation, 3, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(this.program.positionLocation);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        gl.disableVertexAttribArray(this.program.positionLocation);
    };
    FancyGrid.prototype._createBuffers = function (gl) {
        this.vtxBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vtxBuffer);
        var vtx = new Float32Array(4 * 3);
        vtx[0] = -1;
        vtx[1] = 0;
        vtx[2] = -1;
        vtx[3] = 1;
        vtx[4] = 0;
        vtx[5] = -1;
        vtx[6] = -1;
        vtx[7] = 0;
        vtx[8] = 1;
        vtx[9] = 1;
        vtx[10] = 0;
        vtx[11] = 1;
        gl.bufferData(gl.ARRAY_BUFFER, vtx, gl.STATIC_DRAW);
    };
    FancyGrid.prototype.destroy = function (gl) {
        this.program.destroy(gl);
        gl.deleteBuffer(this.vtxBuffer);
    };
    return FancyGrid;
}();
var MDL0_Program = /** @class */function (_super) {
    __extends(MDL0_Program, _super);
    function MDL0_Program() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.vert = "\nprecision mediump float;\n\nuniform mat4 u_modelView;\nuniform mat4 u_projection;\n\nattribute vec3 a_position;\nattribute vec4 a_color;\nvarying vec4 v_color;\n\nvoid main() {\n    v_color = a_color.bgra;\n    gl_Position = u_projection * u_modelView * vec4(a_position, 1.0);\n}\n";
        _this.frag = "\nprecision mediump float;\n\nvarying vec4 v_color;\n\nvoid main() {\n    gl_FragColor = v_color;\n}\n";
        return _this;
    }
    MDL0_Program.prototype.bind = function (gl, prog) {
        _super.prototype.bind.call(this, gl, prog);
        this.positionLocation = gl.getAttribLocation(prog, "a_position");
        this.colorLocation = gl.getAttribLocation(prog, "a_color");
    };
    return MDL0_Program;
}(Program_1.default);
var Scene = /** @class */function () {
    function Scene(gl, mdl0) {
        this.textures = [];
        this.fancyGrid = new FancyGrid(gl);
        this.program = new MDL0_Program();
        this.mdl0 = mdl0;
        this._createBuffers(gl);
        this.renderFlags = new render_1.RenderFlags();
        this.renderFlags.depthTest = true;
    }
    Scene.prototype.render = function (state) {
        var gl = state.gl;
        state.useProgram(this.program);
        state.bindModelView();
        state.useFlags(this.renderFlags);
        gl.bindBuffer(gl.ARRAY_BUFFER, this.clrBuffer);
        gl.vertexAttribPointer(this.program.colorLocation, 4, gl.UNSIGNED_BYTE, true, 0, 0);
        gl.enableVertexAttribArray(this.program.colorLocation);
        var frameNumber = state.time / 16 % this.mdl0.animCount | 0;
        var vtxOffset = frameNumber * this.mdl0.animSize;
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vtxBuffer);
        gl.vertexAttribPointer(this.program.positionLocation, 3, gl.FLOAT, false, this.mdl0.vertSize, vtxOffset);
        gl.enableVertexAttribArray(this.program.positionLocation);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.idxBuffer);
        gl.drawElements(gl.TRIANGLES, this.mdl0.idxData.length, gl.UNSIGNED_SHORT, 0);
        gl.disableVertexAttribArray(this.program.colorLocation);
        gl.disableVertexAttribArray(this.program.positionLocation);
        this.fancyGrid.render(state);
    };
    Scene.prototype._createBuffers = function (gl) {
        this.clrBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, this.clrBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, this.mdl0.clrData, gl.STATIC_DRAW);
        this.idxBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.idxBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.mdl0.idxData, gl.STATIC_DRAW);
        this.vtxBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vtxBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, this.mdl0.vtxData, gl.STATIC_DRAW);
    };
    Scene.prototype.destroy = function (gl) {
        gl.deleteBuffer(this.clrBuffer);
        gl.deleteBuffer(this.vtxBuffer);
        gl.deleteBuffer(this.idxBuffer);
        this.program.destroy(gl);
    };
    return Scene;
}();
var SceneDesc = /** @class */function () {
    function SceneDesc(name, path) {
        this.defaultCameraController = Camera_1.OrbitCameraController;
        this.name = name;
        this.path = path;
        this.id = this.path;
    }
    SceneDesc.prototype.createScene = function (gl) {
        return util_1.fetch(this.path).then(function (result) {
            var mdl0 = MDL0.parse(result);
            return new Scene(gl, mdl0);
        });
    };
    return SceneDesc;
}();
exports.SceneDesc = SceneDesc;
},{"./mdl0":"mdl0\\mdl0.ts","../render":"render.ts","../Program":"Program.ts","../util":"util.ts","../Camera":"Camera.ts"}],"mdl0\\scenes.ts":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var render_1 = require("./render");
var name = "Sonic Mania";
var id = "mdl0";
var sceneDescs = ['Meshes/Continue/Count0.bin', 'Meshes/Continue/Count1.bin', 'Meshes/Continue/Count2.bin', 'Meshes/Continue/Count3.bin', 'Meshes/Continue/Count4.bin', 'Meshes/Continue/Count5.bin', 'Meshes/Continue/Count6.bin', 'Meshes/Continue/Count7.bin', 'Meshes/Continue/Count8.bin', 'Meshes/Continue/Count9.bin', 'Meshes/Decoration/Bird.bin', 'Meshes/Decoration/Fish.bin', 'Meshes/Decoration/Flower1.bin', 'Meshes/Decoration/Flower2.bin', 'Meshes/Decoration/Flower3.bin', 'Meshes/Decoration/Pillar1.bin', 'Meshes/Decoration/Pillar2.bin', 'Meshes/Decoration/Tree.bin', 'Meshes/Global/Sonic.bin', 'Meshes/Global/SpecialRing.bin', 'Meshes/Special/EmeraldBlue.bin', 'Meshes/Special/EmeraldCyan.bin', 'Meshes/Special/EmeraldGreen.bin', 'Meshes/Special/EmeraldGrey.bin', 'Meshes/Special/EmeraldPurple.bin', 'Meshes/Special/EmeraldRed.bin', 'Meshes/Special/EmeraldYellow.bin', 'Meshes/Special/ItemBox.bin', 'Meshes/Special/KnuxBall.bin', 'Meshes/Special/KnuxDash.bin', 'Meshes/Special/KnuxJog.bin', 'Meshes/Special/KnuxJump.bin', 'Meshes/Special/KnuxTumble.bin', 'Meshes/Special/Shadow.bin', 'Meshes/Special/SonicBall.bin', 'Meshes/Special/SonicDash.bin', 'Meshes/Special/SonicJog.bin', 'Meshes/Special/SonicJump.bin', 'Meshes/Special/SonicTumble.bin', 'Meshes/Special/Springboard.bin', 'Meshes/Special/TailsBall.bin', 'Meshes/Special/TailsDash.bin', 'Meshes/Special/TailsJog.bin', 'Meshes/Special/TailsJump.bin', 'Meshes/Special/TailsTumble.bin', 'Meshes/Special/UFOChase.bin', 'Meshes/SSZ/EggTower.bin', 'Meshes/TMZ/MonarchBG.bin', 'Meshes/TMZ/OrbNet.bin'].map(function (filename) {
    var path = "data/mdl0/" + filename;
    var name = filename;
    return new render_1.SceneDesc(name, path);
});
exports.sceneGroup = { id: id, name: name, sceneDescs: sceneDescs };
},{"./render":"mdl0\\render.ts"}],"zelview\\f3dex2.ts":[function(require,module,exports) {
"use strict";

var __importStar = this && this.__importStar || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) {
        if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    }result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var gl_matrix_1 = require("gl-matrix");
var Render = __importStar(require("./render"));
var render_1 = require("../render");
function extractBits(value, offset, bits) {
    return value >> offset & (1 << bits) - 1;
}
var OtherModeH = {
    CYCLETYPE_SFT: 20,
    CYCLETYPE_LEN: 2
};
var CYCLETYPE = {
    _1CYCLE: 0,
    _2CYCLE: 1,
    COPY: 2,
    FILL: 3
};
var UCodeCommands;
(function (UCodeCommands) {
    UCodeCommands[UCodeCommands["VTX"] = 1] = "VTX";
    UCodeCommands[UCodeCommands["TRI1"] = 5] = "TRI1";
    UCodeCommands[UCodeCommands["TRI2"] = 6] = "TRI2";
    UCodeCommands[UCodeCommands["GEOMETRYMODE"] = 217] = "GEOMETRYMODE";
    UCodeCommands[UCodeCommands["SETOTHERMODE_L"] = 226] = "SETOTHERMODE_L";
    UCodeCommands[UCodeCommands["SETOTHERMODE_H"] = 227] = "SETOTHERMODE_H";
    UCodeCommands[UCodeCommands["DL"] = 222] = "DL";
    UCodeCommands[UCodeCommands["ENDDL"] = 223] = "ENDDL";
    UCodeCommands[UCodeCommands["MTX"] = 218] = "MTX";
    UCodeCommands[UCodeCommands["POPMTX"] = 216] = "POPMTX";
    UCodeCommands[UCodeCommands["TEXTURE"] = 215] = "TEXTURE";
    UCodeCommands[UCodeCommands["LOADTLUT"] = 240] = "LOADTLUT";
    UCodeCommands[UCodeCommands["LOADBLOCK"] = 243] = "LOADBLOCK";
    UCodeCommands[UCodeCommands["SETTILESIZE"] = 242] = "SETTILESIZE";
    UCodeCommands[UCodeCommands["SETTILE"] = 245] = "SETTILE";
    UCodeCommands[UCodeCommands["SETPRIMCOLOR"] = 249] = "SETPRIMCOLOR";
    UCodeCommands[UCodeCommands["SETENVCOLOR"] = 251] = "SETENVCOLOR";
    UCodeCommands[UCodeCommands["SETCOMBINE"] = 252] = "SETCOMBINE";
    UCodeCommands[UCodeCommands["SETTIMG"] = 253] = "SETTIMG";
    UCodeCommands[UCodeCommands["RDPLOADSYNC"] = 230] = "RDPLOADSYNC";
    UCodeCommands[UCodeCommands["RDPPIPESYNC"] = 231] = "RDPPIPESYNC";
})(UCodeCommands || (UCodeCommands = {}));
var State = /** @class */function () {
    function State() {
        this.programMap = {};
        this.geometryMode = 0;
        this.otherModeL = 0;
        this.otherModeH = CYCLETYPE._2CYCLE << OtherModeH.CYCLETYPE_SFT;
        this.primColor = gl_matrix_1.vec4.clone([1, 1, 1, 1]);
        // FIXME: Initial envColor depends on which map is loaded, and can be animated.
        this.envColor = gl_matrix_1.vec4.clone([0, 0, 0, 0.5]);
        this.textureTiles = [];
    }
    State.prototype.lookupAddress = function (addr) {
        return this.rom.lookupAddress(this.banks, addr);
    };
    State.prototype.getDLProgram = function (params) {
        var hash = Render.hashF3DEX2Params(params);
        if (!(hash in this.programMap)) {
            this.programMap[hash] = new Render.F3DEX2Program(params);
        }
        return this.programMap[hash];
    };
    State.prototype.pushProgramCmds = function () {
        // Clone all relevant fields to prevent the closure from seeing different data than
        // intended.
        var envColor = gl_matrix_1.vec4.clone(this.envColor);
        var primColor = gl_matrix_1.vec4.clone(this.primColor);
        var geometryMode = this.geometryMode;
        var otherModeL = this.otherModeL;
        var otherModeH = this.otherModeH;
        var progParams = {
            use2Cycle: extractBits(otherModeH, OtherModeH.CYCLETYPE_SFT, OtherModeH.CYCLETYPE_LEN) == CYCLETYPE._2CYCLE,
            combiners: this.combiners
        };
        // TODO: Don't call getDLProgram if state didn't change, because it can be expensive.
        var prog = this.getDLProgram(progParams);
        var alphaTestMode;
        if (otherModeL & OtherModeL.FORCE_BL) {
            alphaTestMode = 0;
        } else {
            alphaTestMode = otherModeL & OtherModeL.CVG_X_ALPHA ? 0x1 : 0 | otherModeL & OtherModeL.ALPHA_CVG_SEL ? 0x2 : 0;
        }
        flushTexture(this);
        var textures = [];
        // TODO: handle tiles other than 0 and 1 if needed?
        if (this.textureTiles[0] && this.textureTiles[0].addr != 0) textures[0] = Object.assign({}, this.textureTiles[0]);
        if (this.textureTiles[1] && this.textureTiles[1].addr != 0) textures[1] = Object.assign({}, this.textureTiles[1]);
        this.cmds.push(function (renderState) {
            var gl = renderState.gl;
            renderState.useProgram(prog);
            renderState.bindModelView();
            gl.uniform1i(prog.texture0Location, 0);
            gl.uniform1i(prog.texture1Location, 1);
            gl.uniform4fv(prog.envLocation, envColor);
            gl.uniform4fv(prog.primLocation, primColor);
            for (var i = 0; i < 2; i++) {
                gl.activeTexture(gl.TEXTURE0 + i);
                if (textures[i]) {
                    gl.bindTexture(gl.TEXTURE_2D, textures[i].glTextureId);
                    gl.uniform2fv(prog.txsLocation[i], [1 / textures[i].width, 1 / textures[i].height]);
                } else {
                    gl.bindTexture(gl.TEXTURE_2D, null);
                    gl.uniform2fv(prog.txsLocation[i], [1, 1]);
                }
            }
            gl.activeTexture(gl.TEXTURE0);
            var lighting = !!(geometryMode & GeometryMode.LIGHTING);
            // When lighting is disabled, the vertex colors are passed to the rasterizer as the SHADE attribute.
            // When lighting is enabled, the vertex colors represent normals and SHADE is computed by the RSP.
            var useVertexColors = lighting ? 0 : 1;
            gl.uniform1i(prog.useVertexColorsLocation, useVertexColors);
            gl.uniform1i(prog.alphaTestLocation, alphaTestMode);
        });
    };
    return State;
}();
// 3 pos + 2 uv + 4 color/nrm
var VERTEX_SIZE = 9;
var VERTEX_BYTES = VERTEX_SIZE * Float32Array.BYTES_PER_ELEMENT;
function readVertex(state, which, addr) {
    var rom = state.rom;
    var offs = state.lookupAddress(addr);
    var posX = rom.view.getInt16(offs + 0, false);
    var posY = rom.view.getInt16(offs + 2, false);
    var posZ = rom.view.getInt16(offs + 4, false);
    var pos = gl_matrix_1.vec3.clone([posX, posY, posZ]);
    gl_matrix_1.vec3.transformMat4(pos, pos, state.mtx);
    var txU = rom.view.getInt16(offs + 8, false) * (1 / 32);
    var txV = rom.view.getInt16(offs + 10, false) * (1 / 32);
    var vtxArray = new Float32Array(state.vertexBuffer.buffer, which * VERTEX_BYTES, VERTEX_SIZE);
    vtxArray[0] = pos[0];
    vtxArray[1] = pos[1];
    vtxArray[2] = pos[2];
    vtxArray[3] = txU;
    vtxArray[4] = txV;
    vtxArray[5] = rom.view.getUint8(offs + 12) / 255;
    vtxArray[6] = rom.view.getUint8(offs + 13) / 255;
    vtxArray[7] = rom.view.getUint8(offs + 14) / 255;
    vtxArray[8] = rom.view.getUint8(offs + 15) / 255;
}
function cmd_VTX(state, w0, w1) {
    var N = w0 >> 12 & 0xFF;
    var V0 = (w0 >> 1 & 0x7F) - N;
    var addr = w1;
    for (var i = 0; i < N; i++) {
        var which = V0 + i;
        readVertex(state, which, addr);
        addr += 16;
    }
}
function flushDraw(state) {
    var gl = state.gl;
    var vtxBufSize = state.vertexData.length / VERTEX_SIZE;
    var vtxOffs = state.vertexOffs;
    var vtxCount = vtxBufSize - vtxOffs;
    state.vertexOffs = vtxBufSize;
    if (vtxCount === 0) return;
    state.pushProgramCmds();
    state.cmds.push(function (renderState) {
        var gl = renderState.gl;
        gl.drawArrays(gl.TRIANGLES, vtxOffs, vtxCount);
    });
}
function translateTRI(state, idxData) {
    idxData.forEach(function (idx, i) {
        var offs = idx * VERTEX_SIZE;
        for (var i_1 = 0; i_1 < VERTEX_SIZE; i_1++) {
            state.vertexData.push(state.vertexBuffer[offs + i_1]);
        }
    });
}
function tri(idxData, offs, cmd) {
    idxData[offs + 0] = cmd >> 17 & 0x7F;
    idxData[offs + 1] = cmd >> 9 & 0x7F;
    idxData[offs + 2] = cmd >> 1 & 0x7F;
}
function flushTexture(state) {
    if (state.textureTiles[0] && state.textureTiles[0].addr != 0) loadTile(state, state.textureTiles[0]);
    if (state.textureTiles[1] && state.textureTiles[0].addr != 0) loadTile(state, state.textureTiles[1]);
}
function cmd_TRI1(state, w0, w1) {
    flushTexture(state);
    var idxData = new Uint8Array(3);
    tri(idxData, 0, w0);
    translateTRI(state, idxData);
}
function cmd_TRI2(state, w0, w1) {
    flushTexture(state);
    var idxData = new Uint8Array(6);
    tri(idxData, 0, w0);
    tri(idxData, 3, w1);
    translateTRI(state, idxData);
}
var GeometryMode = {
    CULL_FRONT: 0x0200,
    CULL_BACK: 0x0400,
    LIGHTING: 0x020000
};
function cmd_GEOMETRYMODE(state, w0, w1) {
    flushDraw(state);
    state.geometryMode = state.geometryMode & (~w0 & 0x00FFFFFF) | w1;
    var newMode = state.geometryMode;
    var renderFlags = new render_1.RenderFlags();
    var cullFront = newMode & GeometryMode.CULL_FRONT;
    var cullBack = newMode & GeometryMode.CULL_BACK;
    if (cullFront && cullBack) renderFlags.cullMode = render_1.CullMode.FRONT_AND_BACK;else if (cullFront) renderFlags.cullMode = render_1.CullMode.FRONT;else if (cullBack) renderFlags.cullMode = render_1.CullMode.BACK;else renderFlags.cullMode = render_1.CullMode.NONE;
    state.cmds.push(function (renderState) {
        renderState.useFlags(renderFlags);
    });
}
var OtherModeL = {
    Z_CMP: 0x0010,
    Z_UPD: 0x0020,
    ZMODE_DEC: 0x0C00,
    CVG_X_ALPHA: 0x1000,
    ALPHA_CVG_SEL: 0x2000,
    FORCE_BL: 0x4000
};
function cmd_SETOTHERMODE_L(state, w0, w1) {
    flushDraw(state);
    var len = extractBits(w0, 0, 8) + 1;
    var sft = Math.max(0, 32 - extractBits(w0, 8, 8) - len);
    var mask = (1 << len) - 1 << sft;
    state.otherModeL = state.otherModeL & ~mask | w1 & mask;
    var renderFlags = new render_1.RenderFlags();
    var newMode = state.otherModeL;
    renderFlags.depthTest = !!(newMode & OtherModeL.Z_CMP);
    renderFlags.depthWrite = !!(newMode & OtherModeL.Z_UPD);
    var alphaTestMode;
    if (newMode & OtherModeL.FORCE_BL) {
        alphaTestMode = 0;
        renderFlags.blendMode = render_1.BlendMode.ADD;
    } else {
        alphaTestMode = newMode & OtherModeL.CVG_X_ALPHA ? 0x1 : 0 | newMode & OtherModeL.ALPHA_CVG_SEL ? 0x2 : 0;
        renderFlags.blendMode = render_1.BlendMode.NONE;
    }
    state.cmds.push(function (renderState) {
        var gl = renderState.gl;
        renderState.useFlags(renderFlags);
        if (newMode & OtherModeL.ZMODE_DEC) {
            gl.enable(gl.POLYGON_OFFSET_FILL);
            gl.polygonOffset(-0.5, -0.5);
        } else {
            gl.disable(gl.POLYGON_OFFSET_FILL);
        }
    });
}
function cmd_SETOTHERMODE_H(state, w0, w1) {
    flushDraw(state);
    var len = extractBits(w0, 0, 8) + 1;
    var sft = Math.max(0, 32 - extractBits(w0, 8, 8) - len);
    var mask = (1 << len) - 1 << sft;
    state.otherModeH = state.otherModeH & ~mask | w1 & mask;
}
function cmd_DL(state, w0, w1) {
    runDL(state, w1);
}
function cmd_MTX(state, w0, w1) {
    if (w1 & 0x80000000) state.mtx = state.mtxStack.pop();
    w1 &= ~0x80000000;
    state.geometryMode = 0;
    state.otherModeL = 0;
    state.mtxStack.push(state.mtx);
    state.mtx = gl_matrix_1.mat4.clone(state.mtx);
    var rom = state.rom;
    var offs = state.lookupAddress(w1);
    var mtx = gl_matrix_1.mat4.create();
    for (var x = 0; x < 4; x++) {
        for (var y = 0; y < 4; y++) {
            var mt1 = rom.view.getUint16(offs, false);
            var mt2 = rom.view.getUint16(offs + 32, false);
            mtx[x * 4 + y] = (mt1 << 16 | mt2) * (1 / 0x10000);
            offs += 2;
        }
    }
    gl_matrix_1.mat4.multiply(state.mtx, state.mtx, mtx);
}
function cmd_POPMTX(state, w0, w1) {
    state.mtx = state.mtxStack.pop();
}
function cmd_TEXTURE(state, w0, w1) {
    // XXX(jstpierre): Bring this back at some point.
    /*
    const boundTexture = {};
    state.boundTexture = boundTexture;
      const s = w1 >> 16;
    const t = w1 & 0x0000FFFF;
      state.boundTexture.scaleS = (s + 1) / 0x10000;
    state.boundTexture.scaleT = (t + 1) / 0x10000;
    */
}
function cmd_SETCOMBINE(state, w0, w1) {
    flushDraw(state);
    state.combiners = Object.freeze({
        colorCombiners: Object.freeze([Object.freeze({
            subA: extractBits(w0, 20, 4),
            subB: extractBits(w1, 28, 4),
            mul: extractBits(w0, 15, 5),
            add: extractBits(w1, 15, 3)
        }), Object.freeze({
            subA: extractBits(w0, 5, 4),
            subB: extractBits(w1, 24, 4),
            mul: extractBits(w0, 0, 5),
            add: extractBits(w1, 6, 3)
        })]),
        alphaCombiners: Object.freeze([Object.freeze({
            subA: extractBits(w0, 12, 3),
            subB: extractBits(w1, 12, 3),
            mul: extractBits(w0, 9, 3),
            add: extractBits(w1, 9, 3)
        }), Object.freeze({
            subA: extractBits(w1, 21, 3),
            subB: extractBits(w1, 3, 3),
            mul: extractBits(w1, 18, 3),
            add: extractBits(w1, 0, 3)
        })])
    });
}
function cmd_SETENVCOLOR(state, w0, w1) {
    flushDraw(state);
    state.envColor = gl_matrix_1.vec4.clone([extractBits(w1, 24, 8) / 255, extractBits(w1, 16, 8) / 255, extractBits(w1, 8, 8) / 255, extractBits(w1, 0, 8) / 255]);
}
function cmd_SETPRIMCOLOR(state, w0, w1) {
    flushDraw(state);
    state.primColor = gl_matrix_1.vec4.clone([extractBits(w1, 24, 8) / 255, extractBits(w1, 16, 8) / 255, extractBits(w1, 8, 8) / 255, extractBits(w1, 0, 8) / 255]);
}
function r5g5b5a1(dst, dstOffs, p) {
    var r, g, b, a;
    r = (p & 0xF800) >> 11;
    r = r << 8 - 5 | r >> 10 - 8;
    g = (p & 0x07C0) >> 6;
    g = g << 8 - 5 | g >> 10 - 8;
    b = (p & 0x003E) >> 1;
    b = b << 8 - 5 | b >> 10 - 8;
    a = p & 0x0001 ? 0xFF : 0x00;
    dst[dstOffs + 0] = r;
    dst[dstOffs + 1] = g;
    dst[dstOffs + 2] = b;
    dst[dstOffs + 3] = a;
}
function cmd_SETTIMG(state, w0, w1) {
    var format = w0 >> 21 & 0x7;
    var size = w0 >> 19 & 0x3;
    var width = (w0 & 0x1000) + 1;
    var addr = w1;
    state.textureImageAddr = addr;
}
function cmd_SETTILE(state, w0, w1) {
    state.currentTile = {
        format: w0 >> 16 & 0xFF,
        cms: w1 >> 8 & 0x3,
        cmt: w1 >> 18 & 0x3,
        // tmem: w0 & 0x1FF,
        lineSize: w0 >> 9 & 0x1FF,
        // palette: (w1 >> 20) & 0xF,
        // shiftS: w1 & 0xF,
        // shiftT: (w1 >> 10) & 0xF,
        maskS: w1 >> 4 & 0xF,
        maskT: w1 >> 14 & 0xF,
        width: 0, height: 0, dstFormat: null,
        pixels: null, addr: 0, glTextureId: null,
        uls: 0, ult: 0, lrs: 0, lrt: 0
    };
}
function cmd_SETTILESIZE(state, w0, w1) {
    var tileIdx = w1 >> 24 & 0x7;
    // XXX(jstpierre): Multiple tiles?
    var tile = state.currentTile;
    tile.uls = w0 >> 14 & 0x3FF;
    tile.ult = w0 >> 2 & 0x3FF;
    tile.lrs = w1 >> 14 & 0x3FF;
    tile.lrt = w1 >> 2 & 0x3FF;
    calcTextureSize(tile);
}
function cmd_LOADTLUT(state, w0, w1) {
    var rom = state.rom;
    // XXX: properly implement uls/ult/lrs/lrt
    var size = ((w1 & 0x00FFF000) >> 14) + 1;
    var dst = new Uint8Array(size * 4);
    var srcOffs = state.lookupAddress(state.textureImageAddr);
    var dstOffs = 0;
    for (var i = 0; i < size; i++) {
        var pixel = rom.view.getUint16(srcOffs, false);
        r5g5b5a1(dst, dstOffs, pixel);
        srcOffs += 2;
        dstOffs += 4;
    }
    state.palettePixels = dst;
}
function tileCacheKey(state, tile) {
    // XXX: Do we need more than this?
    var srcOffs = state.lookupAddress(tile.addr);
    return srcOffs;
}
// XXX: This is global to cut down on resources between DLs.
var tileCache = new Map();
function loadTile(state, texture) {
    if (texture.glTextureId) return;
    var key = tileCacheKey(state, texture);
    var otherTile = tileCache.get(key);
    if (!otherTile) {
        translateTexture(state, texture);
        tileCache.set(key, texture);
    } else if (texture !== otherTile) {
        texture.glTextureId = otherTile.glTextureId;
    }
}
function convert_CI4(state, texture) {
    var palette = state.palettePixels;
    if (!palette) return;
    var nBytes = texture.width * texture.height * 4;
    var dst = new Uint8Array(nBytes);
    var srcOffs = state.lookupAddress(texture.addr);
    var i = 0;
    for (var y = 0; y < texture.height; y++) {
        for (var x = 0; x < texture.width; x += 2) {
            var b = state.rom.view.getUint8(srcOffs++);
            var idx = void 0;
            idx = ((b & 0xF0) >> 4) * 4;
            dst[i++] = palette[idx++];
            dst[i++] = palette[idx++];
            dst[i++] = palette[idx++];
            dst[i++] = palette[idx++];
            idx = (b & 0x0F) * 4;
            dst[i++] = palette[idx++];
            dst[i++] = palette[idx++];
            dst[i++] = palette[idx++];
            dst[i++] = palette[idx++];
        }
    }
    texture.pixels = dst;
}
function convert_I4(state, texture) {
    var nBytes = texture.width * texture.height * 2;
    var dst = new Uint8Array(nBytes);
    var srcOffs = state.lookupAddress(texture.addr);
    var i = 0;
    for (var y = 0; y < texture.height; y++) {
        for (var x = 0; x < texture.width; x += 2) {
            var b = state.rom.view.getUint8(srcOffs++);
            var p = void 0;
            p = (b & 0xF0) >> 4;
            p = p << 4 | p;
            dst[i++] = p;
            dst[i++] = p;
            p = b & 0x0F;
            p = p << 4 | p;
            dst[i++] = p;
            dst[i++] = p;
        }
    }
    texture.pixels = dst;
}
function convert_IA4(state, texture) {
    var nBytes = texture.width * texture.height * 2;
    var dst = new Uint8Array(nBytes);
    var srcOffs = state.lookupAddress(texture.addr);
    var i = 0;
    for (var y = 0; y < texture.height; y++) {
        for (var x = 0; x < texture.width; x += 2) {
            var b = state.rom.view.getUint8(srcOffs++);
            var p = void 0;
            var pm = void 0;
            p = (b & 0xF0) >> 4;
            pm = p & 0x0E;
            dst[i++] = pm << 4 | pm;
            dst[i++] = p & 0x01 ? 0xFF : 0x00;
            p = b & 0x0F;
            pm = p & 0x0E;
            dst[i++] = pm << 4 | pm;
            dst[i++] = p & 0x01 ? 0xFF : 0x00;
        }
    }
    texture.pixels = dst;
}
function convert_CI8(state, texture) {
    var palette = state.palettePixels;
    if (!palette) return;
    var nBytes = texture.width * texture.height * 4;
    var dst = new Uint8Array(nBytes);
    var srcOffs = state.lookupAddress(texture.addr);
    var i = 0;
    for (var y = 0; y < texture.height; y++) {
        for (var x = 0; x < texture.width; x++) {
            var idx = state.rom.view.getUint8(srcOffs) * 4;
            dst[i++] = palette[idx++];
            dst[i++] = palette[idx++];
            dst[i++] = palette[idx++];
            dst[i++] = palette[idx++];
            srcOffs++;
        }
    }
    texture.pixels = dst;
}
function convert_I8(state, texture) {
    var nBytes = texture.width * texture.height * 2;
    var dst = new Uint8Array(nBytes);
    var srcOffs = state.lookupAddress(texture.addr);
    var i = 0;
    for (var y = 0; y < texture.height; y++) {
        for (var x = 0; x < texture.width; x++) {
            var p = state.rom.view.getUint8(srcOffs++);
            dst[i++] = p;
            dst[i++] = p;
        }
    }
    texture.pixels = dst;
}
function convert_IA8(state, texture) {
    var nBytes = texture.width * texture.height * 2;
    var dst = new Uint8Array(nBytes);
    var srcOffs = state.lookupAddress(texture.addr);
    var i = 0;
    for (var y = 0; y < texture.height; y++) {
        for (var x = 0; x < texture.width; x++) {
            var b = state.rom.view.getUint8(srcOffs++);
            var p = void 0;
            p = (b & 0xF0) >> 4;
            p = p << 4 | p;
            dst[i++] = p;
            p = b & 0x0F;
            p = p >> 4 | p;
            dst[i++] = p;
        }
    }
    texture.pixels = dst;
}
function convert_RGBA16(state, texture) {
    var rom = state.rom;
    var nBytes = texture.width * texture.height * 4;
    var dst = new Uint8Array(nBytes);
    var srcOffs = state.lookupAddress(texture.addr);
    var i = 0;
    for (var y = 0; y < texture.height; y++) {
        for (var x = 0; x < texture.width; x++) {
            var pixel = rom.view.getUint16(srcOffs, false);
            r5g5b5a1(dst, i, pixel);
            i += 4;
            srcOffs += 2;
        }
    }
    texture.pixels = dst;
}
function convert_IA16(state, texture) {
    var nBytes = texture.width * texture.height * 2;
    var dst = new Uint8Array(nBytes);
    var srcOffs = state.lookupAddress(texture.addr);
    var i = 0;
    for (var y = 0; y < texture.height; y++) {
        for (var x = 0; x < texture.width; x++) {
            dst[i++] = state.rom.view.getUint8(srcOffs++);
            dst[i++] = state.rom.view.getUint8(srcOffs++);
        }
    }
    texture.pixels = dst;
}
function textureToCanvas(texture) {
    var canvas = document.createElement("canvas");
    canvas.width = texture.width;
    canvas.height = texture.height;
    var ctx = canvas.getContext("2d");
    var imgData = ctx.createImageData(canvas.width, canvas.height);
    if (texture.dstFormat === "i8") {
        for (var si = 0, di = 0; di < imgData.data.length; si++, di += 4) {
            imgData.data[di + 0] = texture.pixels[si];
            imgData.data[di + 1] = texture.pixels[si];
            imgData.data[di + 2] = texture.pixels[si];
            imgData.data[di + 3] = 255;
        }
    } else if (texture.dstFormat === "i8_a8") {
        for (var si = 0, di = 0; di < imgData.data.length; si += 2, di += 4) {
            imgData.data[di + 0] = texture.pixels[si];
            imgData.data[di + 1] = texture.pixels[si];
            imgData.data[di + 2] = texture.pixels[si];
            imgData.data[di + 3] = texture.pixels[si + 1];
        }
    } else if (texture.dstFormat === "rgba8") {
        imgData.data.set(texture.pixels);
    }
    canvas.title = '0x' + texture.addr.toString(16) + '  ' + texture.format.toString(16) + '  ' + texture.dstFormat;
    ctx.putImageData(imgData, 0, 0);
    var surfaces = [canvas];
    return { name: canvas.title, surfaces: surfaces };
}
function translateTexture(state, texture) {
    var gl = state.gl;
    function convertTexturePixels() {
        switch (texture.format) {
            // 4-bit
            case 0x40:
                return convert_CI4(state, texture); // CI
            case 0x60:
                return convert_IA4(state, texture); // IA
            case 0x80:
                return convert_I4(state, texture); // I
            // 8-bit
            case 0x48:
                return convert_CI8(state, texture); // CI
            case 0x68:
                return convert_IA8(state, texture); // IA
            case 0x88:
                return convert_I8(state, texture); // I
            // 16-bit
            case 0x10:
                return convert_RGBA16(state, texture); // RGBA
            case 0x70:
                return convert_IA16(state, texture); // IA
            default:
                console.error("Unsupported texture", texture.format.toString(16));
        }
    }
    texture.dstFormat = calcTextureDestFormat(texture);
    var srcOffs = state.lookupAddress(texture.addr);
    if (srcOffs !== null) convertTexturePixels();
    if (!texture.pixels) {
        if (texture.dstFormat === "i8") texture.pixels = new Uint8Array(texture.width * texture.height);else if (texture.dstFormat === "i8_a8") texture.pixels = new Uint8Array(texture.width * texture.height * 2);else if (texture.dstFormat === "rgba8") texture.pixels = new Uint8Array(texture.width * texture.height * 4);
    }
    function translateWrap(cm) {
        switch (cm) {
            case 1:
                return gl.MIRRORED_REPEAT;
            case 2:
                return gl.CLAMP_TO_EDGE;
            case 3:
                return gl.CLAMP_TO_EDGE;
            default:
                return gl.REPEAT;
        }
    }
    var texId = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texId);
    // Filters are set to NEAREST here because filtering is performed in the fragment shader.
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, translateWrap(texture.cms));
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, translateWrap(texture.cmt));
    var glFormat;
    if (texture.dstFormat === "i8") glFormat = gl.LUMINANCE;else if (texture.dstFormat === "i8_a8") glFormat = gl.LUMINANCE_ALPHA;else if (texture.dstFormat === "rgba8") glFormat = gl.RGBA;
    gl.texImage2D(gl.TEXTURE_2D, 0, glFormat, texture.width, texture.height, 0, glFormat, gl.UNSIGNED_BYTE, texture.pixels);
    texture.glTextureId = texId;
    state.textures.push(textureToCanvas(texture));
}
function calcTextureDestFormat(texture) {
    switch (texture.format & 0xE0) {
        case 0x00:
            return "rgba8"; // RGBA
        case 0x40:
            return "rgba8"; // CI -- XXX -- do we need to check the palette type?
        case 0x60:
            return "i8_a8"; // IA
        case 0x80:
            return "i8_a8"; // I
        default:
            throw new Error("Invalid texture type");
    }
}
function calcTextureSize(texture) {
    var maxTexel, lineShift;
    switch (texture.format) {
        // 4-bit
        case 0x00:
            maxTexel = 4096;
            lineShift = 4;
            break; // RGBA
        case 0x40:
            maxTexel = 4096;
            lineShift = 4;
            break; // CI
        case 0x60:
            maxTexel = 8196;
            lineShift = 4;
            break; // IA
        case 0x80:
            maxTexel = 8196;
            lineShift = 4;
            break; // I
        // 8-bit
        case 0x08:
            maxTexel = 2048;
            lineShift = 3;
            break; // RGBA
        case 0x48:
            maxTexel = 2048;
            lineShift = 3;
            break; // CI
        case 0x68:
            maxTexel = 4096;
            lineShift = 3;
            break; // IA
        case 0x88:
            maxTexel = 4096;
            lineShift = 3;
            break; // I
        // 16-bit
        case 0x10:
            maxTexel = 2048;
            lineShift = 2;
            break; // RGBA
        case 0x50:
            maxTexel = 2048;
            lineShift = 0;
            break; // CI
        case 0x70:
            maxTexel = 2048;
            lineShift = 2;
            break; // IA
        case 0x90:
            maxTexel = 2048;
            lineShift = 0;
            break; // I
        // 32-bit
        case 0x18:
            maxTexel = 1024;
            lineShift = 2;
            break; // RGBA
        default:
            throw "whoops";
    }
    var lineW = texture.lineSize << lineShift;
    var tileW = texture.lrs - texture.uls + 1;
    var tileH = texture.lrt - texture.ult + 1;
    var maskW = 1 << texture.maskS;
    var maskH = 1 << texture.maskT;
    var lineH;
    if (lineW > 0) lineH = Math.min(maxTexel / lineW, tileH);else lineH = 0;
    var width;
    if (texture.maskS > 0 && maskW * maskH <= maxTexel) width = maskW;else if (tileW * tileH <= maxTexel) width = tileW;else width = lineW;
    var height;
    if (texture.maskT > 0 && maskW * maskH <= maxTexel) height = maskH;else if (tileW * tileH <= maxTexel) height = tileH;else height = lineH;
    texture.width = width;
    texture.height = height;
}
var CommandDispatch = {};
CommandDispatch[UCodeCommands.VTX] = cmd_VTX;
CommandDispatch[UCodeCommands.TRI1] = cmd_TRI1;
CommandDispatch[UCodeCommands.TRI2] = cmd_TRI2;
CommandDispatch[UCodeCommands.GEOMETRYMODE] = cmd_GEOMETRYMODE;
CommandDispatch[UCodeCommands.DL] = cmd_DL;
CommandDispatch[UCodeCommands.MTX] = cmd_MTX;
CommandDispatch[UCodeCommands.POPMTX] = cmd_POPMTX;
CommandDispatch[UCodeCommands.SETOTHERMODE_L] = cmd_SETOTHERMODE_L;
CommandDispatch[UCodeCommands.SETOTHERMODE_H] = cmd_SETOTHERMODE_H;
CommandDispatch[UCodeCommands.LOADTLUT] = cmd_LOADTLUT;
CommandDispatch[UCodeCommands.TEXTURE] = cmd_TEXTURE;
CommandDispatch[UCodeCommands.SETCOMBINE] = cmd_SETCOMBINE;
CommandDispatch[UCodeCommands.SETENVCOLOR] = cmd_SETENVCOLOR;
CommandDispatch[UCodeCommands.SETPRIMCOLOR] = cmd_SETPRIMCOLOR;
CommandDispatch[UCodeCommands.SETTIMG] = cmd_SETTIMG;
CommandDispatch[UCodeCommands.SETTILE] = cmd_SETTILE;
CommandDispatch[UCodeCommands.SETTILESIZE] = cmd_SETTILESIZE;
var F3DEX2 = {};
function loadTextureBlock(state, cmds) {
    flushDraw(state);
    var tileIdx = cmds[5][1] >> 24 & 0x7;
    cmd_SETTIMG(state, cmds[0][0], cmds[0][1]);
    cmd_SETTILE(state, cmds[5][0], cmds[5][1]); // state.currentTile is constructed here
    cmd_SETTILESIZE(state, cmds[6][0], cmds[6][1]);
    state.currentTile.addr = state.textureImageAddr;
    state.textureTiles[tileIdx] = state.currentTile;
}
function runDL(state, addr) {
    function collectNextCmds() {
        var L = [];
        var voffs = offs;
        for (var i = 0; i < 8; i++) {
            var cmd0 = rom.view.getUint32(voffs, false);
            var cmd1 = rom.view.getUint32(voffs + 4, false);
            L.push([cmd0, cmd1]);
            voffs += 8;
        }
        return L;
    }
    function matchesCmdStream(cmds, needle) {
        for (var i = 0; i < needle.length; i++) {
            if (cmds[i][0] >>> 24 !== needle[i]) return false;
        }return true;
    }
    var rom = state.rom;
    var offs = state.lookupAddress(addr);
    if (offs === null) return;
    while (true) {
        var cmd0 = rom.view.getUint32(offs, false);
        var cmd1 = rom.view.getUint32(offs + 4, false);
        var cmdType = cmd0 >>> 24;
        if (cmdType === UCodeCommands.ENDDL) break;
        // Texture uploads need to be special.
        if (cmdType === UCodeCommands.SETTIMG) {
            var nextCmds = collectNextCmds();
            if (matchesCmdStream(nextCmds, [UCodeCommands.SETTIMG, UCodeCommands.SETTILE, UCodeCommands.RDPLOADSYNC, UCodeCommands.LOADBLOCK, UCodeCommands.RDPPIPESYNC, UCodeCommands.SETTILE, UCodeCommands.SETTILESIZE])) {
                loadTextureBlock(state, nextCmds);
                offs += 7 * 8;
                continue;
            }
        }
        var func = CommandDispatch[cmdType];
        if (func) func(state, cmd0, cmd1);
        offs += 8;
    }
    flushDraw(state);
}
var DL = /** @class */function () {
    function DL(vao, cmds, textures) {
        this.vao = vao;
        this.cmds = cmds;
        this.textures = textures;
    }
    DL.prototype.render = function (renderState) {
        var gl = renderState.gl;
        gl.bindVertexArray(this.vao);
        this.cmds.forEach(function (cmd) {
            cmd(renderState);
        });
        gl.bindVertexArray(null);
    };
    return DL;
}();
exports.DL = DL;
function readDL(gl, rom, banks, startAddr) {
    var state = new State();
    state.gl = gl;
    state.cmds = [];
    state.textures = [];
    state.mtx = gl_matrix_1.mat4.create();
    state.mtxStack = [state.mtx];
    state.vertexBuffer = new Float32Array(32 * VERTEX_SIZE);
    state.vertexData = [];
    state.vertexOffs = 0;
    state.rom = rom;
    state.banks = banks;
    runDL(state, startAddr);
    var vao = gl.createVertexArray();
    gl.bindVertexArray(vao);
    var vertBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, vertBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(state.vertexData), gl.STATIC_DRAW);
    gl.vertexAttribPointer(Render.F3DEX2Program.a_Position, 3, gl.FLOAT, false, VERTEX_BYTES, 0);
    gl.vertexAttribPointer(Render.F3DEX2Program.a_UV, 2, gl.FLOAT, false, VERTEX_BYTES, 3 * Float32Array.BYTES_PER_ELEMENT);
    gl.vertexAttribPointer(Render.F3DEX2Program.a_Shade, 4, gl.FLOAT, false, VERTEX_BYTES, 5 * Float32Array.BYTES_PER_ELEMENT);
    gl.enableVertexAttribArray(Render.F3DEX2Program.a_Position);
    gl.enableVertexAttribArray(Render.F3DEX2Program.a_UV);
    gl.enableVertexAttribArray(Render.F3DEX2Program.a_Shade);
    gl.bindVertexArray(null);
    return new DL(vao, state.cmds, state.textures);
}
exports.readDL = readDL;
},{"gl-matrix":"..\\node_modules\\gl-matrix\\src\\gl-matrix.js","./render":"zelview\\render.ts","../render":"render.ts"}],"zelview\\zelview0.ts":[function(require,module,exports) {
"use strict";

var __values = this && this.__values || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator],
        i = 0;
    if (m) return m.call(o);
    return {
        next: function next() {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
var __importStar = this && this.__importStar || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) {
        if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    }result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var gl_matrix_1 = require("gl-matrix");
var F3DEX2 = __importStar(require("./f3dex2"));
var util_1 = require("../util");
// Loads the ZELVIEW0 format.
var VFSEntry = /** @class */function () {
    function VFSEntry() {}
    return VFSEntry;
}();
var ZELVIEW0 = /** @class */function () {
    function ZELVIEW0() {}
    ZELVIEW0.prototype.lookupFile = function (pStart) {
        var e_1, _a;
        try {
            for (var _b = __values(this.entries), _c = _b.next(); !_c.done; _c = _b.next()) {
                var entry = _c.value;
                if (entry.pStart === pStart) return entry;
            }
        } catch (e_1_1) {
            e_1 = { error: e_1_1 };
        } finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally {
                if (e_1) throw e_1.error;
            }
        }
        return null;
    };
    ZELVIEW0.prototype.lookupAddress = function (banks, addr) {
        var bankIdx = addr >>> 24;
        var offs = addr & 0x00FFFFFF;
        function findBank() {
            switch (bankIdx) {
                case 0x02:
                    return banks.scene;
                case 0x03:
                    return banks.room;
                default:
                    return null;
            }
        }
        var bank = findBank();
        if (bank === null) return null;
        var absOffs = bank.vStart + offs;
        if (absOffs > bank.vEnd) return null;
        return absOffs;
    };
    ZELVIEW0.prototype.loadAddress = function (banks, addr) {
        var offs = this.lookupAddress(banks, addr);
        return this.view.getUint32(offs);
    };
    ZELVIEW0.prototype.loadScene = function (gl, scene) {
        return readScene(gl, this, scene);
    };
    ZELVIEW0.prototype.loadMainScene = function (gl) {
        return this.loadScene(gl, this.sceneFile);
    };
    return ZELVIEW0;
}();
exports.ZELVIEW0 = ZELVIEW0;
var Mesh = /** @class */function () {
    function Mesh() {
        this.opaque = [];
        this.transparent = [];
    }
    return Mesh;
}();
exports.Mesh = Mesh;
var Headers = /** @class */function () {
    function Headers() {
        this.rooms = [];
    }
    return Headers;
}();
exports.Headers = Headers;
function readZELVIEW0(buffer) {
    var view = buffer.createDataView();
    var MAGIC = "ZELVIEW0";
    if (util_1.readString(buffer, 0, MAGIC.length, false) !== MAGIC) throw new Error("Invalid ZELVIEW0 file");
    var offs = 0x08;
    var count = view.getUint8(offs);
    offs += 0x04;
    var mainFile = view.getUint8(offs);
    offs += 0x04;
    function readVFSEntry() {
        var entry = new VFSEntry();
        entry.filename = util_1.readString(buffer, offs, 0x30);
        offs += 0x30;
        entry.pStart = view.getUint32(offs, true);
        entry.pEnd = view.getUint32(offs + 0x04, true);
        entry.vStart = view.getUint32(offs + 0x08, true);
        entry.vEnd = view.getUint32(offs + 0x0C, true);
        offs += 0x10;
        return entry;
    }
    var entries = [];
    for (var i = 0; i < count; i++) {
        entries.push(readVFSEntry());
    }var zelview0 = new ZELVIEW0();
    zelview0.entries = entries;
    zelview0.sceneFile = entries[mainFile];
    zelview0.view = view;
    zelview0.buffer = buffer;
    return zelview0;
}
exports.readZELVIEW0 = readZELVIEW0;
var HeaderCommands;
(function (HeaderCommands) {
    HeaderCommands[HeaderCommands["Spawns"] = 0] = "Spawns";
    HeaderCommands[HeaderCommands["Actors"] = 1] = "Actors";
    HeaderCommands[HeaderCommands["Camera"] = 2] = "Camera";
    HeaderCommands[HeaderCommands["Collision"] = 3] = "Collision";
    HeaderCommands[HeaderCommands["Rooms"] = 4] = "Rooms";
    HeaderCommands[HeaderCommands["WindSettings"] = 5] = "WindSettings";
    HeaderCommands[HeaderCommands["EntranceList"] = 6] = "EntranceList";
    HeaderCommands[HeaderCommands["SpecialObjects"] = 7] = "SpecialObjects";
    HeaderCommands[HeaderCommands["SpecialBehavior"] = 8] = "SpecialBehavior";
    // 0x09 is unknown
    HeaderCommands[HeaderCommands["Mesh"] = 10] = "Mesh";
    HeaderCommands[HeaderCommands["Objects"] = 11] = "Objects";
    // 0x0C is unused
    HeaderCommands[HeaderCommands["Waypoints"] = 13] = "Waypoints";
    HeaderCommands[HeaderCommands["Transitions"] = 14] = "Transitions";
    HeaderCommands[HeaderCommands["Environment"] = 15] = "Environment";
    HeaderCommands[HeaderCommands["Time"] = 16] = "Time";
    HeaderCommands[HeaderCommands["Skybox"] = 17] = "Skybox";
    HeaderCommands[HeaderCommands["End"] = 20] = "End";
})(HeaderCommands || (HeaderCommands = {}));
function readHeaders(gl, rom, offs, banks) {
    var headers = new Headers();
    function loadAddress(addr) {
        return rom.loadAddress(banks, addr);
    }
    function readCollision(collisionAddr) {
        var offs = rom.lookupAddress(banks, collisionAddr);
        function readVerts(N, addr) {
            var offs = rom.lookupAddress(banks, addr);
            var verts = new Uint16Array(N * 3);
            for (var i = 0; i < N; i++) {
                verts[i * 3 + 0] = rom.view.getInt16(offs + 0x00, false);
                verts[i * 3 + 1] = rom.view.getInt16(offs + 0x02, false);
                verts[i * 3 + 2] = rom.view.getInt16(offs + 0x04, false);
                offs += 0x06;
            }
            return verts;
        }
        var vertsN = rom.view.getUint16(offs + 0x0C, false);
        var vertsAddr = rom.view.getUint32(offs + 0x10, false);
        var verts = readVerts(vertsN, vertsAddr);
        function readPolys(N, addr) {
            var offs = rom.lookupAddress(banks, addr);
            var polys = new Uint16Array(N * 3);
            for (var i = 0; i < N; i++) {
                polys[i * 3 + 0] = rom.view.getUint16(offs + 0x02, false) & 0x0FFF;
                polys[i * 3 + 1] = rom.view.getUint16(offs + 0x04, false) & 0x0FFF;
                polys[i * 3 + 2] = rom.view.getUint16(offs + 0x06, false) & 0x0FFF;
                offs += 0x10;
            }
            return polys;
        }
        var polysN = rom.view.getUint16(offs + 0x14, false);
        var polysAddr = rom.view.getUint32(offs + 0x18, false);
        var polys = readPolys(polysN, polysAddr);
        function readWaters(N, addr) {
            // XXX: While we should probably keep the actual stuff about
            // water boxes, I'm just drawing them, so let's just record
            // a quad.
            var offs = rom.lookupAddress(banks, addr);
            var waters = new Uint16Array(N * 3 * 4);
            for (var i = 0; i < N; i++) {
                var x = rom.view.getInt16(offs + 0x00, false);
                var y = rom.view.getInt16(offs + 0x02, false);
                var z = rom.view.getInt16(offs + 0x04, false);
                var sx = rom.view.getInt16(offs + 0x06, false);
                var sz = rom.view.getInt16(offs + 0x08, false);
                waters[i * 3 * 4 + 0] = x;
                waters[i * 3 * 4 + 1] = y;
                waters[i * 3 * 4 + 2] = z;
                waters[i * 3 * 4 + 3] = x + sx;
                waters[i * 3 * 4 + 4] = y;
                waters[i * 3 * 4 + 5] = z;
                waters[i * 3 * 4 + 6] = x;
                waters[i * 3 * 4 + 7] = y;
                waters[i * 3 * 4 + 8] = z + sz;
                waters[i * 3 * 4 + 9] = x + sx;
                waters[i * 3 * 4 + 10] = y;
                waters[i * 3 * 4 + 11] = z + sz;
                offs += 0x10;
            }
            return waters;
        }
        var watersN = rom.view.getUint16(offs + 0x24, false);
        var watersAddr = rom.view.getUint32(offs + 0x28, false);
        var waters = readWaters(watersN, watersAddr);
        function readCamera(addr) {
            var skyboxCamera = loadAddress(addr + 0x04);
            var offs = rom.lookupAddress(banks, skyboxCamera);
            var x = rom.view.getInt16(offs + 0x00, false);
            var y = rom.view.getInt16(offs + 0x02, false);
            var z = rom.view.getInt16(offs + 0x04, false);
            var a = rom.view.getUint16(offs + 0x06, false) / 0xFFFF * (Math.PI * 2);
            var b = rom.view.getUint16(offs + 0x08, false) / 0xFFFF * (Math.PI * 2) + Math.PI;
            var c = rom.view.getUint16(offs + 0x0A, false) / 0xFFFF * (Math.PI * 2);
            var d = rom.view.getUint16(offs + 0x0C, false);
            var mtx = gl_matrix_1.mat4.create();
            gl_matrix_1.mat4.translate(mtx, mtx, [x, y, z]);
            gl_matrix_1.mat4.rotateZ(mtx, mtx, c);
            gl_matrix_1.mat4.rotateY(mtx, mtx, b);
            gl_matrix_1.mat4.rotateX(mtx, mtx, -a);
            return mtx;
        }
        var cameraAddr = rom.view.getUint32(offs + 0x20, false);
        var camera = readCamera(cameraAddr);
        return { verts: verts, polys: polys, waters: waters, camera: camera };
    }
    function readRoom(file) {
        var banks2 = { scene: banks.scene, room: file };
        return readHeaders(gl, rom, file.vStart, banks2);
    }
    function readRooms(nRooms, roomTableAddr) {
        var rooms = [];
        for (var i = 0; i < nRooms; i++) {
            var pStart = loadAddress(roomTableAddr);
            var file = rom.lookupFile(pStart);
            var room = readRoom(file);
            room.filename = file.filename;
            rooms.push(room);
            roomTableAddr += 8;
        }
        return rooms;
    }
    function loadImage(gl, src) {
        var canvas = document.createElement('canvas');
        var ctx = canvas.getContext('2d');
        var texId = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texId);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        var img = document.createElement('img');
        img.src = src;
        var aspect = 1;
        img.onload = function () {
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0);
            var imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            gl.bindTexture(gl.TEXTURE_2D, texId);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, imgData.width, imgData.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, imgData.data);
        };
        // XXX: Should pull this dynamically at runtime.
        var imgWidth = 320;
        var imgHeight = 240;
        var imgAspect = imgWidth / imgHeight;
        // const viewportAspect = gl.viewportWidth / gl.viewportHeight;
        var x = imgAspect;
        var vertData = new Float32Array([
        /* x   y   z   u  v */
        -x, -1, 0, 0, 1, x, -1, 0, 1, 1, -x, 1, 0, 0, 0, x, 1, 0, 1, 0]);
        var vertBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertData, gl.STATIC_DRAW);
        var idxData = new Uint8Array([0, 1, 2, 3]);
        var idxBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, idxBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, idxData, gl.STATIC_DRAW);
        // 3 pos + 2 uv
        var VERTEX_SIZE = 5;
        var VERTEX_BYTES = VERTEX_SIZE * Float32Array.BYTES_PER_ELEMENT;
        return function (renderState) {
            var gl = renderState.gl;
            var prog = renderState.currentProgram;
            gl.disable(gl.BLEND);
            gl.disable(gl.DEPTH_TEST);
            gl.bindBuffer(gl.ARRAY_BUFFER, vertBuffer);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, idxBuffer);
            gl.vertexAttribPointer(prog.positionLocation, 3, gl.FLOAT, false, VERTEX_BYTES, 0);
            gl.vertexAttribPointer(prog.uvLocation, 2, gl.FLOAT, false, VERTEX_BYTES, 3 * Float32Array.BYTES_PER_ELEMENT);
            gl.enableVertexAttribArray(prog.positionLocation);
            gl.enableVertexAttribArray(prog.uvLocation);
            gl.bindTexture(gl.TEXTURE_2D, texId);
            gl.drawElements(gl.TRIANGLE_STRIP, 4, gl.UNSIGNED_BYTE, 0);
        };
    }
    function readMesh(meshAddr) {
        var hdr = loadAddress(meshAddr);
        var type = hdr >> 24;
        var nEntries = hdr >> 16 & 0xFF;
        var entriesAddr = loadAddress(meshAddr + 4);
        var mesh = new Mesh();
        function readDL(addr) {
            var dlStart = loadAddress(addr);
            if (dlStart === 0) return null;
            return F3DEX2.readDL(gl, rom, banks, dlStart);
        }
        if (type === 0) {
            for (var i = 0; i < nEntries; i++) {
                mesh.opaque.push(readDL(entriesAddr));
                mesh.transparent.push(readDL(entriesAddr + 4));
                entriesAddr += 8;
            }
        } else if (type === 1) {
            // The last entry always seems to contain the BG. Not sure
            // what the other data is about... maybe the VR skybox for rotating scenes?
            var lastEntry = nEntries - 1;
            var bg = loadAddress(meshAddr + lastEntry * 0x0C + 0x08);
            var bgOffs = rom.lookupAddress(banks, bg);
            var buffer = rom.buffer.slice(bgOffs);
            var blob = new Blob([buffer.castToBuffer()], { type: 'image/jpeg' });
            var url = window.URL.createObjectURL(blob);
            mesh.bg = loadImage(gl, url);
        } else if (type === 2) {
            for (var i = 0; i < nEntries; i++) {
                mesh.opaque.push(readDL(entriesAddr + 8));
                mesh.transparent.push(readDL(entriesAddr + 12));
                entriesAddr += 16;
            }
        }
        mesh.opaque = mesh.opaque.filter(function (dl) {
            return !!dl;
        });
        mesh.transparent = mesh.transparent.filter(function (dl) {
            return !!dl;
        });
        mesh.textures = [];
        mesh.opaque.forEach(function (dl) {
            mesh.textures = mesh.textures.concat(dl.textures);
        });
        mesh.transparent.forEach(function (dl) {
            mesh.textures = mesh.textures.concat(dl.textures);
        });
        return mesh;
    }
    headers.rooms = [];
    headers.mesh = null;
    var startOffs = offs;
    while (true) {
        var cmd1 = rom.view.getUint32(offs, false);
        var cmd2 = rom.view.getUint32(offs + 4, false);
        offs += 8;
        var cmdType = cmd1 >> 24;
        if (cmdType === HeaderCommands.End) break;
        switch (cmdType) {
            case HeaderCommands.Collision:
                headers.collision = readCollision(cmd2);
                break;
            case HeaderCommands.Rooms:
                var nRooms = cmd1 >> 16 & 0xFF;
                headers.rooms = readRooms(nRooms, cmd2);
                break;
            case HeaderCommands.Mesh:
                headers.mesh = readMesh(cmd2);
                break;
        }
    }
    return headers;
}
function readScene(gl, zelview0, file) {
    var banks = { scene: file };
    return readHeaders(gl, zelview0, file.vStart, banks);
}
},{"gl-matrix":"..\\node_modules\\gl-matrix\\src\\gl-matrix.js","./f3dex2":"zelview\\f3dex2.ts","../util":"util.ts"}],"zelview\\render.ts":[function(require,module,exports) {
"use strict";

var __extends = this && this.__extends || function () {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
        d.__proto__ = b;
    } || function (d, b) {
        for (var p in b) {
            if (b.hasOwnProperty(p)) d[p] = b[p];
        }
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __importStar = this && this.__importStar || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) {
        if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    }result["default"] = mod;
    return result;
};
var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var ZELVIEW0 = __importStar(require("./zelview0"));
var render_1 = require("../render");
var Program_1 = __importDefault(require("../Program"));
var util_1 = require("../util");
var BillboardBGProgram = /** @class */function (_super) {
    __extends(BillboardBGProgram, _super);
    function BillboardBGProgram() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.vert = "\nattribute vec3 a_position;\nattribute vec2 a_uv;\nvarying vec2 v_uv;\n\nvoid main() {\n    gl_Position = vec4(a_position, 1.0);\n    v_uv = a_uv;\n}\n";
        _this.frag = "\nprecision mediump float;\nvarying vec2 v_uv;\nuniform sampler2D u_texture;\n\nvoid main() {\n    gl_FragColor = texture2D(u_texture, v_uv);\n}\n";
        return _this;
    }
    BillboardBGProgram.prototype.bind = function (gl, prog) {
        _super.prototype.bind.call(this, gl, prog);
        this.positionLocation = gl.getAttribLocation(prog, "a_position");
        this.uvLocation = gl.getAttribLocation(prog, "a_uv");
    };
    return BillboardBGProgram;
}(Program_1.default);
exports.BillboardBGProgram = BillboardBGProgram;
function ccUsesTexel0(c) {
    return c.subA == 1 || c.subB == 1 || c.mul == 1 || c.mul == 8 || c.add == 1;
}
function acUsesTexel0(c) {
    return c.subA == 1 || c.subB == 1 || c.mul == 1 || c.add == 1;
}
function ccUsesTexel1(c) {
    return c.subA == 2 || c.subB == 2 || c.mul == 2 || c.mul == 9 || c.add == 2;
}
function acUsesTexel1(c) {
    return c.subA == 2 || c.subB == 2 || c.mul == 2 || c.add == 2;
}
var F3DEX2_FRAG_BASE = "\nprecision mediump float;\nvarying vec2 v_uv;\nvarying vec4 v_shade;\nuniform vec4 u_env;\nuniform vec4 u_prim;\nuniform sampler2D u_texture0;\nuniform sampler2D u_texture1;\nuniform bool u_useVertexColors;\nuniform int u_alphaTest;\n\nvec4 n64Texture2D(sampler2D tex, vec2 texCoord) {\n    vec2 texSize = vec2(textureSize(tex, 0));\n    vec2 offset = fract(texCoord * texSize - 0.5);\n    offset -= step(1.0, offset.x + offset.y);\n    vec4 c0 = texture2D(tex, texCoord - offset / texSize, 0.0);\n    vec4 c1 = texture2D(tex, texCoord - vec2(offset.x - sign(offset.x), offset.y) / texSize, 0.0);\n    vec4 c2 = texture2D(tex, texCoord - vec2(offset.x, offset.y - sign(offset.y)) / texSize, 0.0);\n    return c0 + abs(offset.x) * (c1 - c0) + abs(offset.y) * (c2 - c0);\t\t\n}\n\nvoid main() {\n#if USE_2CYCLE && CC1_USES_T1\n    // 2-cycle, complete\n    vec4 t00 = n64Texture2D(u_texture0, v_uv);\n    vec4 t10 = n64Texture2D(u_texture1, v_uv);\n    vec4 t01 = t00; // ???\n    vec4 t11 = t10; // ???\n#elif USE_2CYCLE && (CC0_USES_T1 || CC1_USES_T0)\n    // 2-cycle, no texel-next?\n    vec4 t00 = n64Texture2D(u_texture0, v_uv);\n    vec4 t10 = n64Texture2D(u_texture1, v_uv);\n    vec4 t01 = n64Texture2D(u_texture0, v_uv); // ???\n    vec4 t11 = n64Texture2D(u_texture1, v_uv); // ???\n#elif USE_2CYCLE && (CC0_USES_T0 || CC0_USES_LOD_FRAC || CC1_USES_LOD_FRAC)\n    // 2-cycle, no texel 1\n    vec4 t00 = n64Texture2D(u_texture0, v_uv);\n    vec4 t10 = vec4(0.0);\n    vec4 t01 = t00; // ???\n    vec4 t11 = t10; // ???\n#elif USE_2CYCLE\n    vec4 t00 = vec4(0.0);\n    vec4 t10 = vec4(0.0);\n    vec4 t01 = vec4(0.0);\n    vec4 t11 = vec4(0.0);\n#else\n    #error TODO: handle 1-cycle\n#endif\n\n    vec4 shade = v_shade;\n    if (!u_useVertexColors) {\n        shade = vec4(1.0);\n    }\n\n    vec4 combined = shade;\n    vec4 t0;\n    vec4 t1;\n#if USE_2CYCLE\n    t0 = t00;\n    t1 = t10;\n    combined = vec4(\n        (CC0_SUBA - CC0_SUBB) * CC0_MUL + CC0_ADD,\n        (AC0_SUBA - AC0_SUBB) * AC0_MUL + AC0_ADD\n    );\n#endif\n    t0 = t01;\n    t1 = t11;\n    combined = vec4(\n        (CC1_SUBA - CC1_SUBB) * CC1_MUL + CC1_ADD,\n        (AC1_SUBA - AC1_SUBB) * AC1_MUL + AC1_ADD\n    );\n\n    gl_FragColor = combined;\n\n    if (u_alphaTest > 0 && gl_FragColor.a < 0.0125)\n        discard;\n}\n";
var CC_SUBA = {
    0: "combined.rgb",
    1: "t0.rgb",
    2: "t1.rgb",
    3: "u_prim.rgb",
    4: "shade.rgb",
    5: "u_env.rgb",
    6: "vec3(1.0)",
    7: "vec3(0.5)"
};
var CC_SUBB = {
    0: "combined.rgb",
    1: "t0.rgb",
    2: "t1.rgb",
    3: "u_prim.rgb",
    4: "shade.rgb",
    5: "u_env.rgb",
    6: "vec3(0.0)",
    7: "vec3(0.5)"
};
var CC_MUL = {
    0: "combined.rgb",
    1: "t0.rgb",
    2: "t1.rgb",
    3: "u_prim.rgb",
    4: "shade.rgb",
    5: "u_env.rgb",
    6: "vec3(1.0)",
    7: "combined.aaa",
    8: "t0.aaa",
    9: "t1.aaa",
    10: "u_prim.aaa",
    11: "shade.aaa",
    12: "u_env.aaa",
    13: "vec3(1.0)",
    14: "vec3(1.0)",
    15: "vec3(0.5)"
};
var CC_ADD = {
    0: "combined.rgb",
    1: "t0.rgb",
    2: "t1.rgb",
    3: "u_prim.rgb",
    4: "shade.rgb",
    5: "u_env.rgb",
    6: "vec3(1.0)"
};
var AC_ADDSUB = {
    0: "combined.a",
    1: "t0.a",
    2: "t1.a",
    3: "u_prim.a",
    4: "shade.a",
    5: "u_env.a",
    6: "1.0"
};
var AC_MUL = {
    0: "1.0",
    1: "t0.a",
    2: "t1.a",
    3: "u_prim.a",
    4: "shade.a",
    5: "u_env.a",
    6: "1.0"
};
function getOrDefault(obj, key, def) {
    var result = obj[key];
    return result === undefined ? def : result;
}
var F3DEX2Program = /** @class */function (_super) {
    __extends(F3DEX2Program, _super);
    function F3DEX2Program(params) {
        var _this = _super.call(this) || this;
        _this.vert = "\nuniform mat4 u_modelView;\nuniform mat4 u_projection;\nlayout(location = " + F3DEX2Program.a_Position + ") attribute vec3 a_Position;\nlayout(location = " + F3DEX2Program.a_UV + ") attribute vec2 a_UV;\nlayout(location = " + F3DEX2Program.a_Shade + ") attribute vec4 a_Shade;\nout vec4 v_shade;\nout vec2 v_uv;\nuniform vec2 u_txs[2];\n\nvoid main() {\n    gl_Position = u_projection * u_modelView * vec4(a_Position, 1.0);\n    v_uv = a_UV * u_txs[0]; // ??? Is there a second set of texcoords?\n    v_shade = a_Shade;\n}\n";
        _this.frag = "\n#error Shader was not properly constructed.\n";
        _this.frag = "#define USE_2CYCLE " + (params.use2Cycle ? 1 : 0) + "\n";
        for (var i = 0; i < 2; i++) {
            var usesT0 = ccUsesTexel0(params.combiners.colorCombiners[i]) || acUsesTexel0(params.combiners.alphaCombiners[i]);
            var usesT1 = ccUsesTexel1(params.combiners.colorCombiners[i]) || acUsesTexel1(params.combiners.alphaCombiners[i]);
            var usesLodFrac = params.combiners.colorCombiners[i].mul == 13 || params.combiners.alphaCombiners[i].mul == 0;
            _this.frag += "\n#define CC" + i + "_USES_T0 " + (usesT0 ? 1 : 0) + "\n#define CC" + i + "_USES_T1 " + (usesT1 ? 1 : 0) + "\n#define CC" + i + "_USES_LOD_FRAC " + (usesLodFrac ? 1 : 0) + "\n#define CC" + i + "_SUBA " + getOrDefault(CC_SUBA, params.combiners.colorCombiners[i].subA, 'vec3(0.0)') + "\n#define CC" + i + "_SUBB " + getOrDefault(CC_SUBB, params.combiners.colorCombiners[i].subB, 'vec3(0.0)') + "\n#define CC" + i + "_MUL " + getOrDefault(CC_MUL, params.combiners.colorCombiners[i].mul, 'vec3(0.0)') + "\n#define CC" + i + "_ADD " + getOrDefault(CC_ADD, params.combiners.colorCombiners[i].add, 'vec3(0.0)') + "\n#define AC" + i + "_SUBA " + getOrDefault(AC_ADDSUB, params.combiners.alphaCombiners[i].subA, '0.0') + "\n#define AC" + i + "_SUBB " + getOrDefault(AC_ADDSUB, params.combiners.alphaCombiners[i].subB, '0.0') + "\n#define AC" + i + "_MUL " + getOrDefault(AC_MUL, params.combiners.alphaCombiners[i].mul, '0.0') + "\n#define AC" + i + "_ADD " + getOrDefault(AC_ADDSUB, params.combiners.alphaCombiners[i].add, '0.0') + "\n";
        }
        _this.frag += F3DEX2_FRAG_BASE;
        return _this;
    }
    F3DEX2Program.prototype.bind = function (gl, prog) {
        _super.prototype.bind.call(this, gl, prog);
        this.texture0Location = gl.getUniformLocation(prog, "u_texture0");
        this.texture1Location = gl.getUniformLocation(prog, "u_texture1");
        this.txsLocation = [];
        this.txsLocation[0] = gl.getUniformLocation(prog, "u_txs[0]");
        this.txsLocation[1] = gl.getUniformLocation(prog, "u_txs[1]");
        this.envLocation = gl.getUniformLocation(prog, "u_env");
        this.primLocation = gl.getUniformLocation(prog, "u_prim");
        this.useVertexColorsLocation = gl.getUniformLocation(prog, "u_useVertexColors");
        this.alphaTestLocation = gl.getUniformLocation(prog, "u_alphaTest");
    };
    F3DEX2Program.a_Position = 0;
    F3DEX2Program.a_UV = 1;
    F3DEX2Program.a_Shade = 2;
    return F3DEX2Program;
}(Program_1.default);
exports.F3DEX2Program = F3DEX2Program;
var CollisionProgram = /** @class */function (_super) {
    __extends(CollisionProgram, _super);
    function CollisionProgram() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.vert = "\nuniform mat4 u_modelView;\nuniform mat4 u_projection;\nattribute vec3 a_position;\n\nvoid main() {\n    gl_Position = u_projection * u_modelView * vec4(a_position, 1.0);\n}\n";
        _this.frag = "\n#extension GL_EXT_frag_depth : enable\n\nvoid main() {\n    gl_FragColor = vec4(1.0, 1.0, 1.0, 0.2);\n    gl_FragDepthEXT = gl_FragCoord.z - 1e-6;\n}\n";
        return _this;
    }
    CollisionProgram.prototype.bind = function (gl, prog) {
        _super.prototype.bind.call(this, gl, prog);
        this.positionLocation = gl.getAttribLocation(prog, "a_position");
    };
    return CollisionProgram;
}(Program_1.default);
var WaterboxProgram = /** @class */function (_super) {
    __extends(WaterboxProgram, _super);
    function WaterboxProgram() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.vert = "\nuniform mat4 u_modelView;\nuniform mat4 u_projection;\nattribute vec3 a_position;\n\nvoid main() {\n    gl_Position = u_projection * u_modelView * vec4(a_position, 1.0);\n}\n";
        _this.frag = "\nvoid main() {\n    gl_FragColor = vec4(0.2, 0.6, 1.0, 0.2);\n}\n";
        return _this;
    }
    WaterboxProgram.prototype.bind = function (gl, prog) {
        _super.prototype.bind.call(this, gl, prog);
        this.positionLocation = gl.getAttribLocation(prog, "a_position");
    };
    return WaterboxProgram;
}(Program_1.default);
function hashF3DEX2Params(params) {
    return JSON.stringify(params); // TODO: use a more efficient hash mechanism
}
exports.hashF3DEX2Params = hashF3DEX2Params;
var Scene = /** @class */function () {
    function Scene(gl, zelview0) {
        var _this = this;
        this.zelview0 = zelview0;
        this.textures = [];
        this.program_BG = new BillboardBGProgram();
        this.program_COLL = new CollisionProgram();
        this.program_WATERS = new WaterboxProgram();
        var mainScene = zelview0.loadMainScene(gl);
        mainScene.rooms.forEach(function (room) {
            _this.textures = _this.textures.concat(room.mesh.textures);
        });
        var renderScene = this.translateScene(gl, mainScene);
        var renderCollision = this.translateCollision(gl, mainScene);
        var renderWaterBoxes = this.translateWaterBoxes(gl, mainScene);
        this.render = function (state) {
            renderScene(state);
            //renderCollision(state);
            renderWaterBoxes(state);
        };
    }
    Scene.prototype.translateScene = function (gl, scene) {
        var _this = this;
        return function (state) {
            var gl = state.gl;
            var renderDL = function renderDL(dl) {
                dl.render(state);
            };
            var renderMesh = function renderMesh(mesh) {
                if (mesh.bg) {
                    state.useProgram(_this.program_BG);
                    state.bindModelView();
                    mesh.bg(state);
                }
                mesh.opaque.forEach(renderDL);
                mesh.transparent.forEach(renderDL);
            };
            var renderRoom = function renderRoom(room) {
                renderMesh(room.mesh);
            };
            scene.rooms.forEach(function (room) {
                return renderRoom(room);
            });
        };
    };
    Scene.prototype.translateCollision = function (gl, scene) {
        var _this = this;
        var coll = scene.collision;
        function stitchLines(ibd) {
            var lines = new Uint16Array(ibd.length * 2);
            var o = 0;
            for (var i = 0; i < ibd.length; i += 3) {
                lines[o++] = ibd[i + 0];
                lines[o++] = ibd[i + 1];
                lines[o++] = ibd[i + 1];
                lines[o++] = ibd[i + 2];
                lines[o++] = ibd[i + 2];
                lines[o++] = ibd[i + 0];
            }
            return lines;
        }
        var collIdxBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, collIdxBuffer);
        var lineData = stitchLines(coll.polys);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, lineData, gl.STATIC_DRAW);
        var nLinePrim = lineData.length;
        var collVertBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, collVertBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, coll.verts, gl.STATIC_DRAW);
        var renderFlags = new render_1.RenderFlags();
        renderFlags.depthTest = true;
        renderFlags.blendMode = render_1.BlendMode.ADD;
        return function (state) {
            var prog = _this.program_COLL;
            state.useProgram(prog);
            state.bindModelView();
            state.useFlags(renderFlags);
            gl.bindBuffer(gl.ARRAY_BUFFER, collVertBuffer);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, collIdxBuffer);
            gl.vertexAttribPointer(prog.positionLocation, 3, gl.SHORT, false, 0, 0);
            gl.enableVertexAttribArray(prog.positionLocation);
            gl.drawElements(gl.LINES, nLinePrim, gl.UNSIGNED_SHORT, 0);
            gl.disableVertexAttribArray(prog.positionLocation);
        };
    };
    Scene.prototype.translateWaterBoxes = function (gl, scene) {
        var _this = this;
        var coll = scene.collision;
        var wbVtx = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, wbVtx);
        gl.bufferData(gl.ARRAY_BUFFER, coll.waters, gl.STATIC_DRAW);
        var wbIdxData = new Uint16Array(coll.waters.length / 3);
        for (var i = 0; i < wbIdxData.length; i++) {
            wbIdxData[i] = i;
        }var wbIdx = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, wbIdx);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, wbIdxData, gl.STATIC_DRAW);
        var renderFlags = new render_1.RenderFlags();
        renderFlags.blendMode = render_1.BlendMode.ADD;
        renderFlags.cullMode = render_1.CullMode.NONE;
        return function (state) {
            var prog = _this.program_WATERS;
            state.useProgram(prog);
            state.bindModelView();
            state.useFlags(renderFlags);
            gl.bindBuffer(gl.ARRAY_BUFFER, wbVtx);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, wbIdx);
            gl.vertexAttribPointer(prog.positionLocation, 3, gl.SHORT, false, 0, 0);
            gl.enableVertexAttribArray(prog.positionLocation);
            for (var i = 0; i < wbIdxData.length; i += 4) {
                gl.drawElements(gl.TRIANGLE_STRIP, 4, gl.UNSIGNED_SHORT, i * 2);
            }gl.disableVertexAttribArray(prog.positionLocation);
        };
    };
    Scene.prototype.destroy = function (gl) {
        // TODO(jstpierre): Implement destroy for zelview.
    };
    return Scene;
}();
var SceneDesc = /** @class */function () {
    function SceneDesc(name, path) {
        this.name = name;
        this.path = path;
        this.id = this.path;
    }
    SceneDesc.prototype.createScene = function (gl) {
        return util_1.fetch(this.path).then(function (result) {
            var zelview0 = ZELVIEW0.readZELVIEW0(result);
            return new Scene(gl, zelview0);
        });
    };
    return SceneDesc;
}();
exports.SceneDesc = SceneDesc;
},{"./zelview0":"zelview\\zelview0.ts","../render":"render.ts","../Program":"Program.ts","../util":"util.ts"}],"zelview\\scenes.ts":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var render_1 = require("./render");
var id = "zelview";
var name = "Ocarina of Time";
var sceneDescs = [{
    filename: "ydan_scene",
    label: "Inside the Deku Tree"
}, {
    filename: "ddan_scene",
    label: "Dodongo's Cavern"
}, {
    filename: "bdan_scene",
    label: "Inside Jabu-Jabu's Belly"
}, {
    filename: "Bmori1_scene",
    label: "Forest Temple"
}, {
    filename: "HIDAN_scene",
    label: "Fire Temple"
}, {
    filename: "MIZUsin_scene",
    label: "Water Temple"
}, {
    filename: "jyasinzou_scene",
    label: "Spirit Temple"
}, {
    filename: "HAKAdan_scene",
    label: "Shadow Temple"
}, {
    filename: "HAKAdanCH_scene",
    label: "Bottom of the Well"
}, {
    filename: "ice_doukutu_scene",
    label: "Ice Cavern"
}, {
    filename: "ganon_scene",
    label: "Ganon's Castle Tower"
}, {
    filename: "men_scene",
    label: "Gerudo Training Grounds"
}, {
    filename: "gerudoway_scene",
    label: "Thieves' Hideout"
}, {
    filename: "ganontika_scene",
    label: "Ganon's Castle"
}, {
    filename: "ganon_sonogo_scene",
    label: "Ganon's Castle Tower (Crumbling)"
}, {
    filename: "ganontikasonogo_scene",
    label: "Ganon's Castle (Crumbling)"
}, {
    filename: "takaraya_scene",
    label: "Treasure Chest Contest"
}, {
    filename: "ydan_boss_scene",
    label: "Inside the Deku Tree (Boss)"
}, {
    filename: "ddan_boss_scene",
    label: "Dodongo's Cavern (Boss)"
}, {
    filename: "bdan_boss_scene",
    label: "Inside Jabu-Jabu's Belly (Boss)"
}, {
    filename: "moribossroom_scene",
    label: "Forest Temple (Boss)"
}, {
    filename: "FIRE_bs_scene",
    label: "Fire Temple (Boss)"
}, {
    filename: "MIZUsin_bs_scene",
    label: "Water Temple (Boss)"
}, {
    filename: "jyasinboss_scene",
    label: "Spirit Temple (Mid-Boss)"
}, {
    filename: "HAKAdan_bs_scene",
    label: "Shadow Temple (Boss)"
}, {
    filename: "ganon_boss_scene",
    label: "Second-To-Last Boss Ganondorf"
}, {
    filename: "ganon_final_scene",
    label: "Ganondorf, Death Scene"
}, {
    filename: "entra_scene",
    label: "Market Entrance (Day)"
}, {
    filename: "entra_n_scene",
    label: "Market Entrance (Night)"
}, {
    filename: "enrui_scene",
    label: "Market Entrance (Adult)"
}, {
    filename: "market_alley_scene",
    label: "Back Alley (Day)"
}, {
    filename: "market_alley_n_scene",
    label: "Back Alley (Night)"
}, {
    filename: "market_day_scene",
    label: "Market (Day)"
}, {
    filename: "market_night_scene",
    label: "Market (Night)"
}, {
    filename: "market_ruins_scene",
    label: "Market (Adult)"
}, {
    filename: "shrine_scene",
    label: "Temple of Time (Outside, Day)"
}, {
    filename: "shrine_n_scene",
    label: "Temple of Time (Outside, Night)"
}, {
    filename: "shrine_r_scene",
    label: "Temple of Time (Outside, Adult)"
}, {
    filename: "kokiri_home_scene",
    label: "Know-it-all Brothers"
}, {
    filename: "kokiri_home3_scene",
    label: "House of Twins"
}, {
    filename: "kokiri_home4_scene",
    label: "Mido's House"
}, {
    filename: "kokiri_home5_scene",
    label: "Saria's House"
}, {
    filename: "kakariko_scene",
    label: "Kakariko Village House"
}, {
    filename: "kakariko3_scene",
    label: "Back Alley Village House"
}, {
    filename: "shop1_scene",
    label: "Kakariko Bazaar"
}, {
    filename: "kokiri_shop_scene",
    label: "Kokiri Shop"
}, {
    filename: "golon_scene",
    label: "Goron Shop"
}, {
    filename: "zoora_scene",
    label: "Zora Shop"
}, {
    filename: "drag_scene",
    label: "Kakariko Potion Shop"
}, {
    filename: "alley_shop_scene",
    label: "Market Potion Shop"
}, {
    filename: "night_shop_scene",
    label: "Bombchu Shop"
}, {
    filename: "face_shop_scene",
    label: "Happy Mask Shop"
}, {
    filename: "link_home_scene",
    label: "Link's House"
}, {
    filename: "impa_scene",
    label: "Puppy Woman's House"
}, {
    filename: "malon_stable_scene",
    label: "Stables"
}, {
    filename: "labo_scene",
    label: "Impa's House"
}, {
    filename: "hylia_labo_scene",
    label: "Lakeside Laboratory"
}, {
    filename: "tent_scene",
    label: "Carpenter's Tent"
}, {
    filename: "hut_scene",
    label: "Dampé's Hut"
}, {
    filename: "daiyousei_izumi_scene",
    label: "Great Fairy Fountain"
}, {
    filename: "yousei_izumi_tate_scene",
    label: "Small Fairy Fountain"
}, {
    filename: "yousei_izumi_yoko_scene",
    label: "Magic Fairy Fountain"
}, {
    filename: "kakusiana_scene",
    label: "Grottos"
}, {
    filename: "hakaana_scene",
    label: "Grave (1)"
}, {
    filename: "hakaana2_scene",
    label: "Grave (2)"
}, {
    filename: "hakaana_ouke_scene",
    label: "Royal Family's Tomb"
}, {
    filename: "syatekijyou_scene",
    label: "Shooting Gallery"
}, {
    filename: "tokinoma_scene",
    label: "Temple of Time Inside"
}, {
    filename: "kenjyanoma_scene",
    label: "Chamber of Sages"
}, {
    filename: "hairal_niwa_scene",
    label: "Castle Courtyard (Day)"
}, {
    filename: "hairal_niwa_n_scene",
    label: "Castle Courtyard (Night)"
}, {
    filename: "hiral_demo_scene",
    label: "Cutscene Map"
}, {
    filename: "hakasitarelay_scene",
    label: "Dampé's Grave & Kakariko Windmill"
}, {
    filename: "turibori_scene",
    label: "Fishing Pond"
}, {
    filename: "nakaniwa_scene",
    label: "Zelda's Courtyard"
}, {
    filename: "bowling_scene",
    label: "Bombchu Bowling Alley"
}, {
    filename: "souko_scene",
    label: "Talon's House"
}, {
    filename: "miharigoya_scene",
    label: "Lots'o Pots"
}, {
    filename: "mahouya_scene",
    label: "Granny's Potion Shop"
}, {
    filename: "ganon_demo_scene",
    label: "Final Battle against Ganon"
}, {
    filename: "kinsuta_scene",
    label: "Skulltula House"
}, {
    filename: "spot00_scene",
    label: "Hyrule Field"
}, {
    filename: "spot01_scene",
    label: "Kakariko Village"
}, {
    filename: "spot02_scene",
    label: "Kakariko Graveyard"
}, {
    filename: "spot03_scene",
    label: "Zora's River"
}, {
    filename: "spot04_scene",
    label: "Kokiri Forest"
}, {
    filename: "spot05_scene",
    label: "Sacred Forest Meadow"
}, {
    filename: "spot06_scene",
    label: "Lake Hylia"
}, {
    filename: "spot07_scene",
    label: "Zora's Domain"
}, {
    filename: "spot08_scene",
    label: "Zora's Fountain"
}, {
    filename: "spot09_scene",
    label: "Gerudo Valley"
}, {
    filename: "spot10_scene",
    label: "Lost Woods"
}, {
    filename: "spot11_scene",
    label: "Desert Colossus"
}, {
    filename: "spot12_scene",
    label: "Gerudo's Fortress"
}, {
    filename: "spot13_scene",
    label: "Haunted Wasteland"
}, {
    filename: "spot15_scene",
    label: "Hyrule Castle"
}, {
    filename: "spot16_scene",
    label: "Death Mountain"
}, {
    filename: "spot17_scene",
    label: "Death Mountain Crater"
}, {
    filename: "spot18_scene",
    label: "Goron City"
}, {
    filename: "spot20_scene",
    label: "Lon Lon Ranch"
}, {
    filename: "ganon_tou_scene",
    label: "Ganon's Tower (Outside)"
}, {
    filename: "test01_scene",
    label: "Collision Testing Area"
}, {
    filename: "besitu_scene",
    label: "Besitu / Treasure Chest Warp"
}, {
    filename: "depth_test_scene",
    label: "Depth Test"
}, {
    filename: "syotes_scene",
    label: "Stalfos Middle Room"
}, {
    filename: "syotes2_scene",
    label: "Stalfos Boss Room"
}, {
    filename: "sutaru_scene",
    label: "Dark Link Testing Area"
}, {
    filename: "hairal_niwa2_scene",
    label: "Beta Castle Courtyard"
}, {
    filename: "sasatest_scene",
    label: "Action Testing Room"
}, {
    filename: "testroom_scene",
    label: "Item Testing Room"
}].map(function (entry) {
    var path = "data/zelview/" + entry.filename + ".zelview0";
    return new render_1.SceneDesc(entry.label, path);
});
exports.sceneGroup = { id: id, name: name, sceneDescs: sceneDescs };
},{"./render":"zelview\\render.ts"}],"oot3d\\cmb.ts":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("../util");
var VertexBufferSlices = /** @class */function () {
    function VertexBufferSlices() {}
    return VertexBufferSlices;
}();
var CMB = /** @class */function () {
    function CMB() {
        this.textures = [];
        this.materials = [];
        this.sepds = [];
        this.meshs = [];
    }
    return CMB;
}();
exports.CMB = CMB;
var TextureFilter;
(function (TextureFilter) {
    TextureFilter[TextureFilter["NEAREST"] = 9728] = "NEAREST";
    TextureFilter[TextureFilter["LINEAR"] = 9729] = "LINEAR";
    TextureFilter[TextureFilter["NEAREST_MIPMAP_NEAREST"] = 9984] = "NEAREST_MIPMAP_NEAREST";
    TextureFilter[TextureFilter["LINEAR_MIPMAP_NEAREST"] = 9985] = "LINEAR_MIPMAP_NEAREST";
    TextureFilter[TextureFilter["NEAREST_MIPMIP_LINEAR"] = 9986] = "NEAREST_MIPMIP_LINEAR";
    TextureFilter[TextureFilter["LINEAR_MIPMAP_LINEAR"] = 9987] = "LINEAR_MIPMAP_LINEAR";
})(TextureFilter = exports.TextureFilter || (exports.TextureFilter = {}));
var TextureWrapMode;
(function (TextureWrapMode) {
    TextureWrapMode[TextureWrapMode["CLAMP"] = 10496] = "CLAMP";
    TextureWrapMode[TextureWrapMode["REPEAT"] = 10497] = "REPEAT";
})(TextureWrapMode = exports.TextureWrapMode || (exports.TextureWrapMode = {}));
var TextureBinding = /** @class */function () {
    function TextureBinding() {}
    return TextureBinding;
}();
var Material = /** @class */function () {
    function Material() {
        this.textureBindings = [];
    }
    return Material;
}();
exports.Material = Material;
function readMatsChunk(cmb, buffer) {
    var view = buffer.createDataView();
    util_1.assert(util_1.readString(buffer, 0x00, 0x04) === 'mats');
    var count = view.getUint32(0x08, true);
    var offs = 0x0C;
    for (var i = 0; i < count; i++) {
        var mat = new Material();
        var bindingOffs = offs + 0x10;
        for (var j = 0; j < 3; j++) {
            var binding = new TextureBinding();
            binding.textureIdx = view.getInt16(bindingOffs + 0x00, true);
            binding.minFilter = view.getUint16(bindingOffs + 0x04, true);
            binding.magFilter = view.getUint16(bindingOffs + 0x06, true);
            binding.wrapS = view.getUint16(bindingOffs + 0x08, true);
            binding.wrapT = view.getUint16(bindingOffs + 0x0A, true);
            mat.textureBindings.push(binding);
            bindingOffs += 0x18;
        }
        mat.alphaTestEnable = !!view.getUint8(offs + 0x130);
        cmb.materials.push(mat);
        offs += 0x15C;
    }
}
var TextureFormat;
(function (TextureFormat) {
    TextureFormat[TextureFormat["ETC1"] = 26458] = "ETC1";
    TextureFormat[TextureFormat["ETC1A4"] = 26459] = "ETC1A4";
    TextureFormat[TextureFormat["RGBA5551"] = 2150917970] = "RGBA5551";
    TextureFormat[TextureFormat["RGB565"] = 2204329812] = "RGB565";
    TextureFormat[TextureFormat["A8"] = 335636310] = "A8";
    TextureFormat[TextureFormat["L8"] = 335636311] = "L8";
    TextureFormat[TextureFormat["LA8"] = 335636312] = "LA8";
})(TextureFormat || (TextureFormat = {}));
var Texture = /** @class */function () {
    function Texture() {}
    return Texture;
}();
exports.Texture = Texture;
function expand4to8(n) {
    return n << 4 | n;
}
function expand5to8(n) {
    return n << 8 - 5 | n >>> 10 - 8;
}
function expand6to8(n) {
    return n << 8 - 6 | n >>> 12 - 8;
}
function decodeTexture_ETC1_4x4_Color(dst, w1, w2, dstOffs, stride) {
    // w1 = Upper 32-bit word, "control" data
    // w2 = Lower 32-bit word, "pixel" data
    // Table 3.17.2 -- Intensity tables for each codeword.
    var intensityTableMap = [[-8, -2, 2, 8], [-17, -5, 5, 17], [-29, -9, 9, 29], [-42, -13, 13, 42], [-60, -18, 18, 60], [-80, -24, 24, 80], [-106, -33, 33, 106], [-183, -47, 48, 183]];
    // Table 3.17.3 -- MSB/LSB colors to modifiers.
    //
    //  msb lsb
    //  --- ---
    //   0  0   small positive value (2nd intensity)
    //   0  1   large positive value (3rd intensity)
    //   1  0   small negative value (1st intensity)
    //   1  1   large negative value (0th intensity)
    //
    // Why the spec doesn't lay out the intensity map in this order,
    // I'll never know...
    var pixelToColorIndex = [2, 3, 1, 0];
    var diff = w1 & 2;
    var flip = w1 & 1;
    // Intensity tables for each block.
    var intensityIndex1 = w1 >> 5 & 0x7;
    var intensityIndex2 = w1 >> 2 & 0x7;
    var intensityTable1 = intensityTableMap[intensityIndex1];
    var intensityTable2 = intensityTableMap[intensityIndex2];
    function signed3(n) {
        // Sign-extend.
        return n << 29 >> 29;
    }
    function clamp(n) {
        if (n < 0) return 0;
        if (n > 255) return 255;
        return n;
    }
    // Get the color table for a given block.
    function getColors(colors, r, g, b, intensityMap) {
        for (var i = 0; i < 4; i++) {
            colors[i * 3 + 0] = clamp(r + intensityMap[i]);
            colors[i * 3 + 1] = clamp(g + intensityMap[i]);
            colors[i * 3 + 2] = clamp(b + intensityMap[i]);
        }
    }
    var colors1 = new Uint8Array(3 * 4);
    var colors2 = new Uint8Array(3 * 4);
    if (diff) {
        var baseR1a = w1 >>> 27 & 0x1F;
        var baseR2d = signed3(w1 >>> 24 & 0x07);
        var baseG1a = w1 >>> 19 & 0x1F;
        var baseG2d = signed3(w1 >>> 16 & 0x07);
        var baseB1a = w1 >>> 11 & 0x1F;
        var baseB2d = signed3(w1 >>> 8 & 0x07);
        var baseR1 = expand5to8(baseR1a);
        var baseR2 = expand5to8(baseR1a + baseR2d);
        var baseG1 = expand5to8(baseG1a);
        var baseG2 = expand5to8(baseG1a + baseG2d);
        var baseB1 = expand5to8(baseB1a);
        var baseB2 = expand5to8(baseB1a + baseB2d);
        getColors(colors1, baseR1, baseG1, baseB1, intensityTable1);
        getColors(colors2, baseR2, baseG2, baseB2, intensityTable2);
    } else {
        var baseR1 = expand4to8(w1 >>> 28 & 0x0F);
        var baseR2 = expand4to8(w1 >>> 24 & 0x0F);
        var baseG1 = expand4to8(w1 >>> 20 & 0x0F);
        var baseG2 = expand4to8(w1 >>> 16 & 0x0F);
        var baseB1 = expand4to8(w1 >>> 12 & 0x0F);
        var baseB2 = expand4to8(w1 >>> 8 & 0x0F);
        getColors(colors1, baseR1, baseG1, baseB1, intensityTable1);
        getColors(colors2, baseR2, baseG2, baseB2, intensityTable2);
    }
    // Go through each pixel and copy the color into the right spot...
    for (var i = 0; i < 16; i++) {
        var lsb = w2 >>> i & 0x01;
        var msb = w2 >>> 16 + i & 0x01;
        var lookup = msb << 1 | lsb;
        var colorsIndex = pixelToColorIndex[lookup];
        // Indexes march down and to the right here.
        var y = i & 0x03;
        var x = i >> 2;
        var dstIndex = dstOffs + (y * stride + x) * 4;
        // Whether we're in block 1 or block 2;
        var whichBlock = void 0;
        // If flipbit=0, the block is divided into two 2x4
        // subblocks side-by-side.
        if (flip === 0) whichBlock = x & 2;else whichBlock = y & 2;
        var colors = whichBlock ? colors2 : colors1;
        dst[dstIndex + 0] = colors[colorsIndex * 3 + 0];
        dst[dstIndex + 1] = colors[colorsIndex * 3 + 1];
        dst[dstIndex + 2] = colors[colorsIndex * 3 + 2];
    }
}
function decodeTexture_ETC1_4x4_Alpha(dst, a1, a2, dstOffs, stride) {
    for (var ax = 0; ax < 2; ax++) {
        for (var ay = 0; ay < 4; ay++) {
            var dstIndex = dstOffs + (ay * stride + ax) * 4;
            dst[dstIndex + 3] = expand4to8(a2 & 0x0F);
            a2 >>= 4;
        }
    }
    for (var ax = 2; ax < 4; ax++) {
        for (var ay = 0; ay < 4; ay++) {
            var dstIndex = dstOffs + (ay * stride + ax) * 4;
            dst[dstIndex + 3] = expand4to8(a1 & 0x0F);
            a1 >>= 4;
        }
    }
}
function decodeTexture_ETC1(texture, texData, alpha) {
    var pixels = new Uint8Array(texture.width * texture.height * 4);
    var stride = texture.width;
    var src = texData.createDataView();
    var offs = 0;
    for (var yy = 0; yy < texture.height; yy += 8) {
        for (var xx = 0; xx < texture.width; xx += 8) {
            // Order of each set of 4 blocks: top left, top right, bottom left, bottom right...
            for (var y = 0; y < 8; y += 4) {
                for (var x = 0; x < 8; x += 4) {
                    var dstOffs = ((yy + y) * stride + (xx + x)) * 4;
                    var a1 = void 0;
                    var a2 = void 0;
                    if (alpha) {
                        // In ETC1A4 mode, we have 8 bytes of per-pixel alpha data preceeding the tile.
                        a2 = src.getUint32(offs + 0x00, true);
                        a1 = src.getUint32(offs + 0x04, true);
                        offs += 0x08;
                    } else {
                        a2 = 0xFFFFFFFF;
                        a1 = 0xFFFFFFFF;
                    }
                    decodeTexture_ETC1_4x4_Alpha(pixels, a1, a2, dstOffs, stride);
                    var w2 = src.getUint32(offs + 0x00, true);
                    var w1 = src.getUint32(offs + 0x04, true);
                    decodeTexture_ETC1_4x4_Color(pixels, w1, w2, dstOffs, stride);
                    offs += 0x08;
                }
            }
        }
    }
    return pixels;
}
function decodeTexture_Tiled(texture, texData, decoder) {
    var pixels = new Uint8Array(texture.width * texture.height * 4);
    var stride = texture.width;
    function morton7(n) {
        // 0a0b0c => 000abc
        return n >> 2 & 0x04 | n >> 1 & 0x02 | n & 0x01;
    }
    for (var yy = 0; yy < texture.height; yy += 8) {
        for (var xx = 0; xx < texture.width; xx += 8) {
            // Iterate in Morton order inside each tile.
            for (var i = 0; i < 0x40; i++) {
                var x = morton7(i);
                var y = morton7(i >> 1);
                var dstOffs = ((yy + y) * stride + xx + x) * 4;
                decoder(pixels, dstOffs);
            }
        }
    }
    return pixels;
}
function decodeTexture_RGBA5551(texture, texData) {
    var src = texData.createDataView();
    var srcOffs = 0;
    return decodeTexture_Tiled(texture, texData, function (pixels, dstOffs) {
        var p = src.getUint16(srcOffs, true);
        pixels[dstOffs + 0] = expand5to8(p >> 11 & 0x1F);
        pixels[dstOffs + 1] = expand5to8(p >> 6 & 0x1F);
        pixels[dstOffs + 2] = expand5to8(p >> 1 & 0x1F);
        pixels[dstOffs + 3] = p & 0x01 ? 0xFF : 0x00;
        srcOffs += 2;
    });
}
function decodeTexture_RGB565(texture, texData) {
    var src = texData.createDataView();
    var srcOffs = 0;
    return decodeTexture_Tiled(texture, texData, function (pixels, dstOffs) {
        var p = src.getUint16(srcOffs, true);
        pixels[dstOffs + 0] = expand5to8(p >> 11 & 0x1F);
        pixels[dstOffs + 1] = expand6to8(p >> 5 & 0x3F);
        pixels[dstOffs + 2] = expand5to8(p & 0x1F);
        pixels[dstOffs + 3] = 0xFF;
        srcOffs += 2;
    });
}
function decodeTexture_A8(texture, texData) {
    var src = texData.createDataView();
    var srcOffs = 0;
    return decodeTexture_Tiled(texture, texData, function (pixels, dstOffs) {
        var A = src.getUint8(srcOffs++);
        pixels[dstOffs + 0] = 0xFF;
        pixels[dstOffs + 1] = 0xFF;
        pixels[dstOffs + 2] = 0xFF;
        pixels[dstOffs + 3] = A;
    });
}
function decodeTexture_L8(texture, texData) {
    var src = texData.createDataView();
    var srcOffs = 0;
    return decodeTexture_Tiled(texture, texData, function (pixels, dstOffs) {
        var L = src.getUint8(srcOffs++);
        pixels[dstOffs + 0] = L;
        pixels[dstOffs + 1] = L;
        pixels[dstOffs + 2] = L;
        pixels[dstOffs + 3] = L;
    });
}
function decodeTexture_LA8(texture, texData) {
    var src = texData.createDataView();
    var srcOffs = 0;
    return decodeTexture_Tiled(texture, texData, function (pixels, dstOffs) {
        var L = src.getUint8(srcOffs++);
        var A = src.getUint8(srcOffs++);
        pixels[dstOffs + 0] = L;
        pixels[dstOffs + 1] = L;
        pixels[dstOffs + 2] = L;
        pixels[dstOffs + 3] = A;
    });
}
function decodeTexture(texture, texData) {
    switch (texture.format) {
        case TextureFormat.ETC1:
            return decodeTexture_ETC1(texture, texData, false);
        case TextureFormat.ETC1A4:
            return decodeTexture_ETC1(texture, texData, true);
        case TextureFormat.RGBA5551:
            return decodeTexture_RGBA5551(texture, texData);
        case TextureFormat.RGB565:
            return decodeTexture_RGB565(texture, texData);
        case TextureFormat.A8:
            return decodeTexture_A8(texture, texData);
        case TextureFormat.L8:
            return decodeTexture_L8(texture, texData);
        case TextureFormat.LA8:
            return decodeTexture_LA8(texture, texData);
        default:
            throw new Error("Unsupported texture type! " + texture.format);
    }
}
function readTexChunk(cmb, buffer, texData) {
    var view = buffer.createDataView();
    util_1.assert(util_1.readString(buffer, 0x00, 0x04) === 'tex ');
    var count = view.getUint32(0x08, true);
    var offs = 0x0C;
    for (var i = 0; i < count; i++) {
        var texture = new Texture();
        var size = view.getUint32(offs + 0x00, true);
        texture.width = view.getUint16(offs + 0x08, true);
        texture.height = view.getUint16(offs + 0x0A, true);
        texture.format = view.getUint32(offs + 0x0C, true);
        var dataOffs = view.getUint32(offs + 0x10, true);
        texture.name = util_1.readString(buffer, offs + 0x14, 0x10);
        texture.name = texture.name + "  (" + texture.format + ")";
        offs += 0x24;
        texture.pixels = decodeTexture(texture, texData.slice(dataOffs, dataOffs + size));
        cmb.textures.push(texture);
    }
}
function readVatrChunk(cmb, buffer) {
    var view = buffer.createDataView();
    util_1.assert(util_1.readString(buffer, 0x00, 0x04) === 'vatr');
    cmb.vertexBufferSlices = new VertexBufferSlices();
    var posSize = view.getUint32(0x0C, true);
    var posOffs = view.getUint32(0x10, true);
    cmb.vertexBufferSlices.posBuffer = buffer.slice(posOffs, posOffs + posSize);
    var nrmSize = view.getUint32(0x14, true);
    var nrmOffs = view.getUint32(0x18, true);
    cmb.vertexBufferSlices.nrmBuffer = buffer.slice(nrmOffs, nrmOffs + nrmSize);
    var colSize = view.getUint32(0x1C, true);
    var colOffs = view.getUint32(0x20, true);
    cmb.vertexBufferSlices.colBuffer = buffer.slice(colOffs, colOffs + colSize);
    var txcSize = view.getUint32(0x24, true);
    var txcOffs = view.getUint32(0x28, true);
    cmb.vertexBufferSlices.txcBuffer = buffer.slice(txcOffs, txcOffs + txcSize);
}
var Mesh = /** @class */function () {
    function Mesh() {}
    return Mesh;
}();
exports.Mesh = Mesh;
function readMshsChunk(cmb, buffer) {
    var view = buffer.createDataView();
    util_1.assert(util_1.readString(buffer, 0x00, 0x04) === 'mshs');
    var count = view.getUint32(0x08, true);
    var offs = 0x10;
    for (var i = 0; i < count; i++) {
        var mesh = new Mesh();
        mesh.sepdIdx = view.getUint16(offs, true);
        mesh.matsIdx = view.getUint8(offs + 2);
        cmb.meshs.push(mesh);
        offs += 0x04;
    }
}
var DataType;
(function (DataType) {
    DataType[DataType["Byte"] = 5120] = "Byte";
    DataType[DataType["UByte"] = 5121] = "UByte";
    DataType[DataType["Short"] = 5122] = "Short";
    DataType[DataType["UShort"] = 5123] = "UShort";
    DataType[DataType["Int"] = 5124] = "Int";
    DataType[DataType["UInt"] = 5125] = "UInt";
    DataType[DataType["Float"] = 5126] = "Float";
})(DataType = exports.DataType || (exports.DataType = {}));
var Prm = /** @class */function () {
    function Prm() {}
    return Prm;
}();
exports.Prm = Prm;
function readPrmChunk(cmb, buffer) {
    var view = buffer.createDataView();
    util_1.assert(util_1.readString(buffer, 0x00, 0x04) === 'prm ');
    var prm = new Prm();
    prm.indexType = view.getUint32(0x10, true);
    prm.count = view.getUint16(0x14, true);
    prm.offset = view.getUint16(0x16, true);
    return prm;
}
function readPrmsChunk(cmb, buffer) {
    var view = buffer.createDataView();
    util_1.assert(util_1.readString(buffer, 0x00, 0x04) === 'prms');
    var prmOffs = view.getUint32(0x14, true);
    return readPrmChunk(cmb, buffer.slice(prmOffs));
}
var Sepd = /** @class */function () {
    function Sepd() {
        this.prms = [];
    }
    return Sepd;
}();
exports.Sepd = Sepd;
function readSepdChunk(cmb, buffer) {
    var view = buffer.createDataView();
    util_1.assert(util_1.readString(buffer, 0x00, 0x04) === 'sepd');
    var count = view.getUint16(0x08, true);
    var sepd = new Sepd();
    var offs = 0x108;
    for (var i = 0; i < count; i++) {
        var prmsOffs = view.getUint32(offs, true);
        sepd.prms.push(readPrmsChunk(cmb, buffer.slice(prmsOffs)));
        offs += 0x02;
    }
    sepd.posStart = view.getUint32(0x24, true);
    sepd.posScale = view.getFloat32(0x28, true);
    sepd.posType = view.getUint16(0x2C, true);
    sepd.nrmStart = view.getUint32(0x40, true);
    sepd.nrmScale = view.getFloat32(0x44, true);
    sepd.nrmType = view.getUint16(0x48, true);
    sepd.colStart = view.getUint32(0x5C, true);
    sepd.colScale = view.getFloat32(0x60, true);
    sepd.colType = view.getUint16(0x64, true);
    sepd.txcStart = view.getUint32(0x78, true);
    sepd.txcScale = view.getFloat32(0x7C, true);
    sepd.txcType = view.getUint16(0x80, true);
    return sepd;
}
function readShpChunk(cmb, buffer) {
    var view = buffer.createDataView();
    util_1.assert(util_1.readString(buffer, 0x00, 0x04) === 'shp ');
    var count = view.getUint32(0x08, true);
    var offs = 0x10;
    for (var i = 0; i < count; i++) {
        var sepdOffs = view.getUint16(offs, true);
        var sepd = readSepdChunk(cmb, buffer.slice(sepdOffs));
        cmb.sepds.push(sepd);
        offs += 0x02;
    }
}
function readSklmChunk(cmb, buffer) {
    var view = buffer.createDataView();
    util_1.assert(util_1.readString(buffer, 0x00, 0x04) === 'sklm');
    var mshsChunkOffs = view.getUint32(0x08, true);
    readMshsChunk(cmb, buffer.slice(mshsChunkOffs));
    var shpChunkOffs = view.getUint32(0x0C, true);
    readShpChunk(cmb, buffer.slice(shpChunkOffs));
}
function parse(buffer) {
    var view = buffer.createDataView();
    var cmb = new CMB();
    util_1.assert(util_1.readString(buffer, 0x00, 0x04) === 'cmb ');
    var size = view.getUint32(0x04, true);
    cmb.name = util_1.readString(buffer, 0x10, 0x10);
    var matsChunkOffs = view.getUint32(0x28, true);
    readMatsChunk(cmb, buffer.slice(matsChunkOffs));
    var texDataOffs = view.getUint32(0x40, true);
    var texChunkOffs = view.getUint32(0x2C, true);
    readTexChunk(cmb, buffer.slice(texChunkOffs), buffer.slice(texDataOffs));
    var vatrChunkOffs = view.getUint32(0x38, true);
    readVatrChunk(cmb, buffer.slice(vatrChunkOffs));
    var sklmChunkOffs = view.getUint32(0x30, true);
    readSklmChunk(cmb, buffer.slice(sklmChunkOffs));
    var idxDataOffs = view.getUint32(0x3C, true);
    var idxDataCount = view.getUint32(0x20, true);
    cmb.indexBuffer = buffer.slice(idxDataOffs, idxDataOffs + idxDataCount * 2);
    return cmb;
}
exports.parse = parse;
},{"../util":"util.ts"}],"oot3d\\zsi.ts":[function(require,module,exports) {
"use strict";

var __importStar = this && this.__importStar || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) {
        if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    }result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var CMB = __importStar(require("./cmb"));
var util_1 = require("../util");
var ZSI = /** @class */function () {
    function ZSI() {}
    return ZSI;
}();
exports.ZSI = ZSI;
// Subset of Z64 command types.
var HeaderCommands;
(function (HeaderCommands) {
    HeaderCommands[HeaderCommands["Collision"] = 3] = "Collision";
    HeaderCommands[HeaderCommands["Rooms"] = 4] = "Rooms";
    HeaderCommands[HeaderCommands["Mesh"] = 10] = "Mesh";
    HeaderCommands[HeaderCommands["End"] = 20] = "End";
})(HeaderCommands || (HeaderCommands = {}));
var Mesh = /** @class */function () {
    function Mesh() {}
    return Mesh;
}();
exports.Mesh = Mesh;
function readRooms(buffer, nRooms, offs) {
    var rooms = [];
    for (var i = 0; i < nRooms; i++) {
        rooms.push(util_1.readString(buffer, offs, 0x44));
        offs += 0x44;
    }
    return rooms;
}
function readMesh(buffer, offs) {
    var mesh = new Mesh();
    var view = buffer.createDataView();
    var hdr = view.getUint32(offs);
    var type = hdr >> 24;
    var nEntries = hdr >> 16 & 0xFF;
    var entriesAddr = view.getUint32(offs + 4, true);
    util_1.assert(type === 0x02);
    util_1.assert(nEntries === 0x01);
    var opaqueAddr = view.getUint32(entriesAddr + 0x08, true);
    var transparentAddr = view.getUint32(entriesAddr + 0x0C, true);
    if (opaqueAddr !== 0) mesh.opaque = CMB.parse(buffer.slice(opaqueAddr));
    if (transparentAddr !== 0) mesh.transparent = CMB.parse(buffer.slice(transparentAddr));
    mesh.textures = [];
    if (mesh.opaque) mesh.textures = mesh.textures.concat(mesh.opaque.textures);
    if (mesh.transparent) mesh.textures = mesh.textures.concat(mesh.transparent.textures);
    return mesh;
}
function readCollision(buffer, offs) {
    var view = buffer.createDataView();
    var waterboxTableCount = view.getUint16(offs + 0x14, true);
    var waterboxTableOffs = view.getUint32(offs + 0x28, true);
    var waterboxes = new Uint16Array(waterboxTableCount * 3 * 4);
    var waterboxTableIdx = waterboxTableOffs;
    for (var i = 0; i < waterboxTableCount; i++) {
        var x = view.getInt16(waterboxTableIdx + 0x00, true);
        var y = view.getInt16(waterboxTableIdx + 0x02, true);
        var z = view.getInt16(waterboxTableIdx + 0x04, true);
        var sx = view.getInt16(waterboxTableIdx + 0x06, true);
        var sz = view.getInt16(waterboxTableIdx + 0x08, true);
        waterboxes[i * 3 * 4 + 0] = x;
        waterboxes[i * 3 * 4 + 1] = y;
        waterboxes[i * 3 * 4 + 2] = z;
        waterboxes[i * 3 * 4 + 3] = x + sx;
        waterboxes[i * 3 * 4 + 4] = y;
        waterboxes[i * 3 * 4 + 5] = z;
        waterboxes[i * 3 * 4 + 6] = x;
        waterboxes[i * 3 * 4 + 7] = y;
        waterboxes[i * 3 * 4 + 8] = z + sz;
        waterboxes[i * 3 * 4 + 9] = x + sx;
        waterboxes[i * 3 * 4 + 10] = y;
        waterboxes[i * 3 * 4 + 11] = z + sz;
        waterboxTableIdx += 0x10;
    }
    return { waterboxes: waterboxes };
}
// ZSI headers are a slight modification of the original Z64 headers.
function readHeaders(buffer) {
    var view = buffer.createDataView();
    var offs = 0;
    var zsi = new ZSI();
    while (true) {
        var cmd1 = view.getUint32(offs, false);
        var cmd2 = view.getUint32(offs + 4, true);
        offs += 8;
        var cmdType = cmd1 >> 24;
        if (cmdType == HeaderCommands.End) break;
        switch (cmdType) {
            case HeaderCommands.Rooms:
                var nRooms = cmd1 >> 16 & 0xFF;
                zsi.rooms = readRooms(buffer, nRooms, cmd2);
                break;
            case HeaderCommands.Mesh:
                zsi.mesh = readMesh(buffer, cmd2);
                break;
            case HeaderCommands.Collision:
                zsi.collision = readCollision(buffer, cmd2);
                break;
        }
    }
    return zsi;
}
function parse(buffer) {
    util_1.assert(util_1.readString(buffer, 0x00, 0x04) === 'ZSI\x01');
    var name = util_1.readString(buffer, 0x04, 0x0C);
    // ZSI header is done. It's that simple! Now for the actual data.
    var headersBuf = buffer.slice(0x10);
    return readHeaders(headersBuf);
}
exports.parse = parse;
},{"./cmb":"oot3d\\cmb.ts","../util":"util.ts"}],"oot3d\\render.ts":[function(require,module,exports) {
"use strict";

var __extends = this && this.__extends || function () {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
        d.__proto__ = b;
    } || function (d, b) {
        for (var p in b) {
            if (b.hasOwnProperty(p)) d[p] = b[p];
        }
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __values = this && this.__values || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator],
        i = 0;
    if (m) return m.call(o);
    return {
        next: function next() {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
var __importStar = this && this.__importStar || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) {
        if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    }result["default"] = mod;
    return result;
};
var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var CMB = __importStar(require("./cmb"));
var ZSI = __importStar(require("./zsi"));
var Progressable_1 = __importDefault(require("../Progressable"));
var render_1 = require("../render");
var Program_1 = __importDefault(require("../Program"));
var RenderArena_1 = __importDefault(require("../RenderArena"));
var util_1 = require("../util");
var OoT3D_Program = /** @class */function (_super) {
    __extends(OoT3D_Program, _super);
    function OoT3D_Program() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.vert = "\nprecision mediump float;\n\nuniform mat4 u_modelView;\nuniform mat4 u_localMatrix;\nuniform mat4 u_projection;\nuniform float u_posScale;\nuniform float u_uvScale;\nlayout(location = " + OoT3D_Program.a_position + ") in vec3 a_position;\nlayout(location = " + OoT3D_Program.a_uv + ") in vec2 a_uv;\nlayout(location = " + OoT3D_Program.a_color + ") in vec4 a_color;\nvarying vec4 v_color;\nvarying vec2 v_uv;\n\nvoid main() {\n    gl_Position = u_projection * u_modelView * vec4(a_position, 1.0) * u_posScale;\n    v_color = a_color;\n    v_uv = a_uv * u_uvScale;\n    v_uv.t = 1.0 - v_uv.t;\n}";
        _this.frag = "\nprecision mediump float;\nvarying vec2 v_uv;\nvarying vec4 v_color;\nuniform sampler2D u_texture;\nuniform bool u_alphaTest;\n\nvoid main() {\n    gl_FragColor = texture2D(u_texture, v_uv);\n    gl_FragColor *= v_color;\n    if (u_alphaTest && gl_FragColor.a <= 0.8)\n        discard;\n}";
        return _this;
    }
    OoT3D_Program.prototype.bind = function (gl, prog) {
        _super.prototype.bind.call(this, gl, prog);
        this.posScaleLocation = gl.getUniformLocation(prog, "u_posScale");
        this.uvScaleLocation = gl.getUniformLocation(prog, "u_uvScale");
        this.alphaTestLocation = gl.getUniformLocation(prog, "u_alphaTest");
    };
    OoT3D_Program.a_position = 0;
    OoT3D_Program.a_color = 1;
    OoT3D_Program.a_uv = 2;
    return OoT3D_Program;
}(Program_1.default);
function textureToCanvas(texture) {
    var canvas = document.createElement("canvas");
    canvas.width = texture.width;
    canvas.height = texture.height;
    canvas.title = texture.name;
    var ctx = canvas.getContext("2d");
    var imgData = ctx.createImageData(canvas.width, canvas.height);
    for (var i = 0; i < imgData.data.length; i++) {
        imgData.data[i] = texture.pixels[i];
    }ctx.putImageData(imgData, 0, 0);
    var surfaces = [canvas];
    return { name: texture.name, surfaces: surfaces };
}
var Scene = /** @class */function () {
    function Scene(gl, zsi) {
        this.program = new OoT3D_Program();
        this.textures = zsi.mesh.textures.map(function (texture) {
            return textureToCanvas(texture);
        });
        this.zsi = zsi;
        this.arena = new RenderArena_1.default();
        this.model = this.translateModel(gl, zsi.mesh);
    }
    Scene.prototype.render = function (state) {
        var gl = state.gl;
        state.useProgram(this.program);
        state.bindModelView();
        this.model(state);
    };
    Scene.prototype.translateDataType = function (gl, dataType) {
        switch (dataType) {
            case CMB.DataType.Byte:
                return gl.BYTE;
            case CMB.DataType.UByte:
                return gl.UNSIGNED_BYTE;
            case CMB.DataType.Short:
                return gl.SHORT;
            case CMB.DataType.UShort:
                return gl.UNSIGNED_SHORT;
            case CMB.DataType.Int:
                return gl.INT;
            case CMB.DataType.UInt:
                return gl.UNSIGNED_INT;
            case CMB.DataType.Float:
                return gl.FLOAT;
            default:
                throw new Error();
        }
    };
    Scene.prototype.dataTypeSize = function (dataType) {
        switch (dataType) {
            case CMB.DataType.Byte:
                return 1;
            case CMB.DataType.UByte:
                return 1;
            case CMB.DataType.Short:
                return 2;
            case CMB.DataType.UShort:
                return 2;
            case CMB.DataType.Int:
                return 4;
            case CMB.DataType.UInt:
                return 4;
            case CMB.DataType.Float:
                return 4;
            default:
                throw new Error();
        }
    };
    Scene.prototype.translateSepd = function (gl, cmbContext, sepd) {
        var _this = this;
        var vao = this.arena.createVertexArray(gl);
        gl.bindVertexArray(vao);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cmbContext.idxBuffer);
        gl.bindBuffer(gl.ARRAY_BUFFER, cmbContext.posBuffer);
        gl.vertexAttribPointer(OoT3D_Program.a_position, 3, this.translateDataType(gl, sepd.posType), false, 0, sepd.posStart);
        gl.bindBuffer(gl.ARRAY_BUFFER, cmbContext.colBuffer);
        gl.vertexAttribPointer(OoT3D_Program.a_color, 4, this.translateDataType(gl, sepd.colType), true, 0, sepd.colStart);
        gl.bindBuffer(gl.ARRAY_BUFFER, cmbContext.txcBuffer);
        gl.vertexAttribPointer(OoT3D_Program.a_uv, 2, this.translateDataType(gl, sepd.txcType), false, 0, sepd.txcStart);
        gl.enableVertexAttribArray(OoT3D_Program.a_position);
        gl.enableVertexAttribArray(OoT3D_Program.a_color);
        gl.enableVertexAttribArray(OoT3D_Program.a_uv);
        gl.bindVertexArray(null);
        return function () {
            var e_1, _a;
            gl.uniform1f(_this.program.uvScaleLocation, sepd.txcScale);
            gl.uniform1f(_this.program.posScaleLocation, sepd.posScale);
            gl.bindVertexArray(vao);
            try {
                for (var _b = __values(sepd.prms), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var prm = _c.value;
                    gl.drawElements(gl.TRIANGLES, prm.count, _this.translateDataType(gl, prm.indexType), prm.offset * _this.dataTypeSize(prm.indexType));
                }
            } catch (e_1_1) {
                e_1 = { error: e_1_1 };
            } finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                } finally {
                    if (e_1) throw e_1.error;
                }
            }
            gl.bindVertexArray(null);
        };
    };
    Scene.prototype.translateTexture = function (gl, texture) {
        var texId = this.arena.createTexture(gl);
        gl.bindTexture(gl.TEXTURE_2D, texId);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, texture.width, texture.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, texture.pixels);
        return texId;
    };
    Scene.prototype.translateMaterial = function (gl, cmbContext, material) {
        var _this = this;
        function translateWrapMode(wrapMode) {
            switch (wrapMode) {
                case CMB.TextureWrapMode.CLAMP:
                    return gl.CLAMP_TO_EDGE;
                case CMB.TextureWrapMode.REPEAT:
                    return gl.REPEAT;
                default:
                    throw new Error();
            }
        }
        function translateTextureFilter(filter) {
            switch (filter) {
                case CMB.TextureFilter.LINEAR:
                    return gl.LINEAR;
                case CMB.TextureFilter.NEAREST:
                    return gl.NEAREST;
                case CMB.TextureFilter.LINEAR_MIPMAP_LINEAR:
                    return gl.NEAREST;
                case CMB.TextureFilter.LINEAR_MIPMAP_NEAREST:
                    return gl.NEAREST;
                case CMB.TextureFilter.NEAREST_MIPMAP_NEAREST:
                    return gl.NEAREST;
                case CMB.TextureFilter.NEAREST_MIPMIP_LINEAR:
                    return gl.NEAREST;
                default:
                    throw new Error();
            }
        }
        return function () {
            for (var i = 0; i < 1; i++) {
                var binding = material.textureBindings[i];
                if (binding.textureIdx === -1) continue;
                gl.uniform1i(_this.program.alphaTestLocation, material.alphaTestEnable ? 1 : 0);
                gl.activeTexture(gl.TEXTURE0 + i);
                gl.bindTexture(gl.TEXTURE_2D, cmbContext.textures[binding.textureIdx]);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, translateTextureFilter(binding.minFilter));
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, translateTextureFilter(binding.magFilter));
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, translateWrapMode(binding.wrapS));
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, translateWrapMode(binding.wrapT));
            }
        };
    };
    Scene.prototype.translateMesh = function (gl, cmbContext, mesh) {
        var mat = cmbContext.matFuncs[mesh.matsIdx];
        var sepd = cmbContext.sepdFuncs[mesh.sepdIdx];
        return function () {
            mat(mesh);
            sepd();
        };
    };
    Scene.prototype.translateCmb = function (gl, cmb) {
        var _this = this;
        if (!cmb) return function () {};
        var posBuffer = this.arena.createBuffer(gl);
        gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, cmb.vertexBufferSlices.posBuffer.castToBuffer(), gl.STATIC_DRAW);
        var colBuffer = this.arena.createBuffer(gl);
        gl.bindBuffer(gl.ARRAY_BUFFER, colBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, cmb.vertexBufferSlices.colBuffer.castToBuffer(), gl.STATIC_DRAW);
        var nrmBuffer = this.arena.createBuffer(gl);
        gl.bindBuffer(gl.ARRAY_BUFFER, nrmBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, cmb.vertexBufferSlices.nrmBuffer.castToBuffer(), gl.STATIC_DRAW);
        var txcBuffer = this.arena.createBuffer(gl);
        gl.bindBuffer(gl.ARRAY_BUFFER, txcBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, cmb.vertexBufferSlices.txcBuffer.castToBuffer(), gl.STATIC_DRAW);
        var textures = cmb.textures.map(function (texture) {
            return _this.translateTexture(gl, texture);
        });
        var idxBuffer = this.arena.createBuffer(gl);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, idxBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, cmb.indexBuffer.castToBuffer(), gl.STATIC_DRAW);
        var cmbContext = {
            posBuffer: posBuffer,
            colBuffer: colBuffer,
            nrmBuffer: nrmBuffer,
            txcBuffer: txcBuffer,
            idxBuffer: idxBuffer,
            textures: textures
        };
        cmbContext.sepdFuncs = cmb.sepds.map(function (sepd) {
            return _this.translateSepd(gl, cmbContext, sepd);
        });
        cmbContext.matFuncs = cmb.materials.map(function (material) {
            return _this.translateMaterial(gl, cmbContext, material);
        });
        var meshFuncs = cmb.meshs.map(function (mesh) {
            return _this.translateMesh(gl, cmbContext, mesh);
        });
        return function () {
            var e_2, _a;
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, idxBuffer);
            try {
                for (var meshFuncs_1 = __values(meshFuncs), meshFuncs_1_1 = meshFuncs_1.next(); !meshFuncs_1_1.done; meshFuncs_1_1 = meshFuncs_1.next()) {
                    var func = meshFuncs_1_1.value;
                    func();
                }
            } catch (e_2_1) {
                e_2 = { error: e_2_1 };
            } finally {
                try {
                    if (meshFuncs_1_1 && !meshFuncs_1_1.done && (_a = meshFuncs_1.return)) _a.call(meshFuncs_1);
                } finally {
                    if (e_2) throw e_2.error;
                }
            }
        };
    };
    Scene.prototype.translateModel = function (gl, mesh) {
        var opaque = this.translateCmb(gl, mesh.opaque);
        var transparent = this.translateCmb(gl, mesh.transparent);
        var renderFlags = new render_1.RenderFlags();
        renderFlags.blendMode = render_1.BlendMode.ADD;
        renderFlags.depthTest = true;
        renderFlags.cullMode = render_1.CullMode.BACK;
        return function (state) {
            state.useFlags(renderFlags);
            opaque();
            transparent();
        };
    };
    Scene.prototype.destroy = function (gl) {
        this.arena.destroy(gl);
    };
    return Scene;
}();
var MultiScene = /** @class */function () {
    function MultiScene(scenes) {
        var e_3, _a;
        this.scenes = scenes;
        this.textures = [];
        try {
            for (var _b = __values(this.scenes), _c = _b.next(); !_c.done; _c = _b.next()) {
                var scene = _c.value;
                this.textures = this.textures.concat(scene.textures);
            }
        } catch (e_3_1) {
            e_3 = { error: e_3_1 };
        } finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally {
                if (e_3) throw e_3.error;
            }
        }
    }
    MultiScene.prototype.render = function (renderState) {
        this.scenes.forEach(function (scene) {
            scene.render(renderState);
        });
    };
    MultiScene.prototype.destroy = function (gl) {
        this.scenes.forEach(function (scene) {
            return scene.destroy(gl);
        });
    };
    return MultiScene;
}();
function dirname(path) {
    var parts = path.split('/');
    parts.pop();
    return parts.join('/');
}
var SceneDesc = /** @class */function () {
    function SceneDesc(name, path) {
        this.name = name;
        this.path = path;
        this.id = this.path;
    }
    SceneDesc.prototype.createScene = function (gl) {
        var _this = this;
        return util_1.fetch(this.path).then(function (result) {
            return _this._createSceneFromData(gl, result);
        });
    };
    SceneDesc.prototype._createRoomSceneFromData = function (gl, result) {
        var zsi = ZSI.parse(result);
        util_1.assert(zsi.mesh !== null);
        return new Progressable_1.default(Promise.resolve(new Scene(gl, zsi)));
    };
    SceneDesc.prototype._createSceneFromData = function (gl, result) {
        var _this = this;
        var zsi = ZSI.parse(result);
        util_1.assert(zsi.rooms !== null);
        var basePath = dirname(this.path);
        var roomFilenames = zsi.rooms.map(function (romPath) {
            var filename = romPath.split('/').pop();
            return basePath + '/' + filename;
        });
        return Progressable_1.default.all(roomFilenames.map(function (filename) {
            return util_1.fetch(filename).then(function (roomResult) {
                return _this._createRoomSceneFromData(gl, roomResult);
            });
        })).then(function (scenes) {
            return new MultiScene(scenes);
        });
    };
    return SceneDesc;
}();
exports.SceneDesc = SceneDesc;
},{"./cmb":"oot3d\\cmb.ts","./zsi":"oot3d\\zsi.ts","../Progressable":"Progressable.ts","../render":"render.ts","../Program":"Program.ts","../RenderArena":"RenderArena.ts","../util":"util.ts"}],"oot3d\\scenes.ts":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var render_1 = require("./render");
var id = "oot3d";
var name = "Ocarina of Time 3D";
var sceneDescs = [{ name: "Inside the Deku Tree", filename: "ydan_info.zsi" }, { name: "Inside the Deku Tree (Boss)", filename: "ydan_boss_info.zsi" }, { name: "Dodongo's Cavern", filename: "ddan_info.zsi" }, { name: "Dodongo's Cavern (Boss)", filename: "ddan_boss_info.zsi" }, { name: "Jabu-Jabu's Belly", filename: 'bdan_info.zsi' }, { name: "Jabu-Jabu's Belly (Boss)", filename: 'bdan_boss_info.zsi' }, { name: "Forest Temple", filename: 'bmori1_info.zsi' }, { name: "Forest Temple (Boss)", filename: "moriboss_info.zsi" }, { name: "Fire Temple", filename: "hidan_info.zsi" }, { name: "Fire Temple (Boss)", filename: "fire_bs_info.zsi" }, { name: "Water Temple", filename: "mizusin_info.zsi" }, { name: "Water Temple (Boss)", filename: "mizusin_boss_info.zsi" }, { name: "Spirit Temple", filename: "jyasinzou_info.zsi" }, { name: "Spirit Temple (Mid-Boss)", filename: "jyasinzou_boss_info.zsi" }, { name: "Shadow Temple", filename: "hakadan_info.zsi" }, { name: "Shadow Temple (Boss)", filename: "hakadan_boss_info.zsi" }, { name: "Bottom of the Well", filename: "hakadan_ch_info.zsi" }, { name: "Ice Cavern", filename: "ice_doukutu_info.zsi" }, { name: "Gerudo Training Grounds", filename: "men_info.zsi" }, { name: "Thieve's Hideout", filename: "gerudoway_info.zsi" }, { name: "Ganon's Castle", filename: "ganontika_info.zsi" }, { name: "Ganon's Castle (Crumbling)", filename: "ganontikasonogo_info.zsi" }, { name: "Ganon's Castle (Outside)", filename: "ganon_tou_info.zsi" }, { name: "Ganon's Castle Tower", filename: "ganon_info.zsi" }, { name: "Ganon's Castle Tower (Crumbling)", filename: "ganon_sonogo_info.zsi" }, { name: "Second-To-Last Boss Ganondorf", filename: "ganon_boss_info.zsi" }, { name: "Final Battle Against Ganon", filename: "ganon_demo_info.zsi" }, { name: "Ganondorf's Death", filename: "ganon_final_info.zsi" }, { name: "Hyrule Field", filename: "spot00_info.zsi" }, { name: "Kakariko Village", filename: "spot01_info.zsi" }, { name: "Kakariko Graveyard", filename: "spot02_info.zsi" }, { name: "Zora's River", filename: "spot03_info.zsi" }, { name: "Kokiri Firest", filename: "spot04_info.zsi" }, { name: "Sacred Forest Meadow", filename: "spot05_info.zsi" }, { name: "Lake Hylia", filename: "spot06_info.zsi" }, { name: "Zora's Domain", filename: "spot07_info.zsi" }, { name: "Zora's Fountain", filename: "spot08_info.zsi" }, { name: "Gerudo Valley", filename: "spot09_info.zsi" }, { name: "Lost Woods", filename: "spot10_info.zsi" }, { name: "Desert Colossus", filename: "spot11_info.zsi" }, { name: "Gerudo's Fortress", filename: "spot12_info.zsi" }, { name: "Haunted Wasteland", filename: "spot13_info.zsi" }, { name: "Hyrule Castle", filename: "spot15_info.zsi" }, { name: "Death Mountain", filename: "spot16_info.zsi" }, { name: "Death Mountain Crater", filename: "spot17_info.zsi" }, { name: "Goron City", filename: "spot18_info.zsi" }, { name: "Lon Lon Ranch", filename: "spot20_info.zsi" }, { name: "", filename: "spot99_info.zsi" }, { name: "Market Entrance (Day)", filename: "entra_day_info.zsi" }, { name: "Market Entrance (Night)", filename: "entra_night_info.zsi" }, { name: "Market Entrance (Ruins)", filename: "entra_ruins_info.zsi" }, { name: "Market (Day)", filename: "market_day_info.zsi" }, { name: "Market (Night)", filename: "market_night_info.zsi" }, { name: "Market (Ruins)", filename: "market_ruins_info.zsi" }, { name: "Market Back-Alley (Day)", filename: "market_alley_info.zsi" }, { name: "Market Back-Alley (Night)", filename: "market_alley_n_info.zsi" }, { name: "Lots'o'Pots", filename: "miharigoya_info.zsi" }, { name: "Bombchu Bowling Alley", filename: 'bowling_info.zsi' }, { name: "Temple of Time (Outside, Day)", filename: "shrine_info.zsi" }, { name: "Temple of Time (Outside, Night)", filename: "shrine_n_info.zsi" }, { name: "Temple of Time (Outside, Adult)", filename: "shrine_r_info.zsi" }, { name: "Temple of Time (Interior)", filename: "tokinoma_info.zsi" }, { name: "Chamber of Sages", filename: "kenjyanoma_info.zsi" }, { name: "Zora Shop", filename: "zoora_info.zsi" }, { name: "Dampe's Hut", filename: "hut_info.zsi" }, { name: "Great Fairy Fountain", filename: "daiyousei_izumi_info.zsi" }, { name: "Small Fairy Fountain", filename: "yousei_izumi_tate_info.zsi" }, { name: "Magic Fairy Fountain", filename: "yousei_izumi_yoko_info.zsi" }, { name: "Castle Courtyard", filename: "hairal_niwa_info.zsi" }, { name: "Castle Courtyard (Night)", filename: "hairal_niwa_n_info.zsi" }, { name: '', filename: "hakaana_info.zsi" }, { name: "Grottos", filename: "kakusiana_info.zsi" }, { name: "Royal Family's Tomb", filename: "hakaana_ouke_info.zsi" }, { name: "Dampe's Grave & Windmill Hut", filename: "hakasitarelay_info.zsi" }, { name: "Cutscene Map", filename: "hiral_demo_info.zsi" }, { name: "Hylia Lakeside Laboratory", filename: "hylia_labo_info.zsi" }, { name: "Puppy Woman's House", filename: "kakariko_impa_info.zsi" }, { name: "Skulltula House", filename: "kinsuta_info.zsi" }, { name: "Impa's House", filename: "labo_info.zsi" }, { name: "Granny's Potion Shop", filename: "mahouya_info.zsi" }, { name: "Zelda's Courtyard", filename: "nakaniwa_info.zsi" }, { name: "Market Potion Shop", filename: "shop_alley_info.zsi" }, { name: "Kakariko Potion Shop", filename: "shop_drag_info.zsi" }, { name: "Happy Mask Shop", filename: "shop_face_info.zsi" }, { name: "Goron Shop", filename: "shop_golon_info.zsi" }, { name: "Bombchu Shop", filename: "shop_night_info.zsi" }, { name: "Talon's House", filename: "souko_info.zsi" }, { name: "Stables", filename: "stable_info.zsi" }, { name: "Shooting Gallery", filename: "syatekijyou_info.zsi" }, { name: "Treasure Chest Game", filename: "takaraya_info.zsi" }, { name: "Carpenter's Tent", filename: "tent_info.zsi" }, { name: '', filename: "k_home_info.zsi" }, { name: '', filename: "kakariko_info.zsi" }, { name: '', filename: "kokiri_info.zsi" }, { name: '', filename: "link_info.zsi" }, { name: '', filename: "shop_info.zsi" }, { name: "Fishing Pond", filename: "turibori_info.zsi" }].map(function (entry) {
    var path = "data/oot3d/" + entry.filename;
    var name = entry.name || entry.filename;
    return new render_1.SceneDesc(name, path);
});
exports.sceneGroup = { id: id, name: name, sceneDescs: sceneDescs };
},{"./render":"oot3d\\render.ts"}],"fres\\gx2_surface.ts":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function parseGX2Surface(buffer, gx2SurfaceOffs) {
    var view = buffer.slice(gx2SurfaceOffs, gx2SurfaceOffs + 0x9C).createDataView();
    var dimension = view.getUint32(0x00, false);
    var width = view.getUint32(0x04, false);
    var height = view.getUint32(0x08, false);
    var depth = view.getUint32(0x0C, false);
    var numMips = view.getUint32(0x10, false);
    var format = view.getUint32(0x14, false);
    var aaMode = view.getUint32(0x18, false);
    var texDataSize = view.getUint32(0x20, false);
    var mipDataSize = view.getUint32(0x28, false);
    var tileMode = view.getUint32(0x30, false);
    var swizzle = view.getUint32(0x34, false);
    var align = view.getUint32(0x38, false);
    var pitch = view.getUint32(0x3C, false);
    var mipDataOffsetTableIdx = 0x40;
    var mipDataOffsets = [];
    for (var i = 0; i < 13; i++) {
        mipDataOffsets.push(view.getUint32(mipDataOffsetTableIdx, false));
        mipDataOffsetTableIdx += 0x04;
    }
    var surface = { format: format, tileMode: tileMode, swizzle: swizzle, width: width, height: height, depth: depth, pitch: pitch, numMips: numMips, aaMode: aaMode, texDataSize: texDataSize, mipDataSize: mipDataSize, mipDataOffsets: mipDataOffsets };
    return surface;
}
exports.parseGX2Surface = parseGX2Surface;
},{}],"fres\\bfres.ts":[function(require,module,exports) {
"use strict";

var __values = this && this.__values || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator],
        i = 0;
    if (m) return m.call(o);
    return {
        next: function next() {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", { value: true });
var gx2_surface_1 = require("./gx2_surface");
var util_1 = require("../util");
function readBinPtrT(view, offs, littleEndian) {
    var offs2 = view.getInt32(offs, littleEndian);
    if (offs2 === 0) return 0;else return offs + offs2;
}
function parseResDic(buffer, tableOffs, littleEndian) {
    if (tableOffs === 0) return [];
    var view = buffer.createDataView();
    var tableSize = view.getUint32(tableOffs + 0x00, littleEndian);
    var tableCount = view.getUint32(tableOffs + 0x04, littleEndian);
    util_1.assert(tableCount === tableCount);
    var entries = [];
    var tableIdx = tableOffs + 0x08;
    // Skip root entry.
    tableIdx += 0x10;
    for (var i = 0; i < tableCount; i++) {
        // There's a fancy search tree in here which I don't care about at all...
        var name = util_1.readString(buffer, readBinPtrT(view, tableIdx + 0x08, littleEndian));
        var offs = readBinPtrT(view, tableIdx + 0x0C, littleEndian);
        entries.push({ name: name, offs: offs });
        tableIdx += 0x10;
    }
    return entries;
}
function parseFTEX(buffer, entry, littleEndian) {
    var offs = entry.offs;
    var view = buffer.createDataView();
    util_1.assert(util_1.readString(buffer, offs + 0x00, 0x04) === 'FTEX');
    // GX2 is Wii U which is a little-endian system.
    util_1.assert(!littleEndian);
    var gx2SurfaceOffs = offs + 0x04;
    var surface = gx2_surface_1.parseGX2Surface(buffer, gx2SurfaceOffs);
    var texDataOffs = readBinPtrT(view, offs + 0xB0, littleEndian);
    var mipDataOffs = readBinPtrT(view, offs + 0xB4, littleEndian);
    var texData = buffer.subarray(texDataOffs, surface.texDataSize);
    var mipData = buffer.subarray(mipDataOffs, surface.mipDataSize);
    return { surface: surface, texData: texData, mipData: mipData };
}
var UBOParameterType;
(function (UBOParameterType) {
    UBOParameterType[UBOParameterType["Bool1"] = 0] = "Bool1";
    UBOParameterType[UBOParameterType["Bool2"] = 1] = "Bool2";
    UBOParameterType[UBOParameterType["Bool3"] = 2] = "Bool3";
    UBOParameterType[UBOParameterType["Bool4"] = 3] = "Bool4";
    UBOParameterType[UBOParameterType["Int1"] = 4] = "Int1";
    UBOParameterType[UBOParameterType["Int2"] = 5] = "Int2";
    UBOParameterType[UBOParameterType["Int3"] = 6] = "Int3";
    UBOParameterType[UBOParameterType["Int4"] = 7] = "Int4";
    UBOParameterType[UBOParameterType["Uint1"] = 8] = "Uint1";
    UBOParameterType[UBOParameterType["Uint2"] = 9] = "Uint2";
    UBOParameterType[UBOParameterType["Uint3"] = 10] = "Uint3";
    UBOParameterType[UBOParameterType["Uint4"] = 11] = "Uint4";
    UBOParameterType[UBOParameterType["Float1"] = 12] = "Float1";
    UBOParameterType[UBOParameterType["Float2"] = 13] = "Float2";
    UBOParameterType[UBOParameterType["Float3"] = 14] = "Float3";
    UBOParameterType[UBOParameterType["Float4"] = 15] = "Float4";
    UBOParameterType[UBOParameterType["_Reserved_0"] = 16] = "_Reserved_0";
    UBOParameterType[UBOParameterType["Float2x2"] = 17] = "Float2x2";
    UBOParameterType[UBOParameterType["Float2x3"] = 18] = "Float2x3";
    UBOParameterType[UBOParameterType["Float2x4"] = 19] = "Float2x4";
    UBOParameterType[UBOParameterType["_Reserved_1"] = 20] = "_Reserved_1";
    UBOParameterType[UBOParameterType["Float3x2"] = 21] = "Float3x2";
    UBOParameterType[UBOParameterType["Float3x3"] = 22] = "Float3x3";
    UBOParameterType[UBOParameterType["Float3x4"] = 23] = "Float3x4";
    UBOParameterType[UBOParameterType["_Reserved_2"] = 24] = "_Reserved_2";
    UBOParameterType[UBOParameterType["Float4x2"] = 25] = "Float4x2";
    UBOParameterType[UBOParameterType["Float4x3"] = 26] = "Float4x3";
    UBOParameterType[UBOParameterType["Float4x4"] = 27] = "Float4x4";
    UBOParameterType[UBOParameterType["SRT2D"] = 28] = "SRT2D";
    UBOParameterType[UBOParameterType["SRT3D"] = 29] = "SRT3D";
    UBOParameterType[UBOParameterType["TextureSRT"] = 30] = "TextureSRT";
})(UBOParameterType || (UBOParameterType = {}));
var RenderInfoParameterType;
(function (RenderInfoParameterType) {
    RenderInfoParameterType[RenderInfoParameterType["Int"] = 0] = "Int";
    RenderInfoParameterType[RenderInfoParameterType["Float"] = 1] = "Float";
    RenderInfoParameterType[RenderInfoParameterType["String"] = 2] = "String";
})(RenderInfoParameterType || (RenderInfoParameterType = {}));
;
function parseFMDL(buffer, entry, littleEndian) {
    var e_1, _a, e_2, _b, e_3, _c;
    var offs = entry.offs;
    var view = buffer.createDataView();
    util_1.assert(util_1.readString(buffer, offs + 0x00, 0x04) === 'FMDL');
    var fileName = readBinPtrT(view, offs + 0x04, littleEndian);
    var filePath = readBinPtrT(view, offs + 0x08, littleEndian);
    var fsklOffs = readBinPtrT(view, offs + 0x0C, littleEndian);
    var fvtxOffs = readBinPtrT(view, offs + 0x10, littleEndian);
    var fshpResDic = parseResDic(buffer, readBinPtrT(view, offs + 0x14, littleEndian), littleEndian);
    var fmatResDic = parseResDic(buffer, readBinPtrT(view, offs + 0x18, littleEndian), littleEndian);
    var fvtxCount = view.getUint16(offs + 0x20, littleEndian);
    var fshpCount = view.getUint16(offs + 0x22, littleEndian);
    var fmatCount = view.getUint16(offs + 0x24, littleEndian);
    util_1.assert(fshpCount === fshpResDic.length);
    util_1.assert(fmatCount === fmatResDic.length);
    function readBufferData(offs) {
        var size = view.getUint32(offs + 0x04, littleEndian);
        var stride = view.getUint16(offs + 0x0C, littleEndian);
        var dataOffs = readBinPtrT(view, offs + 0x14, littleEndian);
        var data = buffer.subarray(dataOffs, size);
        return { data: data, stride: stride };
    }
    function parseShaderAssignDict(offs) {
        var e_4, _a;
        var resDic = parseResDic(buffer, offs, littleEndian);
        var entries = [];
        try {
            for (var resDic_1 = __values(resDic), resDic_1_1 = resDic_1.next(); !resDic_1_1.done; resDic_1_1 = resDic_1.next()) {
                var entry_1 = resDic_1_1.value;
                var key = entry_1.name;
                var value = util_1.readString(buffer, entry_1.offs);
                entries.push({ key: key, value: value });
            }
        } catch (e_4_1) {
            e_4 = { error: e_4_1 };
        } finally {
            try {
                if (resDic_1_1 && !resDic_1_1.done && (_a = resDic_1.return)) _a.call(resDic_1);
            } finally {
                if (e_4) throw e_4.error;
            }
        }
        return entries;
    }
    // Vertex buffers.
    var fvtxIdx = fvtxOffs;
    var fvtx = [];
    for (var i = 0; i < fvtxCount; i++) {
        util_1.assert(util_1.readString(buffer, fvtxIdx + 0x00, 0x04) === 'FVTX');
        var attribCount = view.getUint8(fvtxIdx + 0x04);
        var bufferCount = view.getUint8(fvtxIdx + 0x05);
        var sectionIndex = view.getUint16(fvtxIdx + 0x06);
        util_1.assert(i === sectionIndex);
        var vtxCount = view.getUint32(fvtxIdx + 0x08);
        var attribArrayOffs = readBinPtrT(view, fvtxIdx + 0x10, littleEndian);
        var bufferArrayOffs = readBinPtrT(view, fvtxIdx + 0x18, littleEndian);
        var attribs = [];
        var attribArrayIdx = attribArrayOffs;
        for (var j = 0; j < attribCount; j++) {
            var name = util_1.readString(buffer, readBinPtrT(view, attribArrayIdx + 0x00, littleEndian));
            var bufferIndex = view.getUint8(attribArrayIdx + 0x04);
            var bufferStart = view.getUint16(attribArrayIdx + 0x06, littleEndian);
            var format = view.getUint32(attribArrayIdx + 0x08, littleEndian);
            attribs.push({ name: name, bufferIndex: bufferIndex, bufferStart: bufferStart, format: format });
            attribArrayIdx += 0x0C;
        }
        var buffers = [];
        var bufferArrayIdx = bufferArrayOffs;
        for (var j = 0; j < bufferCount; j++) {
            var bufferData = readBufferData(bufferArrayIdx);
            buffers.push(bufferData);
            bufferArrayIdx += 0x18;
        }
        fvtx.push({ buffers: buffers, attribs: attribs, vtxCount: vtxCount });
        fvtxIdx += 0x20;
    }
    // Shapes.
    var fshp = [];
    try {
        for (var fshpResDic_1 = __values(fshpResDic), fshpResDic_1_1 = fshpResDic_1.next(); !fshpResDic_1_1.done; fshpResDic_1_1 = fshpResDic_1.next()) {
            var fshpEntry = fshpResDic_1_1.value;
            var offs_1 = fshpEntry.offs;
            util_1.assert(util_1.readString(buffer, offs_1 + 0x00, 0x04) === 'FSHP');
            var name = util_1.readString(buffer, readBinPtrT(view, offs_1 + 0x04, littleEndian));
            var fmatIndex = view.getUint16(offs_1 + 0x0E, littleEndian);
            var fsklIndex = view.getUint16(offs_1 + 0x10, littleEndian);
            var fvtxIndex = view.getUint16(offs_1 + 0x12, littleEndian);
            // Each mesh corresponds to one LoD.
            var meshArrayCount = view.getUint8(offs_1 + 0x17);
            var meshArrayOffs = readBinPtrT(view, offs_1 + 0x24, littleEndian);
            var meshArrayIdx = meshArrayOffs;
            var meshes = [];
            for (var i = 0; i < meshArrayCount; i++) {
                var primType = view.getUint32(meshArrayIdx + 0x00, littleEndian);
                var indexFormat = view.getUint32(meshArrayIdx + 0x04, littleEndian);
                var indexBufferOffs = readBinPtrT(view, meshArrayIdx + 0x14, littleEndian);
                var indexBufferData = readBufferData(indexBufferOffs);
                var submeshArrayCount = view.getUint16(meshArrayIdx + 0x0C, littleEndian);
                var submeshArrayOffs = readBinPtrT(view, meshArrayIdx + 0x10, littleEndian);
                var submeshArrayIdx = submeshArrayOffs;
                var submeshes = [];
                for (var j = 0; j < submeshArrayCount; j++) {
                    var indexBufferOffset = view.getUint32(submeshArrayIdx + 0x00, littleEndian);
                    var indexBufferCount = view.getUint32(submeshArrayIdx + 0x04, littleEndian);
                    submeshes.push({ indexBufferOffset: indexBufferOffset, indexBufferCount: indexBufferCount });
                    submeshArrayIdx += 0x08;
                }
                meshes.push({ primType: primType, indexFormat: indexFormat, indexBufferData: indexBufferData, submeshes: submeshes });
                meshArrayIdx += 0x1C;
            }
            fshp.push({ name: name, fmatIndex: fmatIndex, fvtxIndex: fvtxIndex, meshes: meshes });
        }
    } catch (e_1_1) {
        e_1 = { error: e_1_1 };
    } finally {
        try {
            if (fshpResDic_1_1 && !fshpResDic_1_1.done && (_a = fshpResDic_1.return)) _a.call(fshpResDic_1);
        } finally {
            if (e_1) throw e_1.error;
        }
    }
    // Materials.
    var fmat = [];
    try {
        for (var fmatResDic_1 = __values(fmatResDic), fmatResDic_1_1 = fmatResDic_1.next(); !fmatResDic_1_1.done; fmatResDic_1_1 = fmatResDic_1.next()) {
            var fmatEntry = fmatResDic_1_1.value;
            var offs_2 = fmatEntry.offs;
            util_1.assert(util_1.readString(buffer, offs_2 + 0x00, 0x04) === 'FMAT');
            var name = util_1.readString(buffer, readBinPtrT(view, offs_2 + 0x04, littleEndian));
            var renderInfoParameterCount = view.getUint16(offs_2 + 0x0E, littleEndian);
            var textureReferenceCount = view.getUint8(offs_2 + 0x10);
            var textureSamplerCount = view.getUint8(offs_2 + 0x11);
            var materialParameterCount = view.getUint16(offs_2 + 0x12);
            var materialParameterDataLength = view.getUint16(offs_2 + 0x16);
            var renderInfoParameterResDic = parseResDic(buffer, readBinPtrT(view, offs_2 + 0x1C, littleEndian), littleEndian);
            var renderStateOffs = readBinPtrT(view, offs_2 + 0x20, littleEndian);
            var shaderAssignOffs = readBinPtrT(view, offs_2 + 0x24, littleEndian);
            var textureReferenceArrayOffs = readBinPtrT(view, offs_2 + 0x28, littleEndian);
            var textureSamplerArrayOffs = readBinPtrT(view, offs_2 + 0x2C, littleEndian);
            var materialParameterArrayOffs = readBinPtrT(view, offs_2 + 0x34, littleEndian);
            var materialParameterDataOffs = readBinPtrT(view, offs_2 + 0x3C, littleEndian);
            var materialParameterDataBuffer = buffer.subarray(materialParameterDataOffs, materialParameterDataLength);
            var renderInfoParameters = [];
            try {
                for (var renderInfoParameterResDic_1 = __values(renderInfoParameterResDic), renderInfoParameterResDic_1_1 = renderInfoParameterResDic_1.next(); !renderInfoParameterResDic_1_1.done; renderInfoParameterResDic_1_1 = renderInfoParameterResDic_1.next()) {
                    var renderInfoParameterEntry = renderInfoParameterResDic_1_1.value;
                    var offs_3 = renderInfoParameterEntry.offs;
                    var arrayLength = view.getUint16(offs_3 + 0x00, littleEndian);
                    var type = view.getUint8(offs_3 + 0x02);
                    var name_1 = util_1.readString(buffer, readBinPtrT(view, offs_3 + 0x04, littleEndian));
                    var arrayIdx = offs_3 + 0x08;
                    switch (type) {
                        case RenderInfoParameterType.Int:
                            {
                                var data = [];
                                for (var i = 0; i < arrayLength; i++) {
                                    data.push(view.getInt32(arrayIdx, littleEndian));
                                    arrayIdx += 0x04;
                                }
                                renderInfoParameters.push({ type: type, name: name_1, data: data });
                                break;
                            }
                        case RenderInfoParameterType.Float:
                            {
                                var data = [];
                                for (var i = 0; i < arrayLength; i++) {
                                    data.push(view.getFloat32(arrayIdx, littleEndian));
                                    arrayIdx += 0x04;
                                }
                                renderInfoParameters.push({ type: type, name: name_1, data: data });
                                break;
                            }
                        case RenderInfoParameterType.String:
                            {
                                var data = [];
                                for (var i = 0; i < arrayLength; i++) {
                                    data.push(util_1.readString(buffer, readBinPtrT(view, arrayIdx, littleEndian)));
                                    arrayIdx += 0x04;
                                }
                                renderInfoParameters.push({ type: type, name: name_1, data: data });
                                break;
                            }
                    }
                }
            } catch (e_3_1) {
                e_3 = { error: e_3_1 };
            } finally {
                try {
                    if (renderInfoParameterResDic_1_1 && !renderInfoParameterResDic_1_1.done && (_c = renderInfoParameterResDic_1.return)) _c.call(renderInfoParameterResDic_1);
                } finally {
                    if (e_3) throw e_3.error;
                }
            }
            util_1.assert(textureSamplerCount === textureReferenceCount);
            var textureSamplerArrayIdx = textureSamplerArrayOffs;
            var textureReferenceArrayIdx = textureReferenceArrayOffs;
            var textureAssigns = [];
            for (var i = 0; i < textureSamplerCount; i++) {
                var samplerParam0 = view.getUint32(textureSamplerArrayIdx + 0x00, littleEndian);
                var samplerParam1 = view.getUint32(textureSamplerArrayIdx + 0x04, littleEndian);
                var samplerParam2 = view.getUint32(textureSamplerArrayIdx + 0x08, littleEndian);
                var attribName = util_1.readString(buffer, readBinPtrT(view, textureSamplerArrayIdx + 0x10, littleEndian));
                var index = view.getUint8(textureSamplerArrayIdx + 0x14);
                util_1.assert(index === i);
                textureSamplerArrayIdx += 0x18;
                var textureName = util_1.readString(buffer, readBinPtrT(view, textureReferenceArrayIdx + 0x00, littleEndian));
                var ftexOffs = readBinPtrT(view, textureReferenceArrayIdx + 0x04, littleEndian);
                textureReferenceArrayIdx += 0x08;
                var texClampU = samplerParam0 >>> 0 & 0x07;
                var texClampV = samplerParam0 >>> 3 & 0x07;
                var texFilterMag = samplerParam0 >>> 9 & 0x03;
                var texFilterMin = samplerParam0 >>> 12 & 0x03;
                var texFilterMip = samplerParam0 >>> 17 & 0x03;
                textureAssigns.push({ attribName: attribName, textureName: textureName, ftexOffs: ftexOffs, texClampU: texClampU, texClampV: texClampV, texFilterMin: texFilterMin, texFilterMag: texFilterMag, texFilterMip: texFilterMip });
            }
            var materialParameterArrayIdx = materialParameterArrayOffs;
            var materialParameters = [];
            for (var i = 0; i < materialParameterCount; i++) {
                var type = view.getUint8(materialParameterArrayIdx + 0x00);
                var size = view.getUint8(materialParameterArrayIdx + 0x01);
                var dataOffs = view.getUint16(materialParameterArrayIdx + 0x02, littleEndian);
                var dependedIndex = view.getUint16(materialParameterArrayIdx + 0x0C, littleEndian);
                var dependIndex = view.getUint16(materialParameterArrayIdx + 0x0E, littleEndian);
                var name_2 = util_1.readString(buffer, readBinPtrT(view, materialParameterArrayIdx + 0x10, littleEndian));
                materialParameterArrayIdx += 0x14;
                materialParameters.push({ type: type, size: size, dataOffs: dataOffs, name: name_2 });
            }
            // Shader assign.
            var shaderArchiveName = util_1.readString(buffer, readBinPtrT(view, shaderAssignOffs + 0x00, littleEndian));
            var shadingModelName = util_1.readString(buffer, readBinPtrT(view, shaderAssignOffs + 0x04, littleEndian));
            var vertShaderInputCount = view.getUint8(shaderAssignOffs + 0x0C);
            var vertShaderInputDict = parseShaderAssignDict(readBinPtrT(view, shaderAssignOffs + 0x10, littleEndian));
            util_1.assert(vertShaderInputDict.length === vertShaderInputCount);
            var fragShaderInputCount = view.getUint8(shaderAssignOffs + 0x0D);
            var fragShaderInputDict = parseShaderAssignDict(readBinPtrT(view, shaderAssignOffs + 0x14, littleEndian));
            util_1.assert(fragShaderInputDict.length === fragShaderInputCount);
            var paramDict = parseShaderAssignDict(readBinPtrT(view, shaderAssignOffs + 0x18, littleEndian));
            var paramCount = view.getUint16(shaderAssignOffs + 0x0E);
            util_1.assert(paramDict.length === paramCount);
            var shaderAssign = {
                shaderArchiveName: shaderArchiveName,
                shadingModelName: shadingModelName,
                vertShaderInputDict: vertShaderInputDict,
                fragShaderInputDict: fragShaderInputDict,
                paramDict: paramDict
            };
            // Render state.
            var renderState0 = view.getUint32(renderStateOffs + 0x00, littleEndian);
            var renderState1 = view.getUint32(renderStateOffs + 0x04, littleEndian);
            var renderState2 = view.getUint32(renderStateOffs + 0x08, littleEndian);
            var cullFront = !!(renderState1 >>> 0 & 0x01);
            var cullBack = !!(renderState1 >>> 1 & 0x01);
            var frontFaceMode = renderState1 >>> 2 & 0x01;
            var depthTest = !!(renderState2 >>> 1 & 0x01);
            var depthWrite = !!(renderState2 >>> 2 & 0x01);
            var depthCompareFunc = renderState2 >> 4 & 0x07;
            var renderState = { cullFront: cullFront, cullBack: cullBack, frontFaceMode: frontFaceMode, depthTest: depthTest, depthWrite: depthWrite, depthCompareFunc: depthCompareFunc };
            fmat.push({ name: name, renderInfoParameters: renderInfoParameters, textureAssigns: textureAssigns, materialParameterDataBuffer: materialParameterDataBuffer, materialParameters: materialParameters, shaderAssign: shaderAssign, renderState: renderState });
        }
    } catch (e_2_1) {
        e_2 = { error: e_2_1 };
    } finally {
        try {
            if (fmatResDic_1_1 && !fmatResDic_1_1.done && (_b = fmatResDic_1.return)) _b.call(fmatResDic_1);
        } finally {
            if (e_2) throw e_2.error;
        }
    }
    return { fvtx: fvtx, fshp: fshp, fmat: fmat };
}
function parse(buffer) {
    var e_5, _a, e_6, _b;
    var view = buffer.createDataView();
    util_1.assert(util_1.readString(buffer, 0x00, 0x04) === 'FRES');
    var littleEndian;
    switch (view.getUint16(0x08, false)) {
        case 0xFEFF:
            littleEndian = false;
            break;
        case 0xFFFE:
            littleEndian = true;
            break;
        default:
            throw new Error("Invalid BOM");
    }
    var version = view.getUint32(0x04, littleEndian);
    var supportedVersions = [0x03040001, 0x03040002, 0x03040004, 0x03050003];
    util_1.assert(supportedVersions.includes(version));
    var fileNameOffs = readBinPtrT(view, 0x14, littleEndian);
    var fileName = util_1.readString(buffer, fileNameOffs);
    function parseResDicIdx(idx) {
        var tableOffs = readBinPtrT(view, 0x20 + idx * 0x04, littleEndian);
        var tableCount = view.getUint16(0x50 + idx * 0x02, littleEndian);
        var resDic = parseResDic(buffer, tableOffs, littleEndian);
        util_1.assert(tableCount === resDic.length);
        return resDic;
    }
    var fmdlTable = parseResDicIdx(0x00);
    var ftexTable = parseResDicIdx(0x01);
    var fskaTable = parseResDicIdx(0x02);
    var textures = [];
    try {
        for (var ftexTable_1 = __values(ftexTable), ftexTable_1_1 = ftexTable_1.next(); !ftexTable_1_1.done; ftexTable_1_1 = ftexTable_1.next()) {
            var entry = ftexTable_1_1.value;
            var texture = parseFTEX(buffer, entry, littleEndian);
            textures.push({ entry: entry, texture: texture });
        }
    } catch (e_5_1) {
        e_5 = { error: e_5_1 };
    } finally {
        try {
            if (ftexTable_1_1 && !ftexTable_1_1.done && (_a = ftexTable_1.return)) _a.call(ftexTable_1);
        } finally {
            if (e_5) throw e_5.error;
        }
    }
    var models = [];
    try {
        for (var fmdlTable_1 = __values(fmdlTable), fmdlTable_1_1 = fmdlTable_1.next(); !fmdlTable_1_1.done; fmdlTable_1_1 = fmdlTable_1.next()) {
            var entry = fmdlTable_1_1.value;
            var fmdl = parseFMDL(buffer, entry, littleEndian);
            models.push({ entry: entry, fmdl: fmdl });
        }
    } catch (e_6_1) {
        e_6 = { error: e_6_1 };
    } finally {
        try {
            if (fmdlTable_1_1 && !fmdlTable_1_1.done && (_b = fmdlTable_1.return)) _b.call(fmdlTable_1);
        } finally {
            if (e_6) throw e_6.error;
        }
    }
    return { textures: textures, models: models };
}
exports.parse = parse;
},{"./gx2_surface":"fres\\gx2_surface.ts","../util":"util.ts"}],"fres\\sarc.ts":[function(require,module,exports) {
"use strict";
// Nintendo SARC archive format.

Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("../util");
function parse(buffer) {
    var view = buffer.createDataView();
    util_1.assert(util_1.readString(buffer, 0x00, 0x04) === 'SARC');
    var littleEndian;
    switch (view.getUint16(0x06, false)) {
        case 0xFEFF:
            littleEndian = false;
            break;
        case 0xFFFE:
            littleEndian = true;
            break;
        default:
            throw new Error("Invalid BOM");
    }
    util_1.assert(view.getUint16(0x04, littleEndian) === 0x14); // Header length.
    var dataOffset = view.getUint32(0x0C, littleEndian);
    var version = view.getUint16(0x10, littleEndian);
    util_1.assert(version === 0x100);
    util_1.assert(util_1.readString(buffer, 0x14, 0x04) === 'SFAT');
    util_1.assert(view.getUint16(0x18, littleEndian) === 0x0C);
    var fileCount = view.getUint16(0x1A, littleEndian);
    var sfntTableOffs = 0x20 + 0x10 * fileCount;
    util_1.assert(util_1.readString(buffer, sfntTableOffs, 0x04) === 'SFNT');
    util_1.assert(view.getUint16(sfntTableOffs + 0x04, littleEndian) === 0x08);
    var sfntStringTableOffs = sfntTableOffs + 0x08;
    var files = [];
    var fileTableIdx = 0x20;
    for (var i = 0; i < fileCount; i++) {
        var nameHash = view.getUint32(fileTableIdx + 0x00, littleEndian);
        var flags = view.getUint16(fileTableIdx + 0x04, littleEndian);
        var name = void 0;
        if (flags & 0x0100) {
            var nameOffs = view.getUint16(fileTableIdx + 0x06, littleEndian) * 4;
            name = util_1.readString(buffer, sfntStringTableOffs + nameOffs, 0xFF);
        } else {
            name = null;
        }
        var fileStart = view.getUint32(fileTableIdx + 0x08, littleEndian);
        var fileEnd = view.getUint32(fileTableIdx + 0x0C, littleEndian);
        var startOffs = dataOffset + fileStart;
        var endOffs = dataOffset + fileEnd;
        files.push({ name: name, offset: startOffs, buffer: buffer.slice(startOffs, endOffs) });
        fileTableIdx += 0x10;
    }
    return { buffer: buffer, files: files };
}
exports.parse = parse;
},{"../util":"util.ts"}],"fres\\gx2_enum.ts":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var GX2Dimension;
(function (GX2Dimension) {
    GX2Dimension[GX2Dimension["_2D"] = 1] = "_2D";
    GX2Dimension[GX2Dimension["_2D_ARRAY"] = 5] = "_2D_ARRAY";
    GX2Dimension[GX2Dimension["_2D_MSAA"] = 6] = "_2D_MSAA";
})(GX2Dimension = exports.GX2Dimension || (exports.GX2Dimension = {}));
var GX2SurfaceFormat;
(function (GX2SurfaceFormat) {
    GX2SurfaceFormat[GX2SurfaceFormat["FLAG_SRGB"] = 1024] = "FLAG_SRGB";
    GX2SurfaceFormat[GX2SurfaceFormat["FLAG_SNORM"] = 512] = "FLAG_SNORM";
    GX2SurfaceFormat[GX2SurfaceFormat["FMT_MASK"] = 63] = "FMT_MASK";
    GX2SurfaceFormat[GX2SurfaceFormat["FMT_BC1"] = 49] = "FMT_BC1";
    GX2SurfaceFormat[GX2SurfaceFormat["FMT_BC3"] = 51] = "FMT_BC3";
    GX2SurfaceFormat[GX2SurfaceFormat["FMT_BC4"] = 52] = "FMT_BC4";
    GX2SurfaceFormat[GX2SurfaceFormat["FMT_BC5"] = 53] = "FMT_BC5";
    GX2SurfaceFormat[GX2SurfaceFormat["FMT_TCS_R8_G8_B8_A8"] = 26] = "FMT_TCS_R8_G8_B8_A8";
    GX2SurfaceFormat[GX2SurfaceFormat["BC1_UNORM"] = 49] = "BC1_UNORM";
    GX2SurfaceFormat[GX2SurfaceFormat["BC1_SRGB"] = 1073] = "BC1_SRGB";
    GX2SurfaceFormat[GX2SurfaceFormat["BC3_UNORM"] = 51] = "BC3_UNORM";
    GX2SurfaceFormat[GX2SurfaceFormat["BC3_SRGB"] = 1075] = "BC3_SRGB";
    GX2SurfaceFormat[GX2SurfaceFormat["BC4_UNORM"] = 52] = "BC4_UNORM";
    GX2SurfaceFormat[GX2SurfaceFormat["BC4_SNORM"] = 564] = "BC4_SNORM";
    GX2SurfaceFormat[GX2SurfaceFormat["BC5_UNORM"] = 53] = "BC5_UNORM";
    GX2SurfaceFormat[GX2SurfaceFormat["BC5_SNORM"] = 565] = "BC5_SNORM";
    GX2SurfaceFormat[GX2SurfaceFormat["TCS_R8_G8_B8_A8_UNORM"] = 26] = "TCS_R8_G8_B8_A8_UNORM";
    GX2SurfaceFormat[GX2SurfaceFormat["TCS_R8_G8_B8_A8_SRGB"] = 1050] = "TCS_R8_G8_B8_A8_SRGB";
})(GX2SurfaceFormat = exports.GX2SurfaceFormat || (exports.GX2SurfaceFormat = {}));
var GX2TileMode;
(function (GX2TileMode) {
    GX2TileMode[GX2TileMode["_1D_TILED_THIN1"] = 2] = "_1D_TILED_THIN1";
    GX2TileMode[GX2TileMode["_2D_TILED_THIN1"] = 4] = "_2D_TILED_THIN1";
})(GX2TileMode = exports.GX2TileMode || (exports.GX2TileMode = {}));
var GX2AAMode;
(function (GX2AAMode) {
    GX2AAMode[GX2AAMode["_1X"] = 0] = "_1X";
    GX2AAMode[GX2AAMode["_2X"] = 1] = "_2X";
    GX2AAMode[GX2AAMode["_4X"] = 2] = "_4X";
    GX2AAMode[GX2AAMode["_8X"] = 3] = "_8X";
})(GX2AAMode = exports.GX2AAMode || (exports.GX2AAMode = {}));
var GX2PrimitiveType;
(function (GX2PrimitiveType) {
    GX2PrimitiveType[GX2PrimitiveType["TRIANGLES"] = 4] = "TRIANGLES";
})(GX2PrimitiveType = exports.GX2PrimitiveType || (exports.GX2PrimitiveType = {}));
var GX2IndexFormat;
(function (GX2IndexFormat) {
    GX2IndexFormat[GX2IndexFormat["U16_LE"] = 0] = "U16_LE";
    GX2IndexFormat[GX2IndexFormat["U32_LE"] = 1] = "U32_LE";
    GX2IndexFormat[GX2IndexFormat["U16"] = 4] = "U16";
    GX2IndexFormat[GX2IndexFormat["U32"] = 9] = "U32";
})(GX2IndexFormat = exports.GX2IndexFormat || (exports.GX2IndexFormat = {}));
var GX2AttribFormat;
(function (GX2AttribFormat) {
    GX2AttribFormat[GX2AttribFormat["_8_UNORM"] = 0] = "_8_UNORM";
    GX2AttribFormat[GX2AttribFormat["_8_UINT"] = 256] = "_8_UINT";
    GX2AttribFormat[GX2AttribFormat["_8_SNORM"] = 512] = "_8_SNORM";
    GX2AttribFormat[GX2AttribFormat["_8_SINT"] = 768] = "_8_SINT";
    GX2AttribFormat[GX2AttribFormat["_8_8_UNORM"] = 4] = "_8_8_UNORM";
    GX2AttribFormat[GX2AttribFormat["_8_8_SNORM"] = 516] = "_8_8_SNORM";
    GX2AttribFormat[GX2AttribFormat["_8_8_8_8_UNORM"] = 10] = "_8_8_8_8_UNORM";
    GX2AttribFormat[GX2AttribFormat["_8_8_8_8_SNORM"] = 522] = "_8_8_8_8_SNORM";
    GX2AttribFormat[GX2AttribFormat["_16_16_UNORM"] = 7] = "_16_16_UNORM";
    GX2AttribFormat[GX2AttribFormat["_16_16_SNORM"] = 519] = "_16_16_SNORM";
    GX2AttribFormat[GX2AttribFormat["_10_10_10_2_UNORM"] = 11] = "_10_10_10_2_UNORM";
    GX2AttribFormat[GX2AttribFormat["_10_10_10_2_SNORM"] = 523] = "_10_10_10_2_SNORM";
    GX2AttribFormat[GX2AttribFormat["_16_16_16_16_UNORM"] = 14] = "_16_16_16_16_UNORM";
    GX2AttribFormat[GX2AttribFormat["_16_16_16_16_SNORM"] = 526] = "_16_16_16_16_SNORM";
    GX2AttribFormat[GX2AttribFormat["_16_16_FLOAT"] = 2056] = "_16_16_FLOAT";
    GX2AttribFormat[GX2AttribFormat["_16_16_16_16_FLOAT"] = 2063] = "_16_16_16_16_FLOAT";
    GX2AttribFormat[GX2AttribFormat["_32_32_FLOAT"] = 2061] = "_32_32_FLOAT";
    GX2AttribFormat[GX2AttribFormat["_32_32_32_FLOAT"] = 2065] = "_32_32_32_FLOAT";
})(GX2AttribFormat = exports.GX2AttribFormat || (exports.GX2AttribFormat = {}));
var GX2TexClamp;
(function (GX2TexClamp) {
    GX2TexClamp[GX2TexClamp["WRAP"] = 0] = "WRAP";
    GX2TexClamp[GX2TexClamp["MIRROR"] = 1] = "MIRROR";
    GX2TexClamp[GX2TexClamp["CLAMP"] = 2] = "CLAMP";
})(GX2TexClamp = exports.GX2TexClamp || (exports.GX2TexClamp = {}));
var GX2TexXYFilterType;
(function (GX2TexXYFilterType) {
    GX2TexXYFilterType[GX2TexXYFilterType["POINT"] = 0] = "POINT";
    GX2TexXYFilterType[GX2TexXYFilterType["BILINEAR"] = 1] = "BILINEAR";
})(GX2TexXYFilterType = exports.GX2TexXYFilterType || (exports.GX2TexXYFilterType = {}));
var GX2TexMipFilterType;
(function (GX2TexMipFilterType) {
    GX2TexMipFilterType[GX2TexMipFilterType["NO_MIP"] = 0] = "NO_MIP";
    GX2TexMipFilterType[GX2TexMipFilterType["POINT"] = 1] = "POINT";
    GX2TexMipFilterType[GX2TexMipFilterType["LINEAR"] = 2] = "LINEAR";
})(GX2TexMipFilterType = exports.GX2TexMipFilterType || (exports.GX2TexMipFilterType = {}));
var GX2CompareFunction;
(function (GX2CompareFunction) {
    GX2CompareFunction[GX2CompareFunction["NEVER"] = 0] = "NEVER";
    GX2CompareFunction[GX2CompareFunction["LESS"] = 1] = "LESS";
    GX2CompareFunction[GX2CompareFunction["EQUAL"] = 2] = "EQUAL";
    GX2CompareFunction[GX2CompareFunction["LEQUAL"] = 3] = "LEQUAL";
    GX2CompareFunction[GX2CompareFunction["GREATER"] = 4] = "GREATER";
    GX2CompareFunction[GX2CompareFunction["NOTEQUAL"] = 5] = "NOTEQUAL";
    GX2CompareFunction[GX2CompareFunction["GEQUAL"] = 6] = "GEQUAL";
    GX2CompareFunction[GX2CompareFunction["ALWAYS"] = 7] = "ALWAYS";
})(GX2CompareFunction = exports.GX2CompareFunction || (exports.GX2CompareFunction = {}));
var GX2FrontFaceMode;
(function (GX2FrontFaceMode) {
    GX2FrontFaceMode[GX2FrontFaceMode["CCW"] = 0] = "CCW";
    GX2FrontFaceMode[GX2FrontFaceMode["CW"] = 1] = "CW";
})(GX2FrontFaceMode = exports.GX2FrontFaceMode || (exports.GX2FrontFaceMode = {}));
},{}],"worker_util.ts":[function(require,module,exports) {
"use strict";

var __values = this && this.__values || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator],
        i = 0;
    if (m) return m.call(o);
    return {
        next: function next() {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("./util");
var WorkerManager = /** @class */function () {
    function WorkerManager(worker, onworkerdone) {
        this.worker = worker;
        this.onworkerdone = onworkerdone;
        this.currentRequest = null;
        this.worker.onmessage = this._workerOnMessage.bind(this);
    }
    WorkerManager.prototype._workerOnMessage = function (e) {
        var resp = e.data;
        this.currentRequest = util_1.assertExists(this.currentRequest);
        this.currentRequest.resolve(resp);
        this.currentRequest = null;
        this.onworkerdone();
    };
    WorkerManager.prototype.execute = function (req) {
        this.currentRequest = req;
        this.worker.postMessage(req.request);
    };
    WorkerManager.prototype.isFree = function () {
        return this.currentRequest === null;
    };
    WorkerManager.prototype.terminate = function () {
        return this.worker.terminate();
    };
    return WorkerManager;
}();
var WorkerPool = /** @class */function () {
    function WorkerPool(workerConstructor, numWorkers) {
        if (numWorkers === void 0) {
            numWorkers = 8;
        }
        this.workerConstructor = workerConstructor;
        this.numWorkers = numWorkers;
        this.outstandingRequests = [];
        this.workers = [];
    }
    WorkerPool.prototype.terminate = function () {
        var e_1, _a;
        try {
            for (var _b = __values(this.workers), _c = _b.next(); !_c.done; _c = _b.next()) {
                var worker = _c.value;
                worker.terminate();
            }
        } catch (e_1_1) {
            e_1 = { error: e_1_1 };
        } finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally {
                if (e_1) throw e_1.error;
            }
        }
        this.workers = [];
    };
    WorkerPool.prototype.build = function () {
        if (this.workers.length > 0) return;
        var numWorkers = this.numWorkers;
        while (numWorkers--) {
            var manager = new WorkerManager(this.workerConstructor(), this._onWorkerDone.bind(this));
            this.workers.push(manager);
        }
    };
    WorkerPool.prototype.execute = function (request) {
        var _this = this;
        this.build();
        var p = new Promise(function (resolve, reject) {
            var workerManagerRequest = { request: request, resolve: resolve };
            _this.insertRequest(workerManagerRequest);
        });
        this.pumpQueue();
        return p;
    };
    WorkerPool.prototype.insertRequest = function (workerManagerRequest) {
        var i;
        for (i = 0; i < this.outstandingRequests.length; i++) {
            if (this.outstandingRequests[i].request.priority > workerManagerRequest.request.priority) break;
        }
        this.outstandingRequests.splice(i, 0, workerManagerRequest);
    };
    WorkerPool.prototype.pumpQueue = function () {
        var e_2, _a;
        try {
            for (var _b = __values(this.workers), _c = _b.next(); !_c.done; _c = _b.next()) {
                var worker = _c.value;
                if (this.outstandingRequests.length === 0) return;
                if (worker.isFree()) {
                    var req = util_1.assertExists(this.outstandingRequests.shift());
                    worker.execute(req);
                }
            }
        } catch (e_2_1) {
            e_2 = { error: e_2_1 };
        } finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally {
                if (e_2) throw e_2.error;
            }
        }
    };
    WorkerPool.prototype._onWorkerDone = function () {
        this.pumpQueue();
    };
    return WorkerPool;
}();
exports.WorkerPool = WorkerPool;
function makeWorkerFromSource(sources) {
    var blob = new Blob(sources, { type: 'application/javascript' });
    var url = window.URL.createObjectURL(blob);
    var w = new Worker(url);
    window.URL.revokeObjectURL(url);
    return w;
}
exports.makeWorkerFromSource = makeWorkerFromSource;
},{"./util":"util.ts"}],"fres\\gx2_swizzle.ts":[function(require,module,exports) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var gx2_enum_1 = require("./gx2_enum");
var worker_util_1 = require("../worker_util");
// This is all contained in one function in order to make it easier to Worker-ize.
function _deswizzle(inSurface, srcBuffer, mipLevel) {
    var numPipes = 2;
    var numBanks = 4;
    var microTileWidth = 8;
    var microTileHeight = 8;
    var macroTileWidth = 8 * numBanks;
    var macroTileHeight = 8 * numPipes;
    var microTilePixels = microTileWidth * microTileHeight;
    var pipeInterleaveBytes = 256;
    var numPipeBits = 1;
    var numBankBits = 2;
    var numGroupBits = 8;
    var rowSize = 2048;
    var swapSize = 256;
    var splitSize = 2048;
    function memcpy(dst, dstOffs, src, srcOffs, length) {
        dst.set(new Uint8Array(src, srcOffs, length), dstOffs);
    }
    function alignPow2(n) {
        var x = 1;
        while (x < n) {
            x *= 2;
        }return x;
    }
    function align(n, multiple) {
        var mask = multiple - 1;
        return n + mask & ~mask;
    }
    function computeSurfaceMipLevelTileMode(surface, mipLevel) {
        // Level starts at 0.
        if (mipLevel > 0) {
            surface.width = Math.max(alignPow2(surface.width >> mipLevel), 1);
            surface.pitch = Math.max(alignPow2(surface.pitch >> mipLevel), 1);
            surface.height = Math.max(alignPow2(surface.height >> mipLevel), 1);
            var numSamples = 1 << surface.aaMode;
            var thickness = computeSurfaceThickness(surface.tileMode);
            var bytesPerBlock_1 = computeSurfaceBytesPerBlock(surface.format);
            var microTileThickness = computeSurfaceThickness(surface.tileMode);
            var bytesPerSample = bytesPerBlock_1 * microTileThickness * microTilePixels;
            var microTileBytes = bytesPerSample * numSamples;
            var pitchAlignFactor = Math.max(pipeInterleaveBytes / microTileBytes, 1) | 0;
            var macroTileHeightBlocks = macroTileHeight * computeSurfaceBlockWidth(surface.format);
            if (surface.tileMode === gx2_enum_1.GX2TileMode._2D_TILED_THIN1 && (surface.pitch < pitchAlignFactor * macroTileWidth || surface.height < macroTileHeightBlocks)) surface.tileMode = gx2_enum_1.GX2TileMode._1D_TILED_THIN1;
        }
    }
    function computePipeFromCoordWoRotation(x, y) {
        // NumPipes = 2
        var x3 = x >>> 3 & 1;
        var y3 = y >>> 3 & 1;
        var pipeBit0 = y3 ^ x3;
        return pipeBit0 << 0;
    }
    function computeBankFromCoordWoRotation(x, y) {
        var ty = y / numPipes | 0;
        var x3 = x >>> 3 & 1;
        var x4 = x >>> 4 & 1;
        var ty3 = ty >>> 3 & 1;
        var ty4 = ty >>> 4 & 1;
        var p0 = ty4 ^ x3;
        var p1 = ty3 ^ x4;
        return p1 << 1 | p0 << 0;
    }
    function computeSurfaceThickness(tileMode) {
        switch (tileMode) {
            case gx2_enum_1.GX2TileMode._1D_TILED_THIN1:
            case gx2_enum_1.GX2TileMode._2D_TILED_THIN1:
                return 1;
        }
    }
    function computeSurfaceBlockWidth(format) {
        switch (format & gx2_enum_1.GX2SurfaceFormat.FMT_MASK) {
            case gx2_enum_1.GX2SurfaceFormat.FMT_BC1:
            case gx2_enum_1.GX2SurfaceFormat.FMT_BC3:
            case gx2_enum_1.GX2SurfaceFormat.FMT_BC4:
            case gx2_enum_1.GX2SurfaceFormat.FMT_BC5:
                return 4;
            default:
                return 1;
        }
    }
    function computeSurfaceBytesPerBlock(format) {
        switch (format & gx2_enum_1.GX2SurfaceFormat.FMT_MASK) {
            case gx2_enum_1.GX2SurfaceFormat.FMT_BC1:
            case gx2_enum_1.GX2SurfaceFormat.FMT_BC4:
                return 8;
            case gx2_enum_1.GX2SurfaceFormat.FMT_BC3:
            case gx2_enum_1.GX2SurfaceFormat.FMT_BC5:
                return 16;
            // For non-block formats, a "block" is a pixel.
            case gx2_enum_1.GX2SurfaceFormat.FMT_TCS_R8_G8_B8_A8:
                return 4;
            default:
                throw new Error("Unsupported surface format " + format);
        }
    }
    function computePixelIndexWithinMicroTile(x, y, bytesPerBlock) {
        var x0 = x >>> 0 & 1;
        var x1 = x >>> 1 & 1;
        var x2 = x >>> 2 & 1;
        var y0 = y >>> 0 & 1;
        var y1 = y >>> 1 & 1;
        var y2 = y >>> 2 & 1;
        var pixelBits;
        if (bytesPerBlock === 8) {
            pixelBits = [y2, y1, x2, x1, y0, x0];
        } else if (bytesPerBlock === 16) {
            pixelBits = [y2, y1, x2, x1, x0, y0];
        } else if (bytesPerBlock === 4) {
            pixelBits = [y2, y1, y0, x2, x1, x0];
        } else {
            throw new Error("Invalid bpp");
        }
        var p5 = pixelBits[0];
        var p4 = pixelBits[1];
        var p3 = pixelBits[2];
        var p2 = pixelBits[3];
        var p1 = pixelBits[4];
        var p0 = pixelBits[5];
        return p5 << 5 | p4 << 4 | p3 << 3 | p2 << 2 | p1 << 1 | p0 << 0;
    }
    function computeSurfaceRotationFromTileMode(tileMode) {
        switch (tileMode) {
            case gx2_enum_1.GX2TileMode._2D_TILED_THIN1:
                return numPipes * ((numBanks >> 1) - 1);
            default:
                throw new Error("Unsupported tile mode " + tileMode);
        }
    }
    function computeTileModeAspectRatio(tileMode) {
        switch (tileMode) {
            case gx2_enum_1.GX2TileMode._2D_TILED_THIN1:
                return 1;
            default:
                throw new Error("Unsupported tile mode " + tileMode);
        }
    }
    function computeMacroTilePitch(tileMode) {
        return macroTileWidth / computeTileModeAspectRatio(tileMode);
    }
    function computeMacroTileHeight(tileMode) {
        return macroTileHeight / computeTileModeAspectRatio(tileMode);
    }
    function computeSurfaceAddrFromCoordMicroTiled(x, y, surface) {
        // XXX(jstpierre): 3D Textures
        var slice = 0;
        var bytesPerBlock = computeSurfaceBytesPerBlock(surface.format);
        var microTileThickness = computeSurfaceThickness(surface.tileMode);
        var microTileBytes = bytesPerBlock * microTileThickness * microTilePixels;
        var microTilesPerRow = surface.pitch / microTileWidth;
        var microTileIndexX = x / microTileWidth | 0;
        var microTileIndexY = y / microTileHeight | 0;
        var microTileIndexZ = slice / microTileThickness | 0;
        var microTileOffset = microTileBytes * (microTileIndexX + microTileIndexY * microTilesPerRow);
        var sliceBytes = surface.pitch * surface.height * microTileThickness * bytesPerBlock;
        var sliceOffset = microTileIndexZ * sliceBytes;
        var pixelIndex = computePixelIndexWithinMicroTile(x, y, bytesPerBlock);
        var pixelOffset = bytesPerBlock * pixelIndex;
        return pixelOffset + microTileOffset + sliceOffset;
    }
    function computeSurfaceAddrFromCoordMacroTiled(x, y, surface) {
        // XXX(jstpierre): AA textures
        var sample = 0;
        // XXX(jstpierre): 3D Textures
        var slice = 0;
        var numSamples = 1 << surface.aaMode;
        var pipeSwizzle = surface.swizzle >> 8 & 0x01;
        var bankSwizzle = surface.swizzle >> 9 & 0x03;
        var bytesPerBlock = computeSurfaceBytesPerBlock(surface.format);
        var microTileThickness = computeSurfaceThickness(surface.tileMode);
        var bytesPerSample = bytesPerBlock * microTileThickness * microTilePixels;
        var microTileBytes = bytesPerSample * numSamples;
        var isSamplesSplit = numSamples > 1 && microTileBytes > splitSize;
        var samplesPerSlice = Math.max(isSamplesSplit ? splitSize / bytesPerSample : numSamples, 1);
        var numSampleSplits = isSamplesSplit ? numSamples / samplesPerSlice : 1;
        var numSurfaceSamples = isSamplesSplit ? samplesPerSlice : numSamples;
        var rotation = computeSurfaceRotationFromTileMode(surface.tileMode);
        var macroTilePitch = computeMacroTilePitch(surface.tileMode);
        var macroTileHeight = computeMacroTileHeight(surface.tileMode);
        var groupMask = (1 << numGroupBits) - 1;
        var pixelIndex = computePixelIndexWithinMicroTile(x, y, bytesPerBlock);
        var pixelOffset = pixelIndex * bytesPerBlock;
        var sampleOffset = sample * (microTileBytes / numSamples);
        var elemOffset = pixelOffset + sampleOffset;
        var sampleSlice;
        if (isSamplesSplit) {
            var tileSliceBytes = microTileBytes / numSampleSplits;
            sampleSlice = elemOffset / tileSliceBytes | 0;
            elemOffset = elemOffset % tileSliceBytes;
        } else {
            sampleSlice = 0;
        }
        var pipe1 = computePipeFromCoordWoRotation(x, y);
        var bank1 = computeBankFromCoordWoRotation(x, y);
        var bankPipe = pipe1 + numPipes * bank1;
        var sliceIn = slice / (microTileThickness > 1 ? 4 : 1);
        var swizzle = pipeSwizzle + numPipes * bankSwizzle;
        bankPipe = bankPipe ^ (numPipes * sampleSlice * ((numBanks >> 1) + 1) ^ swizzle + sliceIn * rotation);
        bankPipe = bankPipe % (numPipes * numBanks);
        var pipe = bankPipe % numPipes | 0;
        var bank = bankPipe / numPipes | 0;
        var sliceBytes = surface.height * surface.pitch * microTileThickness * bytesPerBlock * numSamples;
        var sliceOffset = sliceBytes * (sampleSlice / microTileThickness | 0);
        var numSwizzleBits = numBankBits + numPipeBits;
        var macroTilesPerRow = surface.pitch / macroTilePitch | 0;
        var macroTileBytes = numSamples * microTileThickness * bytesPerBlock * macroTileHeight * macroTilePitch;
        var macroTileIndexX = x / macroTilePitch | 0;
        var macroTileIndexY = y / macroTileHeight | 0;
        var macroTileOffset = (macroTileIndexX + macroTilesPerRow * macroTileIndexY) * macroTileBytes;
        var totalOffset = elemOffset + (macroTileOffset + sliceOffset >> numSwizzleBits);
        var offsetHigh = (totalOffset & ~groupMask) << numSwizzleBits;
        var offsetLow = totalOffset & groupMask;
        var pipeBits = pipe << numGroupBits;
        var bankBits = bank << numPipeBits + numGroupBits;
        var addr = bankBits | pipeBits | offsetLow | offsetHigh;
        return addr;
    }
    // Have to spell this thing out the long way...
    var surface = {
        format: inSurface.format,
        tileMode: inSurface.tileMode,
        aaMode: inSurface.aaMode,
        swizzle: inSurface.swizzle,
        width: inSurface.width,
        height: inSurface.height,
        depth: inSurface.depth,
        pitch: inSurface.pitch,
        numMips: inSurface.numMips,
        texDataSize: inSurface.texDataSize,
        mipDataSize: inSurface.mipDataSize,
        mipDataOffsets: inSurface.mipDataOffsets
    };
    computeSurfaceMipLevelTileMode(surface, mipLevel);
    // For non-BC formats, "block" = 1 pixel.
    var blockSize = computeSurfaceBlockWidth(surface.format);
    var srcWidthBlocks = (surface.width + blockSize - 1) / blockSize | 0;
    var srcHeightBlocks = (surface.height + blockSize - 1) / blockSize | 0;
    var dstWidth = inSurface.width >>> mipLevel;
    var dstHeight = inSurface.height >>> mipLevel;
    var dstWidthBlocks = (dstWidth + blockSize - 1) / blockSize | 0;
    var dstHeightBlocks = (dstHeight + blockSize - 1) / blockSize | 0;
    var bytesPerBlock = computeSurfaceBytesPerBlock(surface.format);
    var dst = new Uint8Array(dstWidthBlocks * dstHeightBlocks * bytesPerBlock);
    for (var y = 0; y < dstHeightBlocks; y++) {
        for (var x = 0; x < dstWidthBlocks; x++) {
            var srcIdx = void 0;
            switch (surface.tileMode) {
                case gx2_enum_1.GX2TileMode._1D_TILED_THIN1:
                    srcIdx = computeSurfaceAddrFromCoordMicroTiled(x, y, surface);
                    break;
                case gx2_enum_1.GX2TileMode._2D_TILED_THIN1:
                    srcIdx = computeSurfaceAddrFromCoordMacroTiled(x, y, surface);
                    break;
                default:
                    var tileMode_ = surface.tileMode;
                    throw new Error("Unsupported tile mode " + tileMode_.toString(16));
            }
            var dstIdx = (y * dstWidthBlocks + x) * bytesPerBlock;
            memcpy(dst, dstIdx, srcBuffer, srcIdx, bytesPerBlock);
        }
    }
    var pixels = dst.buffer;
    var width = dstWidth;
    var height = dstHeight;
    return { width: width, height: height, pixels: pixels };
}
function deswizzleWorker(global) {
    global.onmessage = function (e) {
        var req = e.data;
        var deswizzledSurface = _deswizzle(req.surface, req.buffer, req.mipLevel);
        global.postMessage(deswizzledSurface, [deswizzledSurface.pixels]);
    };
}
function makeDeswizzleWorker() {
    return worker_util_1.makeWorkerFromSource([_deswizzle.toString(), deswizzleWorker.toString(), 'deswizzleWorker(this)']);
}
var Deswizzler = /** @class */function () {
    function Deswizzler() {
        this.pool = new worker_util_1.WorkerPool(makeDeswizzleWorker);
    }
    Deswizzler.prototype.deswizzle = function (surface, buffer, mipLevel) {
        var req = { surface: surface, buffer: buffer, mipLevel: mipLevel, priority: mipLevel };
        return this.pool.execute(req);
    };
    Deswizzler.prototype.terminate = function () {
        this.pool.terminate();
    };
    Deswizzler.prototype.build = function () {
        this.pool.build();
    };
    return Deswizzler;
}();
exports.deswizzler = new Deswizzler();
},{"./gx2_enum":"fres\\gx2_enum.ts","../worker_util":"worker_util.ts"}],"fres\\gx2_texture.ts":[function(require,module,exports) {
"use strict";

var __assign = this && this.__assign || Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) {
            if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var gx2_enum_1 = require("./gx2_enum");
var gx2_swizzle_1 = require("./gx2_swizzle");
// #region Texture Decode
function expand5to8(n) {
    return n << 8 - 5 | n >>> 10 - 8;
}
function expand6to8(n) {
    return n << 8 - 6 | n >>> 12 - 8;
}
// Use the fast GX approximation.
function s3tcblend(a, b) {
    // return (a*3 + b*5) / 8;
    return (a << 1) + a + ((b << 2) + b) >>> 3;
}
// Software decompresses from standard BC1 (DXT1) to RGBA.
function decompressBC1Surface(surface) {
    var bytesPerPixel = 4;
    var width = surface.width;
    var height = surface.height;
    var dst = new Uint8Array(width * height * bytesPerPixel);
    var view = new DataView(surface.pixels);
    var colorTable = new Uint8Array(16);
    var srcOffs = 0;
    for (var yy = 0; yy < height; yy += 4) {
        for (var xx = 0; xx < width; xx += 4) {
            var color1 = view.getUint16(srcOffs + 0x00, true);
            var color2 = view.getUint16(srcOffs + 0x02, true);
            // Fill in first two colors in color table.
            // TODO(jstpierre): SRGB-correct blending.
            colorTable[0] = expand5to8(color1 >> 11 & 0x1F);
            colorTable[1] = expand6to8(color1 >> 5 & 0x3F);
            colorTable[2] = expand5to8(color1 & 0x1F);
            colorTable[3] = 0xFF;
            colorTable[4] = expand5to8(color2 >> 11 & 0x1F);
            colorTable[5] = expand6to8(color2 >> 5 & 0x3F);
            colorTable[6] = expand5to8(color2 & 0x1F);
            colorTable[7] = 0xFF;
            if (color1 > color2) {
                // Predict gradients.
                colorTable[8] = s3tcblend(colorTable[4], colorTable[0]);
                colorTable[9] = s3tcblend(colorTable[5], colorTable[1]);
                colorTable[10] = s3tcblend(colorTable[6], colorTable[2]);
                colorTable[11] = 0xFF;
                colorTable[12] = s3tcblend(colorTable[0], colorTable[4]);
                colorTable[13] = s3tcblend(colorTable[1], colorTable[5]);
                colorTable[14] = s3tcblend(colorTable[2], colorTable[6]);
                colorTable[15] = 0xFF;
            } else {
                colorTable[8] = colorTable[0] + colorTable[4] >>> 1;
                colorTable[9] = colorTable[1] + colorTable[5] >>> 1;
                colorTable[10] = colorTable[2] + colorTable[6] >>> 1;
                colorTable[11] = 0xFF;
                colorTable[12] = 0x00;
                colorTable[13] = 0x00;
                colorTable[14] = 0x00;
                colorTable[15] = 0x00;
            }
            var bits = view.getUint32(srcOffs + 0x04, true);
            for (var y = 0; y < 4; y++) {
                for (var x = 0; x < 4; x++) {
                    var dstPx = (yy + y) * width + xx + x;
                    var dstOffs = dstPx * 4;
                    var colorIdx = bits & 0x03;
                    dst[dstOffs + 0] = colorTable[colorIdx * 4 + 0];
                    dst[dstOffs + 1] = colorTable[colorIdx * 4 + 1];
                    dst[dstOffs + 2] = colorTable[colorIdx * 4 + 2];
                    dst[dstOffs + 3] = colorTable[colorIdx * 4 + 3];
                    bits >>= 2;
                }
            }
            srcOffs += 0x08;
        }
    }
    var pixels = dst.buffer;
    return { type: 'RGBA', flag: surface.flag, width: width, height: height, pixels: pixels };
}
// Software decompresses from standard BC3 (DXT5) to RGBA.
function decompressBC3Surface(surface) {
    var bytesPerPixel = 4;
    var width = surface.width;
    var height = surface.height;
    var dst = new Uint8Array(width * height * bytesPerPixel);
    var view = new DataView(surface.pixels);
    var colorTable = new Uint8Array(16);
    var alphaTable = new Uint8Array(8);
    var srcOffs = 0;
    for (var yy = 0; yy < height; yy += 4) {
        for (var xx = 0; xx < width; xx += 4) {
            var alpha1 = view.getUint8(srcOffs + 0x00);
            var alpha2 = view.getUint8(srcOffs + 0x01);
            alphaTable[0] = alpha1;
            alphaTable[1] = alpha2;
            if (alpha1 > alpha2) {
                alphaTable[2] = (6 * alpha1 + 1 * alpha2) / 7;
                alphaTable[3] = (5 * alpha1 + 2 * alpha2) / 7;
                alphaTable[4] = (4 * alpha1 + 3 * alpha2) / 7;
                alphaTable[5] = (3 * alpha1 + 4 * alpha2) / 7;
                alphaTable[6] = (2 * alpha1 + 5 * alpha2) / 7;
                alphaTable[7] = (1 * alpha1 + 6 * alpha2) / 7;
            } else {
                alphaTable[2] = (4 * alpha1 + 1 * alpha2) / 5;
                alphaTable[3] = (3 * alpha1 + 2 * alpha2) / 5;
                alphaTable[4] = (2 * alpha1 + 3 * alpha2) / 5;
                alphaTable[5] = (1 * alpha1 + 4 * alpha2) / 5;
                alphaTable[6] = 0;
                alphaTable[7] = 255;
            }
            var alphaBits0 = view.getUint32(srcOffs + 0x02, true) & 0x00FFFFFF;
            var alphaBits1 = view.getUint32(srcOffs + 0x04, true) >>> 8;
            for (var y = 0; y < 4; y++) {
                for (var x = 0; x < 4; x++) {
                    var dstIdx = (yy + y) * width + xx + x;
                    var dstOffs = dstIdx * bytesPerPixel;
                    var fullShift = (y * 4 + x) * 3;
                    var alphaBits = fullShift < 24 ? alphaBits0 : alphaBits1;
                    var shift = fullShift % 24;
                    var index = alphaBits >>> shift & 0x07;
                    dst[dstOffs + 3] = alphaTable[index];
                }
            }
            srcOffs += 0x08;
            var color1 = view.getUint16(srcOffs + 0x00, true);
            var color2 = view.getUint16(srcOffs + 0x02, true);
            // Fill in first two colors in color table.
            // TODO(jstpierre): SRGB-correct blending.
            colorTable[0] = expand5to8(color1 >> 11 & 0x1F);
            colorTable[1] = expand6to8(color1 >> 5 & 0x3F);
            colorTable[2] = expand5to8(color1 & 0x1F);
            colorTable[3] = 0xFF;
            colorTable[4] = expand5to8(color2 >> 11 & 0x1F);
            colorTable[5] = expand6to8(color2 >> 5 & 0x3F);
            colorTable[6] = expand5to8(color2 & 0x1F);
            colorTable[7] = 0xFF;
            if (color1 > color2) {
                // Predict gradients.
                colorTable[8] = s3tcblend(colorTable[4], colorTable[0]);
                colorTable[9] = s3tcblend(colorTable[5], colorTable[1]);
                colorTable[10] = s3tcblend(colorTable[6], colorTable[2]);
                colorTable[11] = 0xFF;
                colorTable[12] = s3tcblend(colorTable[0], colorTable[4]);
                colorTable[13] = s3tcblend(colorTable[1], colorTable[5]);
                colorTable[14] = s3tcblend(colorTable[2], colorTable[6]);
                colorTable[15] = 0xFF;
            } else {
                colorTable[8] = colorTable[0] + colorTable[4] >>> 1;
                colorTable[9] = colorTable[1] + colorTable[5] >>> 1;
                colorTable[10] = colorTable[2] + colorTable[6] >>> 1;
                colorTable[11] = 0xFF;
                colorTable[12] = 0x00;
                colorTable[13] = 0x00;
                colorTable[14] = 0x00;
                colorTable[15] = 0xFF;
            }
            var colorBits = view.getUint32(srcOffs + 0x04, true);
            for (var y = 0; y < 4; y++) {
                for (var x = 0; x < 4; x++) {
                    var dstIdx = (yy + y) * width + xx + x;
                    var dstOffs = dstIdx * bytesPerPixel;
                    var colorIdx = colorBits & 0x03;
                    dst[dstOffs + 0] = colorTable[colorIdx * 4 + 0];
                    dst[dstOffs + 1] = colorTable[colorIdx * 4 + 1];
                    dst[dstOffs + 2] = colorTable[colorIdx * 4 + 2];
                    colorBits >>= 2;
                }
            }
            srcOffs += 0x08;
        }
    }
    var pixels = dst.buffer;
    return { type: 'RGBA', flag: surface.flag, width: width, height: height, pixels: pixels };
}
// Software decompresses from standard BC4/BC5 to RGBA.
function decompressBC45Surface(surface) {
    var bytesPerPixel = 4;
    var width = surface.width;
    var height = surface.height;
    var signed = surface.flag === 'SNORM';
    var view = new DataView(surface.pixels);
    var dst;
    var colorTable;
    var srcBytesPerPixel;
    if (surface.type === 'BC4') srcBytesPerPixel = 1;else srcBytesPerPixel = 2;
    if (signed) {
        dst = new Int8Array(width * height * bytesPerPixel);
        colorTable = new Int8Array(8);
    } else {
        dst = new Uint8Array(width * height * bytesPerPixel);
        colorTable = new Uint8Array(8);
    }
    var srcOffs = 0;
    for (var yy = 0; yy < height; yy += 4) {
        for (var xx = 0; xx < width; xx += 4) {
            for (var ch = 0; ch < srcBytesPerPixel; ch++) {
                var red0 = void 0;
                var red1 = void 0;
                if (signed) {
                    red0 = view.getInt8(srcOffs + 0x00);
                    red1 = view.getInt8(srcOffs + 0x01);
                } else {
                    red0 = view.getUint8(srcOffs + 0x00);
                    red1 = view.getUint8(srcOffs + 0x01);
                }
                colorTable[0] = red0;
                colorTable[1] = red1;
                if (red0 > red1) {
                    colorTable[2] = (6 * red0 + 1 * red1) / 7;
                    colorTable[3] = (5 * red0 + 2 * red1) / 7;
                    colorTable[4] = (4 * red0 + 3 * red1) / 7;
                    colorTable[5] = (3 * red0 + 4 * red1) / 7;
                    colorTable[6] = (2 * red0 + 5 * red1) / 7;
                    colorTable[7] = (1 * red0 + 6 * red1) / 7;
                } else {
                    colorTable[2] = (4 * red0 + 1 * red1) / 5;
                    colorTable[3] = (3 * red0 + 2 * red1) / 5;
                    colorTable[4] = (2 * red0 + 3 * red1) / 5;
                    colorTable[5] = (1 * red0 + 4 * red1) / 5;
                    colorTable[6] = signed ? -128 : 0;
                    colorTable[7] = signed ? 127 : 255;
                }
                var colorBits0 = view.getUint32(srcOffs + 0x02, true) & 0x00FFFFFF;
                var colorBits1 = view.getUint32(srcOffs + 0x04, true) >>> 8;
                for (var y = 0; y < 4; y++) {
                    for (var x = 0; x < 4; x++) {
                        var dstIdx = (yy + y) * width + xx + x;
                        var dstOffs = dstIdx * bytesPerPixel;
                        var fullShift = (y * 4 + x) * 3;
                        var colorBits = fullShift < 24 ? colorBits0 : colorBits1;
                        var shift = fullShift % 24;
                        var index = colorBits >>> shift & 0x07;
                        if (srcBytesPerPixel === 1) {
                            dst[dstOffs + 0] = colorTable[index];
                            dst[dstOffs + 1] = colorTable[index];
                            dst[dstOffs + 2] = colorTable[index];
                            dst[dstOffs + 3] = signed ? 127 : 255;
                        } else {
                            if (ch === 0) {
                                dst[dstOffs + 0] = colorTable[index];
                            } else if (ch === 1) {
                                dst[dstOffs + 1] = colorTable[index];
                                dst[dstOffs + 2] = signed ? 127 : 255;
                                dst[dstOffs + 3] = signed ? 127 : 255;
                            }
                        }
                    }
                }
                srcOffs += 0x08;
            }
        }
    }
    var pixels = dst.buffer;
    return { type: 'RGBA', flag: surface.flag, width: width, height: height, pixels: pixels };
}
function decompressBC(surface) {
    switch (surface.type) {
        case 'BC1':
            return decompressBC1Surface(surface);
        case 'BC3':
            return decompressBC3Surface(surface);
        case 'BC4':
        case 'BC5':
            return decompressBC45Surface(surface);
    }
}
exports.decompressBC = decompressBC;
function deswizzleSurface(surface, texData, mipLevel) {
    return gx2_swizzle_1.deswizzler.deswizzle(surface, texData.castToBuffer(), mipLevel);
}
exports.deswizzleSurface = deswizzleSurface;
function decodeSurface(surface, texData, mipData, mipLevel) {
    var levelData;
    if (mipLevel === 0) {
        levelData = texData;
    } else if (mipLevel === 1) {
        levelData = mipData;
    } else {
        var offset = surface.mipDataOffsets[mipLevel - 1];
        levelData = mipData.slice(offset);
    }
    var width = surface.width;
    var height = surface.height;
    return deswizzleSurface(surface, levelData, mipLevel).then(function (deswizzledSurface) {
        switch (surface.format) {
            case gx2_enum_1.GX2SurfaceFormat.BC1_UNORM:
                return __assign({ type: 'BC1', flag: 'UNORM' }, deswizzledSurface);
            case gx2_enum_1.GX2SurfaceFormat.BC1_SRGB:
                return __assign({ type: 'BC1', flag: 'SRGB' }, deswizzledSurface);
            case gx2_enum_1.GX2SurfaceFormat.BC3_UNORM:
                return __assign({ type: 'BC3', flag: 'UNORM' }, deswizzledSurface);
            case gx2_enum_1.GX2SurfaceFormat.BC3_SRGB:
                return __assign({ type: 'BC3', flag: 'SRGB' }, deswizzledSurface);
            case gx2_enum_1.GX2SurfaceFormat.BC4_UNORM:
                return __assign({ type: 'BC4', flag: 'UNORM' }, deswizzledSurface);
            case gx2_enum_1.GX2SurfaceFormat.BC4_SNORM:
                return __assign({ type: 'BC4', flag: 'SNORM' }, deswizzledSurface);
            case gx2_enum_1.GX2SurfaceFormat.BC5_UNORM:
                return __assign({ type: 'BC5', flag: 'UNORM' }, deswizzledSurface);
            case gx2_enum_1.GX2SurfaceFormat.BC5_SNORM:
                return __assign({ type: 'BC5', flag: 'SNORM' }, deswizzledSurface);
            case gx2_enum_1.GX2SurfaceFormat.TCS_R8_G8_B8_A8_UNORM:
                return __assign({ type: 'RGBA', flag: 'UNORM' }, deswizzledSurface);
            case gx2_enum_1.GX2SurfaceFormat.TCS_R8_G8_B8_A8_SRGB:
                return __assign({ type: 'RGBA', flag: 'SRGB' }, deswizzledSurface);
            default:
                throw new Error("Bad format in decodeSurface: " + surface.format.toString(16));
        }
    });
}
exports.decodeSurface = decodeSurface;
function surfaceToCanvas(canvas, surface) {
    var ctx = canvas.getContext('2d');
    var width = surface.width;
    var height = surface.height;
    var imageData = new ImageData(width, height);
    switch (surface.type) {
        case 'RGBA':
            if (surface.flag === 'UNORM') {
                var src = new Uint8Array(surface.pixels);
                imageData.data.set(src);
            } else if (surface.flag === 'SRGB') {
                // XXX(jstpierre): SRGB
                var src = new Uint8Array(surface.pixels);
                imageData.data.set(src);
            } else if (surface.flag === 'SNORM') {
                var src = new Int8Array(surface.pixels);
                var data = new Uint8Array(surface.pixels.byteLength);
                for (var i = 0; i < src.length; i++) {
                    data[i] = src[i] + 128;
                }
                imageData.data.set(data);
            }
            break;
    }
    ctx.putImageData(imageData, 0, 0);
}
exports.surfaceToCanvas = surfaceToCanvas;
function decompressSurface(texture) {
    switch (texture.type) {
        case 'RGBA':
            return texture;
        case 'BC1':
        case 'BC3':
        case 'BC4':
        case 'BC5':
            return decompressBC(texture);
    }
}
exports.decompressSurface = decompressSurface;
// #endregion
},{"./gx2_enum":"fres\\gx2_enum.ts","./gx2_swizzle":"fres\\gx2_swizzle.ts"}],"fres\\render.ts":[function(require,module,exports) {
"use strict";

var __extends = this && this.__extends || function () {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
        d.__proto__ = b;
    } || function (d, b) {
        for (var p in b) {
            if (b.hasOwnProperty(p)) d[p] = b[p];
        }
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __values = this && this.__values || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator],
        i = 0;
    if (m) return m.call(o);
    return {
        next: function next() {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
var __importStar = this && this.__importStar || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) {
        if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    }result["default"] = mod;
    return result;
};
var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var gx2_enum_1 = require("./gx2_enum");
var gx2_swizzle_1 = require("./gx2_swizzle");
var GX2Texture = __importStar(require("./gx2_texture"));
var render_1 = require("../render");
var Program_1 = __importDefault(require("../Program"));
var RenderArena_1 = __importDefault(require("../RenderArena"));
var util_1 = require("../util");
var ArrayBufferSlice_1 = __importDefault(require("../ArrayBufferSlice"));
var endian_1 = require("../endian");
var BufferCoalescer_1 = require("../BufferCoalescer");
var ProgramGambit_UBER = /** @class */function (_super) {
    __extends(ProgramGambit_UBER, _super);
    function ProgramGambit_UBER() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.$a = ProgramGambit_UBER.attribLocations;
        _this.vert = "\nuniform mat4 u_modelView;\nuniform mat4 u_projection;\nuniform mat4 u_view;\nlayout(location = " + _this.$a._p0 + ") in vec3 a_p0;\nlayout(location = " + _this.$a._n0 + ") in vec3 a_n0;\nlayout(location = " + _this.$a._t0 + ") in vec4 a_t0;\nlayout(location = " + _this.$a._u0 + ") in vec2 a_u0;\nlayout(location = " + _this.$a._u1 + ") in vec2 a_u1;\n\nout vec3 v_PositionWorld;\nout vec2 v_TexCoord0;\nout vec3 v_NormalWorld;\nout vec4 v_TangentWorld;\n\nout vec3 v_CameraWorld;\n\nvoid main() {\n    gl_Position = u_projection * u_modelView * vec4(a_p0, 1.0);\n    v_PositionWorld = a_p0.xyz;\n    v_TexCoord0 = a_u0;\n    v_NormalWorld = a_n0;\n    v_TangentWorld = a_t0;\n    // TODO(jstpierre): Don't be dumb.\n    v_CameraWorld = inverse(u_view)[3].xyz;\n}\n";
        _this.frag = "\nuniform mat4 u_view;\n\nuniform sampler2D s_a0;\nuniform sampler2D s_n0;\nuniform sampler2D s_e0;\nuniform sampler2D s_s0;\n\nin vec3 v_PositionWorld;\nin vec2 v_TexCoord0;\nin vec3 v_NormalWorld;\nin vec4 v_TangentWorld;\n\nin vec3 v_CameraWorld;\n\nvec4 textureSRGB(sampler2D s, vec2 uv) {\n    vec4 srgba = texture(s, uv);\n    vec3 srgb = srgba.rgb;\n    // XXX(jstpierre): Turn sRGB texturing back on at some point...\n#ifndef NOPE_HAS_WEBGL_compressed_texture_s3tc_srgb\n    vec3 rgb = srgb;\n#else\n    // http://chilliant.blogspot.com/2012/08/srgb-approximations-for-hlsl.html\n    vec3 rgb = srgb * (srgb * (srgb * 0.305306011 + 0.682171111) + 0.012522878);\n#endif\n    return vec4(rgb, srgba.a);\n}\n\nvoid main() {\n    vec4 tx_albedo0  = textureSRGB(s_a0, v_TexCoord0);\n    vec4 tx_emissive = textureSRGB(s_e0, v_TexCoord0);\n    vec4 tx_normal   = textureSRGB(s_n0, v_TexCoord0);\n    vec4 tx_specular = textureSRGB(s_s0, v_TexCoord0);\n\n    // Perturb normal with map.\n    vec3 nrm = v_NormalWorld.xyz;\n    vec3 tan = normalize(v_TangentWorld.xyz);\n    vec3 btn = cross(nrm, tan) * v_TangentWorld.w;\n\n    vec3 local_nrm = vec3(tx_normal.xy, 0);\n    float len2 = 1.0 - local_nrm.x*local_nrm.x - local_nrm.y*local_nrm.y;\n    local_nrm.z = sqrt(clamp(len2, 0.0, 1.0));\n    vec3 normal_dir = (local_nrm.x * tan + local_nrm.y * btn + local_nrm.z * nrm);\n\n    vec3 view_dir = normalize(v_PositionWorld.xyz - v_CameraWorld);\n    vec3 refl_dir = reflect(-view_dir, normal_dir);\n\n    // Calulate incident light.\n    float diffuse = 0.0;\n    float specular = 0.0;\n\n    // Basic directional lighting.\n    vec3 d_light_dir = normalize(vec3(-u_view[2].x, 0.0, u_view[2].z));\n    // Sky-ish color. If we were better we would use a cubemap...\n    const vec3 d_light_col = vec3(0.9, 0.9, 1.4);\n    const float spec_power = 35.0;\n\n    diffuse += clamp(dot(normal_dir, d_light_dir), 0.0, 1.0);\n    specular += pow(clamp(dot(refl_dir, d_light_dir), 0.0, 1.0), spec_power);\n\n    // Dumb constant ambient.\n    diffuse += 0.6;\n    specular += 0.012;\n\n    vec3 diffuse_light = d_light_col * diffuse;\n    vec3 specular_light = d_light_col * specular * tx_specular.x;\n\n    vec4 albedo = tx_albedo0;\n    // TODO(jstpierre): Multitex?\n\n    o_color = vec4(0, 0, 0, 0);\n    o_color.rgb += albedo.rgb * diffuse_light;\n    o_color.rgb += specular_light;\n    o_color.a = albedo.a;\n\n    // TODO(jstpierre): Configurable alpha test\n    if (o_color.a < 0.5)\n        discard;\n\n    o_color.rgb += tx_emissive.rgb;\n\n    // Gamma correction.\n    o_color.rgb = pow(o_color.rgb, vec3(1.0 / 2.2));\n}\n";
        return _this;
    }
    ProgramGambit_UBER.prototype.bind = function (gl, prog) {
        _super.prototype.bind.call(this, gl, prog);
        this.u_view = gl.getUniformLocation(prog, "u_view");
        this.s_a0 = gl.getUniformLocation(prog, "s_a0");
        this.s_e0 = gl.getUniformLocation(prog, "s_e0");
        this.s_n0 = gl.getUniformLocation(prog, "s_n0");
        this.s_s0 = gl.getUniformLocation(prog, "s_s0");
    };
    ProgramGambit_UBER.prototype.getTextureUniformLocation = function (name) {
        if (name === "_a0") return this.s_a0;else if (name === "_e0") return this.s_e0;else if (name === "_n0") return this.s_n0;else if (name === "_s0") return this.s_s0;else return null;
    };
    ProgramGambit_UBER.attribLocations = {
        _p0: 0,
        _n0: 1,
        _t0: 2,
        _u0: 3,
        _u1: 4
    };
    return ProgramGambit_UBER;
}(Program_1.default);
function getAttribFormatInfo(format) {
    switch (format) {
        case gx2_enum_1.GX2AttribFormat._8_SINT:
            return { compCount: 1, elemSize: 1, type: WebGL2RenderingContext.BYTE, normalized: false };
        case gx2_enum_1.GX2AttribFormat._8_SNORM:
            return { compCount: 1, elemSize: 1, type: WebGL2RenderingContext.BYTE, normalized: true };
        case gx2_enum_1.GX2AttribFormat._8_UINT:
            return { compCount: 1, elemSize: 1, type: WebGL2RenderingContext.UNSIGNED_BYTE, normalized: false };
        case gx2_enum_1.GX2AttribFormat._8_UNORM:
            return { compCount: 1, elemSize: 1, type: WebGL2RenderingContext.UNSIGNED_BYTE, normalized: true };
        case gx2_enum_1.GX2AttribFormat._8_8_UNORM:
            return { compCount: 2, elemSize: 1, type: WebGL2RenderingContext.UNSIGNED_BYTE, normalized: true };
        case gx2_enum_1.GX2AttribFormat._8_8_SNORM:
            return { compCount: 2, elemSize: 1, type: WebGL2RenderingContext.UNSIGNED_BYTE, normalized: true };
        case gx2_enum_1.GX2AttribFormat._8_8_8_8_UNORM:
            return { compCount: 4, elemSize: 1, type: WebGL2RenderingContext.UNSIGNED_BYTE, normalized: true };
        case gx2_enum_1.GX2AttribFormat._8_8_8_8_SNORM:
            return { compCount: 4, elemSize: 1, type: WebGL2RenderingContext.UNSIGNED_BYTE, normalized: true };
        case gx2_enum_1.GX2AttribFormat._16_16_UNORM:
            return { compCount: 2, elemSize: 2, type: WebGL2RenderingContext.UNSIGNED_SHORT, normalized: true };
        case gx2_enum_1.GX2AttribFormat._16_16_SNORM:
            return { compCount: 2, elemSize: 2, type: WebGL2RenderingContext.SHORT, normalized: true };
        case gx2_enum_1.GX2AttribFormat._16_16_FLOAT:
            return { compCount: 2, elemSize: 2, type: WebGL2RenderingContext.HALF_FLOAT, normalized: false };
        case gx2_enum_1.GX2AttribFormat._16_16_16_16_FLOAT:
            return { compCount: 4, elemSize: 2, type: WebGL2RenderingContext.HALF_FLOAT, normalized: false };
        case gx2_enum_1.GX2AttribFormat._16_16_16_16_UNORM:
            return { compCount: 4, elemSize: 2, type: WebGL2RenderingContext.UNSIGNED_SHORT, normalized: true };
        case gx2_enum_1.GX2AttribFormat._16_16_16_16_SNORM:
            return { compCount: 4, elemSize: 2, type: WebGL2RenderingContext.SHORT, normalized: true };
        case gx2_enum_1.GX2AttribFormat._32_32_FLOAT:
            return { compCount: 2, elemSize: 4, type: WebGL2RenderingContext.FLOAT, normalized: false };
        case gx2_enum_1.GX2AttribFormat._32_32_32_FLOAT:
            return { compCount: 4, elemSize: 4, type: WebGL2RenderingContext.FLOAT, normalized: false };
        case gx2_enum_1.GX2AttribFormat._10_10_10_2_UNORM:
        case gx2_enum_1.GX2AttribFormat._10_10_10_2_SNORM:
            // Should be handled during the buffer load case.
            return null;
        default:
            throw new Error("Unsupported attribute format " + format);
    }
}
function convertVertexBufferCopy(buffer, attrib, vtxCount) {
    var stride = buffer.stride;
    util_1.assert(stride !== 0);
    var formatInfo = getAttribFormatInfo(attrib.format);
    util_1.assert(formatInfo !== null);
    var numValues = vtxCount * formatInfo.compCount;
    function getOutputBuffer() {
        if (formatInfo.elemSize === 1) return new Uint8Array(numValues);else if (formatInfo.elemSize === 2) return new Uint16Array(numValues);else if (formatInfo.elemSize === 4) return new Uint32Array(numValues);else throw new Error();
    }
    var dataView = buffer.data.createDataView();
    var out = getOutputBuffer();
    var offs = attrib.bufferStart;
    var dst = 0;
    for (var i = 0; i < vtxCount; i++) {
        for (var j = 0; j < formatInfo.compCount; j++) {
            var srcOffs = offs + j * formatInfo.elemSize;
            if (formatInfo.elemSize === 1) out[dst] = dataView.getUint8(srcOffs);else if (formatInfo.elemSize === 2) out[dst] = dataView.getUint16(srcOffs);else if (formatInfo.elemSize === 4) out[dst] = dataView.getUint32(srcOffs);
            dst++;
        }
        offs += stride;
    }
    return new ArrayBufferSlice_1.default(out.buffer);
}
function convertVertexBuffer_10_10_10_2(buffer, attrib, vtxCount) {
    util_1.assert(buffer.stride !== 0);
    var elemSize = 4;
    var compCount = 4;
    var numValues = vtxCount * compCount;
    var signed;
    function getOutputBuffer() {
        if (attrib.format === gx2_enum_1.GX2AttribFormat._10_10_10_2_SNORM) {
            attrib.format = gx2_enum_1.GX2AttribFormat._16_16_16_16_SNORM;
            signed = true;
            return new Int16Array(numValues);
        } else if (attrib.format === gx2_enum_1.GX2AttribFormat._10_10_10_2_UNORM) {
            attrib.format = gx2_enum_1.GX2AttribFormat._16_16_16_16_UNORM;
            signed = false;
            return new Uint16Array(numValues);
        } else {
            throw new Error("whoops");
        }
    }
    var view = buffer.data.createDataView();
    var out = getOutputBuffer();
    function signExtend10(n) {
        if (signed) return n << 22 >> 22;else return n;
    }
    var offs = attrib.bufferStart;
    var dst = 0;
    for (var i = 0; i < vtxCount; i++) {
        var n = view.getUint32(offs, false);
        out[dst++] = signExtend10(n >>> 0 & 0x3FF) << 4;
        out[dst++] = signExtend10(n >>> 10 & 0x3FF) << 4;
        out[dst++] = signExtend10(n >>> 20 & 0x3FF) << 4;
        out[dst++] = (n >>> 30 & 0x03) << 14;
        offs += buffer.stride;
    }
    return new ArrayBufferSlice_1.default(out.buffer);
}
function convertVertexBuffer(buffer, attrib, vtxCount) {
    var formatInfo = getAttribFormatInfo(attrib.format);
    if (formatInfo !== null) {
        var byteSize = formatInfo.compCount * formatInfo.elemSize;
        if (buffer.stride <= byteSize && attrib.bufferStart === 0) {
            // Fastest path -- just endian swap.
            return buffer.data.convertFromEndianness(endian_1.Endianness.BIG_ENDIAN, formatInfo.elemSize);
        } else {
            // Has a native WebGL equivalent, just requires us to convert strides.
            return convertVertexBufferCopy(buffer, attrib, vtxCount);
        }
    } else {
        // No native WebGL equivalent. Let's see what we can do...
        switch (attrib.format) {
            case gx2_enum_1.GX2AttribFormat._10_10_10_2_SNORM:
            case gx2_enum_1.GX2AttribFormat._10_10_10_2_UNORM:
                return convertVertexBuffer_10_10_10_2(buffer, attrib, vtxCount);
        }
    }
    throw new Error("whoops");
}
var Scene = /** @class */function () {
    function Scene(gl, fres, isSkybox) {
        this.fres = fres;
        this.isSkybox = isSkybox;
        this.prog = new ProgramGambit_UBER();
        this.fres = fres;
        this.arena = new RenderArena_1.default();
        this.blankTexture = this.arena.createTexture(gl);
        gl.bindTexture(gl.TEXTURE_2D, this.blankTexture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA8, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array(4));
        this.textures = [];
        this.modelFuncs = this.translateFRES(gl, this.fres);
    }
    Scene.prototype.translateFVTXBuffers = function (fvtx, vertexDatas) {
        for (var i = 0; i < fvtx.attribs.length; i++) {
            var attrib = fvtx.attribs[i];
            var location = ProgramGambit_UBER.attribLocations[attrib.name];
            if (location === undefined) continue;
            var buffer = fvtx.buffers[attrib.bufferIndex];
            // Convert the vertex buffer data into a loadable format... might edit "attrib"
            // if it has to load a non-WebGL-native format...
            var vertexData = convertVertexBuffer(buffer, attrib, fvtx.vtxCount);
            vertexDatas.push(vertexData);
        }
    };
    Scene.prototype.translateFVTX = function (gl, fvtx, coalescedVertex) {
        var vao = this.arena.createVertexArray(gl);
        gl.bindVertexArray(vao);
        for (var i = 0; i < fvtx.attribs.length; i++) {
            var attrib = fvtx.attribs[i];
            var location = ProgramGambit_UBER.attribLocations[attrib.name];
            if (location === undefined) continue;
            var formatInfo = getAttribFormatInfo(attrib.format);
            var buffer = coalescedVertex.shift();
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer.buffer);
            gl.vertexAttribPointer(location, formatInfo.compCount, formatInfo.type, formatInfo.normalized, 0, buffer.offset);
            gl.enableVertexAttribArray(location);
        }
        return vao;
    };
    Scene.prototype.translateTexClamp = function (gl, clampMode) {
        switch (clampMode) {
            case gx2_enum_1.GX2TexClamp.CLAMP:
                return gl.CLAMP_TO_EDGE;
            case gx2_enum_1.GX2TexClamp.WRAP:
                return gl.REPEAT;
            case gx2_enum_1.GX2TexClamp.MIRROR:
                return gl.MIRRORED_REPEAT;
            default:
                throw new Error("Unknown tex clamp mode " + clampMode);
        }
    };
    Scene.prototype.translateTexFilter = function (gl, filter, mipFilter) {
        if (mipFilter === gx2_enum_1.GX2TexMipFilterType.LINEAR && filter === gx2_enum_1.GX2TexXYFilterType.BILINEAR) return gl.LINEAR_MIPMAP_LINEAR;
        if (mipFilter === gx2_enum_1.GX2TexMipFilterType.LINEAR && filter === gx2_enum_1.GX2TexXYFilterType.POINT) return gl.NEAREST_MIPMAP_LINEAR;
        if (mipFilter === gx2_enum_1.GX2TexMipFilterType.POINT && filter === gx2_enum_1.GX2TexXYFilterType.BILINEAR) return gl.LINEAR_MIPMAP_NEAREST;
        if (mipFilter === gx2_enum_1.GX2TexMipFilterType.POINT && filter === gx2_enum_1.GX2TexXYFilterType.POINT) return gl.NEAREST_MIPMAP_LINEAR;
        if (mipFilter === gx2_enum_1.GX2TexMipFilterType.NO_MIP && filter === gx2_enum_1.GX2TexXYFilterType.BILINEAR) return gl.LINEAR;
        if (mipFilter === gx2_enum_1.GX2TexMipFilterType.NO_MIP && filter === gx2_enum_1.GX2TexXYFilterType.POINT) return gl.NEAREST;
        throw new Error("Unknown texture filter mode");
    };
    Scene.prototype.translateFrontFaceMode = function (frontFaceMode) {
        switch (frontFaceMode) {
            case gx2_enum_1.GX2FrontFaceMode.CCW:
                return render_1.FrontFaceMode.CCW;
            case gx2_enum_1.GX2FrontFaceMode.CW:
                return render_1.FrontFaceMode.CW;
        }
    };
    Scene.prototype.translateCompareFunction = function (compareFunc) {
        switch (compareFunc) {
            case gx2_enum_1.GX2CompareFunction.NEVER:
                return render_1.CompareMode.NEVER;
            case gx2_enum_1.GX2CompareFunction.LESS:
                return render_1.CompareMode.LESS;
            case gx2_enum_1.GX2CompareFunction.EQUAL:
                return render_1.CompareMode.EQUAL;
            case gx2_enum_1.GX2CompareFunction.LEQUAL:
                return render_1.CompareMode.LEQUAL;
            case gx2_enum_1.GX2CompareFunction.GREATER:
                return render_1.CompareMode.GREATER;
            case gx2_enum_1.GX2CompareFunction.NOTEQUAL:
                return render_1.CompareMode.NEQUAL;
            case gx2_enum_1.GX2CompareFunction.GEQUAL:
                return render_1.CompareMode.GEQUAL;
            case gx2_enum_1.GX2CompareFunction.ALWAYS:
                return render_1.CompareMode.ALWAYS;
        }
    };
    Scene.prototype.translateCullMode = function (cullFront, cullBack) {
        if (cullFront && cullBack) return render_1.CullMode.FRONT_AND_BACK;else if (cullFront) return render_1.CullMode.FRONT;else if (cullBack) return render_1.CullMode.BACK;else return render_1.CullMode.NONE;
    };
    Scene.prototype.translateRenderState = function (renderState) {
        var renderFlags = new render_1.RenderFlags();
        renderFlags.frontFace = this.translateFrontFaceMode(renderState.frontFaceMode);
        renderFlags.depthTest = renderState.depthTest;
        renderFlags.depthFunc = this.translateCompareFunction(renderState.depthCompareFunc);
        renderFlags.depthWrite = renderState.depthWrite;
        renderFlags.cullMode = this.translateCullMode(renderState.cullFront, renderState.cullBack);
        return renderFlags;
    };
    Scene.prototype.translateFMAT = function (gl, fmat) {
        var _this = this;
        var e_1, _a;
        var attribNames = ['_a0', '_e0', '_n0', '_s0'];
        var textureAssigns = fmat.textureAssigns.filter(function (textureAssign) {
            return attribNames.includes(textureAssign.attribName);
        });
        var samplers = [];
        try {
            for (var textureAssigns_1 = __values(textureAssigns), textureAssigns_1_1 = textureAssigns_1.next(); !textureAssigns_1_1.done; textureAssigns_1_1 = textureAssigns_1.next()) {
                var textureAssign = textureAssigns_1_1.value;
                var sampler = this.arena.createSampler(gl);
                gl.samplerParameteri(sampler, gl.TEXTURE_WRAP_S, this.translateTexClamp(gl, textureAssign.texClampU));
                gl.samplerParameteri(sampler, gl.TEXTURE_WRAP_T, this.translateTexClamp(gl, textureAssign.texClampV));
                // XXX(jstpierre): Introduce this when we start decoding mipmaps.
                var texFilterMip = gx2_enum_1.GX2TexMipFilterType.NO_MIP;
                gl.samplerParameteri(sampler, gl.TEXTURE_MAG_FILTER, this.translateTexFilter(gl, textureAssign.texFilterMag, texFilterMip));
                gl.samplerParameteri(sampler, gl.TEXTURE_MIN_FILTER, this.translateTexFilter(gl, textureAssign.texFilterMin, texFilterMip));
                samplers.push(sampler);
            }
        } catch (e_1_1) {
            e_1 = { error: e_1_1 };
        } finally {
            try {
                if (textureAssigns_1_1 && !textureAssigns_1_1.done && (_a = textureAssigns_1.return)) _a.call(textureAssigns_1);
            } finally {
                if (e_1) throw e_1.error;
            }
        }
        // const prog = new ProgramGambit_UBER();
        // this.arena.trackProgram(prog);
        var prog = this.prog;
        var renderFlags = this.translateRenderState(fmat.renderState);
        return function (state) {
            state.useProgram(prog);
            state.bindModelView(_this.isSkybox);
            gl.uniformMatrix4fv(prog.u_view, false, state.view);
            state.useFlags(renderFlags);
            var _loop_1 = function _loop_1(i) {
                var attribName = attribNames[i];
                gl.activeTexture(gl.TEXTURE0 + i);
                var uniformLocation = prog.getTextureUniformLocation(attribName);
                gl.uniform1i(uniformLocation, i);
                var textureAssignIndex = textureAssigns.findIndex(function (textureAssign) {
                    return textureAssign.attribName === attribName;
                });
                var bound = false;
                if (textureAssignIndex >= 0) {
                    var textureAssign_1 = textureAssigns[textureAssignIndex];
                    var ftexIndex = _this.fres.textures.findIndex(function (textureEntry) {
                        return textureEntry.entry.offs === textureAssign_1.ftexOffs;
                    });
                    if (ftexIndex >= 0) {
                        var ftex = _this.fres.textures[ftexIndex];
                        util_1.assert(ftex.entry.name === textureAssign_1.textureName);
                        var glTexture = _this.glTextures[ftexIndex];
                        gl.bindTexture(gl.TEXTURE_2D, glTexture);
                        var sampler = samplers[textureAssignIndex];
                        gl.bindSampler(i, sampler);
                        bound = true;
                    }
                }
                if (!bound) {
                    // If we have no binding for this texture, replace it with something harmless...
                    gl.bindTexture(gl.TEXTURE_2D, _this.blankTexture);
                }
            };
            // Textures.
            for (var i = 0; i < attribNames.length; i++) {
                _loop_1(i);
            }
        };
    };
    Scene.prototype.translateIndexBuffer = function (indexFormat, indexBufferData) {
        switch (indexFormat) {
            case gx2_enum_1.GX2IndexFormat.U16_LE:
            case gx2_enum_1.GX2IndexFormat.U32_LE:
                return indexBufferData;
            case gx2_enum_1.GX2IndexFormat.U16:
                return indexBufferData.convertFromEndianness(endian_1.Endianness.BIG_ENDIAN, 2);
            case gx2_enum_1.GX2IndexFormat.U32:
                return indexBufferData.convertFromEndianness(endian_1.Endianness.BIG_ENDIAN, 4);
        }
    };
    Scene.prototype.translateFSHPBuffers = function (fshp, indexDatas) {
        var e_2, _a;
        try {
            for (var _b = __values(fshp.meshes), _c = _b.next(); !_c.done; _c = _b.next()) {
                var mesh = _c.value;
                util_1.assert(mesh.indexBufferData.stride === 0);
                var indexData = this.translateIndexBuffer(mesh.indexFormat, mesh.indexBufferData.data);
                indexDatas.push(indexData);
            }
        } catch (e_2_1) {
            e_2 = { error: e_2_1 };
        } finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally {
                if (e_2) throw e_2.error;
            }
        }
    };
    Scene.prototype.translateIndexFormat = function (gl, indexFormat) {
        // Little-endian translation was done above.
        switch (indexFormat) {
            case gx2_enum_1.GX2IndexFormat.U16:
            case gx2_enum_1.GX2IndexFormat.U16_LE:
                return gl.UNSIGNED_SHORT;
            case gx2_enum_1.GX2IndexFormat.U32:
            case gx2_enum_1.GX2IndexFormat.U32_LE:
                return gl.UNSIGNED_INT;
            default:
                throw new Error("Unsupported index format " + indexFormat);
        }
    };
    Scene.prototype.translatePrimType = function (gl, primType) {
        switch (primType) {
            case gx2_enum_1.GX2PrimitiveType.TRIANGLES:
                return gl.TRIANGLES;
            default:
                throw new Error("Unsupported primitive type " + primType);
        }
    };
    Scene.prototype.translateFSHP = function (gl, fshp, coalescedIndex) {
        var _this = this;
        var e_3, _a;
        var glIndexBuffers = [];
        try {
            for (var _b = __values(fshp.meshes), _c = _b.next(); !_c.done; _c = _b.next()) {
                var mesh = _c.value;
                glIndexBuffers.push(coalescedIndex.shift());
            }
        } catch (e_3_1) {
            e_3 = { error: e_3_1 };
        } finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally {
                if (e_3) throw e_3.error;
            }
        }
        return function (state) {
            var e_4, _a;
            var lod = 0;
            var mesh = fshp.meshes[lod];
            var glIndexBuffer = glIndexBuffers[lod];
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, glIndexBuffer.buffer);
            try {
                for (var _b = __values(mesh.submeshes), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var submesh = _c.value;
                    gl.drawElements(_this.translatePrimType(gl, mesh.primType), submesh.indexBufferCount, _this.translateIndexFormat(gl, mesh.indexFormat), glIndexBuffer.offset + submesh.indexBufferOffset);
                }
            } catch (e_4_1) {
                e_4 = { error: e_4_1 };
            } finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                } finally {
                    if (e_4) throw e_4.error;
                }
            }
        };
    };
    Scene.prototype.translateModel = function (gl, model, coalescedVertex, coalescedIndex) {
        var _this = this;
        var fmdl = model.fmdl;
        var fvtxVaos = fmdl.fvtx.map(function (fvtx) {
            return _this.translateFVTX(gl, fvtx, coalescedVertex);
        });
        var fmatFuncs = fmdl.fmat.map(function (fmat) {
            return _this.translateFMAT(gl, fmat);
        });
        var fshpFuncs = fmdl.fshp.map(function (fshp) {
            return _this.translateFSHP(gl, fshp, coalescedIndex);
        });
        return function (state) {
            // _drcmap is the map used for the Gamepad. It does nothing but cause Z-fighting.
            if (model.entry.name.endsWith('_drcmap')) return;
            // "_DV" seems to be the skybox. There are additional models which are powered
            // by skeleton animation, which we don't quite support yet. Kill them for now.
            if (model.entry.name.indexOf('_DV_') !== -1) return;
            var gl = state.gl;
            for (var i = 0; i < fmdl.fshp.length; i++) {
                var fshp = fmdl.fshp[i];
                // XXX(jstpierre): Sun is dynamically moved by the game engine, I think...
                // ... unless it's SKL animation. For now, skip it.
                if (fshp.name === 'Sun__VRL_Sun') continue;
                gl.bindVertexArray(fvtxVaos[fshp.fvtxIndex]);
                // Set up our material state.
                fmatFuncs[fshp.fmatIndex](state);
                // Draw our meshes.
                fshpFuncs[i](state);
            }
        };
    };
    Scene.prototype.getCompressedFormat = function (gl, tex) {
        switch (tex.type) {
            case 'BC4':
            case 'BC5':
                return null;
        }
        var ext_compressed_texture_s3tc = gl.getExtension('WEBGL_compressed_texture_s3tc');
        // const ext_compressed_texture_s3tc_srgb = gl.getExtension('WEBGL_compressed_texture_s3tc_srgb');
        // XXX(jstpierre): Don't use sRGB for now since we sometimes fall back to SW decode.
        /*
        if (tex.flag === 'SRGB' && ext_compressed_texture_s3tc_srgb) {
            switch (tex.type) {
            case 'BC1':
                return ext_compressed_texture_s3tc_srgb.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
            case 'BC3':
                return ext_compressed_texture_s3tc_srgb.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
            }
        }
        */
        if (ext_compressed_texture_s3tc) {
            switch (tex.type) {
                case 'BC1':
                    return ext_compressed_texture_s3tc.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                case 'BC3':
                    return ext_compressed_texture_s3tc.COMPRESSED_RGBA_S3TC_DXT5_EXT;
            }
        }
        return null;
    };
    Scene.prototype.translateTexture = function (gl, textureEntry) {
        var _this = this;
        var glTexture = this.arena.createTexture(gl);
        gl.bindTexture(gl.TEXTURE_2D, glTexture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAX_LEVEL, 0);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA8, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array(4));
        var texture = textureEntry.texture;
        var surface = texture.surface;
        var canvases = [];
        var _loop_2 = function _loop_2(i) {
            var mipLevel = i;
            var canvas = document.createElement('canvas');
            canvas.width = 0;
            canvas.height = 0;
            canvases.push(canvas);
            GX2Texture.decodeSurface(surface, texture.texData, texture.mipData, mipLevel).then(function (decodedSurface) {
                // Sometimes the surfaces appear to have garbage sizes.
                if (decodedSurface.width === 0 || decodedSurface.height === 0) return;
                gl.bindTexture(gl.TEXTURE_2D, glTexture);
                // Decodes should show up in order, thanks to priority. Change this if we ever
                // change the logic, because it is indeed sketchy...
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAX_LEVEL, mipLevel);
                // XXX(jstpierre): Sometimes Splatoon uses non-block-sized textures. OpenGL does
                // not like this one bit. If this is the case, decompress in software.
                var isBlockSized = !!(texture.surface.width & 0x03) || !!(texture.surface.height & 0x03);
                // First check if we have to decompress compressed textures.
                switch (decodedSurface.type) {
                    case "BC1":
                    case "BC3":
                    case "BC4":
                    case "BC5":
                        var compressedFormat = _this.getCompressedFormat(gl, decodedSurface);
                        if (compressedFormat === null || !isBlockSized) decodedSurface = GX2Texture.decompressBC(decodedSurface);
                        break;
                }
                var pixels = decodedSurface.pixels;
                var width = decodedSurface.width;
                var height = decodedSurface.height;
                util_1.assert(pixels.byteLength > 0);
                switch (decodedSurface.type) {
                    case "RGBA":
                        {
                            var internalFormat = decodedSurface.flag === 'SRGB' ? gl.SRGB8_ALPHA8 : decodedSurface.flag === 'SNORM' ? gl.RGBA8_SNORM : gl.RGBA8;
                            var type = decodedSurface.flag === 'SNORM' ? gl.BYTE : gl.UNSIGNED_BYTE;
                            var data = decodedSurface.flag === 'SNORM' ? new Int8Array(pixels) : new Uint8Array(pixels);
                            gl.texImage2D(gl.TEXTURE_2D, mipLevel, internalFormat, width, height, 0, gl.RGBA, type, data);
                            break;
                        }
                    case "BC1":
                    case "BC3":
                    case "BC4":
                    case "BC5":
                        {
                            var compressedFormat = _this.getCompressedFormat(gl, decodedSurface);
                            util_1.assert(compressedFormat !== null);
                            gl.compressedTexImage2D(gl.TEXTURE_2D, mipLevel, compressedFormat, width, height, 0, new Uint8Array(pixels));
                            break;
                        }
                }
                // XXX(jstpierre): Do this on a worker as well?
                var canvas = canvases[mipLevel];
                var decompressedSurface = GX2Texture.decompressSurface(decodedSurface);
                canvas.width = decompressedSurface.width;
                canvas.height = decompressedSurface.height;
                canvas.title = textureEntry.entry.name + " " + surface.format + " (" + surface.width + "x" + surface.height + ")";
                GX2Texture.surfaceToCanvas(canvas, decompressedSurface);
            });
        };
        for (var i = 0; i < surface.numMips; i++) {
            _loop_2(i);
        }
        this.textures.push({ name: textureEntry.entry.name, surfaces: canvases });
        return glTexture;
    };
    Scene.prototype.translateModelBuffers = function (modelEntry, vertexDatas, indexDatas) {
        var _this = this;
        // Translate vertex data.
        modelEntry.fmdl.fvtx.forEach(function (fvtx) {
            return _this.translateFVTXBuffers(fvtx, vertexDatas);
        });
        modelEntry.fmdl.fshp.forEach(function (fshp) {
            return _this.translateFSHPBuffers(fshp, indexDatas);
        });
    };
    Scene.prototype.translateFRES = function (gl, fres) {
        var _this = this;
        this.glTextures = fres.textures.map(function (ftex) {
            return _this.translateTexture(gl, ftex);
        });
        // Gather buffers.
        var vertexDatas = [];
        var indexDatas = [];
        fres.models.forEach(function (modelEntry) {
            _this.translateModelBuffers(modelEntry, vertexDatas, indexDatas);
        });
        var coalescedVertex = BufferCoalescer_1.coalesceBuffer(gl, gl.ARRAY_BUFFER, vertexDatas);
        var coalescedIndex = BufferCoalescer_1.coalesceBuffer(gl, gl.ELEMENT_ARRAY_BUFFER, indexDatas);
        this.arena.buffers.push(coalescedVertex[0].buffer);
        this.arena.buffers.push(coalescedIndex[0].buffer);
        return fres.models.map(function (modelEntry) {
            return _this.translateModel(gl, modelEntry, coalescedVertex, coalescedIndex);
        });
    };
    Scene.prototype.render = function (state) {
        this.modelFuncs.forEach(function (func) {
            func(state);
        });
    };
    Scene.prototype.destroy = function (gl) {
        // Tear down the deswizzle workers.
        gx2_swizzle_1.deswizzler.terminate();
        this.arena.destroy(gl);
    };
    return Scene;
}();
exports.Scene = Scene;
},{"./gx2_enum":"fres\\gx2_enum.ts","./gx2_swizzle":"fres\\gx2_swizzle.ts","./gx2_texture":"fres\\gx2_texture.ts","../render":"render.ts","../Program":"Program.ts","../RenderArena":"RenderArena.ts","../util":"util.ts","../ArrayBufferSlice":"ArrayBufferSlice.ts","../endian":"endian.ts","../BufferCoalescer":"BufferCoalescer.ts"}],"fres\\scenes.ts":[function(require,module,exports) {
"use strict";

var __values = this && this.__values || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator],
        i = 0;
    if (m) return m.call(o);
    return {
        next: function next() {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
var __importStar = this && this.__importStar || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) {
        if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    }result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var BFRES = __importStar(require("./bfres"));
var SARC = __importStar(require("./sarc"));
var Yaz0 = __importStar(require("../compression/Yaz0"));
var render_1 = require("./render");
var util_1 = require("../util");
function collectTextures(scenes) {
    var e_1, _a;
    var textures = [];
    try {
        for (var scenes_1 = __values(scenes), scenes_1_1 = scenes_1.next(); !scenes_1_1.done; scenes_1_1 = scenes_1.next()) {
            var scene = scenes_1_1.value;
            if (scene) textures.push.apply(textures, scene.textures);
        }
    } catch (e_1_1) {
        e_1 = { error: e_1_1 };
    } finally {
        try {
            if (scenes_1_1 && !scenes_1_1.done && (_a = scenes_1.return)) _a.call(scenes_1);
        } finally {
            if (e_1) throw e_1.error;
        }
    }
    return textures;
}
var FRESRenderer = /** @class */function () {
    function FRESRenderer(mainScene) {
        this.mainScene = mainScene;
        this.textures = collectTextures([this.mainScene]);
    }
    FRESRenderer.prototype.render = function (state) {
        var gl = state.gl;
        state.setClipPlanes(0.2, 500000);
        if (this.mainScene) {
            this.mainScene.render(state);
        }
    };
    FRESRenderer.prototype.destroy = function (gl) {
        if (this.mainScene) this.mainScene.destroy(gl);
    };
    return FRESRenderer;
}();
function createSceneFromFRESBuffer(gl, buffer, isSkybox) {
    if (isSkybox === void 0) {
        isSkybox = false;
    }
    var fres = BFRES.parse(buffer);
    return new FRESRenderer(new render_1.Scene(gl, fres, isSkybox));
}
exports.createSceneFromFRESBuffer = createSceneFromFRESBuffer;
function createSceneFromSARCBuffer(gl, buffer, isSkybox) {
    if (isSkybox === void 0) {
        isSkybox = false;
    }
    return Promise.resolve(buffer).then(function (buffer) {
        if (util_1.readString(buffer, 0, 4) === 'Yaz0') return Yaz0.decompress(buffer);else return buffer;
    }).then(function (buffer) {
        var sarc = SARC.parse(buffer);
        var file = sarc.files.find(function (file) {
            return file.name.endsWith('.bfres');
        });
        return createSceneFromFRESBuffer(gl, file.buffer, isSkybox);
    });
}
exports.createSceneFromSARCBuffer = createSceneFromSARCBuffer;
},{"./bfres":"fres\\bfres.ts","./sarc":"fres\\sarc.ts","../compression/Yaz0":"compression\\Yaz0.ts","./render":"fres\\render.ts","../util":"util.ts"}],"fres\\splatoon_scenes.ts":[function(require,module,exports) {
"use strict";

var __values = this && this.__values || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator],
        i = 0;
    if (m) return m.call(o);
    return {
        next: function next() {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
var __read = this && this.__read || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o),
        r,
        ar = [],
        e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {
            ar.push(r.value);
        }
    } catch (error) {
        e = { error: error };
    } finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
            if (e) throw e.error;
        }
    }
    return ar;
};
var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var scenes_1 = require("./scenes");
var Progressable_1 = __importDefault(require("../Progressable"));
var util_1 = require("../util");
function collectTextures(scenes) {
    var e_1, _a;
    var textures = [];
    try {
        for (var scenes_2 = __values(scenes), scenes_2_1 = scenes_2.next(); !scenes_2_1.done; scenes_2_1 = scenes_2.next()) {
            var scene = scenes_2_1.value;
            if (scene) textures.push.apply(textures, scene.textures);
        }
    } catch (e_1_1) {
        e_1 = { error: e_1_1 };
    } finally {
        try {
            if (scenes_2_1 && !scenes_2_1.done && (_a = scenes_2.return)) _a.call(scenes_2);
        } finally {
            if (e_1) throw e_1.error;
        }
    }
    return textures;
}
var SplatoonRenderer = /** @class */function () {
    function SplatoonRenderer(mainScene, skyScene) {
        this.mainScene = mainScene;
        this.skyScene = skyScene;
        this.textures = collectTextures([this.mainScene, this.skyScene]);
    }
    SplatoonRenderer.prototype.render = function (state) {
        var gl = state.gl;
        state.setClipPlanes(0.2, 500000);
        if (this.skyScene) {
            this.skyScene.render(state);
        }
        gl.clear(gl.DEPTH_BUFFER_BIT);
        if (this.mainScene) {
            this.mainScene.render(state);
        }
    };
    SplatoonRenderer.prototype.destroy = function (gl) {
        if (this.skyScene) this.skyScene.destroy(gl);
        if (this.mainScene) this.mainScene.destroy(gl);
    };
    return SplatoonRenderer;
}();
var SplatoonSceneDesc = /** @class */function () {
    function SplatoonSceneDesc(name, path) {
        this.name = name;
        this.path = path;
        this.id = this.path;
    }
    SplatoonSceneDesc.prototype.createScene = function (gl) {
        return Progressable_1.default.all([this._createSceneFromPath(gl, "data/spl/" + this.path, false), this._createSceneFromPath(gl, 'data/spl/VR_SkyDayCumulonimbus.szs', true)]).then(function (scenes) {
            var _a = __read(scenes, 2),
                mainScene = _a[0],
                skyScene = _a[1];
            return new SplatoonRenderer(mainScene, skyScene);
        });
    };
    SplatoonSceneDesc.prototype._createSceneFromPath = function (gl, path, isSkybox) {
        return util_1.fetch(path).then(function (result) {
            return scenes_1.createSceneFromSARCBuffer(gl, result, isSkybox);
        });
    };
    return SplatoonSceneDesc;
}();
// Splatoon Models
var name = "Splatoon";
var id = "splatoon";
var sceneDescs = [new SplatoonSceneDesc('Inkopolis Plaza', 'Fld_Plaza00.szs'), new SplatoonSceneDesc('Inkopolis Plaza Lobby', 'Fld_PlazaLobby.szs'), new SplatoonSceneDesc('Ancho-V Games', 'Fld_Office00.szs'), new SplatoonSceneDesc('Arrowana Mall', 'Fld_UpDown00.szs'), new SplatoonSceneDesc('Blackbelly Skatepark', 'Fld_SkatePark00.szs'), new SplatoonSceneDesc('Bluefin Depot', 'Fld_Ruins00.szs'), new SplatoonSceneDesc('Camp Triggerfish', 'Fld_Athletic00.szs'), new SplatoonSceneDesc('Flounder Heights', 'Fld_Jyoheki00.szs'), new SplatoonSceneDesc('Hammerhead Bridge', 'Fld_Kaisou00.szs'), new SplatoonSceneDesc('Kelp Dome', 'Fld_Maze00.szs'), new SplatoonSceneDesc('Mahi-Mahi Resort', 'Fld_Hiagari00.szs'), new SplatoonSceneDesc('Moray Towers', 'Fld_Tuzura00.szs'), new SplatoonSceneDesc('Museum d\'Alfonsino', 'Fld_Pivot00.szs'), new SplatoonSceneDesc('Pirahna Pit', 'Fld_Quarry00.szs'), new SplatoonSceneDesc('Port Mackerel', 'Fld_Amida00.szs'), new SplatoonSceneDesc('Saltspray Rig', 'Fld_SeaPlant00.szs'), new SplatoonSceneDesc('Urchin Underpass (New)', 'Fld_Crank01.szs'), new SplatoonSceneDesc('Urchin Underpass (Old)', 'Fld_Crank00.szs'), new SplatoonSceneDesc('Walleye Warehouse', 'Fld_Warehouse00.szs'), new SplatoonSceneDesc('Octo Valley', 'Fld_World00.szs'), new SplatoonSceneDesc('Object: Tree', 'Obj_Tree02.szs')];
exports.sceneGroup = { id: id, name: name, sceneDescs: sceneDescs };
},{"./scenes":"fres\\scenes.ts","../Progressable":"Progressable.ts","../util":"util.ts"}],"dksiv\\iv.ts":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function parseIV(buffer) {
    var view = buffer.createDataView();
    var numChunks = view.getUint32(0x00, true);
    var r = view.getFloat32(0x04, true);
    var g = view.getFloat32(0x08, true);
    var b = view.getFloat32(0x0C, true);
    var color = new Float32Array([r, g, b]);
    var chunks = [];
    var chunkTableIdx = 0x10;
    for (var i = 0; i < numChunks; i++) {
        var idxDataOffs = view.getUint32(chunkTableIdx + 0x00, true);
        var idxDataCount = view.getUint32(chunkTableIdx + 0x04, true);
        var posDataOffs = view.getUint32(chunkTableIdx + 0x08, true);
        var posDataCount = view.getUint32(chunkTableIdx + 0x0C, true);
        var indexData = buffer.createTypedArray(Uint16Array, idxDataOffs, idxDataCount);
        var positionData = buffer.createTypedArray(Float32Array, posDataOffs, posDataCount * 3);
        chunks.push({ indexData: indexData, positionData: positionData });
        chunkTableIdx += 0x10;
    }
    return { color: color, chunks: chunks };
}
exports.parseIV = parseIV;
},{}],"dksiv\\render.ts":[function(require,module,exports) {
"use strict";

var __extends = this && this.__extends || function () {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
        d.__proto__ = b;
    } || function (d, b) {
        for (var p in b) {
            if (b.hasOwnProperty(p)) d[p] = b[p];
        }
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var gl_matrix_1 = require("gl-matrix");
var render_1 = require("../render");
var Program_1 = __importDefault(require("../Program"));
var IVProgram = /** @class */function (_super) {
    __extends(IVProgram, _super);
    function IVProgram() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.vert = "\nprecision mediump float;\n\nuniform mat4 u_modelView;\nuniform mat4 u_projection;\n\nlayout(location = " + IVProgram.a_Position + ") attribute vec3 a_Position;\nlayout(location = " + IVProgram.a_Normal + ") attribute vec3 a_Normal;\n\nout vec3 v_Normal;\n\nvoid main() {\n    const float t_ModelScale = 20.0;\n    gl_Position = u_projection * u_modelView * vec4(a_Position * t_ModelScale, 1.0);\n    v_Normal = a_Normal;\n}\n";
        _this.frag = "\nprecision mediump float;\n\nuniform vec3 u_Color;\n\nin vec3 v_Normal;\n\nvoid main() {\n    vec3 u_LightDirection = normalize(vec3(.2, -1, .5));\n    float t_LightIntensity = dot(-v_Normal, u_LightDirection);\n    vec3 t_LightColor = t_LightIntensity * vec3(0.3);\n    gl_FragColor = vec4(u_Color + t_LightColor, 1.0);\n}\n";
        return _this;
    }
    IVProgram.prototype.bind = function (gl, prog) {
        _super.prototype.bind.call(this, gl, prog);
        this.u_Color = gl.getUniformLocation(prog, 'u_Color');
    };
    IVProgram.a_Position = 0;
    IVProgram.a_Normal = 1;
    return IVProgram;
}(Program_1.default);
var Chunk = /** @class */function () {
    function Chunk(gl, chunk) {
        this.chunk = chunk;
        this.createTopology(gl, chunk);
    }
    Chunk.prototype.createTopology = function (gl, chunk) {
        // Run through our data, calculate normals and such.
        var t = gl_matrix_1.vec3.create();
        var posData = new Float32Array(chunk.indexData.length * 3);
        var nrmData = new Float32Array(chunk.indexData.length * 3);
        for (var i = 0; i < chunk.indexData.length; i += 3) {
            var i0 = chunk.indexData[i + 0];
            var i1 = chunk.indexData[i + 1];
            var i2 = chunk.indexData[i + 2];
            var t0x = chunk.positionData[i0 * 3 + 0];
            var t0y = chunk.positionData[i0 * 3 + 1];
            var t0z = chunk.positionData[i0 * 3 + 2];
            var t1x = chunk.positionData[i1 * 3 + 0];
            var t1y = chunk.positionData[i1 * 3 + 1];
            var t1z = chunk.positionData[i1 * 3 + 2];
            var t2x = chunk.positionData[i2 * 3 + 0];
            var t2y = chunk.positionData[i2 * 3 + 1];
            var t2z = chunk.positionData[i2 * 3 + 2];
            gl_matrix_1.vec3.cross(t, [t0x - t1x, t0y - t1y, t0z - t1z], [t0x - t2x, t0y - t2y, t0z - t2z]);
            gl_matrix_1.vec3.normalize(t, t);
            posData[(i + 0) * 3 + 0] = t0x;
            posData[(i + 0) * 3 + 1] = t0y;
            posData[(i + 0) * 3 + 2] = t0z;
            posData[(i + 1) * 3 + 0] = t1x;
            posData[(i + 1) * 3 + 1] = t1y;
            posData[(i + 1) * 3 + 2] = t1z;
            posData[(i + 2) * 3 + 0] = t2x;
            posData[(i + 2) * 3 + 1] = t2y;
            posData[(i + 2) * 3 + 2] = t2z;
            nrmData[(i + 0) * 3 + 0] = t[0];
            nrmData[(i + 0) * 3 + 1] = t[1];
            nrmData[(i + 0) * 3 + 2] = t[2];
            nrmData[(i + 1) * 3 + 0] = t[0];
            nrmData[(i + 1) * 3 + 1] = t[1];
            nrmData[(i + 1) * 3 + 2] = t[2];
            nrmData[(i + 2) * 3 + 0] = t[0];
            nrmData[(i + 2) * 3 + 1] = t[1];
            nrmData[(i + 2) * 3 + 2] = t[2];
        }
        this.vao = gl.createVertexArray();
        gl.bindVertexArray(this.vao);
        this.posBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, this.posBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, posData, gl.STATIC_DRAW);
        gl.vertexAttribPointer(IVProgram.a_Position, 3, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(IVProgram.a_Position);
        this.nrmBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, this.nrmBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, nrmData, gl.STATIC_DRAW);
        gl.vertexAttribPointer(IVProgram.a_Normal, 3, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(IVProgram.a_Normal);
        this.numVertices = chunk.indexData.length;
    };
    Chunk.prototype.render = function (state) {
        var gl = state.gl;
        gl.bindVertexArray(this.vao);
        gl.drawArrays(gl.TRIANGLES, 0, this.numVertices);
    };
    Chunk.prototype.destroy = function (gl) {
        gl.deleteVertexArray(this.vao);
        gl.deleteBuffer(this.posBuffer);
        gl.deleteBuffer(this.nrmBuffer);
    };
    return Chunk;
}();
var Scene = /** @class */function () {
    function Scene(gl, name, iv) {
        this.name = name;
        this.iv = iv;
        this.textures = [];
        this.visible = true;
        this.chunks = this.iv.chunks.map(function (chunk) {
            return new Chunk(gl, chunk);
        });
        this.program = new IVProgram();
        this.renderFlags = new render_1.RenderFlags();
        this.renderFlags.cullMode = render_1.CullMode.BACK;
        this.renderFlags.depthTest = true;
    }
    Scene.prototype.setVisible = function (v) {
        this.visible = v;
    };
    Scene.prototype.render = function (state) {
        if (!this.visible) return;
        var gl = state.gl;
        state.setClipPlanes(10, 500000);
        state.useProgram(this.program);
        state.bindModelView();
        state.useFlags(this.renderFlags);
        gl.uniform3fv(this.program.u_Color, this.iv.color);
        this.chunks.forEach(function (chunk) {
            chunk.render(state);
        });
    };
    Scene.prototype.destroy = function (gl) {
        this.chunks.forEach(function (chunk) {
            chunk.destroy(gl);
        });
        this.program.destroy(gl);
    };
    return Scene;
}();
exports.Scene = Scene;
},{"gl-matrix":"..\\node_modules\\gl-matrix\\src\\gl-matrix.js","../render":"render.ts","../Program":"Program.ts"}],"dksiv\\scenes.ts":[function(require,module,exports) {
"use strict";

var __values = this && this.__values || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator],
        i = 0;
    if (m) return m.call(o);
    return {
        next: function next() {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
var __importStar = this && this.__importStar || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) {
        if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    }result["default"] = mod;
    return result;
};
var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var iv_1 = require("./iv");
var render_1 = require("./render");
var UI = __importStar(require("../ui"));
var Progressable_1 = __importDefault(require("../Progressable"));
var util_1 = require("../util");
var dks1Paths = ["data/dksiv/dks1/15-0 Sens Fortress.iv", "data/dksiv/dks1/15-1 Anor Londo.iv", "data/dksiv/dks1/16-0 New Londo Ruins+Valley of Drakes.iv", "data/dksiv/dks1/17-0 Duke's Archive+Crystal Caves.iv", "data/dksiv/dks1/18-0 Kiln of the first Flame.iv", "data/dksiv/dks1/18-1 Undead Asylum.iv", "data/dksiv/dks1/10-0 Depths.iv", "data/dksiv/dks1/10-1 Undead Burg.iv", "data/dksiv/dks1/10-2 Firelink Shrine.iv", "data/dksiv/dks1/11-0 Painted World of Ariamis.iv", "data/dksiv/dks1/12-0 Darkroot Garden+Basin.iv", "data/dksiv/dks1/12-1 Oolacile.iv", "data/dksiv/dks1/13-0 Catacombs.iv", "data/dksiv/dks1/13-1 Tomb of the Giants.iv", "data/dksiv/dks1/13-2 Ash Lake.iv", "data/dksiv/dks1/14-0 Blighttown+Quelaags Domain.iv", "data/dksiv/dks1/14-1 Demon Ruins+Lost Izalith.iv"];
var dks2Paths = ["data/dksiv/dks2/10_25_The Gutter & Black Gulch.iv", "data/dksiv/dks2/10_27_Dragon Aerie & Dragon Shrine.iv", "data/dksiv/dks2/10_29_Majula.iv", "data/dksiv/dks2/10_30_Heide's Tower of Flame.iv", "data/dksiv/dks2/10_31_Heide's Tower of Flame & Cathedral of Blue.iv", "data/dksiv/dks2/10_32_Shaded Woods & Shrine of Winter.iv", "data/dksiv/dks2/10_33_Doors of Pharros.iv", "data/dksiv/dks2/10_34_Grave of Saints.iv", "data/dksiv/dks2/20_10_Memory of Vammar, Orro, Jeigh.iv", "data/dksiv/dks2/20_11_Shrine of Amana.iv", "data/dksiv/dks2/20_21_Drangleic Castle & King's Passage & Throne of Want.iv", "data/dksiv/dks2/20_24_Undead Crypt.iv", "data/dksiv/dks2/20_26_Dragon Memories.iv", "data/dksiv/dks2/40_03_Dark Chasm of Old.iv", "data/dksiv/dks2/10_02_Things Betwixt.iv", "data/dksiv/dks2/10_04_Majula.iv", "data/dksiv/dks2/10_10_Forest of Fallen Giants.iv", "data/dksiv/dks2/10_14_Brightstone Cove Tseldora & Lord's Private Chamber.iv", "data/dksiv/dks2/10_15_Aldia's Keep.iv", "data/dksiv/dks2/10_16_The Lost Bastille & Sinners' Rise & Belfry Luna.iv", "data/dksiv/dks2/10_17_Harvest Valley & Earthen Peak.iv", "data/dksiv/dks2/10_18_No-man's Wharf.iv", "data/dksiv/dks2/10_19_Iron Keep & Belfry Sol.iv", "data/dksiv/dks2/10_23_Huntsman's Copse & Undead Purgatory.iv"];
var MultiScene = /** @class */function () {
    function MultiScene(scenes) {
        var e_1, _a;
        this.scenes = scenes;
        this.textures = [];
        try {
            for (var _b = __values(this.scenes), _c = _b.next(); !_c.done; _c = _b.next()) {
                var scene = _c.value;
                this.textures = this.textures.concat(scene.textures);
            }
        } catch (e_1_1) {
            e_1 = { error: e_1_1 };
        } finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally {
                if (e_1) throw e_1.error;
            }
        }
    }
    MultiScene.prototype.createPanels = function () {
        var layers = new UI.LayerPanel();
        layers.setLayers(this.scenes);
        return [layers];
    };
    MultiScene.prototype.render = function (renderState) {
        this.scenes.forEach(function (scene) {
            scene.render(renderState);
        });
    };
    MultiScene.prototype.destroy = function (gl) {
        this.scenes.forEach(function (scene) {
            return scene.destroy(gl);
        });
    };
    return MultiScene;
}();
var SceneDesc = /** @class */function () {
    function SceneDesc(id, name, paths) {
        this.id = id;
        this.name = name;
        this.paths = paths;
    }
    SceneDesc.prototype.createScene = function (gl) {
        var _this = this;
        return Progressable_1.default.all(this.paths.map(function (path) {
            return _this.createSceneForPath(gl, path);
        })).then(function (scenes) {
            return new MultiScene(scenes);
        });
    };
    SceneDesc.prototype.createSceneForPath = function (gl, path) {
        return util_1.fetch(path).then(function (result) {
            var iv = iv_1.parseIV(result);
            var basename = path.split('/').pop();
            return new render_1.Scene(gl, basename, iv);
        });
    };
    return SceneDesc;
}();
var sceneDescs = [new SceneDesc('dks1', 'Dark Souls 1', dks1Paths), new SceneDesc('dks2', 'Dark Souls 2', dks2Paths)];
var name = "Dark Souls Collision Data";
var id = "dksiv";
exports.sceneGroup = { id: id, name: name, sceneDescs: sceneDescs };
},{"./iv":"dksiv\\iv.ts","./render":"dksiv\\render.ts","../ui":"ui.ts","../Progressable":"Progressable.ts","../util":"util.ts"}],"metroid_prime\\pak.ts":[function(require,module,exports) {
"use strict";
// Implements Retro's PAK format as seen in Metroid Prime 1.

Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("../util");
function parse(buffer) {
    var view = buffer.createDataView();
    util_1.assert(view.getUint32(0x00) === 0x00030005);
    // Named resource table.
    var offs = 0x08;
    var namedResourceTableEntries = [];
    var namedResourceTableCount = view.getUint32(offs);
    offs += 0x04;
    for (var i = 0; i < namedResourceTableCount; i++) {
        var fourCC = util_1.readString(buffer, offs + 0x00, 4, false);
        var fileID = util_1.readString(buffer, offs + 0x04, 4, false);
        var fileNameLength = view.getUint32(offs + 0x08);
        var fileName = util_1.readString(buffer, offs + 0x0C, fileNameLength, false);
        namedResourceTableEntries.push({ fourCC: fourCC, fileID: fileID, fileName: fileName });
        offs += 0x0C + fileNameLength;
    }
    var namedResourceTable = new Map();
    var resourceTable = new Map();
    // Regular resource table.
    var resourceTableCount = view.getUint32(offs + 0x00);
    offs += 0x04;
    var _loop_1 = function _loop_1(i) {
        var isCompressed = !!view.getUint32(offs + 0x00);
        var fourCC = util_1.readString(buffer, offs + 0x04, 4, false);
        var fileID = util_1.readString(buffer, offs + 0x08, 4, false);
        var fileSize = view.getUint32(offs + 0x0C);
        var fileOffset = view.getUint32(offs + 0x10);
        offs += 0x14;
        var decompressedSize = fileSize;
        if (isCompressed) {
            decompressedSize = view.getUint32(fileOffset);
            fileOffset += 0x04;
            fileSize -= 0x04;
        }
        if (resourceTable.has(fileID)) {
            var existingResource = resourceTable.get(fileID);
            // Skip files that are apparently the same.
            util_1.assert(fourCC === existingResource.fourCC);
            util_1.assert(fileSize === existingResource.fileSize);
            return "continue";
        }
        // Check for a named resource.
        var name = null;
        var namedResourceTableEntry = namedResourceTableEntries.find(function (nr) {
            return nr.fileID === fileID;
        });
        if (namedResourceTableEntry) {
            name = namedResourceTableEntry.fileName;
            util_1.assert(namedResourceTableEntry.fourCC === fourCC);
        }
        var fileBuffer = buffer.slice(fileOffset, fileOffset + fileSize);
        var fileResource = { name: name, fourCC: fourCC, fileID: fileID, fileSize: fileSize, fileOffset: fileOffset, isCompressed: isCompressed, decompressedSize: decompressedSize, buffer: fileBuffer };
        resourceTable.set(fileResource.fileID, fileResource);
        if (name !== null) namedResourceTable.set(fileResource.name, fileResource);
    };
    for (var i = 0; i < resourceTableCount; i++) {
        _loop_1(i);
    }
    return { namedResourceTable: namedResourceTable, resourceTable: resourceTable };
}
exports.parse = parse;
},{"../util":"util.ts"}],"..\\node_modules\\pako\\lib\\utils\\common.js":[function(require,module,exports) {
'use strict';


var TYPED_OK =  (typeof Uint8Array !== 'undefined') &&
                (typeof Uint16Array !== 'undefined') &&
                (typeof Int32Array !== 'undefined');

function _has(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}

exports.assign = function (obj /*from1, from2, from3, ...*/) {
  var sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    var source = sources.shift();
    if (!source) { continue; }

    if (typeof source !== 'object') {
      throw new TypeError(source + 'must be non-object');
    }

    for (var p in source) {
      if (_has(source, p)) {
        obj[p] = source[p];
      }
    }
  }

  return obj;
};


// reduce buffer size, avoiding mem copy
exports.shrinkBuf = function (buf, size) {
  if (buf.length === size) { return buf; }
  if (buf.subarray) { return buf.subarray(0, size); }
  buf.length = size;
  return buf;
};


var fnTyped = {
  arraySet: function (dest, src, src_offs, len, dest_offs) {
    if (src.subarray && dest.subarray) {
      dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
      return;
    }
    // Fallback to ordinary array
    for (var i = 0; i < len; i++) {
      dest[dest_offs + i] = src[src_offs + i];
    }
  },
  // Join array of chunks to single array.
  flattenChunks: function (chunks) {
    var i, l, len, pos, chunk, result;

    // calculate data length
    len = 0;
    for (i = 0, l = chunks.length; i < l; i++) {
      len += chunks[i].length;
    }

    // join chunks
    result = new Uint8Array(len);
    pos = 0;
    for (i = 0, l = chunks.length; i < l; i++) {
      chunk = chunks[i];
      result.set(chunk, pos);
      pos += chunk.length;
    }

    return result;
  }
};

var fnUntyped = {
  arraySet: function (dest, src, src_offs, len, dest_offs) {
    for (var i = 0; i < len; i++) {
      dest[dest_offs + i] = src[src_offs + i];
    }
  },
  // Join array of chunks to single array.
  flattenChunks: function (chunks) {
    return [].concat.apply([], chunks);
  }
};


// Enable/Disable typed arrays use, for testing
//
exports.setTyped = function (on) {
  if (on) {
    exports.Buf8  = Uint8Array;
    exports.Buf16 = Uint16Array;
    exports.Buf32 = Int32Array;
    exports.assign(exports, fnTyped);
  } else {
    exports.Buf8  = Array;
    exports.Buf16 = Array;
    exports.Buf32 = Array;
    exports.assign(exports, fnUntyped);
  }
};

exports.setTyped(TYPED_OK);

},{}],"..\\node_modules\\pako\\lib\\zlib\\trees.js":[function(require,module,exports) {
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var utils = require('../utils/common');

/* Public constants ==========================================================*/
/* ===========================================================================*/


//var Z_FILTERED          = 1;
//var Z_HUFFMAN_ONLY      = 2;
//var Z_RLE               = 3;
var Z_FIXED               = 4;
//var Z_DEFAULT_STRATEGY  = 0;

/* Possible values of the data_type field (though see inflate()) */
var Z_BINARY              = 0;
var Z_TEXT                = 1;
//var Z_ASCII             = 1; // = Z_TEXT
var Z_UNKNOWN             = 2;

/*============================================================================*/


function zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }

// From zutil.h

var STORED_BLOCK = 0;
var STATIC_TREES = 1;
var DYN_TREES    = 2;
/* The three kinds of block type */

var MIN_MATCH    = 3;
var MAX_MATCH    = 258;
/* The minimum and maximum match lengths */

// From deflate.h
/* ===========================================================================
 * Internal compression state.
 */

var LENGTH_CODES  = 29;
/* number of length codes, not counting the special END_BLOCK code */

var LITERALS      = 256;
/* number of literal bytes 0..255 */

var L_CODES       = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */

var D_CODES       = 30;
/* number of distance codes */

var BL_CODES      = 19;
/* number of codes used to transfer the bit lengths */

var HEAP_SIZE     = 2 * L_CODES + 1;
/* maximum heap size */

var MAX_BITS      = 15;
/* All codes must not exceed MAX_BITS bits */

var Buf_size      = 16;
/* size of bit buffer in bi_buf */


/* ===========================================================================
 * Constants
 */

var MAX_BL_BITS = 7;
/* Bit length codes must not exceed MAX_BL_BITS bits */

var END_BLOCK   = 256;
/* end of block literal code */

var REP_3_6     = 16;
/* repeat previous bit length 3-6 times (2 bits of repeat count) */

var REPZ_3_10   = 17;
/* repeat a zero length 3-10 times  (3 bits of repeat count) */

var REPZ_11_138 = 18;
/* repeat a zero length 11-138 times  (7 bits of repeat count) */

/* eslint-disable comma-spacing,array-bracket-spacing */
var extra_lbits =   /* extra bits for each length code */
  [0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0];

var extra_dbits =   /* extra bits for each distance code */
  [0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];

var extra_blbits =  /* extra bits for each bit length code */
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7];

var bl_order =
  [16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];
/* eslint-enable comma-spacing,array-bracket-spacing */

/* The lengths of the bit length codes are sent in order of decreasing
 * probability, to avoid transmitting the lengths for unused bit length codes.
 */

/* ===========================================================================
 * Local data. These are initialized only once.
 */

// We pre-fill arrays with 0 to avoid uninitialized gaps

var DIST_CODE_LEN = 512; /* see definition of array dist_code below */

// !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1
var static_ltree  = new Array((L_CODES + 2) * 2);
zero(static_ltree);
/* The static literal tree. Since the bit lengths are imposed, there is no
 * need for the L_CODES extra codes used during heap construction. However
 * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
 * below).
 */

var static_dtree  = new Array(D_CODES * 2);
zero(static_dtree);
/* The static distance tree. (Actually a trivial tree since all codes use
 * 5 bits.)
 */

var _dist_code    = new Array(DIST_CODE_LEN);
zero(_dist_code);
/* Distance codes. The first 256 values correspond to the distances
 * 3 .. 258, the last 256 values correspond to the top 8 bits of
 * the 15 bit distances.
 */

var _length_code  = new Array(MAX_MATCH - MIN_MATCH + 1);
zero(_length_code);
/* length code for each normalized match length (0 == MIN_MATCH) */

var base_length   = new Array(LENGTH_CODES);
zero(base_length);
/* First normalized length for each code (0 = MIN_MATCH) */

var base_dist     = new Array(D_CODES);
zero(base_dist);
/* First normalized distance for each code (0 = distance of 1) */


function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {

  this.static_tree  = static_tree;  /* static tree or NULL */
  this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */
  this.extra_base   = extra_base;   /* base index for extra_bits */
  this.elems        = elems;        /* max number of elements in the tree */
  this.max_length   = max_length;   /* max bit length for the codes */

  // show if `static_tree` has data or dummy - needed for monomorphic objects
  this.has_stree    = static_tree && static_tree.length;
}


var static_l_desc;
var static_d_desc;
var static_bl_desc;


function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;     /* the dynamic tree */
  this.max_code = 0;            /* largest code with non zero frequency */
  this.stat_desc = stat_desc;   /* the corresponding static tree */
}



function d_code(dist) {
  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
}


/* ===========================================================================
 * Output a short LSB first on the stream.
 * IN assertion: there is enough room in pendingBuf.
 */
function put_short(s, w) {
//    put_byte(s, (uch)((w) & 0xff));
//    put_byte(s, (uch)((ush)(w) >> 8));
  s.pending_buf[s.pending++] = (w) & 0xff;
  s.pending_buf[s.pending++] = (w >>> 8) & 0xff;
}


/* ===========================================================================
 * Send a value on a given number of bits.
 * IN assertion: length <= 16 and value fits in length bits.
 */
function send_bits(s, value, length) {
  if (s.bi_valid > (Buf_size - length)) {
    s.bi_buf |= (value << s.bi_valid) & 0xffff;
    put_short(s, s.bi_buf);
    s.bi_buf = value >> (Buf_size - s.bi_valid);
    s.bi_valid += length - Buf_size;
  } else {
    s.bi_buf |= (value << s.bi_valid) & 0xffff;
    s.bi_valid += length;
  }
}


function send_code(s, c, tree) {
  send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);
}


/* ===========================================================================
 * Reverse the first len bits of a code, using straightforward code (a faster
 * method would use a table)
 * IN assertion: 1 <= len <= 15
 */
function bi_reverse(code, len) {
  var res = 0;
  do {
    res |= code & 1;
    code >>>= 1;
    res <<= 1;
  } while (--len > 0);
  return res >>> 1;
}


/* ===========================================================================
 * Flush the bit buffer, keeping at most 7 bits in it.
 */
function bi_flush(s) {
  if (s.bi_valid === 16) {
    put_short(s, s.bi_buf);
    s.bi_buf = 0;
    s.bi_valid = 0;

  } else if (s.bi_valid >= 8) {
    s.pending_buf[s.pending++] = s.bi_buf & 0xff;
    s.bi_buf >>= 8;
    s.bi_valid -= 8;
  }
}


/* ===========================================================================
 * Compute the optimal bit lengths for a tree and update the total bit length
 * for the current block.
 * IN assertion: the fields freq and dad are set, heap[heap_max] and
 *    above are the tree nodes sorted by increasing frequency.
 * OUT assertions: the field len is set to the optimal bit length, the
 *     array bl_count contains the frequencies for each bit length.
 *     The length opt_len is updated; static_len is also updated if stree is
 *     not null.
 */
function gen_bitlen(s, desc)
//    deflate_state *s;
//    tree_desc *desc;    /* the tree descriptor */
{
  var tree            = desc.dyn_tree;
  var max_code        = desc.max_code;
  var stree           = desc.stat_desc.static_tree;
  var has_stree       = desc.stat_desc.has_stree;
  var extra           = desc.stat_desc.extra_bits;
  var base            = desc.stat_desc.extra_base;
  var max_length      = desc.stat_desc.max_length;
  var h;              /* heap index */
  var n, m;           /* iterate over the tree elements */
  var bits;           /* bit length */
  var xbits;          /* extra bits */
  var f;              /* frequency */
  var overflow = 0;   /* number of elements with bit length too large */

  for (bits = 0; bits <= MAX_BITS; bits++) {
    s.bl_count[bits] = 0;
  }

  /* In a first pass, compute the optimal bit lengths (which may
   * overflow in the case of the bit length tree).
   */
  tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */

  for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
    n = s.heap[h];
    bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n * 2 + 1]/*.Len*/ = bits;
    /* We overwrite tree[n].Dad which is no longer needed */

    if (n > max_code) { continue; } /* not a leaf node */

    s.bl_count[bits]++;
    xbits = 0;
    if (n >= base) {
      xbits = extra[n - base];
    }
    f = tree[n * 2]/*.Freq*/;
    s.opt_len += f * (bits + xbits);
    if (has_stree) {
      s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);
    }
  }
  if (overflow === 0) { return; }

  // Trace((stderr,"\nbit length overflow\n"));
  /* This happens for example on obj2 and pic of the Calgary corpus */

  /* Find the first bit length which could increase: */
  do {
    bits = max_length - 1;
    while (s.bl_count[bits] === 0) { bits--; }
    s.bl_count[bits]--;      /* move one leaf down the tree */
    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */
    s.bl_count[max_length]--;
    /* The brother of the overflow item also moves one step up,
     * but this does not affect bl_count[max_length]
     */
    overflow -= 2;
  } while (overflow > 0);

  /* Now recompute all bit lengths, scanning in increasing frequency.
   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
   * lengths instead of fixing only the wrong ones. This idea is taken
   * from 'ar' written by Haruhiko Okumura.)
   */
  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits];
    while (n !== 0) {
      m = s.heap[--h];
      if (m > max_code) { continue; }
      if (tree[m * 2 + 1]/*.Len*/ !== bits) {
        // Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
        s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;
        tree[m * 2 + 1]/*.Len*/ = bits;
      }
      n--;
    }
  }
}


/* ===========================================================================
 * Generate the codes for a given tree and bit counts (which need not be
 * optimal).
 * IN assertion: the array bl_count contains the bit length statistics for
 * the given tree and the field len is set for all tree elements.
 * OUT assertion: the field code is set for all tree elements of non
 *     zero code length.
 */
function gen_codes(tree, max_code, bl_count)
//    ct_data *tree;             /* the tree to decorate */
//    int max_code;              /* largest code with non zero frequency */
//    ushf *bl_count;            /* number of codes at each bit length */
{
  var next_code = new Array(MAX_BITS + 1); /* next code value for each bit length */
  var code = 0;              /* running code value */
  var bits;                  /* bit index */
  var n;                     /* code index */

  /* The distribution counts are first used to generate the code values
   * without bit reversal.
   */
  for (bits = 1; bits <= MAX_BITS; bits++) {
    next_code[bits] = code = (code + bl_count[bits - 1]) << 1;
  }
  /* Check that the bit counts in bl_count are consistent. The last code
   * must be all ones.
   */
  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
  //        "inconsistent bit counts");
  //Tracev((stderr,"\ngen_codes: max_code %d ", max_code));

  for (n = 0;  n <= max_code; n++) {
    var len = tree[n * 2 + 1]/*.Len*/;
    if (len === 0) { continue; }
    /* Now reverse the bits */
    tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);

    //Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
  }
}


/* ===========================================================================
 * Initialize the various 'constant' tables.
 */
function tr_static_init() {
  var n;        /* iterates over tree elements */
  var bits;     /* bit counter */
  var length;   /* length value */
  var code;     /* code value */
  var dist;     /* distance index */
  var bl_count = new Array(MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */

  // do check in _tr_init()
  //if (static_init_done) return;

  /* For some embedded targets, global variables are not initialized: */
/*#ifdef NO_INIT_GLOBAL_POINTERS
  static_l_desc.static_tree = static_ltree;
  static_l_desc.extra_bits = extra_lbits;
  static_d_desc.static_tree = static_dtree;
  static_d_desc.extra_bits = extra_dbits;
  static_bl_desc.extra_bits = extra_blbits;
#endif*/

  /* Initialize the mapping length (0..255) -> length code (0..28) */
  length = 0;
  for (code = 0; code < LENGTH_CODES - 1; code++) {
    base_length[code] = length;
    for (n = 0; n < (1 << extra_lbits[code]); n++) {
      _length_code[length++] = code;
    }
  }
  //Assert (length == 256, "tr_static_init: length != 256");
  /* Note that the length 255 (match length 258) can be represented
   * in two different ways: code 284 + 5 bits or code 285, so we
   * overwrite length_code[255] to use the best encoding:
   */
  _length_code[length - 1] = code;

  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
  dist = 0;
  for (code = 0; code < 16; code++) {
    base_dist[code] = dist;
    for (n = 0; n < (1 << extra_dbits[code]); n++) {
      _dist_code[dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: dist != 256");
  dist >>= 7; /* from now on, all distances are divided by 128 */
  for (; code < D_CODES; code++) {
    base_dist[code] = dist << 7;
    for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {
      _dist_code[256 + dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: 256+dist != 512");

  /* Construct the codes of the static literal tree */
  for (bits = 0; bits <= MAX_BITS; bits++) {
    bl_count[bits] = 0;
  }

  n = 0;
  while (n <= 143) {
    static_ltree[n * 2 + 1]/*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  while (n <= 255) {
    static_ltree[n * 2 + 1]/*.Len*/ = 9;
    n++;
    bl_count[9]++;
  }
  while (n <= 279) {
    static_ltree[n * 2 + 1]/*.Len*/ = 7;
    n++;
    bl_count[7]++;
  }
  while (n <= 287) {
    static_ltree[n * 2 + 1]/*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  /* Codes 286 and 287 do not exist, but we must include them in the
   * tree construction to get a canonical Huffman tree (longest code
   * all ones)
   */
  gen_codes(static_ltree, L_CODES + 1, bl_count);

  /* The static distance tree is trivial: */
  for (n = 0; n < D_CODES; n++) {
    static_dtree[n * 2 + 1]/*.Len*/ = 5;
    static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);
  }

  // Now data ready and we can init static trees
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES, MAX_BL_BITS);

  //static_init_done = true;
}


/* ===========================================================================
 * Initialize a new block.
 */
function init_block(s) {
  var n; /* iterates over tree elements */

  /* Initialize the trees. */
  for (n = 0; n < L_CODES;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }
  for (n = 0; n < D_CODES;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }
  for (n = 0; n < BL_CODES; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }

  s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;
  s.opt_len = s.static_len = 0;
  s.last_lit = s.matches = 0;
}


/* ===========================================================================
 * Flush the bit buffer and align the output on a byte boundary
 */
function bi_windup(s)
{
  if (s.bi_valid > 8) {
    put_short(s, s.bi_buf);
  } else if (s.bi_valid > 0) {
    //put_byte(s, (Byte)s->bi_buf);
    s.pending_buf[s.pending++] = s.bi_buf;
  }
  s.bi_buf = 0;
  s.bi_valid = 0;
}

/* ===========================================================================
 * Copy a stored block, storing first the length and its
 * one's complement if requested.
 */
function copy_block(s, buf, len, header)
//DeflateState *s;
//charf    *buf;    /* the input data */
//unsigned len;     /* its length */
//int      header;  /* true if block header must be written */
{
  bi_windup(s);        /* align on byte boundary */

  if (header) {
    put_short(s, len);
    put_short(s, ~len);
  }
//  while (len--) {
//    put_byte(s, *buf++);
//  }
  utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
  s.pending += len;
}

/* ===========================================================================
 * Compares to subtrees, using the tree depth as tie breaker when
 * the subtrees have equal frequency. This minimizes the worst case length.
 */
function smaller(tree, n, m, depth) {
  var _n2 = n * 2;
  var _m2 = m * 2;
  return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||
         (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));
}

/* ===========================================================================
 * Restore the heap property by moving down the tree starting at node k,
 * exchanging a node with the smallest of its two sons if necessary, stopping
 * when the heap property is re-established (each father smaller than its
 * two sons).
 */
function pqdownheap(s, tree, k)
//    deflate_state *s;
//    ct_data *tree;  /* the tree to restore */
//    int k;               /* node to move down */
{
  var v = s.heap[k];
  var j = k << 1;  /* left son of k */
  while (j <= s.heap_len) {
    /* Set j to the smallest of the two sons: */
    if (j < s.heap_len &&
      smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
      j++;
    }
    /* Exit if v is smaller than both sons */
    if (smaller(tree, v, s.heap[j], s.depth)) { break; }

    /* Exchange v with the smallest son */
    s.heap[k] = s.heap[j];
    k = j;

    /* And continue down the tree, setting j to the left son of k */
    j <<= 1;
  }
  s.heap[k] = v;
}


// inlined manually
// var SMALLEST = 1;

/* ===========================================================================
 * Send the block data compressed using the given Huffman trees
 */
function compress_block(s, ltree, dtree)
//    deflate_state *s;
//    const ct_data *ltree; /* literal tree */
//    const ct_data *dtree; /* distance tree */
{
  var dist;           /* distance of matched string */
  var lc;             /* match length or unmatched char (if dist == 0) */
  var lx = 0;         /* running index in l_buf */
  var code;           /* the code to send */
  var extra;          /* number of extra bits to send */

  if (s.last_lit !== 0) {
    do {
      dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | (s.pending_buf[s.d_buf + lx * 2 + 1]);
      lc = s.pending_buf[s.l_buf + lx];
      lx++;

      if (dist === 0) {
        send_code(s, lc, ltree); /* send a literal byte */
        //Tracecv(isgraph(lc), (stderr," '%c' ", lc));
      } else {
        /* Here, lc is the match length - MIN_MATCH */
        code = _length_code[lc];
        send_code(s, code + LITERALS + 1, ltree); /* send the length code */
        extra = extra_lbits[code];
        if (extra !== 0) {
          lc -= base_length[code];
          send_bits(s, lc, extra);       /* send the extra length bits */
        }
        dist--; /* dist is now the match distance - 1 */
        code = d_code(dist);
        //Assert (code < D_CODES, "bad d_code");

        send_code(s, code, dtree);       /* send the distance code */
        extra = extra_dbits[code];
        if (extra !== 0) {
          dist -= base_dist[code];
          send_bits(s, dist, extra);   /* send the extra distance bits */
        }
      } /* literal or match pair ? */

      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
      //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,
      //       "pendingBuf overflow");

    } while (lx < s.last_lit);
  }

  send_code(s, END_BLOCK, ltree);
}


/* ===========================================================================
 * Construct one Huffman tree and assigns the code bit strings and lengths.
 * Update the total bit length for the current block.
 * IN assertion: the field freq is set for all tree elements.
 * OUT assertions: the fields len and code are set to the optimal bit length
 *     and corresponding code. The length opt_len is updated; static_len is
 *     also updated if stree is not null. The field max_code is set.
 */
function build_tree(s, desc)
//    deflate_state *s;
//    tree_desc *desc; /* the tree descriptor */
{
  var tree     = desc.dyn_tree;
  var stree    = desc.stat_desc.static_tree;
  var has_stree = desc.stat_desc.has_stree;
  var elems    = desc.stat_desc.elems;
  var n, m;          /* iterate over heap elements */
  var max_code = -1; /* largest code with non zero frequency */
  var node;          /* new node being created */

  /* Construct the initial heap, with least frequent element in
   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
   * heap[0] is not used.
   */
  s.heap_len = 0;
  s.heap_max = HEAP_SIZE;

  for (n = 0; n < elems; n++) {
    if (tree[n * 2]/*.Freq*/ !== 0) {
      s.heap[++s.heap_len] = max_code = n;
      s.depth[n] = 0;

    } else {
      tree[n * 2 + 1]/*.Len*/ = 0;
    }
  }

  /* The pkzip format requires that at least one distance code exists,
   * and that at least one bit should be sent even if there is only one
   * possible code. So to avoid special checks later on we force at least
   * two codes of non zero frequency.
   */
  while (s.heap_len < 2) {
    node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);
    tree[node * 2]/*.Freq*/ = 1;
    s.depth[node] = 0;
    s.opt_len--;

    if (has_stree) {
      s.static_len -= stree[node * 2 + 1]/*.Len*/;
    }
    /* node is 0 or 1 so it does not have extra bits */
  }
  desc.max_code = max_code;

  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
   * establish sub-heaps of increasing lengths:
   */
  for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }

  /* Construct the Huffman tree by repeatedly combining the least two
   * frequent nodes.
   */
  node = elems;              /* next internal node of the tree */
  do {
    //pqremove(s, tree, n);  /* n = node of least frequency */
    /*** pqremove ***/
    n = s.heap[1/*SMALLEST*/];
    s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];
    pqdownheap(s, tree, 1/*SMALLEST*/);
    /***/

    m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */

    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */
    s.heap[--s.heap_max] = m;

    /* Create a new node father of n and m */
    tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;
    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
    tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;

    /* and insert the new node in the heap */
    s.heap[1/*SMALLEST*/] = node++;
    pqdownheap(s, tree, 1/*SMALLEST*/);

  } while (s.heap_len >= 2);

  s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];

  /* At this point, the fields freq and dad are set. We can now
   * generate the bit lengths.
   */
  gen_bitlen(s, desc);

  /* The field len is now set, we can generate the bit codes */
  gen_codes(tree, max_code, s.bl_count);
}


/* ===========================================================================
 * Scan a literal or distance tree to determine the frequencies of the codes
 * in the bit length tree.
 */
function scan_tree(s, tree, max_code)
//    deflate_state *s;
//    ct_data *tree;   /* the tree to be scanned */
//    int max_code;    /* and its largest code of non zero frequency */
{
  var n;                     /* iterates over all tree elements */
  var prevlen = -1;          /* last emitted length */
  var curlen;                /* length of current code */

  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

  var count = 0;             /* repeat count of the current code */
  var max_count = 7;         /* max repeat count */
  var min_count = 4;         /* min repeat count */

  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

    if (++count < max_count && curlen === nextlen) {
      continue;

    } else if (count < min_count) {
      s.bl_tree[curlen * 2]/*.Freq*/ += count;

    } else if (curlen !== 0) {

      if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }
      s.bl_tree[REP_3_6 * 2]/*.Freq*/++;

    } else if (count <= 10) {
      s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;

    } else {
      s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;
    }

    count = 0;
    prevlen = curlen;

    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;

    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;

    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}


/* ===========================================================================
 * Send a literal or distance tree in compressed form, using the codes in
 * bl_tree.
 */
function send_tree(s, tree, max_code)
//    deflate_state *s;
//    ct_data *tree; /* the tree to be scanned */
//    int max_code;       /* and its largest code of non zero frequency */
{
  var n;                     /* iterates over all tree elements */
  var prevlen = -1;          /* last emitted length */
  var curlen;                /* length of current code */

  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

  var count = 0;             /* repeat count of the current code */
  var max_count = 7;         /* max repeat count */
  var min_count = 4;         /* min repeat count */

  /* tree[max_code+1].Len = -1; */  /* guard already set */
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

    if (++count < max_count && curlen === nextlen) {
      continue;

    } else if (count < min_count) {
      do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);

    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s, curlen, s.bl_tree);
        count--;
      }
      //Assert(count >= 3 && count <= 6, " 3_6?");
      send_code(s, REP_3_6, s.bl_tree);
      send_bits(s, count - 3, 2);

    } else if (count <= 10) {
      send_code(s, REPZ_3_10, s.bl_tree);
      send_bits(s, count - 3, 3);

    } else {
      send_code(s, REPZ_11_138, s.bl_tree);
      send_bits(s, count - 11, 7);
    }

    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;

    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;

    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}


/* ===========================================================================
 * Construct the Huffman tree for the bit lengths and return the index in
 * bl_order of the last bit length code to send.
 */
function build_bl_tree(s) {
  var max_blindex;  /* index of last bit length code of non zero freq */

  /* Determine the bit length frequencies for literal and distance trees */
  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);

  /* Build the bit length tree: */
  build_tree(s, s.bl_desc);
  /* opt_len now includes the length of the tree representations, except
   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
   */

  /* Determine the number of bit length codes to send. The pkzip format
   * requires that at least 4 bit length codes be sent. (appnote.txt says
   * 3 but the actual value used is 4.)
   */
  for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
    if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {
      break;
    }
  }
  /* Update opt_len to include the bit length tree and counts */
  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  //Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
  //        s->opt_len, s->static_len));

  return max_blindex;
}


/* ===========================================================================
 * Send the header for a block using dynamic Huffman trees: the counts, the
 * lengths of the bit length codes, the literal tree and the distance tree.
 * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
 */
function send_all_trees(s, lcodes, dcodes, blcodes)
//    deflate_state *s;
//    int lcodes, dcodes, blcodes; /* number of codes for each tree */
{
  var rank;                    /* index in bl_order */

  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
  //        "too many codes");
  //Tracev((stderr, "\nbl counts: "));
  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */
  send_bits(s, dcodes - 1,   5);
  send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */
  for (rank = 0; rank < blcodes; rank++) {
    //Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);
  }
  //Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */
  //Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */
  //Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
}


/* ===========================================================================
 * Check if the data type is TEXT or BINARY, using the following algorithm:
 * - TEXT if the two conditions below are satisfied:
 *    a) There are no non-portable control characters belonging to the
 *       "black list" (0..6, 14..25, 28..31).
 *    b) There is at least one printable character belonging to the
 *       "white list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
 * - BINARY otherwise.
 * - The following partially-portable control characters form a
 *   "gray list" that is ignored in this detection algorithm:
 *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
 * IN assertion: the fields Freq of dyn_ltree are set.
 */
function detect_data_type(s) {
  /* black_mask is the bit mask of black-listed bytes
   * set bits 0..6, 14..25, and 28..31
   * 0xf3ffc07f = binary 11110011111111111100000001111111
   */
  var black_mask = 0xf3ffc07f;
  var n;

  /* Check for non-textual ("black-listed") bytes. */
  for (n = 0; n <= 31; n++, black_mask >>>= 1) {
    if ((black_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {
      return Z_BINARY;
    }
  }

  /* Check for textual ("white-listed") bytes. */
  if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||
      s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {
    return Z_TEXT;
  }
  for (n = 32; n < LITERALS; n++) {
    if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {
      return Z_TEXT;
    }
  }

  /* There are no "black-listed" or "white-listed" bytes:
   * this stream either is empty or has tolerated ("gray-listed") bytes only.
   */
  return Z_BINARY;
}


var static_init_done = false;

/* ===========================================================================
 * Initialize the tree data structures for a new zlib stream.
 */
function _tr_init(s)
{

  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }

  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);
  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);
  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);

  s.bi_buf = 0;
  s.bi_valid = 0;

  /* Initialize the first block of the first file: */
  init_block(s);
}


/* ===========================================================================
 * Send a stored block
 */
function _tr_stored_block(s, buf, stored_len, last)
//DeflateState *s;
//charf *buf;       /* input block */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    /* send block type */
  copy_block(s, buf, stored_len, true); /* with header */
}


/* ===========================================================================
 * Send one empty static block to give enough lookahead for inflate.
 * This takes 10 bits, of which 7 may remain in the bit buffer.
 */
function _tr_align(s) {
  send_bits(s, STATIC_TREES << 1, 3);
  send_code(s, END_BLOCK, static_ltree);
  bi_flush(s);
}


/* ===========================================================================
 * Determine the best encoding for the current block: dynamic trees, static
 * trees or store, and output the encoded block to the zip file.
 */
function _tr_flush_block(s, buf, stored_len, last)
//DeflateState *s;
//charf *buf;       /* input block, or NULL if too old */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
  var opt_lenb, static_lenb;  /* opt_len and static_len in bytes */
  var max_blindex = 0;        /* index of last bit length code of non zero freq */

  /* Build the Huffman trees unless a stored block is forced */
  if (s.level > 0) {

    /* Check if the file is binary or text */
    if (s.strm.data_type === Z_UNKNOWN) {
      s.strm.data_type = detect_data_type(s);
    }

    /* Construct the literal and distance trees */
    build_tree(s, s.l_desc);
    // Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));

    build_tree(s, s.d_desc);
    // Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));
    /* At this point, opt_len and static_len are the total bit lengths of
     * the compressed block data, excluding the tree representations.
     */

    /* Build the bit length tree for the above two trees, and get the index
     * in bl_order of the last bit length code to send.
     */
    max_blindex = build_bl_tree(s);

    /* Determine the best encoding. Compute the block lengths in bytes. */
    opt_lenb = (s.opt_len + 3 + 7) >>> 3;
    static_lenb = (s.static_len + 3 + 7) >>> 3;

    // Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
    //        s->last_lit));

    if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }

  } else {
    // Assert(buf != (char*)0, "lost buf");
    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
  }

  if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {
    /* 4: two words for the lengths */

    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
     * Otherwise we can't have processed more than WSIZE input bytes since
     * the last block flush, because compression would have been
     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
     * transform a block into a stored block.
     */
    _tr_stored_block(s, buf, stored_len, last);

  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {

    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
    compress_block(s, static_ltree, static_dtree);

  } else {
    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s, s.dyn_ltree, s.dyn_dtree);
  }
  // Assert (s->compressed_len == s->bits_sent, "bad compressed size");
  /* The above check is made mod 2^32, for files larger than 512 MB
   * and uLong implemented on 32 bits.
   */
  init_block(s);

  if (last) {
    bi_windup(s);
  }
  // Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
  //       s->compressed_len-7*last));
}

/* ===========================================================================
 * Save the match info and tally the frequency counts. Return true if
 * the current block must be flushed.
 */
function _tr_tally(s, dist, lc)
//    deflate_state *s;
//    unsigned dist;  /* distance of matched string */
//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
{
  //var out_length, in_length, dcode;

  s.pending_buf[s.d_buf + s.last_lit * 2]     = (dist >>> 8) & 0xff;
  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;

  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;
  s.last_lit++;

  if (dist === 0) {
    /* lc is the unmatched char */
    s.dyn_ltree[lc * 2]/*.Freq*/++;
  } else {
    s.matches++;
    /* Here, lc is the match length - MIN_MATCH */
    dist--;             /* dist = match distance - 1 */
    //Assert((ush)dist < (ush)MAX_DIST(s) &&
    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
    //       (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");

    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]/*.Freq*/++;
    s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;
  }

// (!) This block is disabled in zlib defaults,
// don't enable it for binary compatibility

//#ifdef TRUNCATE_BLOCK
//  /* Try to guess if it is profitable to stop the current block here */
//  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {
//    /* Compute an upper bound for the compressed length */
//    out_length = s.last_lit*8;
//    in_length = s.strstart - s.block_start;
//
//    for (dcode = 0; dcode < D_CODES; dcode++) {
//      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);
//    }
//    out_length >>>= 3;
//    //Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
//    //       s->last_lit, in_length, out_length,
//    //       100L - out_length*100L/in_length));
//    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {
//      return true;
//    }
//  }
//#endif

  return (s.last_lit === s.lit_bufsize - 1);
  /* We avoid equality with lit_bufsize because of wraparound at 64K
   * on 16 bit machines and because stored blocks are restricted to
   * 64K-1 bytes.
   */
}

exports._tr_init  = _tr_init;
exports._tr_stored_block = _tr_stored_block;
exports._tr_flush_block  = _tr_flush_block;
exports._tr_tally = _tr_tally;
exports._tr_align = _tr_align;

},{"../utils/common":"..\\node_modules\\pako\\lib\\utils\\common.js"}],"..\\node_modules\\pako\\lib\\zlib\\adler32.js":[function(require,module,exports) {
'use strict';

// Note: adler32 takes 12% for level 0 and 2% for level 6.
// It isn't worth it to make additional optimizations as in original.
// Small size is preferable.

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function adler32(adler, buf, len, pos) {
  var s1 = (adler & 0xffff) |0,
      s2 = ((adler >>> 16) & 0xffff) |0,
      n = 0;

  while (len !== 0) {
    // Set limit ~ twice less than 5552, to keep
    // s2 in 31-bits, because we force signed ints.
    // in other case %= will fail.
    n = len > 2000 ? 2000 : len;
    len -= n;

    do {
      s1 = (s1 + buf[pos++]) |0;
      s2 = (s2 + s1) |0;
    } while (--n);

    s1 %= 65521;
    s2 %= 65521;
  }

  return (s1 | (s2 << 16)) |0;
}


module.exports = adler32;

},{}],"..\\node_modules\\pako\\lib\\zlib\\crc32.js":[function(require,module,exports) {
'use strict';

// Note: we can't get significant speed boost here.
// So write code to minimize size - no pregenerated tables
// and array tools dependencies.

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

// Use ordinary array, since untyped makes no boost here
function makeTable() {
  var c, table = [];

  for (var n = 0; n < 256; n++) {
    c = n;
    for (var k = 0; k < 8; k++) {
      c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
    }
    table[n] = c;
  }

  return table;
}

// Create table on load. Just 255 signed longs. Not a problem.
var crcTable = makeTable();


function crc32(crc, buf, len, pos) {
  var t = crcTable,
      end = pos + len;

  crc ^= -1;

  for (var i = pos; i < end; i++) {
    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];
  }

  return (crc ^ (-1)); // >>> 0;
}


module.exports = crc32;

},{}],"..\\node_modules\\pako\\lib\\zlib\\messages.js":[function(require,module,exports) {
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

module.exports = {
  2:      'need dictionary',     /* Z_NEED_DICT       2  */
  1:      'stream end',          /* Z_STREAM_END      1  */
  0:      '',                    /* Z_OK              0  */
  '-1':   'file error',          /* Z_ERRNO         (-1) */
  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */
  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */
  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */
  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */
  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */
};

},{}],"..\\node_modules\\pako\\lib\\zlib\\deflate.js":[function(require,module,exports) {
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var utils   = require('../utils/common');
var trees   = require('./trees');
var adler32 = require('./adler32');
var crc32   = require('./crc32');
var msg     = require('./messages');

/* Public constants ==========================================================*/
/* ===========================================================================*/


/* Allowed flush values; see deflate() and inflate() below for details */
var Z_NO_FLUSH      = 0;
var Z_PARTIAL_FLUSH = 1;
//var Z_SYNC_FLUSH    = 2;
var Z_FULL_FLUSH    = 3;
var Z_FINISH        = 4;
var Z_BLOCK         = 5;
//var Z_TREES         = 6;


/* Return codes for the compression/decompression functions. Negative values
 * are errors, positive values are used for special but normal events.
 */
var Z_OK            = 0;
var Z_STREAM_END    = 1;
//var Z_NEED_DICT     = 2;
//var Z_ERRNO         = -1;
var Z_STREAM_ERROR  = -2;
var Z_DATA_ERROR    = -3;
//var Z_MEM_ERROR     = -4;
var Z_BUF_ERROR     = -5;
//var Z_VERSION_ERROR = -6;


/* compression levels */
//var Z_NO_COMPRESSION      = 0;
//var Z_BEST_SPEED          = 1;
//var Z_BEST_COMPRESSION    = 9;
var Z_DEFAULT_COMPRESSION = -1;


var Z_FILTERED            = 1;
var Z_HUFFMAN_ONLY        = 2;
var Z_RLE                 = 3;
var Z_FIXED               = 4;
var Z_DEFAULT_STRATEGY    = 0;

/* Possible values of the data_type field (though see inflate()) */
//var Z_BINARY              = 0;
//var Z_TEXT                = 1;
//var Z_ASCII               = 1; // = Z_TEXT
var Z_UNKNOWN             = 2;


/* The deflate compression method */
var Z_DEFLATED  = 8;

/*============================================================================*/


var MAX_MEM_LEVEL = 9;
/* Maximum value for memLevel in deflateInit2 */
var MAX_WBITS = 15;
/* 32K LZ77 window */
var DEF_MEM_LEVEL = 8;


var LENGTH_CODES  = 29;
/* number of length codes, not counting the special END_BLOCK code */
var LITERALS      = 256;
/* number of literal bytes 0..255 */
var L_CODES       = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */
var D_CODES       = 30;
/* number of distance codes */
var BL_CODES      = 19;
/* number of codes used to transfer the bit lengths */
var HEAP_SIZE     = 2 * L_CODES + 1;
/* maximum heap size */
var MAX_BITS  = 15;
/* All codes must not exceed MAX_BITS bits */

var MIN_MATCH = 3;
var MAX_MATCH = 258;
var MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);

var PRESET_DICT = 0x20;

var INIT_STATE = 42;
var EXTRA_STATE = 69;
var NAME_STATE = 73;
var COMMENT_STATE = 91;
var HCRC_STATE = 103;
var BUSY_STATE = 113;
var FINISH_STATE = 666;

var BS_NEED_MORE      = 1; /* block not completed, need more input or more output */
var BS_BLOCK_DONE     = 2; /* block flush performed */
var BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */
var BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */

var OS_CODE = 0x03; // Unix :) . Don't detect, use this default.

function err(strm, errorCode) {
  strm.msg = msg[errorCode];
  return errorCode;
}

function rank(f) {
  return ((f) << 1) - ((f) > 4 ? 9 : 0);
}

function zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }


/* =========================================================================
 * Flush as much pending output as possible. All deflate() output goes
 * through this function so some applications may wish to modify it
 * to avoid allocating a large strm->output buffer and copying into it.
 * (See also read_buf()).
 */
function flush_pending(strm) {
  var s = strm.state;

  //_tr_flush_bits(s);
  var len = s.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) { return; }

  utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
  strm.next_out += len;
  s.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s.pending -= len;
  if (s.pending === 0) {
    s.pending_out = 0;
  }
}


function flush_block_only(s, last) {
  trees._tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);
  s.block_start = s.strstart;
  flush_pending(s.strm);
}


function put_byte(s, b) {
  s.pending_buf[s.pending++] = b;
}


/* =========================================================================
 * Put a short in the pending buffer. The 16-bit value is put in MSB order.
 * IN assertion: the stream state is correct and there is enough room in
 * pending_buf.
 */
function putShortMSB(s, b) {
//  put_byte(s, (Byte)(b >> 8));
//  put_byte(s, (Byte)(b & 0xff));
  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;
  s.pending_buf[s.pending++] = b & 0xff;
}


/* ===========================================================================
 * Read a new buffer from the current input stream, update the adler32
 * and total number of bytes read.  All deflate() input goes through
 * this function so some applications may wish to modify it to avoid
 * allocating a large strm->input buffer and copying from it.
 * (See also flush_pending()).
 */
function read_buf(strm, buf, start, size) {
  var len = strm.avail_in;

  if (len > size) { len = size; }
  if (len === 0) { return 0; }

  strm.avail_in -= len;

  // zmemcpy(buf, strm->next_in, len);
  utils.arraySet(buf, strm.input, strm.next_in, len, start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32(strm.adler, buf, len, start);
  }

  else if (strm.state.wrap === 2) {
    strm.adler = crc32(strm.adler, buf, len, start);
  }

  strm.next_in += len;
  strm.total_in += len;

  return len;
}


/* ===========================================================================
 * Set match_start to the longest match starting at the given string and
 * return its length. Matches shorter or equal to prev_length are discarded,
 * in which case the result is equal to prev_length and match_start is
 * garbage.
 * IN assertions: cur_match is the head of the hash chain for the current
 *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
 * OUT assertion: the match length is not greater than s->lookahead.
 */
function longest_match(s, cur_match) {
  var chain_length = s.max_chain_length;      /* max hash chain length */
  var scan = s.strstart; /* current string */
  var match;                       /* matched string */
  var len;                           /* length of current match */
  var best_len = s.prev_length;              /* best match length so far */
  var nice_match = s.nice_match;             /* stop if match long enough */
  var limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?
      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;

  var _win = s.window; // shortcut

  var wmask = s.w_mask;
  var prev  = s.prev;

  /* Stop when cur_match becomes <= limit. To simplify the code,
   * we prevent matches with the string of window index 0.
   */

  var strend = s.strstart + MAX_MATCH;
  var scan_end1  = _win[scan + best_len - 1];
  var scan_end   = _win[scan + best_len];

  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
   * It is easy to get rid of this optimization if necessary.
   */
  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");

  /* Do not waste too much time if we already have a good match: */
  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  /* Do not look for matches beyond the end of the input. This is necessary
   * to make deflate deterministic.
   */
  if (nice_match > s.lookahead) { nice_match = s.lookahead; }

  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");

  do {
    // Assert(cur_match < s->strstart, "no future");
    match = cur_match;

    /* Skip to next match if the match length cannot increase
     * or if the match length is less than 2.  Note that the checks below
     * for insufficient lookahead only occur occasionally for performance
     * reasons.  Therefore uninitialized memory will be accessed, and
     * conditional jumps will be made that depend on those values.
     * However the length of the match is limited to the lookahead, so
     * the output of deflate is not affected by the uninitialized values.
     */

    if (_win[match + best_len]     !== scan_end  ||
        _win[match + best_len - 1] !== scan_end1 ||
        _win[match]                !== _win[scan] ||
        _win[++match]              !== _win[scan + 1]) {
      continue;
    }

    /* The check at best_len-1 can be removed because it will be made
     * again later. (This heuristic is not always a win.)
     * It is not necessary to compare scan[2] and match[2] since they
     * are always equal when the other bytes match, given that
     * the hash keys are equal and that HASH_BITS >= 8.
     */
    scan += 2;
    match++;
    // Assert(*scan == *match, "match[2]?");

    /* We check for insufficient lookahead only every 8th comparison;
     * the 256th check will be made at strstart+258.
     */
    do {
      /*jshint noempty:false*/
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             scan < strend);

    // Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");

    len = MAX_MATCH - (strend - scan);
    scan = strend - MAX_MATCH;

    if (len > best_len) {
      s.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1  = _win[scan + best_len - 1];
      scan_end   = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);

  if (best_len <= s.lookahead) {
    return best_len;
  }
  return s.lookahead;
}


/* ===========================================================================
 * Fill the window when the lookahead becomes insufficient.
 * Updates strstart and lookahead.
 *
 * IN assertion: lookahead < MIN_LOOKAHEAD
 * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
 *    At least one byte has been read, or avail_in == 0; reads are
 *    performed for at least two bytes (required for the zip translate_eol
 *    option -- not supported here).
 */
function fill_window(s) {
  var _w_size = s.w_size;
  var p, n, m, more, str;

  //Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");

  do {
    more = s.window_size - s.lookahead - s.strstart;

    // JS ints have 32 bit, block below not needed
    /* Deal with !@#$% 64K limit: */
    //if (sizeof(int) <= 2) {
    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
    //        more = wsize;
    //
    //  } else if (more == (unsigned)(-1)) {
    //        /* Very unlikely, but possible on 16 bit machine if
    //         * strstart == 0 && lookahead == 1 (input done a byte at time)
    //         */
    //        more--;
    //    }
    //}


    /* If the window is almost full and there is insufficient lookahead,
     * move the upper half to the lower one to make room in the upper half.
     */
    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {

      utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      /* we now have strstart >= MAX_DIST */
      s.block_start -= _w_size;

      /* Slide the hash table (could be avoided with 32 bit values
       at the expense of memory usage). We slide even when level == 0
       to keep the hash table consistent if we switch back to level > 0
       later. (Using level 0 permanently is not an optimal usage of
       zlib, so we don't care about this pathological case.)
       */

      n = s.hash_size;
      p = n;
      do {
        m = s.head[--p];
        s.head[p] = (m >= _w_size ? m - _w_size : 0);
      } while (--n);

      n = _w_size;
      p = n;
      do {
        m = s.prev[--p];
        s.prev[p] = (m >= _w_size ? m - _w_size : 0);
        /* If n is not on any hash chain, prev[n] is garbage but
         * its value will never be used.
         */
      } while (--n);

      more += _w_size;
    }
    if (s.strm.avail_in === 0) {
      break;
    }

    /* If there was no sliding:
     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
     *    more == window_size - lookahead - strstart
     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
     * => more >= window_size - 2*WSIZE + 2
     * In the BIG_MEM or MMAP case (not yet supported),
     *   window_size == input_size + MIN_LOOKAHEAD  &&
     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
     * Otherwise, window_size == 2*WSIZE so more >= 2.
     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
     */
    //Assert(more >= 2, "more < 2");
    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n;

    /* Initialize the hash value now that we have some input: */
    if (s.lookahead + s.insert >= MIN_MATCH) {
      str = s.strstart - s.insert;
      s.ins_h = s.window[str];

      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + 1]) & s.hash_mask;
//#if MIN_MATCH != 3
//        Call update_hash() MIN_MATCH-3 more times
//#endif
      while (s.insert) {
        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;

        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
        s.insert--;
        if (s.lookahead + s.insert < MIN_MATCH) {
          break;
        }
      }
    }
    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
     * but this is not important since only literal bytes will be emitted.
     */

  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);

  /* If the WIN_INIT bytes after the end of the current data have never been
   * written, then zero those bytes in order to avoid memory check reports of
   * the use of uninitialized (or uninitialised as Julian writes) bytes by
   * the longest match routines.  Update the high water mark for the next
   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
   */
//  if (s.high_water < s.window_size) {
//    var curr = s.strstart + s.lookahead;
//    var init = 0;
//
//    if (s.high_water < curr) {
//      /* Previous high water mark below current data -- zero WIN_INIT
//       * bytes or up to end of window, whichever is less.
//       */
//      init = s.window_size - curr;
//      if (init > WIN_INIT)
//        init = WIN_INIT;
//      zmemzero(s->window + curr, (unsigned)init);
//      s->high_water = curr + init;
//    }
//    else if (s->high_water < (ulg)curr + WIN_INIT) {
//      /* High water mark at or above current data, but below current data
//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
//       * to end of window, whichever is less.
//       */
//      init = (ulg)curr + WIN_INIT - s->high_water;
//      if (init > s->window_size - s->high_water)
//        init = s->window_size - s->high_water;
//      zmemzero(s->window + s->high_water, (unsigned)init);
//      s->high_water += init;
//    }
//  }
//
//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
//    "not enough room for search");
}

/* ===========================================================================
 * Copy without compression as much as possible from the input stream, return
 * the current block state.
 * This function does not insert new strings in the dictionary since
 * uncompressible data is probably not useful. This function is used
 * only for the level=0 compression option.
 * NOTE: this function should be optimized to avoid extra copying from
 * window to pending_buf.
 */
function deflate_stored(s, flush) {
  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
   * to pending_buf_size, and each stored block has a 5 byte header:
   */
  var max_block_size = 0xffff;

  if (max_block_size > s.pending_buf_size - 5) {
    max_block_size = s.pending_buf_size - 5;
  }

  /* Copy as much as possible from input to output: */
  for (;;) {
    /* Fill the window as much as possible: */
    if (s.lookahead <= 1) {

      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||
      //  s->block_start >= (long)s->w_size, "slide too late");
//      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||
//        s.block_start >= s.w_size)) {
//        throw  new Error("slide too late");
//      }

      fill_window(s);
      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }

      if (s.lookahead === 0) {
        break;
      }
      /* flush the current block */
    }
    //Assert(s->block_start >= 0L, "block gone");
//    if (s.block_start < 0) throw new Error("block gone");

    s.strstart += s.lookahead;
    s.lookahead = 0;

    /* Emit a stored block if pending_buf will be full: */
    var max_start = s.block_start + max_block_size;

    if (s.strstart === 0 || s.strstart >= max_start) {
      /* strstart == 0 is possible when wraparound on 16-bit machine */
      s.lookahead = s.strstart - max_start;
      s.strstart = max_start;
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/


    }
    /* Flush if we may have to slide, otherwise block_start may become
     * negative and the data will be gone:
     */
    if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }

  s.insert = 0;

  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }

  if (s.strstart > s.block_start) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }

  return BS_NEED_MORE;
}

/* ===========================================================================
 * Compress as much as possible from the input stream, return the current
 * block state.
 * This function does not perform lazy evaluation of matches and inserts
 * new strings in the dictionary only for unmatched strings or for short
 * matches. It is used only for the fast compression options.
 */
function deflate_fast(s, flush) {
  var hash_head;        /* head of the hash chain */
  var bflush;           /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break; /* flush the current block */
      }
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0/*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     * At this point we have always match_length < MIN_MATCH
     */
    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */
    }
    if (s.match_length >= MIN_MATCH) {
      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only

      /*** _tr_tally_dist(s, s.strstart - s.match_start,
                     s.match_length - MIN_MATCH, bflush); ***/
      bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;

      /* Insert new strings in the hash table only if the match length
       * is not too large. This saves time but degrades compression.
       */
      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {
        s.match_length--; /* string at strstart already in table */
        do {
          s.strstart++;
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
          /* strstart never exceeds WSIZE-MAX_MATCH, so there are
           * always MIN_MATCH bytes ahead.
           */
        } while (--s.match_length !== 0);
        s.strstart++;
      } else
      {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */
        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + 1]) & s.hash_mask;

//#if MIN_MATCH != 3
//                Call UPDATE_HASH() MIN_MATCH-3 more times
//#endif
        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
         * matter since it will be recomputed at next deflate call.
         */
      }
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s.window[s.strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* ===========================================================================
 * Same as above, but achieves better compression. We use a lazy
 * evaluation for matches: a match is finally adopted only if there is
 * no better match at the next window position.
 */
function deflate_slow(s, flush) {
  var hash_head;          /* head of hash chain */
  var bflush;              /* set if current block must be flushed */

  var max_insert;

  /* Process the input block. */
  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) { break; } /* flush the current block */
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0/*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     */
    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH - 1;

    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&
        s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */

      if (s.match_length <= 5 &&
         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {

        /* If prev_match is also MIN_MATCH, match_start is garbage
         * but we will ignore the current match anyway.
         */
        s.match_length = MIN_MATCH - 1;
      }
    }
    /* If there was a match at the previous step and the current
     * match is not better, output the previous match:
     */
    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH;
      /* Do not insert strings in hash table beyond this. */

      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);

      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,
                     s.prev_length - MIN_MATCH, bflush);***/
      bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
      /* Insert in hash table all strings up to the end of the match.
       * strstart-1 and strstart are already inserted. If there is not
       * enough lookahead, the last two strings are not inserted in
       * the hash table.
       */
      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;
      do {
        if (++s.strstart <= max_insert) {
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
        }
      } while (--s.prev_length !== 0);
      s.match_available = 0;
      s.match_length = MIN_MATCH - 1;
      s.strstart++;

      if (bflush) {
        /*** FLUSH_BLOCK(s, 0); ***/
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
        /***/
      }

    } else if (s.match_available) {
      /* If there was no match at the previous position, output a
       * single literal. If there was a match but the current match
       * is longer, truncate the previous match to a single literal.
       */
      //Tracevv((stderr,"%c", s->window[s->strstart-1]));
      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);

      if (bflush) {
        /*** FLUSH_BLOCK_ONLY(s, 0) ***/
        flush_block_only(s, false);
        /***/
      }
      s.strstart++;
      s.lookahead--;
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      /* There is no previous match to compare with, wait for
       * the next step to decide.
       */
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  }
  //Assert (flush != Z_NO_FLUSH, "no flush?");
  if (s.match_available) {
    //Tracevv((stderr,"%c", s->window[s->strstart-1]));
    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
    bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);

    s.match_available = 0;
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }

  return BS_BLOCK_DONE;
}


/* ===========================================================================
 * For Z_RLE, simply look for runs of bytes, generate matches only of distance
 * one.  Do not maintain a hash table.  (It will be regenerated if this run of
 * deflate switches away from Z_RLE.)
 */
function deflate_rle(s, flush) {
  var bflush;            /* set if current block must be flushed */
  var prev;              /* byte at distance one to match */
  var scan, strend;      /* scan goes up to strend for length of run */

  var _win = s.window;

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the longest run, plus one for the unrolled loop.
     */
    if (s.lookahead <= MAX_MATCH) {
      fill_window(s);
      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) { break; } /* flush the current block */
    }

    /* See how many times the previous byte repeats */
    s.match_length = 0;
    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
      scan = s.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s.strstart + MAX_MATCH;
        do {
          /*jshint noempty:false*/
        } while (prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 scan < strend);
        s.match_length = MAX_MATCH - (strend - scan);
        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      }
      //Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");
    }

    /* Emit match if have run of MIN_MATCH or longer, else emit literal */
    if (s.match_length >= MIN_MATCH) {
      //check_match(s, s.strstart, s.strstart - 1, s.match_length);

      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/
      bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s->window[s->strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* ===========================================================================
 * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
 * (It will be regenerated if this run of deflate switches away from Huffman.)
 */
function deflate_huff(s, flush) {
  var bflush;             /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we have a literal to write. */
    if (s.lookahead === 0) {
      fill_window(s);
      if (s.lookahead === 0) {
        if (flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        break;      /* flush the current block */
      }
    }

    /* Output a literal byte */
    s.match_length = 0;
    //Tracevv((stderr,"%c", s->window[s->strstart]));
    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* Values for max_lazy_match, good_match and max_chain_length, depending on
 * the desired pack level (0..9). The values given below have been tuned to
 * exclude worst case performance for pathological files. Better values may be
 * found for specific files.
 */
function Config(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}

var configuration_table;

configuration_table = [
  /*      good lazy nice chain */
  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */
  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */
  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */
  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */

  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */
  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */
  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */
  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */
  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */
  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */
];


/* ===========================================================================
 * Initialize the "longest match" routines for a new zlib stream
 */
function lm_init(s) {
  s.window_size = 2 * s.w_size;

  /*** CLEAR_HASH(s); ***/
  zero(s.head); // Fill with NIL (= 0);

  /* Set the default configuration parameters:
   */
  s.max_lazy_match = configuration_table[s.level].max_lazy;
  s.good_match = configuration_table[s.level].good_length;
  s.nice_match = configuration_table[s.level].nice_length;
  s.max_chain_length = configuration_table[s.level].max_chain;

  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  s.ins_h = 0;
}


function DeflateState() {
  this.strm = null;            /* pointer back to this zlib stream */
  this.status = 0;            /* as the name implies */
  this.pending_buf = null;      /* output still pending */
  this.pending_buf_size = 0;  /* size of pending_buf */
  this.pending_out = 0;       /* next pending byte to output to the stream */
  this.pending = 0;           /* nb of bytes in the pending buffer */
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
  this.gzhead = null;         /* gzip header information to write */
  this.gzindex = 0;           /* where in extra, name, or comment */
  this.method = Z_DEFLATED; /* can only be DEFLATED */
  this.last_flush = -1;   /* value of flush param for previous deflate call */

  this.w_size = 0;  /* LZ77 window size (32K by default) */
  this.w_bits = 0;  /* log2(w_size)  (8..16) */
  this.w_mask = 0;  /* w_size - 1 */

  this.window = null;
  /* Sliding window. Input bytes are read into the second half of the window,
   * and move to the first half later to keep a dictionary of at least wSize
   * bytes. With this organization, matches are limited to a distance of
   * wSize-MAX_MATCH bytes, but this ensures that IO is always
   * performed with a length multiple of the block size.
   */

  this.window_size = 0;
  /* Actual size of window: 2*wSize, except when the user input buffer
   * is directly used as sliding window.
   */

  this.prev = null;
  /* Link to older string with same hash index. To limit the size of this
   * array to 64K, this link is maintained only for the last 32K strings.
   * An index in this array is thus a window index modulo 32K.
   */

  this.head = null;   /* Heads of the hash chains or NIL. */

  this.ins_h = 0;       /* hash index of string to be inserted */
  this.hash_size = 0;   /* number of elements in hash table */
  this.hash_bits = 0;   /* log2(hash_size) */
  this.hash_mask = 0;   /* hash_size-1 */

  this.hash_shift = 0;
  /* Number of bits by which ins_h must be shifted at each input
   * step. It must be such that after MIN_MATCH steps, the oldest
   * byte no longer takes part in the hash key, that is:
   *   hash_shift * MIN_MATCH >= hash_bits
   */

  this.block_start = 0;
  /* Window position at the beginning of the current output block. Gets
   * negative when the window is moved backwards.
   */

  this.match_length = 0;      /* length of best match */
  this.prev_match = 0;        /* previous match */
  this.match_available = 0;   /* set if previous match exists */
  this.strstart = 0;          /* start of string to insert */
  this.match_start = 0;       /* start of matching string */
  this.lookahead = 0;         /* number of valid bytes ahead in window */

  this.prev_length = 0;
  /* Length of the best match at previous step. Matches not greater than this
   * are discarded. This is used in the lazy match evaluation.
   */

  this.max_chain_length = 0;
  /* To speed up deflation, hash chains are never searched beyond this
   * length.  A higher limit improves compression ratio but degrades the
   * speed.
   */

  this.max_lazy_match = 0;
  /* Attempt to find a better match only when the current match is strictly
   * smaller than this value. This mechanism is used only for compression
   * levels >= 4.
   */
  // That's alias to max_lazy_match, don't use directly
  //this.max_insert_length = 0;
  /* Insert new strings in the hash table only if the match length is not
   * greater than this length. This saves time but degrades compression.
   * max_insert_length is used only for compression levels <= 3.
   */

  this.level = 0;     /* compression level (1..9) */
  this.strategy = 0;  /* favor or force Huffman coding*/

  this.good_match = 0;
  /* Use a faster search when the previous match is longer than this */

  this.nice_match = 0; /* Stop searching when current match exceeds this */

              /* used by trees.c: */

  /* Didn't use ct_data typedef below to suppress compiler warning */

  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */

  // Use flat array of DOUBLE size, with interleaved fata,
  // because JS does not support effective
  this.dyn_ltree  = new utils.Buf16(HEAP_SIZE * 2);
  this.dyn_dtree  = new utils.Buf16((2 * D_CODES + 1) * 2);
  this.bl_tree    = new utils.Buf16((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);

  this.l_desc   = null;         /* desc. for literal tree */
  this.d_desc   = null;         /* desc. for distance tree */
  this.bl_desc  = null;         /* desc. for bit length tree */

  //ush bl_count[MAX_BITS+1];
  this.bl_count = new utils.Buf16(MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */

  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
  this.heap = new utils.Buf16(2 * L_CODES + 1);  /* heap used to build the Huffman trees */
  zero(this.heap);

  this.heap_len = 0;               /* number of elements in the heap */
  this.heap_max = 0;               /* element of largest frequency */
  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
   * The same heap array is used to build all trees.
   */

  this.depth = new utils.Buf16(2 * L_CODES + 1); //uch depth[2*L_CODES+1];
  zero(this.depth);
  /* Depth of each subtree used as tie breaker for trees of equal frequency
   */

  this.l_buf = 0;          /* buffer index for literals or lengths */

  this.lit_bufsize = 0;
  /* Size of match buffer for literals/lengths.  There are 4 reasons for
   * limiting lit_bufsize to 64K:
   *   - frequencies can be kept in 16 bit counters
   *   - if compression is not successful for the first block, all input
   *     data is still in the window so we can still emit a stored block even
   *     when input comes from standard input.  (This can also be done for
   *     all blocks if lit_bufsize is not greater than 32K.)
   *   - if compression is not successful for a file smaller than 64K, we can
   *     even emit a stored file instead of a stored block (saving 5 bytes).
   *     This is applicable only for zip (not gzip or zlib).
   *   - creating new Huffman trees less frequently may not provide fast
   *     adaptation to changes in the input data statistics. (Take for
   *     example a binary file with poorly compressible code followed by
   *     a highly compressible string table.) Smaller buffer sizes give
   *     fast adaptation but have of course the overhead of transmitting
   *     trees more frequently.
   *   - I can't count above 4
   */

  this.last_lit = 0;      /* running index in l_buf */

  this.d_buf = 0;
  /* Buffer index for distances. To simplify the code, d_buf and l_buf have
   * the same number of elements. To use different lengths, an extra flag
   * array would be necessary.
   */

  this.opt_len = 0;       /* bit length of current block with optimal trees */
  this.static_len = 0;    /* bit length of current block with static trees */
  this.matches = 0;       /* number of string matches in current block */
  this.insert = 0;        /* bytes at end of window left to insert */


  this.bi_buf = 0;
  /* Output buffer. bits are inserted starting at the bottom (least
   * significant bits).
   */
  this.bi_valid = 0;
  /* Number of valid bits in bi_buf.  All bits above the last valid bit
   * are always zero.
   */

  // Used for window memory init. We safely ignore it for JS. That makes
  // sense only for pointers and memory check tools.
  //this.high_water = 0;
  /* High water mark offset in window for initialized bytes -- bytes above
   * this are set to zero in order to avoid memory check warnings when
   * longest match routines access bytes past the input.  This is then
   * updated to the new high water mark.
   */
}


function deflateResetKeep(strm) {
  var s;

  if (!strm || !strm.state) {
    return err(strm, Z_STREAM_ERROR);
  }

  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;

  s = strm.state;
  s.pending = 0;
  s.pending_out = 0;

  if (s.wrap < 0) {
    s.wrap = -s.wrap;
    /* was made negative by deflate(..., Z_FINISH); */
  }
  s.status = (s.wrap ? INIT_STATE : BUSY_STATE);
  strm.adler = (s.wrap === 2) ?
    0  // crc32(0, Z_NULL, 0)
  :
    1; // adler32(0, Z_NULL, 0)
  s.last_flush = Z_NO_FLUSH;
  trees._tr_init(s);
  return Z_OK;
}


function deflateReset(strm) {
  var ret = deflateResetKeep(strm);
  if (ret === Z_OK) {
    lm_init(strm.state);
  }
  return ret;
}


function deflateSetHeader(strm, head) {
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  if (strm.state.wrap !== 2) { return Z_STREAM_ERROR; }
  strm.state.gzhead = head;
  return Z_OK;
}


function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
  if (!strm) { // === Z_NULL
    return Z_STREAM_ERROR;
  }
  var wrap = 1;

  if (level === Z_DEFAULT_COMPRESSION) {
    level = 6;
  }

  if (windowBits < 0) { /* suppress zlib wrapper */
    wrap = 0;
    windowBits = -windowBits;
  }

  else if (windowBits > 15) {
    wrap = 2;           /* write gzip wrapper instead */
    windowBits -= 16;
  }


  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED ||
    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
    strategy < 0 || strategy > Z_FIXED) {
    return err(strm, Z_STREAM_ERROR);
  }


  if (windowBits === 8) {
    windowBits = 9;
  }
  /* until 256-byte window bug fixed */

  var s = new DeflateState();

  strm.state = s;
  s.strm = strm;

  s.wrap = wrap;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 << s.w_bits;
  s.w_mask = s.w_size - 1;

  s.hash_bits = memLevel + 7;
  s.hash_size = 1 << s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);

  s.window = new utils.Buf8(s.w_size * 2);
  s.head = new utils.Buf16(s.hash_size);
  s.prev = new utils.Buf16(s.w_size);

  // Don't need mem init magic for JS.
  //s.high_water = 0;  /* nothing written to s->window yet */

  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */

  s.pending_buf_size = s.lit_bufsize * 4;

  //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);
  //s->pending_buf = (uchf *) overlay;
  s.pending_buf = new utils.Buf8(s.pending_buf_size);

  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)
  //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);
  s.d_buf = 1 * s.lit_bufsize;

  //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;
  s.l_buf = (1 + 2) * s.lit_bufsize;

  s.level = level;
  s.strategy = strategy;
  s.method = method;

  return deflateReset(strm);
}

function deflateInit(strm, level) {
  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
}


function deflate(strm, flush) {
  var old_flush, s;
  var beg, val; // for gzip header write only

  if (!strm || !strm.state ||
    flush > Z_BLOCK || flush < 0) {
    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
  }

  s = strm.state;

  if (!strm.output ||
      (!strm.input && strm.avail_in !== 0) ||
      (s.status === FINISH_STATE && flush !== Z_FINISH)) {
    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);
  }

  s.strm = strm; /* just in case */
  old_flush = s.last_flush;
  s.last_flush = flush;

  /* Write the header */
  if (s.status === INIT_STATE) {

    if (s.wrap === 2) { // GZIP header
      strm.adler = 0;  //crc32(0L, Z_NULL, 0);
      put_byte(s, 31);
      put_byte(s, 139);
      put_byte(s, 8);
      if (!s.gzhead) { // s->gzhead == Z_NULL
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, s.level === 9 ? 2 :
                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                     4 : 0));
        put_byte(s, OS_CODE);
        s.status = BUSY_STATE;
      }
      else {
        put_byte(s, (s.gzhead.text ? 1 : 0) +
                    (s.gzhead.hcrc ? 2 : 0) +
                    (!s.gzhead.extra ? 0 : 4) +
                    (!s.gzhead.name ? 0 : 8) +
                    (!s.gzhead.comment ? 0 : 16)
                );
        put_byte(s, s.gzhead.time & 0xff);
        put_byte(s, (s.gzhead.time >> 8) & 0xff);
        put_byte(s, (s.gzhead.time >> 16) & 0xff);
        put_byte(s, (s.gzhead.time >> 24) & 0xff);
        put_byte(s, s.level === 9 ? 2 :
                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                     4 : 0));
        put_byte(s, s.gzhead.os & 0xff);
        if (s.gzhead.extra && s.gzhead.extra.length) {
          put_byte(s, s.gzhead.extra.length & 0xff);
          put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);
        }
        if (s.gzhead.hcrc) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
        }
        s.gzindex = 0;
        s.status = EXTRA_STATE;
      }
    }
    else // DEFLATE header
    {
      var header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;
      var level_flags = -1;

      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
        level_flags = 0;
      } else if (s.level < 6) {
        level_flags = 1;
      } else if (s.level === 6) {
        level_flags = 2;
      } else {
        level_flags = 3;
      }
      header |= (level_flags << 6);
      if (s.strstart !== 0) { header |= PRESET_DICT; }
      header += 31 - (header % 31);

      s.status = BUSY_STATE;
      putShortMSB(s, header);

      /* Save the adler32 of the preset dictionary: */
      if (s.strstart !== 0) {
        putShortMSB(s, strm.adler >>> 16);
        putShortMSB(s, strm.adler & 0xffff);
      }
      strm.adler = 1; // adler32(0L, Z_NULL, 0);
    }
  }

//#ifdef GZIP
  if (s.status === EXTRA_STATE) {
    if (s.gzhead.extra/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */

      while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            break;
          }
        }
        put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);
        s.gzindex++;
      }
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (s.gzindex === s.gzhead.extra.length) {
        s.gzindex = 0;
        s.status = NAME_STATE;
      }
    }
    else {
      s.status = NAME_STATE;
    }
  }
  if (s.status === NAME_STATE) {
    if (s.gzhead.name/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */
      //int val;

      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex < s.gzhead.name.length) {
          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);

      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.gzindex = 0;
        s.status = COMMENT_STATE;
      }
    }
    else {
      s.status = COMMENT_STATE;
    }
  }
  if (s.status === COMMENT_STATE) {
    if (s.gzhead.comment/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */
      //int val;

      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex < s.gzhead.comment.length) {
          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);

      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.status = HCRC_STATE;
      }
    }
    else {
      s.status = HCRC_STATE;
    }
  }
  if (s.status === HCRC_STATE) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending(strm);
      }
      if (s.pending + 2 <= s.pending_buf_size) {
        put_byte(s, strm.adler & 0xff);
        put_byte(s, (strm.adler >> 8) & 0xff);
        strm.adler = 0; //crc32(0L, Z_NULL, 0);
        s.status = BUSY_STATE;
      }
    }
    else {
      s.status = BUSY_STATE;
    }
  }
//#endif

  /* Flush as much pending output as possible */
  if (s.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      /* Since avail_out is 0, deflate will be called again with
       * more output space, but possibly with both pending and
       * avail_in equal to zero. There won't be anything to do,
       * but this is not an error situation so make sure we
       * return OK instead of BUF_ERROR at next call of deflate:
       */
      s.last_flush = -1;
      return Z_OK;
    }

    /* Make sure there is something to do and avoid duplicate consecutive
     * flushes. For repeated and useless calls with Z_FINISH, we keep
     * returning Z_STREAM_END instead of Z_BUF_ERROR.
     */
  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&
    flush !== Z_FINISH) {
    return err(strm, Z_BUF_ERROR);
  }

  /* User must not provide more input after the first FINISH: */
  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR);
  }

  /* Start a new block or continue the current one.
   */
  if (strm.avail_in !== 0 || s.lookahead !== 0 ||
    (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {
    var bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :
      (s.strategy === Z_RLE ? deflate_rle(s, flush) :
        configuration_table[s.level].func(s, flush));

    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        /* avoid BUF_ERROR next call, see above */
      }
      return Z_OK;
      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
       * of deflate should use the same flush parameter to make sure
       * that the flush is complete. So we don't have to output an
       * empty block here, this will be done at next call. This also
       * ensures that for a very small output buffer, we emit at most
       * one empty block.
       */
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        trees._tr_align(s);
      }
      else if (flush !== Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */

        trees._tr_stored_block(s, 0, 0, false);
        /* For a full flush, this empty block will be recognized
         * as a special marker by inflate_sync().
         */
        if (flush === Z_FULL_FLUSH) {
          /*** CLEAR_HASH(s); ***/             /* forget history */
          zero(s.head); // Fill with NIL (= 0);

          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */
        return Z_OK;
      }
    }
  }
  //Assert(strm->avail_out > 0, "bug2");
  //if (strm.avail_out <= 0) { throw new Error("bug2");}

  if (flush !== Z_FINISH) { return Z_OK; }
  if (s.wrap <= 0) { return Z_STREAM_END; }

  /* Write the trailer */
  if (s.wrap === 2) {
    put_byte(s, strm.adler & 0xff);
    put_byte(s, (strm.adler >> 8) & 0xff);
    put_byte(s, (strm.adler >> 16) & 0xff);
    put_byte(s, (strm.adler >> 24) & 0xff);
    put_byte(s, strm.total_in & 0xff);
    put_byte(s, (strm.total_in >> 8) & 0xff);
    put_byte(s, (strm.total_in >> 16) & 0xff);
    put_byte(s, (strm.total_in >> 24) & 0xff);
  }
  else
  {
    putShortMSB(s, strm.adler >>> 16);
    putShortMSB(s, strm.adler & 0xffff);
  }

  flush_pending(strm);
  /* If avail_out is zero, the application will call deflate again
   * to flush the rest.
   */
  if (s.wrap > 0) { s.wrap = -s.wrap; }
  /* write the trailer only once! */
  return s.pending !== 0 ? Z_OK : Z_STREAM_END;
}

function deflateEnd(strm) {
  var status;

  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
    return Z_STREAM_ERROR;
  }

  status = strm.state.status;
  if (status !== INIT_STATE &&
    status !== EXTRA_STATE &&
    status !== NAME_STATE &&
    status !== COMMENT_STATE &&
    status !== HCRC_STATE &&
    status !== BUSY_STATE &&
    status !== FINISH_STATE
  ) {
    return err(strm, Z_STREAM_ERROR);
  }

  strm.state = null;

  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
}


/* =========================================================================
 * Initializes the compression dictionary from the given byte
 * sequence without producing any compressed output.
 */
function deflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;

  var s;
  var str, n;
  var wrap;
  var avail;
  var next;
  var input;
  var tmpDict;

  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
    return Z_STREAM_ERROR;
  }

  s = strm.state;
  wrap = s.wrap;

  if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {
    return Z_STREAM_ERROR;
  }

  /* when using zlib wrappers, compute Adler-32 for provided dictionary */
  if (wrap === 1) {
    /* adler32(strm->adler, dictionary, dictLength); */
    strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
  }

  s.wrap = 0;   /* avoid computing Adler-32 in read_buf */

  /* if dictionary would fill window, just replace the history */
  if (dictLength >= s.w_size) {
    if (wrap === 0) {            /* already empty otherwise */
      /*** CLEAR_HASH(s); ***/
      zero(s.head); // Fill with NIL (= 0);
      s.strstart = 0;
      s.block_start = 0;
      s.insert = 0;
    }
    /* use the tail */
    // dictionary = dictionary.slice(dictLength - s.w_size);
    tmpDict = new utils.Buf8(s.w_size);
    utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
    dictionary = tmpDict;
    dictLength = s.w_size;
  }
  /* insert dictionary into window and hash */
  avail = strm.avail_in;
  next = strm.next_in;
  input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s);
  while (s.lookahead >= MIN_MATCH) {
    str = s.strstart;
    n = s.lookahead - (MIN_MATCH - 1);
    do {
      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;

      s.prev[str & s.w_mask] = s.head[s.ins_h];

      s.head[s.ins_h] = str;
      str++;
    } while (--n);
    s.strstart = str;
    s.lookahead = MIN_MATCH - 1;
    fill_window(s);
  }
  s.strstart += s.lookahead;
  s.block_start = s.strstart;
  s.insert = s.lookahead;
  s.lookahead = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s.wrap = wrap;
  return Z_OK;
}


exports.deflateInit = deflateInit;
exports.deflateInit2 = deflateInit2;
exports.deflateReset = deflateReset;
exports.deflateResetKeep = deflateResetKeep;
exports.deflateSetHeader = deflateSetHeader;
exports.deflate = deflate;
exports.deflateEnd = deflateEnd;
exports.deflateSetDictionary = deflateSetDictionary;
exports.deflateInfo = 'pako deflate (from Nodeca project)';

/* Not implemented
exports.deflateBound = deflateBound;
exports.deflateCopy = deflateCopy;
exports.deflateParams = deflateParams;
exports.deflatePending = deflatePending;
exports.deflatePrime = deflatePrime;
exports.deflateTune = deflateTune;
*/

},{"../utils/common":"..\\node_modules\\pako\\lib\\utils\\common.js","./trees":"..\\node_modules\\pako\\lib\\zlib\\trees.js","./adler32":"..\\node_modules\\pako\\lib\\zlib\\adler32.js","./crc32":"..\\node_modules\\pako\\lib\\zlib\\crc32.js","./messages":"..\\node_modules\\pako\\lib\\zlib\\messages.js"}],"..\\node_modules\\pako\\lib\\utils\\strings.js":[function(require,module,exports) {
// String encode/decode helpers
'use strict';


var utils = require('./common');


// Quick check if we can use fast array to bin string conversion
//
// - apply(Array) can fail on Android 2.2
// - apply(Uint8Array) can fail on iOS 5.1 Safari
//
var STR_APPLY_OK = true;
var STR_APPLY_UIA_OK = true;

try { String.fromCharCode.apply(null, [ 0 ]); } catch (__) { STR_APPLY_OK = false; }
try { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (__) { STR_APPLY_UIA_OK = false; }


// Table with utf8 lengths (calculated by first byte of sequence)
// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,
// because max possible codepoint is 0x10ffff
var _utf8len = new utils.Buf8(256);
for (var q = 0; q < 256; q++) {
  _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);
}
_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start


// convert string to array (typed, when possible)
exports.string2buf = function (str) {
  var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;

  // count binary size
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
  }

  // allocate buffer
  buf = new utils.Buf8(buf_len);

  // convert
  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    if (c < 0x80) {
      /* one byte */
      buf[i++] = c;
    } else if (c < 0x800) {
      /* two bytes */
      buf[i++] = 0xC0 | (c >>> 6);
      buf[i++] = 0x80 | (c & 0x3f);
    } else if (c < 0x10000) {
      /* three bytes */
      buf[i++] = 0xE0 | (c >>> 12);
      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
      buf[i++] = 0x80 | (c & 0x3f);
    } else {
      /* four bytes */
      buf[i++] = 0xf0 | (c >>> 18);
      buf[i++] = 0x80 | (c >>> 12 & 0x3f);
      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
      buf[i++] = 0x80 | (c & 0x3f);
    }
  }

  return buf;
};

// Helper (used in 2 places)
function buf2binstring(buf, len) {
  // use fallback for big arrays to avoid stack overflow
  if (len < 65537) {
    if ((buf.subarray && STR_APPLY_UIA_OK) || (!buf.subarray && STR_APPLY_OK)) {
      return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
    }
  }

  var result = '';
  for (var i = 0; i < len; i++) {
    result += String.fromCharCode(buf[i]);
  }
  return result;
}


// Convert byte array to binary string
exports.buf2binstring = function (buf) {
  return buf2binstring(buf, buf.length);
};


// Convert binary string (typed, when possible)
exports.binstring2buf = function (str) {
  var buf = new utils.Buf8(str.length);
  for (var i = 0, len = buf.length; i < len; i++) {
    buf[i] = str.charCodeAt(i);
  }
  return buf;
};


// convert array to string
exports.buf2string = function (buf, max) {
  var i, out, c, c_len;
  var len = max || buf.length;

  // Reserve max possible length (2 words per char)
  // NB: by unknown reasons, Array is significantly faster for
  //     String.fromCharCode.apply than Uint16Array.
  var utf16buf = new Array(len * 2);

  for (out = 0, i = 0; i < len;) {
    c = buf[i++];
    // quick process ascii
    if (c < 0x80) { utf16buf[out++] = c; continue; }

    c_len = _utf8len[c];
    // skip 5 & 6 byte codes
    if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len - 1; continue; }

    // apply mask on first byte
    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;
    // join the rest
    while (c_len > 1 && i < len) {
      c = (c << 6) | (buf[i++] & 0x3f);
      c_len--;
    }

    // terminated by end of string?
    if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }

    if (c < 0x10000) {
      utf16buf[out++] = c;
    } else {
      c -= 0x10000;
      utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);
      utf16buf[out++] = 0xdc00 | (c & 0x3ff);
    }
  }

  return buf2binstring(utf16buf, out);
};


// Calculate max possible position in utf8 buffer,
// that will not break sequence. If that's not possible
// - (very small limits) return max size as is.
//
// buf[] - utf8 bytes array
// max   - length limit (mandatory);
exports.utf8border = function (buf, max) {
  var pos;

  max = max || buf.length;
  if (max > buf.length) { max = buf.length; }

  // go back from last position, until start of sequence found
  pos = max - 1;
  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }

  // Very small and broken sequence,
  // return max, because we should return something anyway.
  if (pos < 0) { return max; }

  // If we came to start of buffer - that means buffer is too small,
  // return max too.
  if (pos === 0) { return max; }

  return (pos + _utf8len[buf[pos]] > max) ? pos : max;
};

},{"./common":"..\\node_modules\\pako\\lib\\utils\\common.js"}],"..\\node_modules\\pako\\lib\\zlib\\zstream.js":[function(require,module,exports) {
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function ZStream() {
  /* next input byte */
  this.input = null; // JS specific, because we have no pointers
  this.next_in = 0;
  /* number of bytes available at input */
  this.avail_in = 0;
  /* total number of input bytes read so far */
  this.total_in = 0;
  /* next output byte should be put there */
  this.output = null; // JS specific, because we have no pointers
  this.next_out = 0;
  /* remaining free space at output */
  this.avail_out = 0;
  /* total number of bytes output so far */
  this.total_out = 0;
  /* last error message, NULL if no error */
  this.msg = ''/*Z_NULL*/;
  /* not visible by applications */
  this.state = null;
  /* best guess about the data type: binary or text */
  this.data_type = 2/*Z_UNKNOWN*/;
  /* adler32 value of the uncompressed data */
  this.adler = 0;
}

module.exports = ZStream;

},{}],"..\\node_modules\\pako\\lib\\deflate.js":[function(require,module,exports) {
'use strict';


var zlib_deflate = require('./zlib/deflate');
var utils        = require('./utils/common');
var strings      = require('./utils/strings');
var msg          = require('./zlib/messages');
var ZStream      = require('./zlib/zstream');

var toString = Object.prototype.toString;

/* Public constants ==========================================================*/
/* ===========================================================================*/

var Z_NO_FLUSH      = 0;
var Z_FINISH        = 4;

var Z_OK            = 0;
var Z_STREAM_END    = 1;
var Z_SYNC_FLUSH    = 2;

var Z_DEFAULT_COMPRESSION = -1;

var Z_DEFAULT_STRATEGY    = 0;

var Z_DEFLATED  = 8;

/* ===========================================================================*/


/**
 * class Deflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[deflate]],
 * [[deflateRaw]] and [[gzip]].
 **/

/* internal
 * Deflate.chunks -> Array
 *
 * Chunks of output data, if [[Deflate#onData]] not overridden.
 **/

/**
 * Deflate.result -> Uint8Array|Array
 *
 * Compressed result, generated by default [[Deflate#onData]]
 * and [[Deflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Deflate#push]] with `Z_FINISH` / `true` param)  or if you
 * push a chunk with explicit flush (call [[Deflate#push]] with
 * `Z_SYNC_FLUSH` param).
 **/

/**
 * Deflate.err -> Number
 *
 * Error code after deflate finished. 0 (Z_OK) on success.
 * You will not need it in real life, because deflate errors
 * are possible only on wrong options or bad `onData` / `onEnd`
 * custom handlers.
 **/

/**
 * Deflate.msg -> String
 *
 * Error message, if [[Deflate.err]] != 0
 **/


/**
 * new Deflate(options)
 * - options (Object): zlib deflate options.
 *
 * Creates new deflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `level`
 * - `windowBits`
 * - `memLevel`
 * - `strategy`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw deflate
 * - `gzip` (Boolean) - create gzip wrapper
 * - `to` (String) - if equal to 'string', then result will be "binary string"
 *    (each char code [0..255])
 * - `header` (Object) - custom header for gzip
 *   - `text` (Boolean) - true if compressed data believed to be text
 *   - `time` (Number) - modification time, unix timestamp
 *   - `os` (Number) - operation system code
 *   - `extra` (Array) - array of bytes with extra data (max 65536)
 *   - `name` (String) - file name (binary string)
 *   - `comment` (String) - comment (binary string)
 *   - `hcrc` (Boolean) - true if header crc should be added
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
 *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * var deflate = new pako.Deflate({ level: 3});
 *
 * deflate.push(chunk1, false);
 * deflate.push(chunk2, true);  // true -> last chunk
 *
 * if (deflate.err) { throw new Error(deflate.err); }
 *
 * console.log(deflate.result);
 * ```
 **/
function Deflate(options) {
  if (!(this instanceof Deflate)) return new Deflate(options);

  this.options = utils.assign({
    level: Z_DEFAULT_COMPRESSION,
    method: Z_DEFLATED,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY,
    to: ''
  }, options || {});

  var opt = this.options;

  if (opt.raw && (opt.windowBits > 0)) {
    opt.windowBits = -opt.windowBits;
  }

  else if (opt.gzip && (opt.windowBits > 0) && (opt.windowBits < 16)) {
    opt.windowBits += 16;
  }

  this.err    = 0;      // error code, if happens (0 = Z_OK)
  this.msg    = '';     // error message
  this.ended  = false;  // used to avoid multiple onEnd() calls
  this.chunks = [];     // chunks of compressed data

  this.strm = new ZStream();
  this.strm.avail_out = 0;

  var status = zlib_deflate.deflateInit2(
    this.strm,
    opt.level,
    opt.method,
    opt.windowBits,
    opt.memLevel,
    opt.strategy
  );

  if (status !== Z_OK) {
    throw new Error(msg[status]);
  }

  if (opt.header) {
    zlib_deflate.deflateSetHeader(this.strm, opt.header);
  }

  if (opt.dictionary) {
    var dict;
    // Convert data if needed
    if (typeof opt.dictionary === 'string') {
      // If we need to compress text, change encoding to utf8.
      dict = strings.string2buf(opt.dictionary);
    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }

    status = zlib_deflate.deflateSetDictionary(this.strm, dict);

    if (status !== Z_OK) {
      throw new Error(msg[status]);
    }

    this._dict_set = true;
  }
}

/**
 * Deflate#push(data[, mode]) -> Boolean
 * - data (Uint8Array|Array|ArrayBuffer|String): input data. Strings will be
 *   converted to utf8 byte sequence.
 * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.
 *
 * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with
 * new compressed chunks. Returns `true` on success. The last data block must have
 * mode Z_FINISH (or `true`). That will flush internal pending buffers and call
 * [[Deflate#onEnd]]. For interim explicit flushes (without ending the stream) you
 * can use mode Z_SYNC_FLUSH, keeping the compression context.
 *
 * On fail call [[Deflate#onEnd]] with error code and return false.
 *
 * We strongly recommend to use `Uint8Array` on input for best speed (output
 * array format is detected automatically). Also, don't skip last param and always
 * use the same type in your code (boolean or number). That will improve JS speed.
 *
 * For regular `Array`-s make sure all elements are [0..255].
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Deflate.prototype.push = function (data, mode) {
  var strm = this.strm;
  var chunkSize = this.options.chunkSize;
  var status, _mode;

  if (this.ended) { return false; }

  _mode = (mode === ~~mode) ? mode : ((mode === true) ? Z_FINISH : Z_NO_FLUSH);

  // Convert data if needed
  if (typeof data === 'string') {
    // If we need to compress text, change encoding to utf8.
    strm.input = strings.string2buf(data);
  } else if (toString.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  do {
    if (strm.avail_out === 0) {
      strm.output = new utils.Buf8(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    status = zlib_deflate.deflate(strm, _mode);    /* no bad return value */

    if (status !== Z_STREAM_END && status !== Z_OK) {
      this.onEnd(status);
      this.ended = true;
      return false;
    }
    if (strm.avail_out === 0 || (strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH))) {
      if (this.options.to === 'string') {
        this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));
      } else {
        this.onData(utils.shrinkBuf(strm.output, strm.next_out));
      }
    }
  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);

  // Finalize on the last chunk.
  if (_mode === Z_FINISH) {
    status = zlib_deflate.deflateEnd(this.strm);
    this.onEnd(status);
    this.ended = true;
    return status === Z_OK;
  }

  // callback interim results if Z_SYNC_FLUSH.
  if (_mode === Z_SYNC_FLUSH) {
    this.onEnd(Z_OK);
    strm.avail_out = 0;
    return true;
  }

  return true;
};


/**
 * Deflate#onData(chunk) -> Void
 * - chunk (Uint8Array|Array|String): output data. Type of array depends
 *   on js engine support. When string output requested, each chunk
 *   will be string.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Deflate.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};


/**
 * Deflate#onEnd(status) -> Void
 * - status (Number): deflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called once after you tell deflate that the input stream is
 * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)
 * or if an error happened. By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Deflate.prototype.onEnd = function (status) {
  // On success - join
  if (status === Z_OK) {
    if (this.options.to === 'string') {
      this.result = this.chunks.join('');
    } else {
      this.result = utils.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};


/**
 * deflate(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * Compress `data` with deflate algorithm and `options`.
 *
 * Supported options are:
 *
 * - level
 * - windowBits
 * - memLevel
 * - strategy
 * - dictionary
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 * - `to` (String) - if equal to 'string', then result will be "binary string"
 *    (each char code [0..255])
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , data = Uint8Array([1,2,3,4,5,6,7,8,9]);
 *
 * console.log(pako.deflate(data));
 * ```
 **/
function deflate(input, options) {
  var deflator = new Deflate(options);

  deflator.push(input, true);

  // That will never happens, if you don't cheat with options :)
  if (deflator.err) { throw deflator.msg || msg[deflator.err]; }

  return deflator.result;
}


/**
 * deflateRaw(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * The same as [[deflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/
function deflateRaw(input, options) {
  options = options || {};
  options.raw = true;
  return deflate(input, options);
}


/**
 * gzip(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * The same as [[deflate]], but create gzip wrapper instead of
 * deflate one.
 **/
function gzip(input, options) {
  options = options || {};
  options.gzip = true;
  return deflate(input, options);
}


exports.Deflate = Deflate;
exports.deflate = deflate;
exports.deflateRaw = deflateRaw;
exports.gzip = gzip;

},{"./zlib/deflate":"..\\node_modules\\pako\\lib\\zlib\\deflate.js","./utils/common":"..\\node_modules\\pako\\lib\\utils\\common.js","./utils/strings":"..\\node_modules\\pako\\lib\\utils\\strings.js","./zlib/messages":"..\\node_modules\\pako\\lib\\zlib\\messages.js","./zlib/zstream":"..\\node_modules\\pako\\lib\\zlib\\zstream.js"}],"..\\node_modules\\pako\\lib\\zlib\\inffast.js":[function(require,module,exports) {
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

// See state defs from inflate.js
var BAD = 30;       /* got a data error -- remain here until reset */
var TYPE = 12;      /* i: waiting for type bits, including last-flag bit */

/*
   Decode literal, length, and distance codes and write out the resulting
   literal and match bytes until either not enough input or output is
   available, an end-of-block is encountered, or a data error is encountered.
   When large enough input and output buffers are supplied to inflate(), for
   example, a 16K input buffer and a 64K output buffer, more than 95% of the
   inflate execution time is spent in this routine.

   Entry assumptions:

        state.mode === LEN
        strm.avail_in >= 6
        strm.avail_out >= 258
        start >= strm.avail_out
        state.bits < 8

   On return, state.mode is one of:

        LEN -- ran out of enough output space or enough available input
        TYPE -- reached end of block code, inflate() to interpret next block
        BAD -- error in block data

   Notes:

    - The maximum input bits used by a length/distance pair is 15 bits for the
      length code, 5 bits for the length extra, 15 bits for the distance code,
      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
      Therefore if strm.avail_in >= 6, then there is enough input to avoid
      checking for available input while decoding.

    - The maximum bytes that a single length/distance pair can output is 258
      bytes, which is the maximum length that can be coded.  inflate_fast()
      requires strm.avail_out >= 258 for each loop to avoid checking for
      output space.
 */
module.exports = function inflate_fast(strm, start) {
  var state;
  var _in;                    /* local strm.input */
  var last;                   /* have enough input while in < last */
  var _out;                   /* local strm.output */
  var beg;                    /* inflate()'s initial strm.output */
  var end;                    /* while out < end, enough space available */
//#ifdef INFLATE_STRICT
  var dmax;                   /* maximum distance from zlib header */
//#endif
  var wsize;                  /* window size or zero if not using window */
  var whave;                  /* valid bytes in the window */
  var wnext;                  /* window write index */
  // Use `s_window` instead `window`, avoid conflict with instrumentation tools
  var s_window;               /* allocated sliding window, if wsize != 0 */
  var hold;                   /* local strm.hold */
  var bits;                   /* local strm.bits */
  var lcode;                  /* local strm.lencode */
  var dcode;                  /* local strm.distcode */
  var lmask;                  /* mask for first level of length codes */
  var dmask;                  /* mask for first level of distance codes */
  var here;                   /* retrieved table entry */
  var op;                     /* code bits, operation, extra bits, or */
                              /*  window position, window bytes to copy */
  var len;                    /* match length, unused bytes */
  var dist;                   /* match distance */
  var from;                   /* where to copy match from */
  var from_source;


  var input, output; // JS specific, because we have no pointers

  /* copy state to local variables */
  state = strm.state;
  //here = state.here;
  _in = strm.next_in;
  input = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
//#ifdef INFLATE_STRICT
  dmax = state.dmax;
//#endif
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;


  /* decode literals and length/distances until end-of-block or not enough
     input data or output space */

  top:
  do {
    if (bits < 15) {
      hold += input[_in++] << bits;
      bits += 8;
      hold += input[_in++] << bits;
      bits += 8;
    }

    here = lcode[hold & lmask];

    dolen:
    for (;;) { // Goto emulation
      op = here >>> 24/*here.bits*/;
      hold >>>= op;
      bits -= op;
      op = (here >>> 16) & 0xff/*here.op*/;
      if (op === 0) {                          /* literal */
        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
        //        "inflate:         literal '%c'\n" :
        //        "inflate:         literal 0x%02x\n", here.val));
        output[_out++] = here & 0xffff/*here.val*/;
      }
      else if (op & 16) {                     /* length base */
        len = here & 0xffff/*here.val*/;
        op &= 15;                           /* number of extra bits */
        if (op) {
          if (bits < op) {
            hold += input[_in++] << bits;
            bits += 8;
          }
          len += hold & ((1 << op) - 1);
          hold >>>= op;
          bits -= op;
        }
        //Tracevv((stderr, "inflate:         length %u\n", len));
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = dcode[hold & dmask];

        dodist:
        for (;;) { // goto emulation
          op = here >>> 24/*here.bits*/;
          hold >>>= op;
          bits -= op;
          op = (here >>> 16) & 0xff/*here.op*/;

          if (op & 16) {                      /* distance base */
            dist = here & 0xffff/*here.val*/;
            op &= 15;                       /* number of extra bits */
            if (bits < op) {
              hold += input[_in++] << bits;
              bits += 8;
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
            }
            dist += hold & ((1 << op) - 1);
//#ifdef INFLATE_STRICT
            if (dist > dmax) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD;
              break top;
            }
//#endif
            hold >>>= op;
            bits -= op;
            //Tracevv((stderr, "inflate:         distance %u\n", dist));
            op = _out - beg;                /* max distance in output */
            if (dist > op) {                /* see if copy from window */
              op = dist - op;               /* distance back in window */
              if (op > whave) {
                if (state.sane) {
                  strm.msg = 'invalid distance too far back';
                  state.mode = BAD;
                  break top;
                }

// (!) This block is disabled in zlib defaults,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//                if (len <= op - whave) {
//                  do {
//                    output[_out++] = 0;
//                  } while (--len);
//                  continue top;
//                }
//                len -= op - whave;
//                do {
//                  output[_out++] = 0;
//                } while (--op > whave);
//                if (op === 0) {
//                  from = _out - dist;
//                  do {
//                    output[_out++] = output[from++];
//                  } while (--len);
//                  continue top;
//                }
//#endif
              }
              from = 0; // window index
              from_source = s_window;
              if (wnext === 0) {           /* very common case */
                from += wsize - op;
                if (op < len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              else if (wnext < op) {      /* wrap around window */
                from += wsize + wnext - op;
                op -= wnext;
                if (op < len) {         /* some from end of window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = 0;
                  if (wnext < len) {  /* some from start of window */
                    op = wnext;
                    len -= op;
                    do {
                      output[_out++] = s_window[from++];
                    } while (--op);
                    from = _out - dist;      /* rest from output */
                    from_source = output;
                  }
                }
              }
              else {                      /* contiguous in window */
                from += wnext - op;
                if (op < len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              while (len > 2) {
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                len -= 3;
              }
              if (len) {
                output[_out++] = from_source[from++];
                if (len > 1) {
                  output[_out++] = from_source[from++];
                }
              }
            }
            else {
              from = _out - dist;          /* copy direct from output */
              do {                        /* minimum length is three */
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                len -= 3;
              } while (len > 2);
              if (len) {
                output[_out++] = output[from++];
                if (len > 1) {
                  output[_out++] = output[from++];
                }
              }
            }
          }
          else if ((op & 64) === 0) {          /* 2nd level distance code */
            here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
            continue dodist;
          }
          else {
            strm.msg = 'invalid distance code';
            state.mode = BAD;
            break top;
          }

          break; // need to emulate goto via "continue"
        }
      }
      else if ((op & 64) === 0) {              /* 2nd level length code */
        here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
        continue dolen;
      }
      else if (op & 32) {                     /* end-of-block */
        //Tracevv((stderr, "inflate:         end of block\n"));
        state.mode = TYPE;
        break top;
      }
      else {
        strm.msg = 'invalid literal/length code';
        state.mode = BAD;
        break top;
      }

      break; // need to emulate goto via "continue"
    }
  } while (_in < last && _out < end);

  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;

  /* update state and return */
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));
  strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));
  state.hold = hold;
  state.bits = bits;
  return;
};

},{}],"..\\node_modules\\pako\\lib\\zlib\\inftrees.js":[function(require,module,exports) {
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var utils = require('../utils/common');

var MAXBITS = 15;
var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
//var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);

var CODES = 0;
var LENS = 1;
var DISTS = 2;

var lbase = [ /* Length codes 257..285 base */
  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
];

var lext = [ /* Length codes 257..285 extra */
  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
  19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78
];

var dbase = [ /* Distance codes 0..29 base */
  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
  257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
  8193, 12289, 16385, 24577, 0, 0
];

var dext = [ /* Distance codes 0..29 extra */
  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
  23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
  28, 28, 29, 29, 64, 64
];

module.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts)
{
  var bits = opts.bits;
      //here = opts.here; /* table entry for duplication */

  var len = 0;               /* a code's length in bits */
  var sym = 0;               /* index of code symbols */
  var min = 0, max = 0;          /* minimum and maximum code lengths */
  var root = 0;              /* number of index bits for root table */
  var curr = 0;              /* number of index bits for current table */
  var drop = 0;              /* code bits to drop for sub-table */
  var left = 0;                   /* number of prefix codes available */
  var used = 0;              /* code entries in table used */
  var huff = 0;              /* Huffman code */
  var incr;              /* for incrementing code, index */
  var fill;              /* index for replicating entries */
  var low;               /* low bits for current root entry */
  var mask;              /* mask for low root bits */
  var next;             /* next available space in table */
  var base = null;     /* base value table to use */
  var base_index = 0;
//  var shoextra;    /* extra bits table to use */
  var end;                    /* use base and extra for symbol > end */
  var count = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */
  var offs = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */
  var extra = null;
  var extra_index = 0;

  var here_bits, here_op, here_val;

  /*
   Process a set of code lengths to create a canonical Huffman code.  The
   code lengths are lens[0..codes-1].  Each length corresponds to the
   symbols 0..codes-1.  The Huffman code is generated by first sorting the
   symbols by length from short to long, and retaining the symbol order
   for codes with equal lengths.  Then the code starts with all zero bits
   for the first code of the shortest length, and the codes are integer
   increments for the same length, and zeros are appended as the length
   increases.  For the deflate format, these bits are stored backwards
   from their more natural integer increment ordering, and so when the
   decoding tables are built in the large loop below, the integer codes
   are incremented backwards.

   This routine assumes, but does not check, that all of the entries in
   lens[] are in the range 0..MAXBITS.  The caller must assure this.
   1..MAXBITS is interpreted as that code length.  zero means that that
   symbol does not occur in this code.

   The codes are sorted by computing a count of codes for each length,
   creating from that a table of starting indices for each length in the
   sorted table, and then entering the symbols in order in the sorted
   table.  The sorted table is work[], with that space being provided by
   the caller.

   The length counts are used for other purposes as well, i.e. finding
   the minimum and maximum length codes, determining if there are any
   codes at all, checking for a valid set of lengths, and looking ahead
   at length counts to determine sub-table sizes when building the
   decoding tables.
   */

  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }

  /* bound code lengths, force root to be within code lengths */
  root = bits;
  for (max = MAXBITS; max >= 1; max--) {
    if (count[max] !== 0) { break; }
  }
  if (root > max) {
    root = max;
  }
  if (max === 0) {                     /* no symbols to code at all */
    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */
    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;
    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;
    table[table_index++] = (1 << 24) | (64 << 16) | 0;


    //table.op[opts.table_index] = 64;
    //table.bits[opts.table_index] = 1;
    //table.val[opts.table_index++] = 0;
    table[table_index++] = (1 << 24) | (64 << 16) | 0;

    opts.bits = 1;
    return 0;     /* no symbols, but wait for decoding to report error */
  }
  for (min = 1; min < max; min++) {
    if (count[min] !== 0) { break; }
  }
  if (root < min) {
    root = min;
  }

  /* check for an over-subscribed or incomplete set of lengths */
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];
    if (left < 0) {
      return -1;
    }        /* over-subscribed */
  }
  if (left > 0 && (type === CODES || max !== 1)) {
    return -1;                      /* incomplete set */
  }

  /* generate offsets into symbol table for each length for sorting */
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }

  /* sort symbols by length, by symbol order within each length */
  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }

  /*
   Create and fill in decoding tables.  In this loop, the table being
   filled is at next and has curr index bits.  The code being used is huff
   with length len.  That code is converted to an index by dropping drop
   bits off of the bottom.  For codes where len is less than drop + curr,
   those top drop + curr - len bits are incremented through all values to
   fill the table with replicated entries.

   root is the number of index bits for the root table.  When len exceeds
   root, sub-tables are created pointed to by the root entry with an index
   of the low root bits of huff.  This is saved in low to check for when a
   new sub-table should be started.  drop is zero when the root table is
   being filled, and drop is root when sub-tables are being filled.

   When a new sub-table is needed, it is necessary to look ahead in the
   code lengths to determine what size sub-table is needed.  The length
   counts are used for this, and so count[] is decremented as codes are
   entered in the tables.

   used keeps track of how many table entries have been allocated from the
   provided *table space.  It is checked for LENS and DIST tables against
   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
   the initial root table size constants.  See the comments in inftrees.h
   for more information.

   sym increments through all symbols, and the loop terminates when
   all codes of length max, i.e. all codes, have been processed.  This
   routine permits incomplete codes, so another loop after this one fills
   in the rest of the decoding tables with invalid code markers.
   */

  /* set up for code type */
  // poor man optimization - use if-else instead of switch,
  // to avoid deopts in old v8
  if (type === CODES) {
    base = extra = work;    /* dummy value--not used */
    end = 19;

  } else if (type === LENS) {
    base = lbase;
    base_index -= 257;
    extra = lext;
    extra_index -= 257;
    end = 256;

  } else {                    /* DISTS */
    base = dbase;
    extra = dext;
    end = -1;
  }

  /* initialize opts for loop */
  huff = 0;                   /* starting code */
  sym = 0;                    /* starting code symbol */
  len = min;                  /* starting code length */
  next = table_index;              /* current table to fill in */
  curr = root;                /* current table index bits */
  drop = 0;                   /* current bits to drop from code for index */
  low = -1;                   /* trigger new sub-table when len > root */
  used = 1 << root;          /* use root table entries */
  mask = used - 1;            /* mask for comparing low */

  /* check available table space */
  if ((type === LENS && used > ENOUGH_LENS) ||
    (type === DISTS && used > ENOUGH_DISTS)) {
    return 1;
  }

  /* process all codes and make table entries */
  for (;;) {
    /* create table entry */
    here_bits = len - drop;
    if (work[sym] < end) {
      here_op = 0;
      here_val = work[sym];
    }
    else if (work[sym] > end) {
      here_op = extra[extra_index + work[sym]];
      here_val = base[base_index + work[sym]];
    }
    else {
      here_op = 32 + 64;         /* end of block */
      here_val = 0;
    }

    /* replicate for those indices with low len bits equal to huff */
    incr = 1 << (len - drop);
    fill = 1 << curr;
    min = fill;                 /* save offset to next table */
    do {
      fill -= incr;
      table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;
    } while (fill !== 0);

    /* backwards increment the len-bit code huff */
    incr = 1 << (len - 1);
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }

    /* go to next symbol, update count, len */
    sym++;
    if (--count[len] === 0) {
      if (len === max) { break; }
      len = lens[lens_index + work[sym]];
    }

    /* create new sub-table if needed */
    if (len > root && (huff & mask) !== low) {
      /* if first time, transition to sub-tables */
      if (drop === 0) {
        drop = root;
      }

      /* increment past last table */
      next += min;            /* here min is 1 << curr */

      /* determine length of next table */
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max) {
        left -= count[curr + drop];
        if (left <= 0) { break; }
        curr++;
        left <<= 1;
      }

      /* check for enough space */
      used += 1 << curr;
      if ((type === LENS && used > ENOUGH_LENS) ||
        (type === DISTS && used > ENOUGH_DISTS)) {
        return 1;
      }

      /* point entry in root table to sub-table */
      low = huff & mask;
      /*table.op[low] = curr;
      table.bits[low] = root;
      table.val[low] = next - opts.table_index;*/
      table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;
    }
  }

  /* fill in remaining table entry if code is incomplete (guaranteed to have
   at most one remaining entry, since if the code is incomplete, the
   maximum code length that was allowed to get this far is one bit) */
  if (huff !== 0) {
    //table.op[next + huff] = 64;            /* invalid code marker */
    //table.bits[next + huff] = len - drop;
    //table.val[next + huff] = 0;
    table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;
  }

  /* set return parameters */
  //opts.table_index += used;
  opts.bits = root;
  return 0;
};

},{"../utils/common":"..\\node_modules\\pako\\lib\\utils\\common.js"}],"..\\node_modules\\pako\\lib\\zlib\\inflate.js":[function(require,module,exports) {
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var utils         = require('../utils/common');
var adler32       = require('./adler32');
var crc32         = require('./crc32');
var inflate_fast  = require('./inffast');
var inflate_table = require('./inftrees');

var CODES = 0;
var LENS = 1;
var DISTS = 2;

/* Public constants ==========================================================*/
/* ===========================================================================*/


/* Allowed flush values; see deflate() and inflate() below for details */
//var Z_NO_FLUSH      = 0;
//var Z_PARTIAL_FLUSH = 1;
//var Z_SYNC_FLUSH    = 2;
//var Z_FULL_FLUSH    = 3;
var Z_FINISH        = 4;
var Z_BLOCK         = 5;
var Z_TREES         = 6;


/* Return codes for the compression/decompression functions. Negative values
 * are errors, positive values are used for special but normal events.
 */
var Z_OK            = 0;
var Z_STREAM_END    = 1;
var Z_NEED_DICT     = 2;
//var Z_ERRNO         = -1;
var Z_STREAM_ERROR  = -2;
var Z_DATA_ERROR    = -3;
var Z_MEM_ERROR     = -4;
var Z_BUF_ERROR     = -5;
//var Z_VERSION_ERROR = -6;

/* The deflate compression method */
var Z_DEFLATED  = 8;


/* STATES ====================================================================*/
/* ===========================================================================*/


var    HEAD = 1;       /* i: waiting for magic header */
var    FLAGS = 2;      /* i: waiting for method and flags (gzip) */
var    TIME = 3;       /* i: waiting for modification time (gzip) */
var    OS = 4;         /* i: waiting for extra flags and operating system (gzip) */
var    EXLEN = 5;      /* i: waiting for extra length (gzip) */
var    EXTRA = 6;      /* i: waiting for extra bytes (gzip) */
var    NAME = 7;       /* i: waiting for end of file name (gzip) */
var    COMMENT = 8;    /* i: waiting for end of comment (gzip) */
var    HCRC = 9;       /* i: waiting for header crc (gzip) */
var    DICTID = 10;    /* i: waiting for dictionary check value */
var    DICT = 11;      /* waiting for inflateSetDictionary() call */
var        TYPE = 12;      /* i: waiting for type bits, including last-flag bit */
var        TYPEDO = 13;    /* i: same, but skip check to exit inflate on new block */
var        STORED = 14;    /* i: waiting for stored size (length and complement) */
var        COPY_ = 15;     /* i/o: same as COPY below, but only first time in */
var        COPY = 16;      /* i/o: waiting for input or output to copy stored block */
var        TABLE = 17;     /* i: waiting for dynamic block table lengths */
var        LENLENS = 18;   /* i: waiting for code length code lengths */
var        CODELENS = 19;  /* i: waiting for length/lit and distance code lengths */
var            LEN_ = 20;      /* i: same as LEN below, but only first time in */
var            LEN = 21;       /* i: waiting for length/lit/eob code */
var            LENEXT = 22;    /* i: waiting for length extra bits */
var            DIST = 23;      /* i: waiting for distance code */
var            DISTEXT = 24;   /* i: waiting for distance extra bits */
var            MATCH = 25;     /* o: waiting for output space to copy string */
var            LIT = 26;       /* o: waiting for output space to write literal */
var    CHECK = 27;     /* i: waiting for 32-bit check value */
var    LENGTH = 28;    /* i: waiting for 32-bit length (gzip) */
var    DONE = 29;      /* finished check, done -- remain here until reset */
var    BAD = 30;       /* got a data error -- remain here until reset */
var    MEM = 31;       /* got an inflate() memory error -- remain here until reset */
var    SYNC = 32;      /* looking for synchronization bytes to restart inflate() */

/* ===========================================================================*/



var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
//var ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);

var MAX_WBITS = 15;
/* 32K LZ77 window */
var DEF_WBITS = MAX_WBITS;


function zswap32(q) {
  return  (((q >>> 24) & 0xff) +
          ((q >>> 8) & 0xff00) +
          ((q & 0xff00) << 8) +
          ((q & 0xff) << 24));
}


function InflateState() {
  this.mode = 0;             /* current inflate mode */
  this.last = false;          /* true if processing last block */
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
  this.havedict = false;      /* true if dictionary provided */
  this.flags = 0;             /* gzip header method and flags (0 if zlib) */
  this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */
  this.check = 0;             /* protected copy of check value */
  this.total = 0;             /* protected copy of output count */
  // TODO: may be {}
  this.head = null;           /* where to save gzip header information */

  /* sliding window */
  this.wbits = 0;             /* log base 2 of requested window size */
  this.wsize = 0;             /* window size or zero if not using window */
  this.whave = 0;             /* valid bytes in the window */
  this.wnext = 0;             /* window write index */
  this.window = null;         /* allocated sliding window, if needed */

  /* bit accumulator */
  this.hold = 0;              /* input bit accumulator */
  this.bits = 0;              /* number of bits in "in" */

  /* for string and stored block copying */
  this.length = 0;            /* literal or length of data to copy */
  this.offset = 0;            /* distance back to copy string from */

  /* for table and code decoding */
  this.extra = 0;             /* extra bits needed */

  /* fixed and dynamic code tables */
  this.lencode = null;          /* starting table for length/literal codes */
  this.distcode = null;         /* starting table for distance codes */
  this.lenbits = 0;           /* index bits for lencode */
  this.distbits = 0;          /* index bits for distcode */

  /* dynamic table building */
  this.ncode = 0;             /* number of code length code lengths */
  this.nlen = 0;              /* number of length code lengths */
  this.ndist = 0;             /* number of distance code lengths */
  this.have = 0;              /* number of code lengths in lens[] */
  this.next = null;              /* next available space in codes[] */

  this.lens = new utils.Buf16(320); /* temporary storage for code lengths */
  this.work = new utils.Buf16(288); /* work area for code table building */

  /*
   because we don't have pointers in js, we use lencode and distcode directly
   as buffers so we don't need codes
  */
  //this.codes = new utils.Buf32(ENOUGH);       /* space for code tables */
  this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */
  this.distdyn = null;             /* dynamic table for distance codes (JS specific) */
  this.sane = 0;                   /* if false, allow invalid distance too far */
  this.back = 0;                   /* bits back of last unprocessed length/lit */
  this.was = 0;                    /* initial length of match */
}

function inflateResetKeep(strm) {
  var state;

  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = ''; /*Z_NULL*/
  if (state.wrap) {       /* to support ill-conceived Java test suite */
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.dmax = 32768;
  state.head = null/*Z_NULL*/;
  state.hold = 0;
  state.bits = 0;
  //state.lencode = state.distcode = state.next = state.codes;
  state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
  state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);

  state.sane = 1;
  state.back = -1;
  //Tracev((stderr, "inflate: reset\n"));
  return Z_OK;
}

function inflateReset(strm) {
  var state;

  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);

}

function inflateReset2(strm, windowBits) {
  var wrap;
  var state;

  /* get the state */
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;

  /* extract wrap request from windowBits parameter */
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  }
  else {
    wrap = (windowBits >> 4) + 1;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }

  /* set number of window bits, free window if different */
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }

  /* update state and reset the rest of it */
  state.wrap = wrap;
  state.wbits = windowBits;
  return inflateReset(strm);
}

function inflateInit2(strm, windowBits) {
  var ret;
  var state;

  if (!strm) { return Z_STREAM_ERROR; }
  //strm.msg = Z_NULL;                 /* in case we return an error */

  state = new InflateState();

  //if (state === Z_NULL) return Z_MEM_ERROR;
  //Tracev((stderr, "inflate: allocated\n"));
  strm.state = state;
  state.window = null/*Z_NULL*/;
  ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK) {
    strm.state = null/*Z_NULL*/;
  }
  return ret;
}

function inflateInit(strm) {
  return inflateInit2(strm, DEF_WBITS);
}


/*
 Return state with length and distance decoding tables and index sizes set to
 fixed code decoding.  Normally this returns fixed tables from inffixed.h.
 If BUILDFIXED is defined, then instead this routine builds the tables the
 first time it's called, and returns those tables the first time and
 thereafter.  This reduces the size of the code by about 2K bytes, in
 exchange for a little execution time.  However, BUILDFIXED should not be
 used for threaded applications, since the rewriting of the tables and virgin
 may not be thread-safe.
 */
var virgin = true;

var lenfix, distfix; // We have no pointers in JS, so keep tables separate

function fixedtables(state) {
  /* build fixed huffman tables if first call (may not be thread safe) */
  if (virgin) {
    var sym;

    lenfix = new utils.Buf32(512);
    distfix = new utils.Buf32(32);

    /* literal/length table */
    sym = 0;
    while (sym < 144) { state.lens[sym++] = 8; }
    while (sym < 256) { state.lens[sym++] = 9; }
    while (sym < 280) { state.lens[sym++] = 7; }
    while (sym < 288) { state.lens[sym++] = 8; }

    inflate_table(LENS,  state.lens, 0, 288, lenfix,   0, state.work, { bits: 9 });

    /* distance table */
    sym = 0;
    while (sym < 32) { state.lens[sym++] = 5; }

    inflate_table(DISTS, state.lens, 0, 32,   distfix, 0, state.work, { bits: 5 });

    /* do this just once */
    virgin = false;
  }

  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
}


/*
 Update the window with the last wsize (normally 32K) bytes written before
 returning.  If window does not exist yet, create it.  This is only called
 when a window is already in use, or when output has been written during this
 inflate call, but the end of the deflate stream has not been reached yet.
 It is also called to create a window for dictionary data when a dictionary
 is loaded.

 Providing output buffers larger than 32K to inflate() should provide a speed
 advantage, since only the last 32K of output is copied to the sliding window
 upon return from inflate(), and since all distances after the first 32K of
 output will fall in the output data, making match copies simpler and faster.
 The advantage may be dependent on the size of the processor's data caches.
 */
function updatewindow(strm, src, end, copy) {
  var dist;
  var state = strm.state;

  /* if it hasn't been done already, allocate space for the window */
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;

    state.window = new utils.Buf8(state.wsize);
  }

  /* copy state->wsize or less output bytes into the circular window */
  if (copy >= state.wsize) {
    utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
    state.wnext = 0;
    state.whave = state.wsize;
  }
  else {
    dist = state.wsize - state.wnext;
    if (dist > copy) {
      dist = copy;
    }
    //zmemcpy(state->window + state->wnext, end - copy, dist);
    utils.arraySet(state.window, src, end - copy, dist, state.wnext);
    copy -= dist;
    if (copy) {
      //zmemcpy(state->window, end - copy, copy);
      utils.arraySet(state.window, src, end - copy, copy, 0);
      state.wnext = copy;
      state.whave = state.wsize;
    }
    else {
      state.wnext += dist;
      if (state.wnext === state.wsize) { state.wnext = 0; }
      if (state.whave < state.wsize) { state.whave += dist; }
    }
  }
  return 0;
}

function inflate(strm, flush) {
  var state;
  var input, output;          // input/output buffers
  var next;                   /* next input INDEX */
  var put;                    /* next output INDEX */
  var have, left;             /* available input and output */
  var hold;                   /* bit buffer */
  var bits;                   /* bits in bit buffer */
  var _in, _out;              /* save starting available input and output */
  var copy;                   /* number of stored or match bytes to copy */
  var from;                   /* where to copy match bytes from */
  var from_source;
  var here = 0;               /* current decoding table entry */
  var here_bits, here_op, here_val; // paked "here" denormalized (JS specific)
  //var last;                   /* parent table entry */
  var last_bits, last_op, last_val; // paked "last" denormalized (JS specific)
  var len;                    /* length to copy for repeats, bits to drop */
  var ret;                    /* return code */
  var hbuf = new utils.Buf8(4);    /* buffer for gzip header crc calculation */
  var opts;

  var n; // temporary var for NEED_BITS

  var order = /* permutation of code lengths */
    [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];


  if (!strm || !strm.state || !strm.output ||
      (!strm.input && strm.avail_in !== 0)) {
    return Z_STREAM_ERROR;
  }

  state = strm.state;
  if (state.mode === TYPE) { state.mode = TYPEDO; }    /* skip check */


  //--- LOAD() ---
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits = state.bits;
  //---

  _in = have;
  _out = left;
  ret = Z_OK;

  inf_leave: // goto emulation
  for (;;) {
    switch (state.mode) {
      case HEAD:
        if (state.wrap === 0) {
          state.mode = TYPEDO;
          break;
        }
        //=== NEEDBITS(16);
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */
          state.check = 0/*crc32(0L, Z_NULL, 0)*/;
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32(state.check, hbuf, 2, 0);
          //===//

          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          state.mode = FLAGS;
          break;
        }
        state.flags = 0;           /* expect zlib header */
        if (state.head) {
          state.head.done = false;
        }
        if (!(state.wrap & 1) ||   /* check if zlib header allowed */
          (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {
          strm.msg = 'incorrect header check';
          state.mode = BAD;
          break;
        }
        if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED) {
          strm.msg = 'unknown compression method';
          state.mode = BAD;
          break;
        }
        //--- DROPBITS(4) ---//
        hold >>>= 4;
        bits -= 4;
        //---//
        len = (hold & 0x0f)/*BITS(4)*/ + 8;
        if (state.wbits === 0) {
          state.wbits = len;
        }
        else if (len > state.wbits) {
          strm.msg = 'invalid window size';
          state.mode = BAD;
          break;
        }
        state.dmax = 1 << len;
        //Tracev((stderr, "inflate:   zlib header ok\n"));
        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
        state.mode = hold & 0x200 ? DICTID : TYPE;
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        break;
      case FLAGS:
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.flags = hold;
        if ((state.flags & 0xff) !== Z_DEFLATED) {
          strm.msg = 'unknown compression method';
          state.mode = BAD;
          break;
        }
        if (state.flags & 0xe000) {
          strm.msg = 'unknown header flags set';
          state.mode = BAD;
          break;
        }
        if (state.head) {
          state.head.text = ((hold >> 8) & 1);
        }
        if (state.flags & 0x0200) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32(state.check, hbuf, 2, 0);
          //===//
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = TIME;
        /* falls through */
      case TIME:
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (state.head) {
          state.head.time = hold;
        }
        if (state.flags & 0x0200) {
          //=== CRC4(state.check, hold)
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          hbuf[2] = (hold >>> 16) & 0xff;
          hbuf[3] = (hold >>> 24) & 0xff;
          state.check = crc32(state.check, hbuf, 4, 0);
          //===
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = OS;
        /* falls through */
      case OS:
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (state.head) {
          state.head.xflags = (hold & 0xff);
          state.head.os = (hold >> 8);
        }
        if (state.flags & 0x0200) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32(state.check, hbuf, 2, 0);
          //===//
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = EXLEN;
        /* falls through */
      case EXLEN:
        if (state.flags & 0x0400) {
          //=== NEEDBITS(16); */
          while (bits < 16) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.length = hold;
          if (state.head) {
            state.head.extra_len = hold;
          }
          if (state.flags & 0x0200) {
            //=== CRC2(state.check, hold);
            hbuf[0] = hold & 0xff;
            hbuf[1] = (hold >>> 8) & 0xff;
            state.check = crc32(state.check, hbuf, 2, 0);
            //===//
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
        }
        else if (state.head) {
          state.head.extra = null/*Z_NULL*/;
        }
        state.mode = EXTRA;
        /* falls through */
      case EXTRA:
        if (state.flags & 0x0400) {
          copy = state.length;
          if (copy > have) { copy = have; }
          if (copy) {
            if (state.head) {
              len = state.head.extra_len - state.length;
              if (!state.head.extra) {
                // Use untyped array for more convenient processing later
                state.head.extra = new Array(state.head.extra_len);
              }
              utils.arraySet(
                state.head.extra,
                input,
                next,
                // extra field is limited to 65536 bytes
                // - no need for additional size check
                copy,
                /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                len
              );
              //zmemcpy(state.head.extra + len, next,
              //        len + copy > state.head.extra_max ?
              //        state.head.extra_max - len : copy);
            }
            if (state.flags & 0x0200) {
              state.check = crc32(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            state.length -= copy;
          }
          if (state.length) { break inf_leave; }
        }
        state.length = 0;
        state.mode = NAME;
        /* falls through */
      case NAME:
        if (state.flags & 0x0800) {
          if (have === 0) { break inf_leave; }
          copy = 0;
          do {
            // TODO: 2 or 1 bytes?
            len = input[next + copy++];
            /* use constant limit because in js we should not preallocate memory */
            if (state.head && len &&
                (state.length < 65536 /*state.head.name_max*/)) {
              state.head.name += String.fromCharCode(len);
            }
          } while (len && copy < have);

          if (state.flags & 0x0200) {
            state.check = crc32(state.check, input, copy, next);
          }
          have -= copy;
          next += copy;
          if (len) { break inf_leave; }
        }
        else if (state.head) {
          state.head.name = null;
        }
        state.length = 0;
        state.mode = COMMENT;
        /* falls through */
      case COMMENT:
        if (state.flags & 0x1000) {
          if (have === 0) { break inf_leave; }
          copy = 0;
          do {
            len = input[next + copy++];
            /* use constant limit because in js we should not preallocate memory */
            if (state.head && len &&
                (state.length < 65536 /*state.head.comm_max*/)) {
              state.head.comment += String.fromCharCode(len);
            }
          } while (len && copy < have);
          if (state.flags & 0x0200) {
            state.check = crc32(state.check, input, copy, next);
          }
          have -= copy;
          next += copy;
          if (len) { break inf_leave; }
        }
        else if (state.head) {
          state.head.comment = null;
        }
        state.mode = HCRC;
        /* falls through */
      case HCRC:
        if (state.flags & 0x0200) {
          //=== NEEDBITS(16); */
          while (bits < 16) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          if (hold !== (state.check & 0xffff)) {
            strm.msg = 'header crc mismatch';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
        }
        if (state.head) {
          state.head.hcrc = ((state.flags >> 9) & 1);
          state.head.done = true;
        }
        strm.adler = state.check = 0;
        state.mode = TYPE;
        break;
      case DICTID:
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        strm.adler = state.check = zswap32(hold);
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = DICT;
        /* falls through */
      case DICT:
        if (state.havedict === 0) {
          //--- RESTORE() ---
          strm.next_out = put;
          strm.avail_out = left;
          strm.next_in = next;
          strm.avail_in = have;
          state.hold = hold;
          state.bits = bits;
          //---
          return Z_NEED_DICT;
        }
        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
        state.mode = TYPE;
        /* falls through */
      case TYPE:
        if (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }
        /* falls through */
      case TYPEDO:
        if (state.last) {
          //--- BYTEBITS() ---//
          hold >>>= bits & 7;
          bits -= bits & 7;
          //---//
          state.mode = CHECK;
          break;
        }
        //=== NEEDBITS(3); */
        while (bits < 3) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.last = (hold & 0x01)/*BITS(1)*/;
        //--- DROPBITS(1) ---//
        hold >>>= 1;
        bits -= 1;
        //---//

        switch ((hold & 0x03)/*BITS(2)*/) {
          case 0:                             /* stored block */
            //Tracev((stderr, "inflate:     stored block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = STORED;
            break;
          case 1:                             /* fixed block */
            fixedtables(state);
            //Tracev((stderr, "inflate:     fixed codes block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = LEN_;             /* decode codes */
            if (flush === Z_TREES) {
              //--- DROPBITS(2) ---//
              hold >>>= 2;
              bits -= 2;
              //---//
              break inf_leave;
            }
            break;
          case 2:                             /* dynamic block */
            //Tracev((stderr, "inflate:     dynamic codes block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = TABLE;
            break;
          case 3:
            strm.msg = 'invalid block type';
            state.mode = BAD;
        }
        //--- DROPBITS(2) ---//
        hold >>>= 2;
        bits -= 2;
        //---//
        break;
      case STORED:
        //--- BYTEBITS() ---// /* go to byte boundary */
        hold >>>= bits & 7;
        bits -= bits & 7;
        //---//
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {
          strm.msg = 'invalid stored block lengths';
          state.mode = BAD;
          break;
        }
        state.length = hold & 0xffff;
        //Tracev((stderr, "inflate:       stored length %u\n",
        //        state.length));
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = COPY_;
        if (flush === Z_TREES) { break inf_leave; }
        /* falls through */
      case COPY_:
        state.mode = COPY;
        /* falls through */
      case COPY:
        copy = state.length;
        if (copy) {
          if (copy > have) { copy = have; }
          if (copy > left) { copy = left; }
          if (copy === 0) { break inf_leave; }
          //--- zmemcpy(put, next, copy); ---
          utils.arraySet(output, input, next, copy, put);
          //---//
          have -= copy;
          next += copy;
          left -= copy;
          put += copy;
          state.length -= copy;
          break;
        }
        //Tracev((stderr, "inflate:       stored end\n"));
        state.mode = TYPE;
        break;
      case TABLE:
        //=== NEEDBITS(14); */
        while (bits < 14) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;
        //--- DROPBITS(5) ---//
        hold >>>= 5;
        bits -= 5;
        //---//
        state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;
        //--- DROPBITS(5) ---//
        hold >>>= 5;
        bits -= 5;
        //---//
        state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;
        //--- DROPBITS(4) ---//
        hold >>>= 4;
        bits -= 4;
        //---//
//#ifndef PKZIP_BUG_WORKAROUND
        if (state.nlen > 286 || state.ndist > 30) {
          strm.msg = 'too many length or distance symbols';
          state.mode = BAD;
          break;
        }
//#endif
        //Tracev((stderr, "inflate:       table sizes ok\n"));
        state.have = 0;
        state.mode = LENLENS;
        /* falls through */
      case LENLENS:
        while (state.have < state.ncode) {
          //=== NEEDBITS(3);
          while (bits < 3) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);
          //--- DROPBITS(3) ---//
          hold >>>= 3;
          bits -= 3;
          //---//
        }
        while (state.have < 19) {
          state.lens[order[state.have++]] = 0;
        }
        // We have separate tables & no pointers. 2 commented lines below not needed.
        //state.next = state.codes;
        //state.lencode = state.next;
        // Switch to use dynamic table
        state.lencode = state.lendyn;
        state.lenbits = 7;

        opts = { bits: state.lenbits };
        ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
        state.lenbits = opts.bits;

        if (ret) {
          strm.msg = 'invalid code lengths set';
          state.mode = BAD;
          break;
        }
        //Tracev((stderr, "inflate:       code lengths ok\n"));
        state.have = 0;
        state.mode = CODELENS;
        /* falls through */
      case CODELENS:
        while (state.have < state.nlen + state.ndist) {
          for (;;) {
            here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if ((here_bits) <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          if (here_val < 16) {
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits;
            //---//
            state.lens[state.have++] = here_val;
          }
          else {
            if (here_val === 16) {
              //=== NEEDBITS(here.bits + 2);
              n = here_bits + 2;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              if (state.have === 0) {
                strm.msg = 'invalid bit length repeat';
                state.mode = BAD;
                break;
              }
              len = state.lens[state.have - 1];
              copy = 3 + (hold & 0x03);//BITS(2);
              //--- DROPBITS(2) ---//
              hold >>>= 2;
              bits -= 2;
              //---//
            }
            else if (here_val === 17) {
              //=== NEEDBITS(here.bits + 3);
              n = here_bits + 3;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              len = 0;
              copy = 3 + (hold & 0x07);//BITS(3);
              //--- DROPBITS(3) ---//
              hold >>>= 3;
              bits -= 3;
              //---//
            }
            else {
              //=== NEEDBITS(here.bits + 7);
              n = here_bits + 7;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              len = 0;
              copy = 11 + (hold & 0x7f);//BITS(7);
              //--- DROPBITS(7) ---//
              hold >>>= 7;
              bits -= 7;
              //---//
            }
            if (state.have + copy > state.nlen + state.ndist) {
              strm.msg = 'invalid bit length repeat';
              state.mode = BAD;
              break;
            }
            while (copy--) {
              state.lens[state.have++] = len;
            }
          }
        }

        /* handle error breaks in while */
        if (state.mode === BAD) { break; }

        /* check for end-of-block code (better have one) */
        if (state.lens[256] === 0) {
          strm.msg = 'invalid code -- missing end-of-block';
          state.mode = BAD;
          break;
        }

        /* build code tables -- note: do not change the lenbits or distbits
           values here (9 and 6) without reading the comments in inftrees.h
           concerning the ENOUGH constants, which depend on those values */
        state.lenbits = 9;

        opts = { bits: state.lenbits };
        ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
        // We have separate tables & no pointers. 2 commented lines below not needed.
        // state.next_index = opts.table_index;
        state.lenbits = opts.bits;
        // state.lencode = state.next;

        if (ret) {
          strm.msg = 'invalid literal/lengths set';
          state.mode = BAD;
          break;
        }

        state.distbits = 6;
        //state.distcode.copy(state.codes);
        // Switch to use dynamic table
        state.distcode = state.distdyn;
        opts = { bits: state.distbits };
        ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
        // We have separate tables & no pointers. 2 commented lines below not needed.
        // state.next_index = opts.table_index;
        state.distbits = opts.bits;
        // state.distcode = state.next;

        if (ret) {
          strm.msg = 'invalid distances set';
          state.mode = BAD;
          break;
        }
        //Tracev((stderr, 'inflate:       codes ok\n'));
        state.mode = LEN_;
        if (flush === Z_TREES) { break inf_leave; }
        /* falls through */
      case LEN_:
        state.mode = LEN;
        /* falls through */
      case LEN:
        if (have >= 6 && left >= 258) {
          //--- RESTORE() ---
          strm.next_out = put;
          strm.avail_out = left;
          strm.next_in = next;
          strm.avail_in = have;
          state.hold = hold;
          state.bits = bits;
          //---
          inflate_fast(strm, _out);
          //--- LOAD() ---
          put = strm.next_out;
          output = strm.output;
          left = strm.avail_out;
          next = strm.next_in;
          input = strm.input;
          have = strm.avail_in;
          hold = state.hold;
          bits = state.bits;
          //---

          if (state.mode === TYPE) {
            state.back = -1;
          }
          break;
        }
        state.back = 0;
        for (;;) {
          here = state.lencode[hold & ((1 << state.lenbits) - 1)];  /*BITS(state.lenbits)*/
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if (here_bits <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        if (here_op && (here_op & 0xf0) === 0) {
          last_bits = here_bits;
          last_op = here_op;
          last_val = here_val;
          for (;;) {
            here = state.lencode[last_val +
                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if ((last_bits + here_bits) <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          //--- DROPBITS(last.bits) ---//
          hold >>>= last_bits;
          bits -= last_bits;
          //---//
          state.back += last_bits;
        }
        //--- DROPBITS(here.bits) ---//
        hold >>>= here_bits;
        bits -= here_bits;
        //---//
        state.back += here_bits;
        state.length = here_val;
        if (here_op === 0) {
          //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
          //        "inflate:         literal '%c'\n" :
          //        "inflate:         literal 0x%02x\n", here.val));
          state.mode = LIT;
          break;
        }
        if (here_op & 32) {
          //Tracevv((stderr, "inflate:         end of block\n"));
          state.back = -1;
          state.mode = TYPE;
          break;
        }
        if (here_op & 64) {
          strm.msg = 'invalid literal/length code';
          state.mode = BAD;
          break;
        }
        state.extra = here_op & 15;
        state.mode = LENEXT;
        /* falls through */
      case LENEXT:
        if (state.extra) {
          //=== NEEDBITS(state.extra);
          n = state.extra;
          while (bits < n) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.length += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
          //--- DROPBITS(state.extra) ---//
          hold >>>= state.extra;
          bits -= state.extra;
          //---//
          state.back += state.extra;
        }
        //Tracevv((stderr, "inflate:         length %u\n", state.length));
        state.was = state.length;
        state.mode = DIST;
        /* falls through */
      case DIST:
        for (;;) {
          here = state.distcode[hold & ((1 << state.distbits) - 1)];/*BITS(state.distbits)*/
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if ((here_bits) <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        if ((here_op & 0xf0) === 0) {
          last_bits = here_bits;
          last_op = here_op;
          last_val = here_val;
          for (;;) {
            here = state.distcode[last_val +
                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if ((last_bits + here_bits) <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          //--- DROPBITS(last.bits) ---//
          hold >>>= last_bits;
          bits -= last_bits;
          //---//
          state.back += last_bits;
        }
        //--- DROPBITS(here.bits) ---//
        hold >>>= here_bits;
        bits -= here_bits;
        //---//
        state.back += here_bits;
        if (here_op & 64) {
          strm.msg = 'invalid distance code';
          state.mode = BAD;
          break;
        }
        state.offset = here_val;
        state.extra = (here_op) & 15;
        state.mode = DISTEXT;
        /* falls through */
      case DISTEXT:
        if (state.extra) {
          //=== NEEDBITS(state.extra);
          n = state.extra;
          while (bits < n) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.offset += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
          //--- DROPBITS(state.extra) ---//
          hold >>>= state.extra;
          bits -= state.extra;
          //---//
          state.back += state.extra;
        }
//#ifdef INFLATE_STRICT
        if (state.offset > state.dmax) {
          strm.msg = 'invalid distance too far back';
          state.mode = BAD;
          break;
        }
//#endif
        //Tracevv((stderr, "inflate:         distance %u\n", state.offset));
        state.mode = MATCH;
        /* falls through */
      case MATCH:
        if (left === 0) { break inf_leave; }
        copy = _out - left;
        if (state.offset > copy) {         /* copy from window */
          copy = state.offset - copy;
          if (copy > state.whave) {
            if (state.sane) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD;
              break;
            }
// (!) This block is disabled in zlib defaults,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//          Trace((stderr, "inflate.c too far\n"));
//          copy -= state.whave;
//          if (copy > state.length) { copy = state.length; }
//          if (copy > left) { copy = left; }
//          left -= copy;
//          state.length -= copy;
//          do {
//            output[put++] = 0;
//          } while (--copy);
//          if (state.length === 0) { state.mode = LEN; }
//          break;
//#endif
          }
          if (copy > state.wnext) {
            copy -= state.wnext;
            from = state.wsize - copy;
          }
          else {
            from = state.wnext - copy;
          }
          if (copy > state.length) { copy = state.length; }
          from_source = state.window;
        }
        else {                              /* copy from output */
          from_source = output;
          from = put - state.offset;
          copy = state.length;
        }
        if (copy > left) { copy = left; }
        left -= copy;
        state.length -= copy;
        do {
          output[put++] = from_source[from++];
        } while (--copy);
        if (state.length === 0) { state.mode = LEN; }
        break;
      case LIT:
        if (left === 0) { break inf_leave; }
        output[put++] = state.length;
        left--;
        state.mode = LEN;
        break;
      case CHECK:
        if (state.wrap) {
          //=== NEEDBITS(32);
          while (bits < 32) {
            if (have === 0) { break inf_leave; }
            have--;
            // Use '|' instead of '+' to make sure that result is signed
            hold |= input[next++] << bits;
            bits += 8;
          }
          //===//
          _out -= left;
          strm.total_out += _out;
          state.total += _out;
          if (_out) {
            strm.adler = state.check =
                /*UPDATE(state.check, put - _out, _out);*/
                (state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out));

          }
          _out = left;
          // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too
          if ((state.flags ? hold : zswap32(hold)) !== state.check) {
            strm.msg = 'incorrect data check';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          //Tracev((stderr, "inflate:   check matches trailer\n"));
        }
        state.mode = LENGTH;
        /* falls through */
      case LENGTH:
        if (state.wrap && state.flags) {
          //=== NEEDBITS(32);
          while (bits < 32) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          if (hold !== (state.total & 0xffffffff)) {
            strm.msg = 'incorrect length check';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          //Tracev((stderr, "inflate:   length matches trailer\n"));
        }
        state.mode = DONE;
        /* falls through */
      case DONE:
        ret = Z_STREAM_END;
        break inf_leave;
      case BAD:
        ret = Z_DATA_ERROR;
        break inf_leave;
      case MEM:
        return Z_MEM_ERROR;
      case SYNC:
        /* falls through */
      default:
        return Z_STREAM_ERROR;
    }
  }

  // inf_leave <- here is real place for "goto inf_leave", emulated via "break inf_leave"

  /*
     Return from inflate(), updating the total counts and the check value.
     If there was no progress during the inflate() call, return a buffer
     error.  Call updatewindow() to create and/or update the window state.
     Note: a memory error from inflate() is non-recoverable.
   */

  //--- RESTORE() ---
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits;
  //---

  if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&
                      (state.mode < CHECK || flush !== Z_FINISH))) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
      state.mode = MEM;
      return Z_MEM_ERROR;
    }
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if (state.wrap && _out) {
    strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
      (state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out));
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) +
                    (state.mode === TYPE ? 128 : 0) +
                    (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
  if (((_in === 0 && _out === 0) || flush === Z_FINISH) && ret === Z_OK) {
    ret = Z_BUF_ERROR;
  }
  return ret;
}

function inflateEnd(strm) {

  if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/) {
    return Z_STREAM_ERROR;
  }

  var state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK;
}

function inflateGetHeader(strm, head) {
  var state;

  /* check state */
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;
  if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR; }

  /* save header structure */
  state.head = head;
  head.done = false;
  return Z_OK;
}

function inflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;

  var state;
  var dictid;
  var ret;

  /* check state */
  if (!strm /* == Z_NULL */ || !strm.state /* == Z_NULL */) { return Z_STREAM_ERROR; }
  state = strm.state;

  if (state.wrap !== 0 && state.mode !== DICT) {
    return Z_STREAM_ERROR;
  }

  /* check for correct dictionary identifier */
  if (state.mode === DICT) {
    dictid = 1; /* adler32(0, null, 0)*/
    /* dictid = adler32(dictid, dictionary, dictLength); */
    dictid = adler32(dictid, dictionary, dictLength, 0);
    if (dictid !== state.check) {
      return Z_DATA_ERROR;
    }
  }
  /* copy dictionary to window using updatewindow(), which will amend the
   existing dictionary if appropriate */
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state.mode = MEM;
    return Z_MEM_ERROR;
  }
  state.havedict = 1;
  // Tracev((stderr, "inflate:   dictionary set\n"));
  return Z_OK;
}

exports.inflateReset = inflateReset;
exports.inflateReset2 = inflateReset2;
exports.inflateResetKeep = inflateResetKeep;
exports.inflateInit = inflateInit;
exports.inflateInit2 = inflateInit2;
exports.inflate = inflate;
exports.inflateEnd = inflateEnd;
exports.inflateGetHeader = inflateGetHeader;
exports.inflateSetDictionary = inflateSetDictionary;
exports.inflateInfo = 'pako inflate (from Nodeca project)';

/* Not implemented
exports.inflateCopy = inflateCopy;
exports.inflateGetDictionary = inflateGetDictionary;
exports.inflateMark = inflateMark;
exports.inflatePrime = inflatePrime;
exports.inflateSync = inflateSync;
exports.inflateSyncPoint = inflateSyncPoint;
exports.inflateUndermine = inflateUndermine;
*/

},{"../utils/common":"..\\node_modules\\pako\\lib\\utils\\common.js","./adler32":"..\\node_modules\\pako\\lib\\zlib\\adler32.js","./crc32":"..\\node_modules\\pako\\lib\\zlib\\crc32.js","./inffast":"..\\node_modules\\pako\\lib\\zlib\\inffast.js","./inftrees":"..\\node_modules\\pako\\lib\\zlib\\inftrees.js"}],"..\\node_modules\\pako\\lib\\zlib\\constants.js":[function(require,module,exports) {
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

module.exports = {

  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH:         0,
  Z_PARTIAL_FLUSH:    1,
  Z_SYNC_FLUSH:       2,
  Z_FULL_FLUSH:       3,
  Z_FINISH:           4,
  Z_BLOCK:            5,
  Z_TREES:            6,

  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK:               0,
  Z_STREAM_END:       1,
  Z_NEED_DICT:        2,
  Z_ERRNO:           -1,
  Z_STREAM_ERROR:    -2,
  Z_DATA_ERROR:      -3,
  //Z_MEM_ERROR:     -4,
  Z_BUF_ERROR:       -5,
  //Z_VERSION_ERROR: -6,

  /* compression levels */
  Z_NO_COMPRESSION:         0,
  Z_BEST_SPEED:             1,
  Z_BEST_COMPRESSION:       9,
  Z_DEFAULT_COMPRESSION:   -1,


  Z_FILTERED:               1,
  Z_HUFFMAN_ONLY:           2,
  Z_RLE:                    3,
  Z_FIXED:                  4,
  Z_DEFAULT_STRATEGY:       0,

  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY:                 0,
  Z_TEXT:                   1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN:                2,

  /* The deflate compression method */
  Z_DEFLATED:               8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};

},{}],"..\\node_modules\\pako\\lib\\zlib\\gzheader.js":[function(require,module,exports) {
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function GZheader() {
  /* true if compressed data believed to be text */
  this.text       = 0;
  /* modification time */
  this.time       = 0;
  /* extra flags (not used when writing a gzip file) */
  this.xflags     = 0;
  /* operating system */
  this.os         = 0;
  /* pointer to extra field or Z_NULL if none */
  this.extra      = null;
  /* extra field length (valid if extra != Z_NULL) */
  this.extra_len  = 0; // Actually, we don't need it in JS,
                       // but leave for few code modifications

  //
  // Setup limits is not necessary because in js we should not preallocate memory
  // for inflate use constant limit in 65536 bytes
  //

  /* space at extra (only when reading header) */
  // this.extra_max  = 0;
  /* pointer to zero-terminated file name or Z_NULL */
  this.name       = '';
  /* space at name (only when reading header) */
  // this.name_max   = 0;
  /* pointer to zero-terminated comment or Z_NULL */
  this.comment    = '';
  /* space at comment (only when reading header) */
  // this.comm_max   = 0;
  /* true if there was or will be a header crc */
  this.hcrc       = 0;
  /* true when done reading gzip header (not used when writing a gzip file) */
  this.done       = false;
}

module.exports = GZheader;

},{}],"..\\node_modules\\pako\\lib\\inflate.js":[function(require,module,exports) {
'use strict';


var zlib_inflate = require('./zlib/inflate');
var utils        = require('./utils/common');
var strings      = require('./utils/strings');
var c            = require('./zlib/constants');
var msg          = require('./zlib/messages');
var ZStream      = require('./zlib/zstream');
var GZheader     = require('./zlib/gzheader');

var toString = Object.prototype.toString;

/**
 * class Inflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[inflate]]
 * and [[inflateRaw]].
 **/

/* internal
 * inflate.chunks -> Array
 *
 * Chunks of output data, if [[Inflate#onData]] not overridden.
 **/

/**
 * Inflate.result -> Uint8Array|Array|String
 *
 * Uncompressed result, generated by default [[Inflate#onData]]
 * and [[Inflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Inflate#push]] with `Z_FINISH` / `true` param) or if you
 * push a chunk with explicit flush (call [[Inflate#push]] with
 * `Z_SYNC_FLUSH` param).
 **/

/**
 * Inflate.err -> Number
 *
 * Error code after inflate finished. 0 (Z_OK) on success.
 * Should be checked if broken data possible.
 **/

/**
 * Inflate.msg -> String
 *
 * Error message, if [[Inflate.err]] != 0
 **/


/**
 * new Inflate(options)
 * - options (Object): zlib inflate options.
 *
 * Creates new inflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `windowBits`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw inflate
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 * By default, when no options set, autodetect deflate/gzip data format via
 * wrapper header.
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
 *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * var inflate = new pako.Inflate({ level: 3});
 *
 * inflate.push(chunk1, false);
 * inflate.push(chunk2, true);  // true -> last chunk
 *
 * if (inflate.err) { throw new Error(inflate.err); }
 *
 * console.log(inflate.result);
 * ```
 **/
function Inflate(options) {
  if (!(this instanceof Inflate)) return new Inflate(options);

  this.options = utils.assign({
    chunkSize: 16384,
    windowBits: 0,
    to: ''
  }, options || {});

  var opt = this.options;

  // Force window size for `raw` data, if not set directly,
  // because we have no header for autodetect.
  if (opt.raw && (opt.windowBits >= 0) && (opt.windowBits < 16)) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) { opt.windowBits = -15; }
  }

  // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate
  if ((opt.windowBits >= 0) && (opt.windowBits < 16) &&
      !(options && options.windowBits)) {
    opt.windowBits += 32;
  }

  // Gzip header has no info about windows size, we can do autodetect only
  // for deflate. So, if window size not set, force it to max when gzip possible
  if ((opt.windowBits > 15) && (opt.windowBits < 48)) {
    // bit 3 (16) -> gzipped data
    // bit 4 (32) -> autodetect gzip/deflate
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }

  this.err    = 0;      // error code, if happens (0 = Z_OK)
  this.msg    = '';     // error message
  this.ended  = false;  // used to avoid multiple onEnd() calls
  this.chunks = [];     // chunks of compressed data

  this.strm   = new ZStream();
  this.strm.avail_out = 0;

  var status  = zlib_inflate.inflateInit2(
    this.strm,
    opt.windowBits
  );

  if (status !== c.Z_OK) {
    throw new Error(msg[status]);
  }

  this.header = new GZheader();

  zlib_inflate.inflateGetHeader(this.strm, this.header);
}

/**
 * Inflate#push(data[, mode]) -> Boolean
 * - data (Uint8Array|Array|ArrayBuffer|String): input data
 * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.
 *
 * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with
 * new output chunks. Returns `true` on success. The last data block must have
 * mode Z_FINISH (or `true`). That will flush internal pending buffers and call
 * [[Inflate#onEnd]]. For interim explicit flushes (without ending the stream) you
 * can use mode Z_SYNC_FLUSH, keeping the decompression context.
 *
 * On fail call [[Inflate#onEnd]] with error code and return false.
 *
 * We strongly recommend to use `Uint8Array` on input for best speed (output
 * format is detected automatically). Also, don't skip last param and always
 * use the same type in your code (boolean or number). That will improve JS speed.
 *
 * For regular `Array`-s make sure all elements are [0..255].
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Inflate.prototype.push = function (data, mode) {
  var strm = this.strm;
  var chunkSize = this.options.chunkSize;
  var dictionary = this.options.dictionary;
  var status, _mode;
  var next_out_utf8, tail, utf8str;
  var dict;

  // Flag to properly process Z_BUF_ERROR on testing inflate call
  // when we check that all output data was flushed.
  var allowBufError = false;

  if (this.ended) { return false; }
  _mode = (mode === ~~mode) ? mode : ((mode === true) ? c.Z_FINISH : c.Z_NO_FLUSH);

  // Convert data if needed
  if (typeof data === 'string') {
    // Only binary strings can be decompressed on practice
    strm.input = strings.binstring2buf(data);
  } else if (toString.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  do {
    if (strm.avail_out === 0) {
      strm.output = new utils.Buf8(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }

    status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);    /* no bad return value */

    if (status === c.Z_NEED_DICT && dictionary) {
      // Convert data if needed
      if (typeof dictionary === 'string') {
        dict = strings.string2buf(dictionary);
      } else if (toString.call(dictionary) === '[object ArrayBuffer]') {
        dict = new Uint8Array(dictionary);
      } else {
        dict = dictionary;
      }

      status = zlib_inflate.inflateSetDictionary(this.strm, dict);

    }

    if (status === c.Z_BUF_ERROR && allowBufError === true) {
      status = c.Z_OK;
      allowBufError = false;
    }

    if (status !== c.Z_STREAM_END && status !== c.Z_OK) {
      this.onEnd(status);
      this.ended = true;
      return false;
    }

    if (strm.next_out) {
      if (strm.avail_out === 0 || status === c.Z_STREAM_END || (strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH))) {

        if (this.options.to === 'string') {

          next_out_utf8 = strings.utf8border(strm.output, strm.next_out);

          tail = strm.next_out - next_out_utf8;
          utf8str = strings.buf2string(strm.output, next_out_utf8);

          // move tail
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail) { utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0); }

          this.onData(utf8str);

        } else {
          this.onData(utils.shrinkBuf(strm.output, strm.next_out));
        }
      }
    }

    // When no more input data, we should check that internal inflate buffers
    // are flushed. The only way to do it when avail_out = 0 - run one more
    // inflate pass. But if output data not exists, inflate return Z_BUF_ERROR.
    // Here we set flag to process this error properly.
    //
    // NOTE. Deflate does not return error in this case and does not needs such
    // logic.
    if (strm.avail_in === 0 && strm.avail_out === 0) {
      allowBufError = true;
    }

  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);

  if (status === c.Z_STREAM_END) {
    _mode = c.Z_FINISH;
  }

  // Finalize on the last chunk.
  if (_mode === c.Z_FINISH) {
    status = zlib_inflate.inflateEnd(this.strm);
    this.onEnd(status);
    this.ended = true;
    return status === c.Z_OK;
  }

  // callback interim results if Z_SYNC_FLUSH.
  if (_mode === c.Z_SYNC_FLUSH) {
    this.onEnd(c.Z_OK);
    strm.avail_out = 0;
    return true;
  }

  return true;
};


/**
 * Inflate#onData(chunk) -> Void
 * - chunk (Uint8Array|Array|String): output data. Type of array depends
 *   on js engine support. When string output requested, each chunk
 *   will be string.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Inflate.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};


/**
 * Inflate#onEnd(status) -> Void
 * - status (Number): inflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called either after you tell inflate that the input stream is
 * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)
 * or if an error happened. By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Inflate.prototype.onEnd = function (status) {
  // On success - join
  if (status === c.Z_OK) {
    if (this.options.to === 'string') {
      // Glue & convert here, until we teach pako to send
      // utf8 aligned strings to onData
      this.result = this.chunks.join('');
    } else {
      this.result = utils.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};


/**
 * inflate(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Decompress `data` with inflate/ungzip and `options`. Autodetect
 * format via wrapper header by default. That's why we don't provide
 * separate `ungzip` method.
 *
 * Supported options are:
 *
 * - windowBits
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , input = pako.deflate([1,2,3,4,5,6,7,8,9])
 *   , output;
 *
 * try {
 *   output = pako.inflate(input);
 * } catch (err)
 *   console.log(err);
 * }
 * ```
 **/
function inflate(input, options) {
  var inflator = new Inflate(options);

  inflator.push(input, true);

  // That will never happens, if you don't cheat with options :)
  if (inflator.err) { throw inflator.msg || msg[inflator.err]; }

  return inflator.result;
}


/**
 * inflateRaw(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * The same as [[inflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/
function inflateRaw(input, options) {
  options = options || {};
  options.raw = true;
  return inflate(input, options);
}


/**
 * ungzip(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Just shortcut to [[inflate]], because it autodetects format
 * by header.content. Done for convenience.
 **/


exports.Inflate = Inflate;
exports.inflate = inflate;
exports.inflateRaw = inflateRaw;
exports.ungzip  = inflate;

},{"./zlib/inflate":"..\\node_modules\\pako\\lib\\zlib\\inflate.js","./utils/common":"..\\node_modules\\pako\\lib\\utils\\common.js","./utils/strings":"..\\node_modules\\pako\\lib\\utils\\strings.js","./zlib/constants":"..\\node_modules\\pako\\lib\\zlib\\constants.js","./zlib/messages":"..\\node_modules\\pako\\lib\\zlib\\messages.js","./zlib/zstream":"..\\node_modules\\pako\\lib\\zlib\\zstream.js","./zlib/gzheader":"..\\node_modules\\pako\\lib\\zlib\\gzheader.js"}],"..\\node_modules\\pako\\index.js":[function(require,module,exports) {
// Top level file is just a mixin of submodules & constants
'use strict';

var assign    = require('./lib/utils/common').assign;

var deflate   = require('./lib/deflate');
var inflate   = require('./lib/inflate');
var constants = require('./lib/zlib/constants');

var pako = {};

assign(pako, deflate, inflate, constants);

module.exports = pako;

},{"./lib/utils/common":"..\\node_modules\\pako\\lib\\utils\\common.js","./lib/deflate":"..\\node_modules\\pako\\lib\\deflate.js","./lib/inflate":"..\\node_modules\\pako\\lib\\inflate.js","./lib/zlib/constants":"..\\node_modules\\pako\\lib\\zlib\\constants.js"}],"metroid_prime\\mlvl.ts":[function(require,module,exports) {
"use strict";
// Implements Retro's MLVL format as seen in Metroid Prime 1.

Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("../util");
function parse(resourceSystem, assetID, buffer) {
    var view = buffer.createDataView();
    util_1.assert(view.getUint32(0x00) == 0xDEAFBABE);
    var version = view.getUint32(0x04);
    // Version that appears in Metroid Prime 1.
    util_1.assert(version === 0x11);
    // STRG file ID?
    var worldNameSTRGID = util_1.readString(buffer, 0x08, 4, false);
    var worldName = resourceSystem.loadAssetByID(worldNameSTRGID, 'STRG');
    var worldSaveID = view.getUint32(0x0C);
    var defaultSkyboxID = util_1.readString(buffer, 0x10, 4, false);
    // Memory Relay junk.
    var memoryRelayTableIdx = 0x14;
    var memoryRelayTableCount = view.getUint32(memoryRelayTableIdx + 0x00);
    memoryRelayTableIdx += 0x04;
    for (var i = 0; i < memoryRelayTableCount; i++) {
        var memoryRelayInstanceID = view.getUint32(memoryRelayTableIdx + 0x00);
        var targetInstanceID = view.getUint32(memoryRelayTableIdx + 0x04);
        var messageType = view.getUint16(memoryRelayTableIdx + 0x08);
        var active = !!view.getUint8(memoryRelayTableIdx + 0x0A);
        memoryRelayTableIdx += 0x0B;
    }
    var areaTableOffs = memoryRelayTableIdx;
    var areaTableCount = view.getUint32(areaTableOffs + 0x00);
    util_1.assert(view.getUint32(areaTableOffs + 0x04) === 0x01);
    var areaTableIdx = areaTableOffs + 0x08;
    var areaTable = [];
    for (var i = 0; i < areaTableCount; i++) {
        var areaSTRGID = util_1.readString(buffer, areaTableIdx, 4, false);
        var areaSTRG = resourceSystem.loadAssetByID(areaSTRGID, 'STRG');
        var areaName = areaSTRG.strings[0];
        areaTableIdx += 0x04;
        areaTableIdx += 0x04 * 12; // Transform matrix
        areaTableIdx += 0x04 * 6; // AABB
        var areaMREAID = util_1.readString(buffer, areaTableIdx + 0x00, 4, false);
        var areaMREA = resourceSystem.findResourceByID(areaMREAID);
        util_1.assert(areaMREA !== null);
        var areaInternalID = view.getUint32(areaTableIdx + 0x04);
        areaTableIdx += 0x08;
        var attachedAreaCount = view.getUint32(areaTableIdx + 0x00);
        areaTableIdx += 0x04;
        for (var j = 0; j < attachedAreaCount; j++) {
            areaTableIdx += 0x02; // Attached Area Index Array
        }
        // TODO(jstpierre): Verify with Aruki. Seems to be undocumented?
        areaTableIdx += 0x04;
        var dependencyTableCount = view.getUint32(areaTableIdx);
        areaTableIdx += 0x04;
        for (var j = 0; j < dependencyTableCount; j++) {
            var dependencyID = view.getUint32(areaTableIdx + 0x00);
            var dependencyFOURCC = view.getUint32(areaTableIdx + 0x04);
            areaTableIdx += 0x08;
        }
        var dependencyOffsetTableCount = view.getUint32(areaTableIdx);
        areaTableIdx += 0x04;
        for (var j = 0; j < dependencyOffsetTableCount; j++) {
            var dependencyOffset = view.getUint32(areaTableIdx + 0x00);
            areaTableIdx += 0x04;
        }
        var dockCount = view.getUint32(areaTableIdx);
        areaTableIdx += 0x04;
        for (var j = 0; j < dockCount; j++) {
            var connectingDockCount = view.getUint32(areaTableIdx);
            areaTableIdx += 0x04;
            for (var k = 0; k < connectingDockCount; k++) {
                var connectingDockAreaIndex = view.getUint32(areaTableIdx + 0x00);
                var connectingDockDockIndex = view.getUint32(areaTableIdx + 0x04);
                areaTableIdx += 0x08;
            }
            var dockCoordinateCount = view.getUint32(areaTableIdx);
            areaTableIdx += 0x04;
            for (var k = 0; k < dockCoordinateCount; k++) {
                areaTableIdx += 0x0C; // xyz floats
            }
        }
        areaTable.push({ areaName: areaName, areaMREAID: areaMREAID });
    }
    return { areaTable: areaTable, defaultSkyboxID: defaultSkyboxID };
}
exports.parse = parse;
},{"../util":"util.ts"}],"metroid_prime\\mrea.ts":[function(require,module,exports) {
"use strict";
// Implements Retro's MREA format as seen in Metroid Prime 1.

var __values = this && this.__values || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator],
        i = 0;
    if (m) return m.call(o);
    return {
        next: function next() {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
var __read = this && this.__read || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o),
        r,
        ar = [],
        e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {
            ar.push(r.value);
        }
    } catch (error) {
        e = { error: error };
    } finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
            if (e) throw e.error;
        }
    }
    return ar;
};
var __importStar = this && this.__importStar || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) {
        if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    }result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var GX_Material = __importStar(require("../gx/gx_material"));
var GX = __importStar(require("../gx/gx_enum"));
var util_1 = require("../util");
var gx_displaylist_1 = require("../gx/gx_displaylist");
var Camera_1 = require("../Camera");
var gl_matrix_1 = require("gl-matrix");
var UVAnimationType;
(function (UVAnimationType) {
    UVAnimationType[UVAnimationType["INV_MAT_SKY"] = 0] = "INV_MAT_SKY";
    UVAnimationType[UVAnimationType["INV_MAT"] = 1] = "INV_MAT";
    UVAnimationType[UVAnimationType["UV_SCROLL"] = 2] = "UV_SCROLL";
    UVAnimationType[UVAnimationType["ROTATION"] = 3] = "ROTATION";
    UVAnimationType[UVAnimationType["FLIPBOOK_U"] = 4] = "FLIPBOOK_U";
    UVAnimationType[UVAnimationType["FLIPBOOK_V"] = 5] = "FLIPBOOK_V";
    UVAnimationType[UVAnimationType["MODEL_MAT"] = 6] = "MODEL_MAT";
    UVAnimationType[UVAnimationType["CYLINDER"] = 7] = "CYLINDER";
})(UVAnimationType = exports.UVAnimationType || (exports.UVAnimationType = {}));
var MaterialFlags;
(function (MaterialFlags) {
    MaterialFlags[MaterialFlags["HAS_KONST"] = 8] = "HAS_KONST";
    MaterialFlags[MaterialFlags["IS_TRANSPARENT"] = 16] = "IS_TRANSPARENT";
    MaterialFlags[MaterialFlags["PUNCHTHROUGH"] = 32] = "PUNCHTHROUGH";
    MaterialFlags[MaterialFlags["HAS_SAMUS_REFL"] = 64] = "HAS_SAMUS_REFL";
    MaterialFlags[MaterialFlags["DEPTH_WRITE"] = 128] = "DEPTH_WRITE";
    MaterialFlags[MaterialFlags["OCCLUDER"] = 512] = "OCCLUDER";
    MaterialFlags[MaterialFlags["HAS_INDTX_REFL"] = 1024] = "HAS_INDTX_REFL";
    MaterialFlags[MaterialFlags["UV_SHORT"] = 8192] = "UV_SHORT";
})(MaterialFlags = exports.MaterialFlags || (exports.MaterialFlags = {}));
function parseMaterialSet(resourceSystem, buffer, offs) {
    var view = buffer.createDataView();
    var textureCount = view.getUint32(offs + 0x00);
    offs += 0x04;
    var textures = [];
    var textureRemapTable = [];
    for (var i = 0; i < textureCount; i++) {
        var materialTXTRID = util_1.readString(buffer, offs, 0x04, false);
        var txtr = resourceSystem.loadAssetByID(materialTXTRID, 'TXTR');
        var txtrIndex = textures.indexOf(txtr);
        if (txtrIndex >= 0) {
            textureRemapTable.push(txtrIndex);
        } else {
            var newIndex = textures.push(txtr) - 1;
            textureRemapTable.push(newIndex);
        }
        offs += 0x04;
    }
    var materialCount = view.getUint32(offs + 0x00);
    offs += 0x04;
    var materialEndTable = [];
    for (var i = 0; i < materialCount; i++) {
        var materialEndOffs = view.getUint32(offs);
        materialEndTable.push(materialEndOffs);
        offs += 0x04;
    }
    var materialsStart = offs;
    var materials = [];
    for (var i = 0; i < materialCount; i++) {
        var flags = view.getUint32(offs + 0x00);
        var textureIndexCount = view.getUint32(offs + 0x04);
        offs += 0x08;
        var textureIndexes = [];
        util_1.assert(textureIndexCount < 8);
        for (var j = 0; j < textureIndexCount; j++) {
            var textureIndex = view.getUint32(offs);
            textureIndexes.push(textureIndex);
            offs += 0x04;
        }
        var vtxAttrFormat = view.getUint32(offs + 0x00);
        var groupIndex = view.getUint32(offs + 0x04);
        offs += 0x08;
        var colorConstants = [];
        if (flags & MaterialFlags.HAS_KONST) {
            var konstCount = view.getUint32(offs);
            offs += 0x04;
            for (var j = 0; j < konstCount; j++) {
                var r = view.getUint8(offs + 0x00);
                var g = view.getUint8(offs + 0x01);
                var b = view.getUint8(offs + 0x02);
                var a = view.getUint8(offs + 0x03);
                colorConstants.push(new GX_Material.Color(r, g, b, a));
                offs += 0x04;
            }
        }
        for (var j = colorConstants.length; j < 4; j++) {
            // Push default colors.
            // XXX(jstpierre): Should this stuff be moved outside GXMaterial?
            colorConstants.push(new GX_Material.Color(0, 0, 0, 0));
        }
        var blendDstFactor = view.getUint16(offs + 0x00);
        var blendSrcFactor = view.getUint16(offs + 0x02);
        offs += 0x04;
        if (flags & MaterialFlags.HAS_INDTX_REFL) {
            var reflectionIndtexSlot = view.getUint32(offs);
            offs += 0x04;
        }
        var colorChannelFlagsTableCount = view.getUint32(offs);
        util_1.assert(colorChannelFlagsTableCount <= 4);
        offs += 0x04;
        var lightChannels = [];
        // Only color channel 1 is stored in the format.
        for (var j = 0; j < 1; j++) {
            var colorChannelFlags = view.getUint32(offs);
            var lightingEnabled = !!(colorChannelFlags & 0x01);
            var ambColorSource = colorChannelFlags >>> 1 & 0x01;
            var matColorSource = colorChannelFlags >>> 2 & 0x01;
            var colorChannel = { lightingEnabled: lightingEnabled, ambColorSource: ambColorSource, matColorSource: matColorSource };
            // XXX(jstpierre): What's with COLOR0A0?
            var alphaChannel = { lightingEnabled: false, ambColorSource: GX.ColorSrc.REG, matColorSource: GX.ColorSrc.REG };
            lightChannels.push({ colorChannel: colorChannel, alphaChannel: alphaChannel });
        }
        offs += 0x04 * colorChannelFlagsTableCount;
        // Fake other channel.
        lightChannels.push({
            colorChannel: { lightingEnabled: false, ambColorSource: GX.ColorSrc.REG, matColorSource: GX.ColorSrc.REG },
            alphaChannel: { lightingEnabled: false, ambColorSource: GX.ColorSrc.REG, matColorSource: GX.ColorSrc.REG }
        });
        var tevStageCount = view.getUint32(offs);
        util_1.assert(tevStageCount <= 8);
        offs += 0x04;
        var tevOrderTableOffs = offs + tevStageCount * 0x14;
        var tevStages = [];
        for (var j = 0; j < tevStageCount; j++) {
            var colorInputSel = view.getUint32(offs + 0x00);
            var alphaInputSel = view.getUint32(offs + 0x04);
            var colorCombineFlags = view.getUint32(offs + 0x08);
            var alphaCombineFlags = view.getUint32(offs + 0x0C);
            var konstAlphaSel = view.getUint8(offs + 0x11);
            var konstColorSel = view.getUint8(offs + 0x12);
            var channelId = GX_Material.getRasColorChannelID(view.getUint8(offs + 0x13));
            var colorInA = colorInputSel >>> 0 & 0x1F;
            var colorInB = colorInputSel >>> 5 & 0x1F;
            var colorInC = colorInputSel >>> 10 & 0x1F;
            var colorInD = colorInputSel >>> 15 & 0x1F;
            var alphaInA = alphaInputSel >>> 0 & 0x1F;
            var alphaInB = alphaInputSel >>> 5 & 0x1F;
            var alphaInC = alphaInputSel >>> 10 & 0x1F;
            var alphaInD = alphaInputSel >>> 15 & 0x1F;
            var colorOp = colorCombineFlags >>> 0 & 0x0F;
            var colorBias = colorCombineFlags >>> 4 & 0x03;
            var colorScale = colorCombineFlags >>> 6 & 0x03;
            var colorClamp = !!(colorCombineFlags >>> 8);
            var colorRegId = colorCombineFlags >>> 9 & 0x03;
            var alphaOp = alphaCombineFlags >>> 0 & 0x0F;
            var alphaBias = alphaCombineFlags >>> 4 & 0x03;
            var alphaScale = alphaCombineFlags >>> 6 & 0x03;
            var alphaClamp = !!(alphaCombineFlags >>> 8);
            var alphaRegId = alphaCombineFlags >>> 9 & 0x03;
            var texCoordId = view.getUint8(tevOrderTableOffs + 0x03);
            var texMap = view.getUint8(tevOrderTableOffs + 0x02);
            var index_1 = j;
            var tevStage = {
                index: index_1,
                colorInA: colorInA, colorInB: colorInB, colorInC: colorInC, colorInD: colorInD, colorOp: colorOp, colorBias: colorBias, colorScale: colorScale, colorClamp: colorClamp, colorRegId: colorRegId,
                alphaInA: alphaInA, alphaInB: alphaInB, alphaInC: alphaInC, alphaInD: alphaInD, alphaOp: alphaOp, alphaBias: alphaBias, alphaScale: alphaScale, alphaClamp: alphaClamp, alphaRegId: alphaRegId,
                texCoordId: texCoordId, texMap: texMap, channelId: channelId,
                konstColorSel: konstColorSel, konstAlphaSel: konstAlphaSel,
                // We don't use indtex.
                indTexStage: GX.IndTexStageID.STAGE0,
                indTexMatrix: GX.IndTexMtxID.OFF,
                indTexFormat: GX.IndTexFormat._8,
                indTexBiasSel: GX.IndTexBiasSel.NONE,
                indTexWrapS: GX.IndTexWrap.OFF,
                indTexWrapT: GX.IndTexWrap.OFF,
                indTexAddPrev: false,
                indTexUseOrigLOD: false
            };
            tevStages.push(tevStage);
            offs += 0x14;
            tevOrderTableOffs += 0x04;
        }
        // Skip past TEV order table.
        offs = tevOrderTableOffs;
        var texGenCount = view.getUint32(offs);
        util_1.assert(texGenCount <= 8);
        offs += 0x04;
        var texGens = [];
        for (var j = 0; j < texGenCount; j++) {
            var index_2 = j;
            var flags_1 = view.getUint32(offs);
            var type = flags_1 >>> 0 & 0x0F;
            var source = flags_1 >>> 4 & 0x0F;
            var matrix = (flags_1 >>> 9 & 0x1F) + 30;
            var normalize = !!(flags_1 & 14);
            var postMatrix = (flags_1 >>> 15 & 0x3F) + 64;
            texGens.push({ index: index_2, type: type, source: source, matrix: matrix, normalize: normalize, postMatrix: postMatrix });
            offs += 0x04;
        }
        var uvAnimations = [];
        var uvAnimationsSize = view.getUint32(offs + 0x00);
        var uvAnimationsCount = view.getUint32(offs + 0x04);
        offs += 0x08;
        for (var j = 0; j < uvAnimationsCount; j++) {
            var type = view.getUint32(offs + 0x00);
            offs += 0x04;
            switch (type) {
                case UVAnimationType.INV_MAT_SKY:
                case UVAnimationType.INV_MAT:
                case UVAnimationType.MODEL_MAT:
                    uvAnimations.push({ type: type });
                    // These guys have no parameters.
                    break;
                case UVAnimationType.UV_SCROLL:
                    {
                        var offsetS = view.getFloat32(offs + 0x00);
                        var offsetT = view.getFloat32(offs + 0x04);
                        var scaleS = view.getFloat32(offs + 0x08);
                        var scaleT = view.getFloat32(offs + 0x0C);
                        uvAnimations.push({ type: type, offsetS: offsetS, offsetT: offsetT, scaleS: scaleS, scaleT: scaleT });
                        offs += 0x10;
                        break;
                    }
                case UVAnimationType.ROTATION:
                    {
                        var offset = view.getFloat32(offs + 0x00);
                        var scale = view.getFloat32(offs + 0x04);
                        uvAnimations.push({ type: type, offset: offset, scale: scale });
                        offs += 0x08;
                        break;
                    }
                case UVAnimationType.FLIPBOOK_U:
                case UVAnimationType.FLIPBOOK_V:
                    {
                        var scale = view.getFloat32(offs + 0x00);
                        var numFrames = view.getFloat32(offs + 0x04);
                        var step = view.getFloat32(offs + 0x08);
                        var offset = view.getFloat32(offs + 0x0C);
                        uvAnimations.push({ type: type, scale: scale, numFrames: numFrames, step: step, offset: offset });
                        offs += 0x10;
                        break;
                    }
                case UVAnimationType.CYLINDER:
                    {
                        var theta = view.getFloat32(offs + 0x00);
                        var phi = view.getFloat32(offs + 0x04);
                        uvAnimations.push({ type: type, theta: theta, phi: phi });
                        offs += 0x08;
                        break;
                    }
            }
        }
        var index = i;
        var translucent = flags & MaterialFlags.IS_TRANSPARENT;
        var name = "PrimeGen_" + i;
        var cullMode = GX.CullMode.FRONT;
        var colorRegisters = [];
        colorRegisters.push(new GX_Material.Color(0, 0, 0, 0));
        colorRegisters.push(new GX_Material.Color(1, 1, 1, 0));
        colorRegisters.push(new GX_Material.Color(1, 1, 1, 0));
        colorRegisters.push(new GX_Material.Color(0, 0, 0, 0));
        var alphaTest = {
            op: GX.AlphaOp.OR,
            compareA: GX.CompareType.GREATER,
            referenceA: 0.25,
            compareB: GX.CompareType.NEVER,
            referenceB: 0
        };
        var blendMode = {
            type: translucent ? GX.BlendMode.BLEND : GX.BlendMode.NONE,
            srcFactor: blendSrcFactor,
            dstFactor: blendDstFactor,
            logicOp: GX.LogicOp.CLEAR
        };
        var ropInfo = {
            blendMode: blendMode,
            depthTest: true,
            depthFunc: GX.CompareType.LESS,
            depthWrite: !!(flags & MaterialFlags.DEPTH_WRITE) && !translucent
        };
        var gxMaterial = {
            index: index, name: name,
            cullMode: cullMode,
            colorRegisters: colorRegisters,
            colorConstants: colorConstants,
            lightChannels: lightChannels,
            texGens: texGens,
            tevStages: tevStages,
            alphaTest: alphaTest,
            ropInfo: ropInfo,
            indTexStages: []
        };
        materials.push({ flags: flags, groupIndex: groupIndex, textureIndexes: textureIndexes, vtxAttrFormat: vtxAttrFormat, gxMaterial: gxMaterial, uvAnimations: uvAnimations });
        util_1.assert(offs - materialsStart === materialEndTable[i]);
    }
    return { textures: textures, textureRemapTable: textureRemapTable, materials: materials };
}
exports.parseMaterialSet = parseMaterialSet;
exports.vtxAttrFormats = [{ vtxAttrib: GX.VertexAttribute.POS, mask: 0x00000003, compCount: 3 }, { vtxAttrib: GX.VertexAttribute.NRM, mask: 0x0000000C, compCount: 3 }, { vtxAttrib: GX.VertexAttribute.CLR0, mask: 0x00000030, compCount: 4 }, { vtxAttrib: GX.VertexAttribute.CLR1, mask: 0x000000C0, compCount: 4 }, { vtxAttrib: GX.VertexAttribute.TEX0, mask: 0x00000300, compCount: 2 }, { vtxAttrib: GX.VertexAttribute.TEX1, mask: 0x00000C00, compCount: 2 }, { vtxAttrib: GX.VertexAttribute.TEX2, mask: 0x00003000, compCount: 2 }, { vtxAttrib: GX.VertexAttribute.TEX3, mask: 0x0000C000, compCount: 2 }, { vtxAttrib: GX.VertexAttribute.TEX4, mask: 0x00030000, compCount: 2 }, { vtxAttrib: GX.VertexAttribute.TEX5, mask: 0x000C0000, compCount: 2 }, { vtxAttrib: GX.VertexAttribute.TEX6, mask: 0x00300000, compCount: 2 }];
function parseGeometry(buffer, materialSet, sectionOffsTable, hasUVShort, sectionIndex) {
    var e_1, _a;
    var view = buffer.createDataView();
    var posSectionOffs = sectionOffsTable[sectionIndex++];
    var nrmSectionOffs = sectionOffsTable[sectionIndex++];
    var clrSectionOffs = sectionOffsTable[sectionIndex++];
    var uvfSectionOffs = sectionOffsTable[sectionIndex++];
    var uvsSectionOffs = hasUVShort ? sectionOffsTable[sectionIndex++] : null;
    var surfaceTableOffs = sectionOffsTable[sectionIndex++];
    var firstSurfaceOffs = sectionOffsTable[sectionIndex];
    var surfaceCount = view.getUint32(surfaceTableOffs + 0x00);
    var surfaces = [];
    function fillVatFormat(nrmType, tex0Type, compShift) {
        var vatFormat = [];
        vatFormat[GX.VertexAttribute.POS] = { compCnt: GX.CompCnt.POS_XYZ, compType: GX.CompType.F32, compShift: compShift };
        vatFormat[GX.VertexAttribute.NRM] = { compCnt: GX.CompCnt.NRM_XYZ, compType: nrmType, compShift: compShift };
        vatFormat[GX.VertexAttribute.CLR0] = { compCnt: GX.CompCnt.CLR_RGBA, compType: GX.CompType.RGBA8, compShift: compShift };
        vatFormat[GX.VertexAttribute.CLR1] = { compCnt: GX.CompCnt.CLR_RGBA, compType: GX.CompType.RGBA8, compShift: compShift };
        vatFormat[GX.VertexAttribute.TEX0] = { compCnt: GX.CompCnt.TEX_ST, compType: tex0Type, compShift: compShift };
        vatFormat[GX.VertexAttribute.TEX1] = { compCnt: GX.CompCnt.TEX_ST, compType: GX.CompType.F32, compShift: compShift };
        vatFormat[GX.VertexAttribute.TEX2] = { compCnt: GX.CompCnt.TEX_ST, compType: GX.CompType.F32, compShift: compShift };
        vatFormat[GX.VertexAttribute.TEX3] = { compCnt: GX.CompCnt.TEX_ST, compType: GX.CompType.F32, compShift: compShift };
        vatFormat[GX.VertexAttribute.TEX4] = { compCnt: GX.CompCnt.TEX_ST, compType: GX.CompType.F32, compShift: compShift };
        vatFormat[GX.VertexAttribute.TEX5] = { compCnt: GX.CompCnt.TEX_ST, compType: GX.CompType.F32, compShift: compShift };
        vatFormat[GX.VertexAttribute.TEX6] = { compCnt: GX.CompCnt.TEX_ST, compType: GX.CompType.F32, compShift: compShift };
        vatFormat[GX.VertexAttribute.TEX7] = { compCnt: GX.CompCnt.TEX_ST, compType: GX.CompType.F32, compShift: compShift };
        return vatFormat;
    }
    for (var i = 0; i < surfaceCount; i++) {
        var surfaceOffs = sectionOffsTable[sectionIndex];
        var surfaceEnd = firstSurfaceOffs + view.getUint32(surfaceTableOffs + 0x04 + i * 0x04);
        var centerX = view.getFloat32(surfaceOffs + 0x00);
        var centerY = view.getFloat32(surfaceOffs + 0x04);
        var centerZ = view.getFloat32(surfaceOffs + 0x08);
        var materialIndex = view.getUint32(surfaceOffs + 0x0C);
        var mantissa = view.getUint16(surfaceOffs + 0x10);
        var displayListSizeExceptNotReally = view.getUint16(surfaceOffs + 0x12);
        var extraDataSize = view.getUint32(surfaceOffs + 0x1C);
        var normalX = view.getFloat32(surfaceOffs + 0x20);
        var normalY = view.getFloat32(surfaceOffs + 0x24);
        var normalZ = view.getFloat32(surfaceOffs + 0x28);
        // XXX(jstpierre): 0x30 or 0x2C?
        var surfaceHeaderEnd = surfaceOffs + 0x2C + extraDataSize;
        var primitiveDataOffs = util_1.align(surfaceHeaderEnd, 32);
        // Build our vertex format.
        var material = materialSet.materials[materialIndex];
        var vtxAttrFormat = material.vtxAttrFormat;
        var vat = [];
        var useUvsArray = material.flags & MaterialFlags.UV_SHORT;
        var vtxArrays = [];
        vtxArrays[GX.VertexAttribute.POS] = { buffer: buffer, offs: posSectionOffs };
        vtxArrays[GX.VertexAttribute.NRM] = { buffer: buffer, offs: nrmSectionOffs };
        vtxArrays[GX.VertexAttribute.CLR0] = { buffer: buffer, offs: clrSectionOffs };
        vtxArrays[GX.VertexAttribute.CLR1] = { buffer: buffer, offs: clrSectionOffs };
        vtxArrays[GX.VertexAttribute.TEX0] = { buffer: buffer, offs: useUvsArray ? uvsSectionOffs : uvfSectionOffs };
        vtxArrays[GX.VertexAttribute.TEX1] = { buffer: buffer, offs: uvfSectionOffs };
        vtxArrays[GX.VertexAttribute.TEX2] = { buffer: buffer, offs: uvfSectionOffs };
        vtxArrays[GX.VertexAttribute.TEX3] = { buffer: buffer, offs: uvfSectionOffs };
        vtxArrays[GX.VertexAttribute.TEX4] = { buffer: buffer, offs: uvfSectionOffs };
        vtxArrays[GX.VertexAttribute.TEX5] = { buffer: buffer, offs: uvfSectionOffs };
        vtxArrays[GX.VertexAttribute.TEX6] = { buffer: buffer, offs: uvfSectionOffs };
        vtxArrays[GX.VertexAttribute.TEX7] = { buffer: buffer, offs: uvfSectionOffs };
        var vcd = [];
        try {
            for (var vtxAttrFormats_1 = __values(exports.vtxAttrFormats), vtxAttrFormats_1_1 = vtxAttrFormats_1.next(); !vtxAttrFormats_1_1.done; vtxAttrFormats_1_1 = vtxAttrFormats_1.next()) {
                var format = vtxAttrFormats_1_1.value;
                if (!(vtxAttrFormat & format.mask)) continue;
                vcd[format.vtxAttrib] = { type: GX.AttrType.INDEX16 };
            }
        } catch (e_1_1) {
            e_1 = { error: e_1_1 };
        } finally {
            try {
                if (vtxAttrFormats_1_1 && !vtxAttrFormats_1_1.done && (_a = vtxAttrFormats_1.return)) _a.call(vtxAttrFormats_1);
            } finally {
                if (e_1) throw e_1.error;
            }
        }
        // GX_VTXFMT0 | GX_VA_NRM = GX_F32
        // GX_VTXFMT1 | GX_VA_NRM = GX_S16
        // GX_VTXFMT2 | GX_VA_NRM = GX_S16
        // GX_VTXFMT0 | GX_VA_TEX0 = GX_F32
        // GX_VTXFMT1 | GX_VA_TEX0 = GX_F32
        // GX_VTXFMT2 | GX_VA_TEX0 = GX_S16
        var compShift = Math.log2(mantissa);
        vat[GX.VtxFmt.VTXFMT0] = fillVatFormat(GX.CompType.F32, GX.CompType.F32, compShift);
        vat[GX.VtxFmt.VTXFMT1] = fillVatFormat(GX.CompType.S16, GX.CompType.F32, compShift);
        vat[GX.VtxFmt.VTXFMT2] = fillVatFormat(GX.CompType.S16, GX.CompType.S16, compShift);
        var vtxLoader = gx_displaylist_1.compileVtxLoaderMultiVat(vat, vcd);
        var dlData = buffer.slice(primitiveDataOffs, surfaceEnd);
        var loadedVertexLayout = vtxLoader.loadedVertexLayout;
        var loadedVertexData = vtxLoader.runVertices(vtxArrays, dlData);
        var surface = {
            materialIndex: materialIndex,
            loadedVertexData: loadedVertexData,
            loadedVertexLayout: loadedVertexLayout
        };
        surfaces.push(surface);
        sectionIndex++;
    }
    var geometry = { surfaces: surfaces };
    return [geometry, sectionIndex];
}
exports.parseGeometry = parseGeometry;
function parse(resourceSystem, assetID, buffer) {
    var _a;
    var view = buffer.createDataView();
    util_1.assert(view.getUint32(0x00) === 0xDEADBEEF);
    var version = view.getUint32(0x04);
    util_1.assert(version === 0x0F);
    // 0x10 - 0x34: Transform matrix
    var worldModelCount = view.getUint32(0x38);
    var dataSectionCount = view.getUint32(0x3C);
    var worldGeometrySectionIndex = view.getUint32(0x40);
    var dataSectionSizeTable = [];
    var dataSectionSizeTableIdx = 0x60;
    for (var i = 0; i < dataSectionCount; i++) {
        var size = view.getUint32(dataSectionSizeTableIdx + 0x00);
        dataSectionSizeTable.push(size);
        dataSectionSizeTableIdx += 0x04;
    }
    var firstDataSectionOffs = util_1.align(dataSectionSizeTableIdx, 32);
    var dataSectionOffsTable = [firstDataSectionOffs];
    for (var i = 1; i < dataSectionCount; i++) {
        var prevOffs = dataSectionOffsTable[i - 1];
        var prevSize = dataSectionSizeTable[i - 1];
        dataSectionOffsTable.push(util_1.align(prevOffs + prevSize, 32));
    }
    // In practice.
    util_1.assert(worldGeometrySectionIndex === 0);
    // The materials section is always the first index in the world geometry section indexes...
    var materialSectionOffs = dataSectionOffsTable[worldGeometrySectionIndex + 0];
    // Parse out materials.
    var materialSet = parseMaterialSet(resourceSystem, buffer, materialSectionOffs);
    var geometrySectionIndex = worldGeometrySectionIndex + 1;
    var worldModels = [];
    for (var i = 0; i < worldModelCount; i++) {
        // World model header.
        var worldModelHeaderOffs = dataSectionOffsTable[geometrySectionIndex];
        var visorFlags = view.getUint32(worldModelHeaderOffs + 0x00);
        var m00 = view.getFloat32(worldModelHeaderOffs + 0x04);
        var m01 = view.getFloat32(worldModelHeaderOffs + 0x08);
        var m02 = view.getFloat32(worldModelHeaderOffs + 0x0C);
        var m03 = view.getFloat32(worldModelHeaderOffs + 0x10);
        var m10 = view.getFloat32(worldModelHeaderOffs + 0x14);
        var m11 = view.getFloat32(worldModelHeaderOffs + 0x18);
        var m12 = view.getFloat32(worldModelHeaderOffs + 0x1C);
        var m13 = view.getFloat32(worldModelHeaderOffs + 0x20);
        var m20 = view.getFloat32(worldModelHeaderOffs + 0x24);
        var m21 = view.getFloat32(worldModelHeaderOffs + 0x28);
        var m22 = view.getFloat32(worldModelHeaderOffs + 0x2C);
        var m23 = view.getFloat32(worldModelHeaderOffs + 0x30);
        var modelMatrix = gl_matrix_1.mat4.fromValues(m00, m10, m20, 0.0, m01, m11, m21, 0.0, m02, m12, m22, 0.0, m03, m13, m23, 1.0);
        var bboxMinX = view.getFloat32(worldModelHeaderOffs + 0x34);
        var bboxMinY = view.getFloat32(worldModelHeaderOffs + 0x38);
        var bboxMinZ = view.getFloat32(worldModelHeaderOffs + 0x3C);
        var bboxMaxX = view.getFloat32(worldModelHeaderOffs + 0x40);
        var bboxMaxY = view.getFloat32(worldModelHeaderOffs + 0x44);
        var bboxMaxZ = view.getFloat32(worldModelHeaderOffs + 0x48);
        var bbox = new Camera_1.AABB(bboxMinX, bboxMinY, bboxMinZ, bboxMaxX, bboxMaxY, bboxMaxZ);
        worldModelHeaderOffs += 0x4C;
        geometrySectionIndex += 1;
        var geometry = void 0;
        _a = __read(parseGeometry(buffer, materialSet, dataSectionOffsTable, true, geometrySectionIndex), 2), geometry = _a[0], geometrySectionIndex = _a[1];
        worldModels.push({ geometry: geometry, modelMatrix: modelMatrix, bbox: bbox });
    }
    return { materialSet: materialSet, worldModels: worldModels };
}
exports.parse = parse;
},{"../gx/gx_material":"gx\\gx_material.ts","../gx/gx_enum":"gx\\gx_enum.ts","../util":"util.ts","../gx/gx_displaylist":"gx\\gx_displaylist.ts","../Camera":"Camera.ts","gl-matrix":"..\\node_modules\\gl-matrix\\src\\gl-matrix.js"}],"metroid_prime\\strg.ts":[function(require,module,exports) {
"use strict";
// Implements Retro's STRG (string table resource group) format as seen in Metroid Prime 1.

Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("../util");
var utf16Decoder = new TextDecoder('utf-16be');
function readUTF16String(buffer, offs) {
    var arr = buffer.createTypedArray(Uint8Array, offs, 0xFF);
    var raw = utf16Decoder.decode(arr);
    var nul = raw.indexOf("\0");
    var str;
    if (nul >= 0) str = raw.slice(0, nul);else str = raw;
    return str;
}
function parse(resourceSystem, assetID, buffer) {
    var view = buffer.createDataView();
    util_1.assert(view.getUint32(0x00) === 0x87654321);
    var version = view.getUint32(0x04);
    util_1.assert(version === 0x00); // Metroid Prime 1
    var languageCount = view.getUint32(0x08);
    var stringCount = view.getUint32(0x0C);
    var languageTableOffs = 0x10;
    var stringsTableOffs = languageTableOffs + languageCount * 0x08;
    var languageTableIdx = languageTableOffs;
    var strings = [];
    for (var i = 0; i < languageCount; i++) {
        var languageID = util_1.readString(buffer, languageTableIdx + 0x00, 4, false);
        var languageStringsOffs = view.getUint32(languageTableIdx + 0x04);
        languageTableIdx += 0x08;
        // Load English for now because I am a dirty American.
        if (languageID === 'ENGL') {
            var stringTableIdx = stringsTableOffs + languageStringsOffs;
            var stringTableSize = view.getUint32(stringTableIdx + 0x00);
            stringTableIdx += 0x04;
            var stringTableDataOffs = stringTableIdx;
            for (var j = 0; j < stringCount; j++) {
                var stringOffs = view.getUint32(stringTableIdx);
                var string = readUTF16String(buffer, stringTableDataOffs + stringOffs);
                strings.push(string);
                stringTableIdx += 0x04;
            }
        }
    }
    return { strings: strings };
}
exports.parse = parse;
},{"../util":"util.ts"}],"metroid_prime\\txtr.ts":[function(require,module,exports) {
"use strict";
// Implements Retro's TXTR (texture) format as seen in Metroid Prime 1.

var __importStar = this && this.__importStar || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) {
        if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    }result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var GX = __importStar(require("../gx/gx_enum"));
var GX_Texture = __importStar(require("../gx/gx_texture"));
var txtrFormatRemap = [GX.TexFormat.I4, GX.TexFormat.I8, GX.TexFormat.IA4, GX.TexFormat.IA8, GX.TexFormat.C4, GX.TexFormat.C8, GX.TexFormat.C14X2, GX.TexFormat.RGB565, GX.TexFormat.RGB5A3, GX.TexFormat.RGBA8, GX.TexFormat.CMPR];
function parse(resourceSystem, assetID, buffer) {
    var view = buffer.createDataView();
    var txtrFormat = view.getUint32(0x00);
    var name = resourceSystem.findResourceNameByID(assetID);
    var format = txtrFormatRemap[txtrFormat];
    var width = view.getUint16(0x04);
    var height = view.getUint16(0x06);
    var mipCount = view.getUint32(0x08);
    var offs = 0x0C;
    var paletteFormat = 0;
    var paletteData = null;
    switch (format) {
        case GX.TexFormat.C4:
        case GX.TexFormat.C8:
            paletteFormat = view.getUint32(offs + 0x00);
            var palWidth = view.getUint32(offs + 0x04);
            var palHeight = view.getUint32(offs + 0x06);
            offs += 0x08;
            var palSize = GX_Texture.calcPaletteSize(format, paletteFormat);
            paletteData = buffer.slice(offs, offs + palSize);
            offs += palSize;
        case GX.TexFormat.C14X2:
            throw "whoops";
    }
    var data = buffer.slice(offs);
    return { name: name, format: format, width: width, height: height, mipCount: mipCount, data: data, paletteFormat: paletteFormat, paletteData: paletteData };
}
exports.parse = parse;
},{"../gx/gx_enum":"gx\\gx_enum.ts","../gx/gx_texture":"gx\\gx_texture.ts"}],"metroid_prime\\cmdl.ts":[function(require,module,exports) {
"use strict";
// Implements Retro's CMDL format as seen in Metroid Prime 1.

var __read = this && this.__read || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o),
        r,
        ar = [],
        e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {
            ar.push(r.value);
        }
    } catch (error) {
        e = { error: error };
    } finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
            if (e) throw e.error;
        }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("../util");
var mrea_1 = require("./mrea");
var Camera_1 = require("../Camera");
var Flags;
(function (Flags) {
    Flags[Flags["SKINNED"] = 1] = "SKINNED";
    Flags[Flags["NRM_SHORT"] = 2] = "NRM_SHORT";
    Flags[Flags["UV_SHORT"] = 4] = "UV_SHORT";
})(Flags || (Flags = {}));
function parse(resourceSystem, assetID, buffer) {
    var _a;
    var view = buffer.createDataView();
    util_1.assert(view.getUint32(0x00) === 0xDEADBABE);
    var version = view.getUint32(0x04);
    util_1.assert(version === 0x02);
    var flags = view.getUint32(0x08);
    var minX = view.getFloat32(0x0C);
    var minY = view.getFloat32(0x10);
    var minZ = view.getFloat32(0x14);
    var maxX = view.getFloat32(0x18);
    var maxY = view.getFloat32(0x1C);
    var maxZ = view.getFloat32(0x20);
    var bbox = new Camera_1.AABB(minX, minY, minZ, maxX, maxY, maxZ);
    var dataSectionCount = view.getUint32(0x24);
    var materialSetCount = view.getUint32(0x28);
    var dataSectionSizeTable = [];
    var dataSectionSizeTableIdx = 0x2C;
    for (var i = 0; i < dataSectionCount; i++) {
        var size = view.getUint32(dataSectionSizeTableIdx + 0x00);
        dataSectionSizeTable.push(size);
        dataSectionSizeTableIdx += 0x04;
    }
    var firstDataSectionOffs = util_1.align(dataSectionSizeTableIdx, 32);
    var dataSectionOffsTable = [firstDataSectionOffs];
    for (var i = 1; i < dataSectionCount; i++) {
        var prevOffs = dataSectionOffsTable[i - 1];
        var prevSize = dataSectionSizeTable[i - 1];
        dataSectionOffsTable.push(util_1.align(prevOffs + prevSize, 32));
    }
    var dataSectionIndex = 0;
    var materialSets = [];
    for (var i = 0; i < materialSetCount; i++) {
        var materialSet = mrea_1.parseMaterialSet(resourceSystem, buffer, dataSectionOffsTable[dataSectionIndex++]);
        materialSets.push(materialSet);
    }
    var hasUVShort = !!(flags & Flags.UV_SHORT);
    var geometry;
    _a = __read(mrea_1.parseGeometry(buffer, materialSets[0], dataSectionOffsTable, hasUVShort, dataSectionIndex++), 2), geometry = _a[0], dataSectionIndex = _a[1];
    return { bbox: bbox, materialSets: materialSets, geometry: geometry };
}
exports.parse = parse;
},{"../util":"util.ts","./mrea":"metroid_prime\\mrea.ts","../Camera":"Camera.ts"}],"metroid_prime\\resource.ts":[function(require,module,exports) {
"use strict";
// Resource System

var __values = this && this.__values || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator],
        i = 0;
    if (m) return m.call(o);
    return {
        next: function next() {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
var __importStar = this && this.__importStar || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) {
        if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    }result["default"] = mod;
    return result;
};
var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var Pako = __importStar(require("pako"));
var ArrayBufferSlice_1 = __importDefault(require("../ArrayBufferSlice"));
var util_1 = require("../util");
var MLVL = __importStar(require("./mlvl"));
var MREA = __importStar(require("./mrea"));
var STRG = __importStar(require("./strg"));
var TXTR = __importStar(require("./txtr"));
var CMDL = __importStar(require("./cmdl"));
var FourCCLoaders = {
    'MLVL': MLVL.parse,
    'MREA': MREA.parse,
    'STRG': STRG.parse,
    'TXTR': TXTR.parse,
    'CMDL': CMDL.parse
};
function hexName(id) {
    var S = '';
    for (var i = 0; i < id.length; i++) {
        S += util_1.hexzero(id.charCodeAt(i), 2).toUpperCase();
    }return S;
}
var ResourceSystem = /** @class */function () {
    function ResourceSystem(paks, nameData) {
        this.paks = paks;
        this.nameData = nameData;
        this._cache = new Map();
    }
    ResourceSystem.prototype.loadResourceBuffer = function (resource) {
        if (resource.isCompressed) {
            var deflated = resource.buffer.createTypedArray(Uint8Array);
            var inflated = Pako.inflate(deflated);
            return new ArrayBufferSlice_1.default(inflated.buffer);
        } else {
            return resource.buffer;
        }
    };
    ResourceSystem.prototype.findResourceNameByID = function (assetID) {
        var assetIDHex = hexName(assetID);
        util_1.assert(assetIDHex.length === 8);
        var nameDataAsset = this.nameData.Assets[assetIDHex];
        if (nameDataAsset) return nameDataAsset.Filename;else return assetIDHex;
    };
    ResourceSystem.prototype.findResourceByID = function (assetID) {
        var e_1, _a;
        util_1.assert(assetID.length === 4);
        try {
            for (var _b = __values(this.paks), _c = _b.next(); !_c.done; _c = _b.next()) {
                var pak = _c.value;
                var resource = pak.resourceTable.get(assetID);
                if (resource) return resource;
            }
        } catch (e_1_1) {
            e_1 = { error: e_1_1 };
        } finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally {
                if (e_1) throw e_1.error;
            }
        }
        return null;
    };
    ResourceSystem.prototype.loadAssetByID = function (assetID, fourCC) {
        if (assetID === '\xFF\xFF\xFF\xFF') return null;
        var cached = this._cache.get(assetID);
        if (cached !== undefined) return cached;
        var loaderFunc = FourCCLoaders[fourCC];
        if (!loaderFunc) return null;
        var resource = this.findResourceByID(assetID);
        util_1.assert(resource.fourCC === fourCC);
        var buffer = this.loadResourceBuffer(resource);
        var inst = loaderFunc(this, assetID, buffer);
        this._cache.set(assetID, inst);
        return inst;
    };
    return ResourceSystem;
}();
exports.ResourceSystem = ResourceSystem;
},{"pako":"..\\node_modules\\pako\\index.js","../ArrayBufferSlice":"ArrayBufferSlice.ts","../util":"util.ts","./mlvl":"metroid_prime\\mlvl.ts","./mrea":"metroid_prime\\mrea.ts","./strg":"metroid_prime\\strg.ts","./txtr":"metroid_prime\\txtr.ts","./cmdl":"metroid_prime\\cmdl.ts"}],"metroid_prime\\render.ts":[function(require,module,exports) {
"use strict";

var __extends = this && this.__extends || function () {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
        d.__proto__ = b;
    } || function (d, b) {
        for (var p in b) {
            if (b.hasOwnProperty(p)) d[p] = b[p];
        }
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
};
var __importStar = this && this.__importStar || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) {
        if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    }result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var gl_matrix_1 = require("gl-matrix");
var ArrayBufferSlice_1 = __importDefault(require("../ArrayBufferSlice"));
var util_1 = require("../util");
var gx_render_1 = require("../gx/gx_render");
var mrea_1 = require("./mrea");
var GX_Material = __importStar(require("../gx/gx_material"));
var BufferCoalescer_1 = __importDefault(require("../BufferCoalescer"));
var Camera_1 = require("../Camera");
var fixPrimeUsingTheWrongConventionYesIKnowItsFromMayaButMayaIsStillWrong = gl_matrix_1.mat4.fromValues(1, 0, 0, 0, 0, 0, -1, 0, 0, 1, 0, 0, 0, 0, 0, 1);
// Cheap way to scale up.
var posScale = 10;
var posMtx = gl_matrix_1.mat4.create();
gl_matrix_1.mat4.multiplyScalar(posMtx, fixPrimeUsingTheWrongConventionYesIKnowItsFromMayaButMayaIsStillWrong, posScale);
posMtx[15] = 1;
var RetroTextureHolder = /** @class */function (_super) {
    __extends(RetroTextureHolder, _super);
    function RetroTextureHolder() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    RetroTextureHolder.prototype.addMaterialSetTextures = function (gl, materialSet) {
        this.addTextures(gl, materialSet.textures);
    };
    return RetroTextureHolder;
}(gx_render_1.TextureHolder);
exports.RetroTextureHolder = RetroTextureHolder;
var textureMappingScratch = util_1.nArray(8, function () {
    return new gx_render_1.TextureMapping();
});
var MREARenderer = /** @class */function () {
    function MREARenderer(gl, textureHolder, name, mrea) {
        this.textureHolder = textureHolder;
        this.name = name;
        this.mrea = mrea;
        this.textures = [];
        this.materialCommands = [];
        this.opaqueCommands = [];
        this.transparentCommands = [];
        this.sceneParams = new gx_render_1.SceneParams();
        this.packetParams = new gx_render_1.PacketParams();
        this.bboxScratch = new Camera_1.AABB();
        this.visible = true;
        this.renderHelper = new gx_render_1.GXRenderHelper(gl);
        this.translateModel(gl);
    }
    MREARenderer.prototype.translateModel = function (gl) {
        var _this = this;
        var materialSet = this.mrea.materialSet;
        this.textureHolder.addMaterialSetTextures(gl, materialSet);
        // Pull out the first material of each group, which should be identical except for textures.
        var groupMaterials = [];
        for (var i = 0; i < materialSet.materials.length; i++) {
            var material = materialSet.materials[i];
            if (!groupMaterials[material.groupIndex]) groupMaterials[material.groupIndex] = material;
        }
        this.materialCommands = groupMaterials.map(function (material) {
            return new Command_Material(material);
        });
        var vertexDatas = [];
        var indexDatas = [];
        // Coalesce surface data.
        this.mrea.worldModels.forEach(function (worldModel) {
            worldModel.geometry.surfaces.forEach(function (surface) {
                vertexDatas.push(new ArrayBufferSlice_1.default(surface.loadedVertexData.packedVertexData));
                indexDatas.push(new ArrayBufferSlice_1.default(surface.loadedVertexData.indexData));
            });
        });
        this.bufferCoalescer = new BufferCoalescer_1.default(gl, vertexDatas, indexDatas);
        var bufferIndex = 0;
        this.mrea.worldModels.forEach(function (worldModel, modelIndex) {
            worldModel.geometry.surfaces.forEach(function (surface) {
                var material = materialSet.materials[surface.materialIndex];
                var coalescedBuffers = _this.bufferCoalescer.coalescedBuffers[bufferIndex++];
                if (material.flags & mrea_1.MaterialFlags.OCCLUDER) return;
                var surfaceCommand = new Command_Surface(gl, surface, coalescedBuffers, modelIndex);
                if (material.flags & mrea_1.MaterialFlags.IS_TRANSPARENT) _this.transparentCommands.push(surfaceCommand);else _this.opaqueCommands.push(surfaceCommand);
            });
        });
    };
    MREARenderer.prototype.setVisible = function (visible) {
        this.visible = visible;
    };
    MREARenderer.prototype.render = function (state) {
        if (!this.visible) return;
        state.setClipPlanes(2, 7500);
        this.renderHelper.bindUniformBuffers(state);
        gx_render_1.fillSceneParamsFromRenderState(this.sceneParams, state);
        this.renderHelper.bindSceneParams(state, this.sceneParams);
        this.computeModelView(this.packetParams.u_PosMtx[0], state);
        this.renderHelper.bindPacketParams(state, this.packetParams);
        // Frustum cull.
        var bbox = this.bboxScratch;
        var modelVisibility = [];
        this.mrea.worldModels.forEach(function (worldModel, i) {
            bbox.transform(worldModel.bbox, posMtx);
            modelVisibility[i] = state.camera.frustum.intersect(bbox) !== Camera_1.IntersectionState.FULLY_OUTSIDE;
        });
        this.execSurfaceCommandList(state, this.opaqueCommands, modelVisibility);
        this.execSurfaceCommandList(state, this.transparentCommands, modelVisibility);
    };
    MREARenderer.prototype.destroy = function (gl) {
        this.materialCommands.forEach(function (cmd) {
            return cmd.destroy(gl);
        });
        this.opaqueCommands.forEach(function (cmd) {
            return cmd.destroy(gl);
        });
        this.transparentCommands.forEach(function (cmd) {
            return cmd.destroy(gl);
        });
        this.bufferCoalescer.destroy(gl);
    };
    MREARenderer.prototype.execSurfaceCommandList = function (state, cmdList, modelVisibility) {
        var currentMaterialIndex = -1;
        var currentGroupIndex = -1;
        for (var i = 0; i < cmdList.length; i++) {
            var surfaceCmd = cmdList[i];
            if (!modelVisibility[surfaceCmd.modelIndex]) continue;
            var materialIndex = surfaceCmd.surface.materialIndex;
            var material = this.mrea.materialSet.materials[materialIndex];
            if (currentMaterialIndex !== materialIndex) {
                var groupIndex = material.groupIndex;
                var materialCommand = this.materialCommands[groupIndex];
                if (groupIndex !== currentGroupIndex) {
                    materialCommand.exec(state, null, false, this.renderHelper);
                    currentGroupIndex = groupIndex;
                }
                this.bindTextures(state, material, materialCommand.program);
                currentMaterialIndex = materialIndex;
            }
            surfaceCmd.exec(state);
        }
    };
    MREARenderer.prototype.fillTextureMapping = function (textureMapping, material) {
        for (var i = 0; i < material.textureIndexes.length; i++) {
            var textureIndex = material.textureIndexes[i];
            if (textureIndex === -1) continue;
            var materialSet = this.mrea.materialSet;
            var txtr = materialSet.textures[materialSet.textureRemapTable[textureIndex]];
            this.textureHolder.fillTextureMapping(textureMapping[i], txtr.name);
        }
    };
    MREARenderer.prototype.bindTextures = function (state, material, program) {
        this.fillTextureMapping(textureMappingScratch, material);
        this.renderHelper.bindMaterialTextureMapping(state, textureMappingScratch, program);
    };
    MREARenderer.prototype.computeModelView = function (dst, state) {
        gl_matrix_1.mat4.copy(dst, state.updateModelView(false, posMtx));
    };
    return MREARenderer;
}();
exports.MREARenderer = MREARenderer;
// TODO(jstpierre): Dedupe.
var CMDLRenderer = /** @class */function () {
    function CMDLRenderer(gl, textureHolder, name, cmdl) {
        this.textureHolder = textureHolder;
        this.name = name;
        this.cmdl = cmdl;
        this.textures = [];
        this.materialCommands = [];
        this.surfaceCommands = [];
        this.sceneParams = new gx_render_1.SceneParams();
        this.packetParams = new gx_render_1.PacketParams();
        this.bboxScratch = new Camera_1.AABB();
        this.modelMatrix = gl_matrix_1.mat4.create();
        this.visible = true;
        this.isSkybox = false;
        this.renderHelper = new gx_render_1.GXRenderHelper(gl);
        this.translateModel(gl);
    }
    CMDLRenderer.prototype.translateModel = function (gl) {
        var _this = this;
        var materialSet = this.cmdl.materialSets[0];
        this.textureHolder.addMaterialSetTextures(gl, materialSet);
        // Pull out the first material of each group, which should be identical except for textures.
        var groupMaterials = [];
        for (var i_1 = 0; i_1 < materialSet.materials.length; i_1++) {
            var material = materialSet.materials[i_1];
            if (!groupMaterials[material.groupIndex]) groupMaterials[material.groupIndex] = material;
        }
        this.materialCommands = groupMaterials.map(function (material) {
            return new Command_Material(material);
        });
        var vertexDatas = [];
        var indexDatas = [];
        // Coalesce surface data.
        this.cmdl.geometry.surfaces.forEach(function (surface) {
            vertexDatas.push(new ArrayBufferSlice_1.default(surface.loadedVertexData.packedVertexData));
            indexDatas.push(new ArrayBufferSlice_1.default(surface.loadedVertexData.indexData));
        });
        this.bufferCoalescer = new BufferCoalescer_1.default(gl, vertexDatas, indexDatas);
        var i = 0;
        this.cmdl.geometry.surfaces.forEach(function (surface) {
            _this.surfaceCommands.push(new Command_Surface(gl, surface, _this.bufferCoalescer.coalescedBuffers[i]));
            ++i;
        });
    };
    CMDLRenderer.prototype.setVisible = function (visible) {
        this.visible = visible;
    };
    CMDLRenderer.prototype.render = function (state) {
        if (!this.visible) return;
        this.renderHelper.bindUniformBuffers(state);
        gx_render_1.fillSceneParamsFromRenderState(this.sceneParams, state);
        this.renderHelper.bindSceneParams(state, this.sceneParams);
        this.computeModelView(this.packetParams.u_PosMtx[0], state);
        this.renderHelper.bindPacketParams(state, this.packetParams);
        var currentMaterialIndex = -1;
        var currentGroupIndex = -1;
        var surfaceCmdIndex = 0;
        var bbox = this.bboxScratch;
        var numSurfaces = this.cmdl.geometry.surfaces.length;
        var materialSet = this.cmdl.materialSets[0];
        // Frustum cull.
        if (!this.isSkybox) {
            bbox.transform(this.cmdl.bbox, posMtx);
            if (state.camera.frustum.intersect(bbox) === Camera_1.IntersectionState.FULLY_OUTSIDE) return;
        }
        for (var i = 0; i < numSurfaces; i++) {
            var surfaceCmd = this.surfaceCommands[surfaceCmdIndex++];
            var materialIndex = surfaceCmd.surface.materialIndex;
            var material = materialSet.materials[materialIndex];
            // Don't render occluder meshes.
            if (material.flags & mrea_1.MaterialFlags.OCCLUDER) continue;
            if (currentMaterialIndex !== materialIndex) {
                var groupIndex = materialSet.materials[materialIndex].groupIndex;
                var materialCommand = this.materialCommands[groupIndex];
                if (groupIndex !== currentGroupIndex) {
                    materialCommand.exec(state, this.modelMatrix, this.isSkybox, this.renderHelper);
                    currentGroupIndex = groupIndex;
                }
                this.bindTextures(state, material, materialCommand.program);
                currentMaterialIndex = materialIndex;
            }
            surfaceCmd.exec(state);
        }
    };
    CMDLRenderer.prototype.destroy = function (gl) {
        this.materialCommands.forEach(function (cmd) {
            return cmd.destroy(gl);
        });
        this.surfaceCommands.forEach(function (cmd) {
            return cmd.destroy(gl);
        });
        this.bufferCoalescer.destroy(gl);
    };
    CMDLRenderer.prototype.fillTextureMapping = function (textureMapping, material) {
        for (var i = 0; i < material.textureIndexes.length; i++) {
            var textureIndex = material.textureIndexes[i];
            if (textureIndex === -1) continue;
            var materialSet = this.cmdl.materialSets[0];
            var txtr = materialSet.textures[materialSet.textureRemapTable[textureIndex]];
            this.textureHolder.fillTextureMapping(textureMapping[i], txtr.name);
        }
    };
    CMDLRenderer.prototype.bindTextures = function (state, material, program) {
        this.fillTextureMapping(textureMappingScratch, material);
        this.renderHelper.bindMaterialTextureMapping(state, textureMappingScratch, program);
    };
    CMDLRenderer.prototype.computeModelView = function (dst, state) {
        gl_matrix_1.mat4.copy(dst, state.updateModelView(this.isSkybox, posMtx));
    };
    return CMDLRenderer;
}();
exports.CMDLRenderer = CMDLRenderer;
var Command_Surface = /** @class */function () {
    function Command_Surface(gl, surface, coalescedBuffers, modelIndex) {
        if (modelIndex === void 0) {
            modelIndex = 0;
        }
        this.surface = surface;
        this.modelIndex = modelIndex;
        this.shapeHelper = new gx_render_1.GXShapeHelper(gl, coalescedBuffers, surface.loadedVertexLayout, surface.loadedVertexData);
    }
    Command_Surface.prototype.exec = function (state) {
        var gl = state.gl;
        this.shapeHelper.drawSimple(gl);
        state.drawCallCount++;
    };
    Command_Surface.prototype.destroy = function (gl) {
        this.shapeHelper.destroy(gl);
    };
    return Command_Surface;
}();
var Command_Material = /** @class */function () {
    function Command_Material(material) {
        this.material = material;
        this.materialParams = new gx_render_1.MaterialParams();
        this.program = new GX_Material.GX_Program(this.material.gxMaterial);
        this.renderFlags = GX_Material.translateRenderFlags(this.material.gxMaterial);
    }
    Command_Material.prototype.exec = function (state, modelMatrix, isSkybox, renderHelper) {
        state.useProgram(this.program);
        state.useFlags(this.renderFlags);
        this.fillMaterialParamsData(state, modelMatrix, isSkybox, this.materialParams);
        renderHelper.bindMaterialParams(state, this.materialParams);
    };
    Command_Material.prototype.destroy = function (gl) {
        this.program.destroy(gl);
    };
    Command_Material.prototype.fillMaterialParamsData = function (state, modelMatrix, isSkybox, materialParams) {
        materialParams.u_ColorMatReg[0].set(1, 1, 1, 1);
        if (isSkybox) materialParams.u_ColorAmbReg[0].set(1, 1, 1, 1);else materialParams.u_ColorMatReg[0].set(0, 0, 0, 1);
        for (var i = 0; i < 4; i++) {
            materialParams.u_Color[i].copy(this.material.gxMaterial.colorRegisters[i]);
        }for (var i = 0; i < 4; i++) {
            materialParams.u_KonstColor[i].copy(this.material.gxMaterial.colorConstants[i]);
        }var animTime = state.time / 1000 % 900;
        for (var i = 0; i < this.material.uvAnimations.length; i++) {
            var uvAnimation = this.material.uvAnimations[i];
            var texMtx = materialParams.u_TexMtx[i];
            var postMtx = materialParams.u_PostTexMtx[i];
            switch (uvAnimation.type) {
                case mrea_1.UVAnimationType.UV_SCROLL:
                    {
                        var transS = animTime * uvAnimation.scaleS + uvAnimation.offsetS;
                        var transT = animTime * uvAnimation.scaleT + uvAnimation.offsetT;
                        texMtx[12] = transS;
                        texMtx[13] = transT;
                        break;
                    }
                case mrea_1.UVAnimationType.ROTATION:
                    {
                        var theta = animTime * uvAnimation.scale + uvAnimation.offset;
                        var cosR = Math.cos(theta);
                        var sinR = Math.sin(theta);
                        texMtx[0] = cosR;
                        texMtx[4] = sinR;
                        texMtx[12] = (1.0 - (cosR - sinR)) * 0.5;
                        texMtx[1] = -sinR;
                        texMtx[5] = cosR;
                        texMtx[13] = (1.0 - (sinR + cosR)) * 0.5;
                        break;
                    }
                case mrea_1.UVAnimationType.FLIPBOOK_U:
                    {
                        var n = uvAnimation.step * uvAnimation.scale * (uvAnimation.offset + animTime);
                        var trans = Math.floor(uvAnimation.numFrames * (n % 1.0)) * uvAnimation.step;
                        texMtx[12] = trans;
                        break;
                    }
                case mrea_1.UVAnimationType.FLIPBOOK_V:
                    {
                        var n = uvAnimation.step * uvAnimation.scale * (uvAnimation.offset + animTime);
                        var trans = Math.floor(uvAnimation.numFrames * (n % 1.0)) * uvAnimation.step;
                        texMtx[13] = trans;
                        break;
                    }
                case mrea_1.UVAnimationType.INV_MAT_SKY:
                    gl_matrix_1.mat4.invert(texMtx, state.view);
                    if (modelMatrix !== null) gl_matrix_1.mat4.mul(texMtx, texMtx, modelMatrix);
                    texMtx[12] = 0;
                    texMtx[13] = 0;
                    texMtx[14] = 0;
                    Camera_1.texEnvMtx(postMtx, 0.5, -0.5, 0.5, 0.5);
                    break;
                case mrea_1.UVAnimationType.INV_MAT:
                    gl_matrix_1.mat4.invert(texMtx, state.view);
                    if (modelMatrix !== null) gl_matrix_1.mat4.mul(texMtx, texMtx, modelMatrix);
                    Camera_1.texEnvMtx(postMtx, 0.5, -0.5, 0.5, 0.5);
                    break;
                case mrea_1.UVAnimationType.MODEL_MAT:
                    if (modelMatrix !== null) gl_matrix_1.mat4.copy(texMtx, modelMatrix);else gl_matrix_1.mat4.identity(texMtx);
                    texMtx[12] = 0;
                    texMtx[13] = 0;
                    texMtx[14] = 0;
                    Camera_1.texEnvMtx(postMtx, 0.5, -0.5, modelMatrix[12] * 0.5, modelMatrix[13] * 0.5);
                    break;
                case mrea_1.UVAnimationType.CYLINDER:
                    {
                        gl_matrix_1.mat4.copy(texMtx, state.view);
                        if (modelMatrix !== null) gl_matrix_1.mat4.mul(texMtx, texMtx, modelMatrix);
                        texMtx[12] = 0;
                        texMtx[13] = 0;
                        texMtx[14] = 0;
                        var xy = (state.view[12] + state.view[13]) * 0.025 * uvAnimation.phi % 1.0;
                        var z = state.view[14] * 0.05 * uvAnimation.phi % 1.0;
                        var a = uvAnimation.theta * 0.5;
                        Camera_1.texEnvMtx(postMtx, a, -a, xy, z);
                        break;
                    }
            }
        }
    };
    return Command_Material;
}();
},{"gl-matrix":"..\\node_modules\\gl-matrix\\src\\gl-matrix.js","../ArrayBufferSlice":"ArrayBufferSlice.ts","../util":"util.ts","../gx/gx_render":"gx\\gx_render.ts","./mrea":"metroid_prime\\mrea.ts","../gx/gx_material":"gx\\gx_material.ts","../BufferCoalescer":"BufferCoalescer.ts","../Camera":"Camera.ts"}],"metroid_prime\\scenes.ts":[function(require,module,exports) {
"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var __values = this && this.__values || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator],
        i = 0;
    if (m) return m.call(o);
    return {
        next: function next() {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
var __importStar = this && this.__importStar || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) {
        if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    }result["default"] = mod;
    return result;
};
var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var PAK = __importStar(require("./pak"));
var resource_1 = require("./resource");
var render_1 = require("./render");
var UI = __importStar(require("../ui"));
var util_1 = require("../util");
var Progressable_1 = __importDefault(require("../Progressable"));
var render_2 = require("../render");
var BYML = __importStar(require("../byml"));
// PAK Files are too big for GitHub.
function findPakBase() {
    if (document.location.protocol === 'file:') {
        return "data/metroid_prime/mp1/";
    } else {
        return "https://funny.computer/cloud/MetroidPrime1/";
    }
}
var pakBase = findPakBase();
var MetroidPrimeWorldScene = /** @class */function () {
    function MetroidPrimeWorldScene(mlvl, textureHolder, skyboxRenderer, areaRenderers) {
        this.mlvl = mlvl;
        this.textureHolder = textureHolder;
        this.skyboxRenderer = skyboxRenderer;
        this.areaRenderers = areaRenderers;
        this.textures = textureHolder.viewerTextures;
    }
    MetroidPrimeWorldScene.prototype.createPanels = function () {
        var layersPanel = new UI.LayerPanel();
        layersPanel.setLayers(this.areaRenderers);
        return [layersPanel];
    };
    MetroidPrimeWorldScene.prototype.render = function (state) {
        var gl = state.gl;
        if (this.skyboxRenderer) this.skyboxRenderer.render(state);
        state.useFlags(render_2.depthClearFlags);
        gl.clear(gl.DEPTH_BUFFER_BIT);
        this.areaRenderers.forEach(function (areaRenderer) {
            areaRenderer.render(state);
        });
    };
    MetroidPrimeWorldScene.prototype.destroy = function (gl) {
        this.textureHolder.destroy(gl);
        if (this.skyboxRenderer) this.skyboxRenderer.destroy(gl);
        this.areaRenderers.forEach(function (areaRenderer) {
            return areaRenderer.destroy(gl);
        });
    };
    return MetroidPrimeWorldScene;
}();
exports.MetroidPrimeWorldScene = MetroidPrimeWorldScene;
var MP1SceneDesc = /** @class */function () {
    function MP1SceneDesc(filename, name) {
        this.filename = filename;
        this.name = name;
        this.id = filename;
    }
    MP1SceneDesc.prototype.createScene = function (gl) {
        var stringsPakP = util_1.fetch(pakBase + "/Strings.pak");
        var levelPakP = util_1.fetch(pakBase + "/" + this.filename);
        var nameDataP = util_1.fetch("data/metroid_prime/mp1/MP1_NameData.crg1");
        return Progressable_1.default.all([levelPakP, stringsPakP, nameDataP]).then(function (datas) {
            var e_1, _a;
            var levelPak = PAK.parse(datas[0]);
            var stringsPak = PAK.parse(datas[1]);
            var nameData = BYML.parse(datas[2], BYML.FileType.CRG1);
            var resourceSystem = new resource_1.ResourceSystem([levelPak, stringsPak], nameData);
            var _loop_1 = function _loop_1(mlvlEntry) {
                util_1.assert(mlvlEntry.fourCC === 'MLVL');
                var mlvl = resourceSystem.loadAssetByID(mlvlEntry.fileID, mlvlEntry.fourCC);
                var areas = mlvl.areaTable;
                var textureHolder = new render_1.RetroTextureHolder();
                var skyboxRenderer = null;
                var skyboxCMDL = resourceSystem.loadAssetByID(mlvl.defaultSkyboxID, 'CMDL');
                if (skyboxCMDL) {
                    var skyboxName = resourceSystem.findResourceNameByID(mlvl.defaultSkyboxID);
                    skyboxRenderer = new render_1.CMDLRenderer(gl, textureHolder, skyboxName, skyboxCMDL);
                    skyboxRenderer.isSkybox = true;
                }
                var areaRenderers = areas.map(function (mreaEntry) {
                    var mrea = resourceSystem.loadAssetByID(mreaEntry.areaMREAID, 'MREA');
                    return new render_1.MREARenderer(gl, textureHolder, mreaEntry.areaName, mrea);
                });
                // By default, set only the first 10 area renderers to visible, so as to not "crash my browser please".
                areaRenderers.slice(10).forEach(function (areaRenderer) {
                    areaRenderer.visible = false;
                });
                return { value: new MetroidPrimeWorldScene(mlvl, textureHolder, skyboxRenderer, areaRenderers) };
            };
            try {
                for (var _b = __values(levelPak.namedResourceTable.values()), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var mlvlEntry = _c.value;
                    var state_1 = _loop_1(mlvlEntry);
                    if ((typeof state_1 === "undefined" ? "undefined" : _typeof(state_1)) === "object") return state_1.value;
                }
            } catch (e_1_1) {
                e_1 = { error: e_1_1 };
            } finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                } finally {
                    if (e_1) throw e_1.error;
                }
            }
            return null;
        });
    };
    return MP1SceneDesc;
}();
var id = "mp1";
var name = "Metroid Prime 1";
var sceneDescs = [new MP1SceneDesc("Metroid1.pak", "Space Pirate Frigate"), new MP1SceneDesc("Metroid2.pak", "Chozo Ruins"), new MP1SceneDesc("Metroid3.pak", "Phendrana Drifts"), new MP1SceneDesc("Metroid4.pak", "Tallon Overworld"), new MP1SceneDesc("Metroid5.pak", "Phazon Mines"), new MP1SceneDesc("Metroid6.pak", "Magmoor Caverns"), new MP1SceneDesc("Metroid7.pak", "Impact Crater")];
exports.sceneGroup = { id: id, name: name, sceneDescs: sceneDescs };
},{"./pak":"metroid_prime\\pak.ts","./resource":"metroid_prime\\resource.ts","./render":"metroid_prime\\render.ts","../ui":"ui.ts","../util":"util.ts","../Progressable":"Progressable.ts","../render":"render.ts","../byml":"byml.ts"}],"compression\\Yay0.ts":[function(require,module,exports) {
"use strict";
// Nintendo Yay0 format.
//
// Similar to Yaz0 (an earlier version, likely), except it packs compressed data
// into three separate substreams.
//
// Header (16 bytes):
//   Magic: "Yay0" (4 bytes)
//   Uncompressed size (4 bytes, big endian)
//   Offset to Lengths substream (4 bytes, big endian)
//   Offset to Data substream (4 bytes, big endian)
//
// Flags substream starts at 0x10 (directly after Header)
//
// Data:
//   Read Flags from Flags substream (1 byte)
//   For each bit in the Flags byte, from MSB to LSB:
//     If flag is 1:
//       Literal: copy one byte from Data substream to dest.
//     If flag is 0:
//       Read LZ77 from Lengths substream (2 bytes, big endian):
//         Length: bits 0-4
//           If Length = 0, then read additional byte from Data (not Lengths!) substream, add 16, and add it to Length.
//         Offset: bits 5-15
//         Copy Length+2 bytes from Offset back in the output buffer.

var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("../util");
var ArrayBufferSlice_1 = __importDefault(require("../ArrayBufferSlice"));
function decompress(srcBuffer) {
    var srcView = srcBuffer.createDataView();
    util_1.assert(util_1.readString(srcBuffer, 0x00, 0x04) === 'Yay0');
    var uncompressedSize = srcView.getUint32(0x04, false);
    var lengthsOffs = srcView.getUint32(0x08, false);
    var dataOffs = srcView.getUint32(0x0C, false);
    var flagsOffs = 0x10;
    var dstBuffer = new Uint8Array(uncompressedSize);
    var dstOffs = 0x00;
    while (true) {
        var commandByte = srcView.getUint8(flagsOffs++);
        var i = 8;
        while (i--) {
            if (commandByte & 1 << i) {
                // Literal.
                uncompressedSize--;
                dstBuffer[dstOffs++] = srcView.getUint8(dataOffs++);
            } else {
                var tmp = srcView.getUint16(lengthsOffs, false);
                lengthsOffs += 2;
                var windowOffset = (tmp & 0x0FFF) + 1;
                var windowLength = (tmp >> 12) + 2;
                if (windowLength === 2) {
                    windowLength += srcView.getUint8(dataOffs++) + 0x10;
                }
                util_1.assert(windowLength >= 3 && windowLength <= 0x111);
                var copyOffs = dstOffs - windowOffset;
                uncompressedSize -= windowLength;
                while (windowLength--) {
                    dstBuffer[dstOffs++] = dstBuffer[copyOffs++];
                }
            }
            if (uncompressedSize <= 0) return new ArrayBufferSlice_1.default(dstBuffer.buffer);
        }
    }
}
exports.decompress = decompress;
},{"../util":"util.ts","../ArrayBufferSlice":"ArrayBufferSlice.ts"}],"luigis_mansion\\bin.ts":[function(require,module,exports) {
"use strict";

var __importStar = this && this.__importStar || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) {
        if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    }result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("../util");
var gl_matrix_1 = require("gl-matrix");
var GX = __importStar(require("../gx/gx_enum"));
var gx_displaylist_1 = require("../gx/gx_displaylist");
var GX_Material = __importStar(require("../gx/gx_material"));
var Camera_1 = require("../Camera");
function parse(buffer) {
    var view = buffer.createDataView();
    var version = view.getUint8(0x00);
    util_1.assert(version === 0x01 || version === 0x02);
    var name = util_1.readString(buffer, 0x01, 0x0B);
    var textureChunkOffs = view.getUint32(0x0C, false);
    var samplerChunkOffs = view.getUint32(0x10, false);
    var materialChunkOffs = view.getUint32(0x34, false);
    var batchChunkOffs = view.getUint32(0x38, false);
    var sceneGraphChunkOffs = view.getUint32(0x3C, false);
    var positionBufferOffs = view.getUint32(0x14, false);
    var tex0BufferOffs = view.getUint32(0x24, false);
    function parseTexture(index) {
        var offs = textureChunkOffs + 0x0C * index;
        var width = view.getUint16(offs + 0x00, false);
        var height = view.getUint16(offs + 0x02, false);
        var format = view.getUint8(offs + 0x04);
        var textureDataOffs = view.getUint32(offs + 0x08, false);
        var data = buffer.slice(textureChunkOffs + textureDataOffs);
        return { width: width, height: height, format: format, data: data };
    }
    function parseSampler(index) {
        var offs = samplerChunkOffs + 0x14 * index;
        var textureIndex = view.getUint16(offs + 0x00);
        var texture = parseTexture(textureIndex);
        var wrapS = view.getUint8(offs + 0x04);
        var wrapT = view.getUint8(offs + 0x04);
        return { texture: texture, wrapS: wrapS, wrapT: wrapT };
    }
    var samplers = [];
    function ensureSampler(index) {
        if (!samplers[index]) samplers[index] = parseSampler(index);
    }
    function parseBatch(index) {
        var offs = batchChunkOffs + 0x18 * index;
        // Not used in-game.
        var triangleCount = view.getUint16(offs + 0x00, false);
        var displayListSize = view.getUint16(offs + 0x02, false) * 0x20;
        var attributes = view.getUint32(offs + 0x04, false);
        // WTF. Shouldn't this be in the material?
        var bumpMap = view.getUint8(offs + 0x08);
        var cullMode = view.getUint8(offs + 0x09);
        var texGenCount = view.getUint8(offs + 0x0A);
        var nbt3 = view.getUint8(offs + 0x0B);
        var displayListOffset = batchChunkOffs + view.getUint32(offs + 0x0C, false);
        var vat = [];
        // Should always have position.
        util_1.assert((attributes & 1 << GX.VertexAttribute.POS) !== 0);
        vat[GX.VertexAttribute.POS] = { compCnt: GX.CompCnt.POS_XYZ, compType: GX.CompType.S16, compShift: 0 };
        // Should always have tex0.
        if (!(attributes & 1 << GX.VertexAttribute.TEX0)) {
            // If we don't have TEX0, then skip this batch...
            console.warn("Batch " + index + " does not have TEX0. WTF? / Attributes: " + attributes.toString(16));
            return null;
        }
        vat[GX.VertexAttribute.TEX0] = { compCnt: GX.CompCnt.TEX_ST, compType: GX.CompType.F32, compShift: 0 };
        vat[GX.VertexAttribute.NRM] = { compCnt: nbt3 ? GX.CompCnt.NRM_NBT3 : GX.CompCnt.NRM_NBT, compType: GX.CompType.F32, compShift: 0 };
        // Set up our input vertex description.
        var vcd = [];
        for (var i = 0; i < GX.VertexAttribute.MAX; i++) {
            if ((attributes & 1 << i) !== 0) {
                // Only care about TEX0 and POS for now...
                var enableOutput = i === GX.VertexAttribute.POS || i === GX.VertexAttribute.TEX0;
                vcd[i] = { type: GX.AttrType.INDEX16, enableOutput: enableOutput };
            }
        }
        var vtxLoader = gx_displaylist_1.compileVtxLoader(vat, vcd);
        var loadedVertexLayout = vtxLoader.loadedVertexLayout;
        var displayListBuffer = buffer.subarray(displayListOffset, displayListSize);
        var vtxArrays = [];
        vtxArrays[GX.VertexAttribute.POS] = { buffer: buffer, offs: positionBufferOffs };
        vtxArrays[GX.VertexAttribute.TEX0] = { buffer: buffer, offs: tex0BufferOffs };
        var loadedVertexData;
        try {
            loadedVertexData = vtxLoader.runVertices(vtxArrays, displayListBuffer);
        } catch (e) {
            // Could not parse batch.
            console.warn("Batch " + index + " had parse error: " + e + " / Attributes: " + attributes.toString(16));
            return null;
        }
        return { vat: vat, loadedVertexLayout: loadedVertexLayout, loadedVertexData: loadedVertexData };
    }
    function parseMaterial(index) {
        var offs = materialChunkOffs + 0x28 * index;
        // TODO(jstpierre): diffuse color
        var samplerIndexes = [];
        for (var i = 0; i < 8; i++) {
            var samplerIndex = view.getInt16(offs + 0x08 + i * 0x02, false);
            samplerIndexes.push(samplerIndex);
            if (samplerIndex >= 0) ensureSampler(samplerIndex);
        }
        // Fake a GX material.
        var texGen0 = {
            index: 0,
            type: GX.TexGenType.MTX2x4,
            source: GX.TexGenSrc.TEX0,
            matrix: GX.TexGenMatrix.IDENTITY,
            normalize: false,
            postMatrix: GX.PostTexGenMatrix.PTIDENTITY
        };
        var texGens = [texGen0];
        var colorRegisters = [];
        colorRegisters.push(new GX_Material.Color(0, 0, 0, 0));
        colorRegisters.push(new GX_Material.Color(0, 0, 0, 0));
        colorRegisters.push(new GX_Material.Color(0, 0, 0, 0));
        colorRegisters.push(new GX_Material.Color(0, 0, 0, 0));
        var lightChannel0 = {
            alphaChannel: { lightingEnabled: false, ambColorSource: GX.ColorSrc.VTX, matColorSource: GX.ColorSrc.VTX },
            colorChannel: { lightingEnabled: false, ambColorSource: GX.ColorSrc.VTX, matColorSource: GX.ColorSrc.VTX }
        };
        var lightChannels = [lightChannel0, lightChannel0];
        var tevStage0 = {
            index: 0,
            channelId: GX.RasColorChannelID.COLOR0A0,
            alphaInA: GX.CombineAlphaInput.ZERO,
            alphaInB: GX.CombineAlphaInput.ZERO,
            alphaInC: GX.CombineAlphaInput.ZERO,
            alphaInD: GX.CombineAlphaInput.TEXA,
            alphaOp: GX.TevOp.ADD,
            alphaBias: GX.TevBias.ZERO,
            alphaClamp: false,
            alphaScale: GX.TevScale.SCALE_1,
            alphaRegId: GX.Register.PREV,
            konstAlphaSel: GX.KonstAlphaSel.KASEL_1,
            colorInA: GX.CombineColorInput.ZERO,
            colorInB: GX.CombineColorInput.ZERO,
            colorInC: GX.CombineColorInput.ZERO,
            colorInD: GX.CombineColorInput.TEXC,
            colorOp: GX.TevOp.ADD,
            colorBias: GX.TevBias.ZERO,
            colorClamp: false,
            colorScale: GX.TevScale.SCALE_1,
            colorRegId: GX.Register.PREV,
            konstColorSel: GX.KonstColorSel.KCSEL_1,
            texCoordId: GX.TexCoordID.TEXCOORD0,
            texMap: GX.TexMapID.TEXMAP0,
            // We don't use indtex.
            indTexStage: GX.IndTexStageID.STAGE0,
            indTexMatrix: GX.IndTexMtxID.OFF,
            indTexFormat: GX.IndTexFormat._8,
            indTexBiasSel: GX.IndTexBiasSel.NONE,
            indTexWrapS: GX.IndTexWrap.OFF,
            indTexWrapT: GX.IndTexWrap.OFF,
            indTexAddPrev: false,
            indTexUseOrigLOD: false
        };
        var tevStages = [tevStage0];
        // Filter any pixels less than 0.1.
        var alphaTest = {
            op: GX.AlphaOp.AND,
            compareA: GX.CompareType.GEQUAL,
            compareB: GX.CompareType.ALWAYS,
            referenceA: 0.1,
            referenceB: 0.0
        };
        var blendMode = {
            type: GX.BlendMode.NONE,
            srcFactor: GX.BlendFactor.ONE,
            dstFactor: GX.BlendFactor.ONE,
            logicOp: GX.LogicOp.CLEAR
        };
        var ropInfo = {
            blendMode: blendMode,
            depthFunc: GX.CompareType.LESS,
            depthTest: true,
            depthWrite: true
        };
        var gxMaterial = {
            index: index, name: '',
            cullMode: GX.CullMode.BACK,
            lightChannels: lightChannels,
            texGens: texGens,
            colorRegisters: colorRegisters,
            colorConstants: colorRegisters,
            tevStages: tevStages,
            alphaTest: alphaTest,
            ropInfo: ropInfo,
            indTexStages: []
        };
        return { gxMaterial: gxMaterial, samplerIndexes: samplerIndexes };
    }
    function traverseSceneGraph(parentNode, nodeIndex) {
        var nodeOffs = sceneGraphChunkOffs + 0x8C * nodeIndex;
        var parentIndex = view.getInt16(nodeOffs + 0x00, false);
        var firstChildIndex = view.getInt16(nodeOffs + 0x02, false);
        var nextSiblingIndex = view.getInt16(nodeOffs + 0x04, false);
        var prevSiblingIndex = view.getInt16(nodeOffs + 0x06, false);
        // view.getUint8(nodeOffs + 0x08);
        var flags = view.getUint8(nodeOffs + 0x09);
        // view.getUint16(node.offs + 0x0A);
        var modelMatrix = gl_matrix_1.mat4.create();
        var scaleX = view.getFloat32(nodeOffs + 0x0C, false);
        var scaleY = view.getFloat32(nodeOffs + 0x10, false);
        var scaleZ = view.getFloat32(nodeOffs + 0x14, false);
        var rotationX = view.getFloat32(nodeOffs + 0x18, false);
        var rotationY = view.getFloat32(nodeOffs + 0x1C, false);
        var rotationZ = view.getFloat32(nodeOffs + 0x20, false);
        var translationX = view.getFloat32(nodeOffs + 0x24, false);
        var translationY = view.getFloat32(nodeOffs + 0x28, false);
        var translationZ = view.getFloat32(nodeOffs + 0x2C, false);
        var bboxMinX = view.getFloat32(nodeOffs + 0x30, false);
        var bboxMinY = view.getFloat32(nodeOffs + 0x34, false);
        var bboxMinZ = view.getFloat32(nodeOffs + 0x38, false);
        var bboxMaxX = view.getFloat32(nodeOffs + 0x3C, false);
        var bboxMaxY = view.getFloat32(nodeOffs + 0x40, false);
        var bboxMaxZ = view.getFloat32(nodeOffs + 0x44, false);
        // const unk = view.getFloat32(nodeOffs + 0x48, false);
        var bbox = null;
        if (bboxMinX !== 0 || bboxMinY !== 0 || bboxMinZ !== 0 || bboxMaxX !== 0 || bboxMaxY !== 0 || bboxMaxZ !== 0) {
            bbox = new Camera_1.AABB(bboxMinX, bboxMinY, bboxMinZ, bboxMaxX, bboxMaxY, bboxMaxZ);
        }
        var scale = gl_matrix_1.vec3.fromValues(scaleX, scaleY, scaleZ);
        var rotation = gl_matrix_1.quat.create();
        gl_matrix_1.quat.fromEuler(rotation, rotationX, rotationY, rotationZ);
        var translation = gl_matrix_1.vec3.fromValues(translationX, translationY, translationZ);
        gl_matrix_1.mat4.fromRotationTranslationScale(modelMatrix, rotation, translation, scale);
        // Flatten matrix hierarchy.
        gl_matrix_1.mat4.mul(modelMatrix, parentNode.modelMatrix, modelMatrix);
        var parts = [];
        var partCount = view.getUint16(nodeOffs + 0x4C, false);
        var partTableIdx = sceneGraphChunkOffs + view.getUint32(nodeOffs + 0x50, false);
        for (var i = 0; i < partCount; i++) {
            var materialIndex = view.getUint16(partTableIdx + 0x00, false);
            var batchIndex = view.getUint16(partTableIdx + 0x02, false);
            partTableIdx += 0x04;
            var material = parseMaterial(materialIndex);
            var batch = parseBatch(batchIndex);
            if (batch === null) continue;
            parts.push({ material: material, batch: batch });
        }
        var children = [];
        var node = { children: children, modelMatrix: modelMatrix, bbox: bbox, parts: parts };
        // Add ourselves to parent.
        parentNode.children.push(node);
        // Parse children
        if (firstChildIndex >= 0) traverseSceneGraph(node, firstChildIndex);
        // Advance to next sibling.
        if (nextSiblingIndex >= 0) traverseSceneGraph(parentNode, nextSiblingIndex);
    }
    // Create a fake root node to be parent to the root nodes.
    var rootNode = { children: [], modelMatrix: gl_matrix_1.mat4.create(), bbox: null, parts: [] };
    traverseSceneGraph(rootNode, 0);
    var bin = { rootNode: rootNode, samplers: samplers };
    return bin;
}
exports.parse = parse;
},{"../util":"util.ts","gl-matrix":"..\\node_modules\\gl-matrix\\src\\gl-matrix.js","../gx/gx_enum":"gx\\gx_enum.ts","../gx/gx_displaylist":"gx\\gx_displaylist.ts","../gx/gx_material":"gx\\gx_material.ts","../Camera":"Camera.ts"}],"luigis_mansion\\render.ts":[function(require,module,exports) {
"use strict";

var __assign = this && this.__assign || Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) {
            if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
    }
    return t;
};
var __values = this && this.__values || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator],
        i = 0;
    if (m) return m.call(o);
    return {
        next: function next() {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
var __importStar = this && this.__importStar || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) {
        if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    }result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var GX_Texture = __importStar(require("../gx/gx_texture"));
var GX_Material = __importStar(require("../gx/gx_material"));
var gx_render_1 = require("../gx/gx_render");
var util_1 = require("../util");
var gl_matrix_1 = require("gl-matrix");
var Camera_1 = require("../Camera");
var Command_Material = /** @class */function () {
    function Command_Material(gl, scene, material) {
        this.scene = scene;
        this.material = material;
        this.materialParams = new gx_render_1.MaterialParams();
        this.program = new GX_Material.GX_Program(this.material.gxMaterial);
        this.renderFlags = GX_Material.translateRenderFlags(this.material.gxMaterial);
        // We don't animate, so we only need to compute this once.
        this.fillMaterialParams(this.materialParams);
    }
    Command_Material.prototype.fillMaterialParams = function (materialParams) {
        // All we care about is textures...
        for (var i = 0; i < this.material.samplerIndexes.length; i++) {
            var samplerIndex = this.material.samplerIndexes[i];
            if (samplerIndex >= 0) {
                var m = this.materialParams.m_TextureMapping[i];
                m.glTexture = this.scene.glTextures[samplerIndex];
            }
        }
    };
    Command_Material.prototype.exec = function (state) {
        var gl = state.gl;
        state.useProgram(this.program);
        state.useFlags(this.renderFlags);
        this.scene.renderHelper.bindMaterialParams(state, this.materialParams);
        this.scene.renderHelper.bindMaterialTextures(state, this.materialParams, this.program);
    };
    Command_Material.prototype.destroy = function (gl) {
        this.program.destroy(gl);
    };
    return Command_Material;
}();
var bboxScratch = new Camera_1.AABB();
var Command_Batch = /** @class */function () {
    function Command_Batch(gl, scene, sceneGraphNode, batch, coalescedBuffers) {
        this.scene = scene;
        this.sceneGraphNode = sceneGraphNode;
        this.batch = batch;
        this.coalescedBuffers = coalescedBuffers;
        this.packetParams = new gx_render_1.PacketParams();
        this.shapeHelper = new gx_render_1.GXShapeHelper(gl, coalescedBuffers, batch.loadedVertexLayout, batch.loadedVertexData);
    }
    Command_Batch.prototype.computeModelView = function (dst, state) {
        gl_matrix_1.mat4.copy(dst, state.updateModelView(false, this.sceneGraphNode.modelMatrix));
    };
    Command_Batch.prototype.exec = function (state) {
        var gl = state.gl;
        if (this.sceneGraphNode.bbox) {
            bboxScratch.transform(this.sceneGraphNode.bbox, this.sceneGraphNode.modelMatrix);
            if (state.camera.frustum.intersect(bboxScratch) === Camera_1.IntersectionState.FULLY_OUTSIDE) {
                return;
            }
        }
        this.computeModelView(this.packetParams.u_PosMtx[0], state);
        this.scene.renderHelper.bindPacketParams(state, this.packetParams);
        this.shapeHelper.drawSimple(gl);
        state.drawCallCount++;
    };
    Command_Batch.prototype.destroy = function (gl) {
        this.shapeHelper.destroy(gl);
    };
    return Command_Batch;
}();
var BinScene = /** @class */function () {
    function BinScene(gl, bin) {
        this.bin = bin;
        this.textures = [];
        this.glTextures = [];
        this.visible = true;
        this.sceneParams = new gx_render_1.SceneParams();
        this.translateModel(gl, bin);
        this.renderHelper = new gx_render_1.GXRenderHelper(gl);
    }
    BinScene.prototype.setVisible = function (visible) {
        this.visible = visible;
    };
    BinScene.prototype.render = function (state) {
        if (!this.visible) return;
        state.setClipPlanes(10, 500000);
        this.renderHelper.bindUniformBuffers(state);
        gx_render_1.fillSceneParamsFromRenderState(this.sceneParams, state);
        this.renderHelper.bindSceneParams(state, this.sceneParams);
        this.commands.forEach(function (command) {
            command.exec(state);
        });
    };
    BinScene.prototype.destroy = function (gl) {
        this.glTextures.forEach(function (textureId) {
            return gl.deleteTexture(textureId);
        });
        this.renderHelper.destroy(gl);
        this.bufferCoalescer.destroy(gl);
    };
    BinScene.prototype.translatePart = function (gl, node, part) {
        var materialCommand = new Command_Material(gl, this, part.material);
        this.commands.push(materialCommand);
        var batch = part.batch;
        var batchIndex = this.batches.indexOf(batch);
        util_1.assert(batchIndex >= 0);
        var batchCommand = new Command_Batch(gl, this, node, batch, this.bufferCoalescer.coalescedBuffers[batchIndex]);
        this.commands.push(batchCommand);
    };
    BinScene.prototype.translateSceneGraph = function (gl, node) {
        var e_1, _a, e_2, _b;
        try {
            for (var _c = __values(node.parts), _d = _c.next(); !_d.done; _d = _c.next()) {
                var part = _d.value;
                this.translatePart(gl, node, part);
            }
        } catch (e_1_1) {
            e_1 = { error: e_1_1 };
        } finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            } finally {
                if (e_1) throw e_1.error;
            }
        }
        try {
            for (var _e = __values(node.children), _f = _e.next(); !_f.done; _f = _e.next()) {
                var child = _f.value;
                this.translateSceneGraph(gl, child);
            }
        } catch (e_2_1) {
            e_2 = { error: e_2_1 };
        } finally {
            try {
                if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
            } finally {
                if (e_2) throw e_2.error;
            }
        }
    };
    BinScene.prototype.collectBatches = function (batches, node) {
        var e_3, _a, e_4, _b;
        try {
            for (var _c = __values(node.parts), _d = _c.next(); !_d.done; _d = _c.next()) {
                var part = _d.value;
                batches.push(part.batch);
            }
        } catch (e_3_1) {
            e_3 = { error: e_3_1 };
        } finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            } finally {
                if (e_3) throw e_3.error;
            }
        }
        try {
            for (var _e = __values(node.children), _f = _e.next(); !_f.done; _f = _e.next()) {
                var child = _f.value;
                this.collectBatches(batches, child);
            }
        } catch (e_4_1) {
            e_4 = { error: e_4_1 };
        } finally {
            try {
                if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
            } finally {
                if (e_4) throw e_4.error;
            }
        }
    };
    BinScene.prototype.translateModel = function (gl, bin) {
        for (var i = 0; i < bin.samplers.length; i++) {
            var sampler = bin.samplers[i];
            var texture = __assign({}, sampler.texture, { name: "unknown " + i });
            var mipChain = GX_Texture.calcMipChain(texture, 1);
            var _a = gx_render_1.loadTextureFromMipChain(gl, mipChain),
                glTexture = _a.glTexture,
                viewerTexture = _a.viewerTexture;
            // GL texture is bound by loadTextureFromMipChain.
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gx_render_1.translateWrapMode(gl, sampler.wrapS));
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gx_render_1.translateWrapMode(gl, sampler.wrapT));
            this.glTextures.push(glTexture);
            this.textures.push(viewerTexture);
        }
        // First, collect all the batches we're rendering.
        this.batches = [];
        this.collectBatches(this.batches, bin.rootNode);
        // Coalesce buffers.
        this.bufferCoalescer = gx_render_1.loadedDataCoalescer(gl, this.batches.map(function (batch) {
            return batch.loadedVertexData;
        }));
        this.commands = [];
        this.translateSceneGraph(gl, bin.rootNode);
    };
    return BinScene;
}();
exports.BinScene = BinScene;
},{"../gx/gx_texture":"gx\\gx_texture.ts","../gx/gx_material":"gx\\gx_material.ts","../gx/gx_render":"gx\\gx_render.ts","../util":"util.ts","gl-matrix":"..\\node_modules\\gl-matrix\\src\\gl-matrix.js","../Camera":"Camera.ts"}],"luigis_mansion\\scenes.ts":[function(require,module,exports) {
"use strict";

var __values = this && this.__values || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator],
        i = 0;
    if (m) return m.call(o);
    return {
        next: function next() {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
};
var __importStar = this && this.__importStar || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) {
        if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    }result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Progressable_1 = __importDefault(require("../Progressable"));
var Yay0 = __importStar(require("../compression/Yay0"));
var util_1 = require("../util");
var RARC = __importStar(require("../j3d/rarc"));
var BIN = __importStar(require("./bin"));
var render_1 = require("./render");
var UI = __importStar(require("../ui"));
var scenes_1 = require("../j3d/scenes");
var render_2 = require("../j3d/render");
function collectTextures(scenes) {
    var e_1, _a;
    var textures = [];
    try {
        for (var scenes_2 = __values(scenes), scenes_2_1 = scenes_2.next(); !scenes_2_1.done; scenes_2_1 = scenes_2.next()) {
            var scene = scenes_2_1.value;
            if (scene) textures.push.apply(textures, scene.textures);
        }
    } catch (e_1_1) {
        e_1 = { error: e_1_1 };
    } finally {
        try {
            if (scenes_2_1 && !scenes_2_1.done && (_a = scenes_2.return)) _a.call(scenes_2);
        } finally {
            if (e_1) throw e_1.error;
        }
    }
    return textures;
}
var LuigisMansionScene = /** @class */function () {
    function LuigisMansionScene(roomScenes) {
        this.roomScenes = roomScenes;
        this.textures = collectTextures(roomScenes);
    }
    LuigisMansionScene.prototype.createPanels = function () {
        var layers = new UI.LayerPanel();
        layers.setLayers(this.roomScenes);
        return [layers];
    };
    LuigisMansionScene.prototype.render = function (state) {
        this.roomScenes.forEach(function (scene) {
            scene.render(state);
        });
    };
    LuigisMansionScene.prototype.destroy = function (gl) {
        this.roomScenes.forEach(function (scene) {
            return scene.destroy(gl);
        });
    };
    return LuigisMansionScene;
}();
function fetchVRBScene(gl, path) {
    return util_1.fetch("data/luigis_mansion/" + path).then(function (buffer) {
        var decompressed = Yay0.decompress(buffer);
        var textureHolder = new render_2.J3DTextureHolder();
        return scenes_1.createScenesFromBuffer(gl, textureHolder, decompressed).then(function (scenes) {
            util_1.assert(scenes.length === 1);
            return scenes[0];
        });
    });
}
function fetchBinScene(gl, path) {
    return util_1.fetch("data/luigis_mansion/" + path).then(function (buffer) {
        var binBuffer;
        if (path.endsWith('.bin')) {
            binBuffer = buffer;
        } else if (path.endsWith('.arc')) {
            var rarc = RARC.parse(buffer);
            var roomBinFile = rarc.findFile('room.bin');
            binBuffer = roomBinFile.buffer;
        }
        var bin = BIN.parse(binBuffer);
        var binScene = new render_1.BinScene(gl, bin);
        binScene.name = path.split('/').pop();
        return binScene;
    });
}
var LuigisMansionBinSceneDesc = /** @class */function () {
    function LuigisMansionBinSceneDesc(id, name, paths) {
        this.id = id;
        this.name = name;
        this.paths = paths;
    }
    LuigisMansionBinSceneDesc.prototype.createScene = function (gl) {
        var promises = this.paths.map(function (path) {
            return fetchBinScene(gl, path);
        });
        // TODO(jstpierre): J3D format in VRB has a different version with a different MAT3 chunk.
        // promises.unshift(fetchVRBScene(gl, `vrball_B.szp`));
        return Progressable_1.default.all(promises).then(function (roomScenes) {
            roomScenes = roomScenes.filter(function (s) {
                return !!s;
            });
            return new LuigisMansionScene(roomScenes);
        });
    };
    return LuigisMansionBinSceneDesc;
}();
function zeroPad(i) {
    var s = '' + i;
    if (s.length === 1) return '0' + s;else return s;
}
// Main mansion
var map2RoomsPaths = ["map2/room_00.arc", "map2/room_01.arc", "map2/room_02.arc", "map2/room_03.arc", "map2/room_04.arc", "map2/room_05.arc", "map2/room_06.arc", "map2/room_07.arc", "map2/room_08.arc", "map2/room_09.arc", "map2/room_10.arc", "map2/room_11.arc", "map2/room_12.arc", "map2/room_13.arc", "map2/room_14.arc", "map2/room_15.arc", "map2/room_16.arc", "map2/room_17.arc", "map2/room_18.arc", "map2/room_19.arc", "map2/room_20.arc", "map2/room_21.arc", "map2/room_22.arc", "map2/room_23.arc", "map2/room_24.arc", "map2/room_25.arc", "map2/room_26.arc", "map2/room_27.arc", "map2/room_28.arc", "map2/room_28A.arc", "map2/room_29.arc", "map2/room_30.arc", "map2/room_31.arc", "map2/room_32.arc", "map2/room_33.arc", "map2/room_34.arc", "map2/room_35.arc", "map2/room_36.arc", "map2/room_37.arc", "map2/room_38.arc", "map2/room_39.arc", "map2/room_40.arc", "map2/room_41.arc", "map2/room_42.arc", "map2/room_43.arc", "map2/room_44.arc", "map2/room_45.arc", "map2/room_46.arc", "map2/room_47.arc", "map2/room_48.arc", "map2/room_49.arc", "map2/room_50.arc", "map2/room_51.arc", "map2/room_52.arc", "map2/room_53.arc", "map2/room_54.arc", "map2/room_55.arc", "map2/room_56.arc", "map2/room_57.arc", "map2/room_58.arc", "map2/room_59.arc", "map2/room_60.arc", "map2/room_61.arc", "map2/room_62.arc", "map2/room_63.arc", "map2/room_64.arc", "map2/room_65.arc", "map2/room_66.arc", "map2/room_67.arc", "map2/room_68.arc", "map2/room_69.arc", "map2/room_70.arc", "map2/room_71.arc", "map2/room_72.arc", "map2/room_73.arc"];
var id = "luigis_mansion";
var name = "Luigi's Mansion";
var sceneDescs = [new LuigisMansionBinSceneDesc('map2', "Main Mansion", map2RoomsPaths),
// h_01.bin is a duplicate of the room.bin found in hakase.arc
new LuigisMansionBinSceneDesc('map1', "E Gadd's Garage", ['map1/h_02.bin', 'map1/hakase.arc']), new LuigisMansionBinSceneDesc('map3', "Training Room", ['map3/h_07_00.arc']), new LuigisMansionBinSceneDesc('map4', "Ghost Portrificationizer", ['map4/h_02.bin']), new LuigisMansionBinSceneDesc('map6', "Gallery", ['map6/gyara_00.arc', 'map6/gyara_01.arc', 'map6/gyara_02.arc', 'map6/gyara_03.arc']), new LuigisMansionBinSceneDesc('map5', "Gallery (Unused)", ['map5/h_03_00.bin', 'map5/h_03_01.bin', 'map5/h_03_02.bin', 'map5/h_03_03.bin']), new LuigisMansionBinSceneDesc('map7', "Gallery (Unused 2)", ['map7/h_05_00.bin', 'map7/h_05_01.bin', 'map7/h_05_02.bin', 'map7/h_05_03.bin']), new LuigisMansionBinSceneDesc('map8', "Gallery (Unused 3)", ['map8/h_06_00.bin', 'map8/h_06_01.bin', 'map8/h_06_02.bin', 'map8/h_06_03.bin']), new LuigisMansionBinSceneDesc('map9', "King Boo Boss Arena", ['map9/lastroof.arc']), new LuigisMansionBinSceneDesc('map10', "Chauncey Boss Arena", ['map10/roombed.arc']), new LuigisMansionBinSceneDesc('map11', "Boolossus Boss Arena", ['map11/beranda.arc']), new LuigisMansionBinSceneDesc('map13', "Bogmire Boss Arena", ['map13/tombboss.arc']), new LuigisMansionBinSceneDesc('map12', "Ghost Portrificationizer (End Credits)", ['map12/h_02.bin'])];
exports.sceneGroup = { id: id, name: name, sceneDescs: sceneDescs };
},{"../Progressable":"Progressable.ts","../compression/Yay0":"compression\\Yay0.ts","../util":"util.ts","../j3d/rarc":"j3d\\rarc.ts","./bin":"luigis_mansion\\bin.ts","./render":"luigis_mansion\\render.ts","../ui":"ui.ts","../j3d/scenes":"j3d\\scenes.ts","../j3d/render":"j3d\\render.ts"}],"rres\\brres.ts":[function(require,module,exports) {
"use strict";
// Parses NintendoWare BRRES (Binary Revolution RESource) files.
// http://wiki.tockdom.com/wiki/BRRES

var __values = this && this.__values || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator],
        i = 0;
    if (m) return m.call(o);
    return {
        next: function next() {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
var __importStar = this && this.__importStar || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) {
        if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    }result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var GX = __importStar(require("../gx/gx_enum"));
var util_1 = require("../util");
var GX_Material = __importStar(require("../gx/gx_material"));
var gx_displaylist_1 = require("../gx/gx_displaylist");
var gl_matrix_1 = require("gl-matrix");
var endian_1 = require("../endian");
var Camera_1 = require("../Camera");
//#region Utility
function calc2dMtx(dst, src) {
    dst[0] = src[0];
    dst[1] = src[1];
    dst[2] = src[4];
    dst[3] = src[5];
    dst[4] = src[12];
    dst[5] = src[13];
}
function calcTexMtx_Basic(dst, scaleS, scaleT, rotation, translationS, translationT) {
    var theta = Math.PI / 180 * rotation;
    var sinR = Math.sin(theta);
    var cosR = Math.cos(theta);
    gl_matrix_1.mat4.identity(dst);
    dst[0] = scaleS * cosR;
    dst[4] = scaleT * -sinR;
    dst[12] = translationS;
    dst[1] = scaleS * sinR;
    dst[5] = scaleT * cosR;
    dst[13] = translationT;
}
function calcTexMtx_Maya(dst, scaleS, scaleT, rotation, translationS, translationT) {
    var theta = Math.PI / 180 * rotation;
    var sinR = Math.sin(theta);
    var cosR = Math.cos(theta);
    gl_matrix_1.mat4.identity(dst);
    dst[0] = scaleS * cosR;
    dst[4] = scaleS * sinR;
    dst[12] = scaleS * (-0.5 * cosR - (0.5 * sinR - 0.5) - translationS);
    dst[1] = scaleT * -sinR;
    dst[5] = scaleT * cosR;
    dst[13] = scaleT * (-0.5 * cosR + (0.5 * sinR - 0.5) + translationT) + 1;
}
function calcTexMtx_Max(dst, scaleS, scaleT, rotation, translationS, translationT) {
    var theta = Math.PI / 180 * rotation;
    var sinR = Math.sin(theta);
    var cosR = Math.cos(theta);
    gl_matrix_1.mat4.identity(dst);
    dst[0] = scaleS * cosR;
    dst[4] = scaleS * sinR;
    dst[12] = scaleS * -cosR * (translationS + 0.5) + scaleS * sinR * (translationT - 0.5) + 0.5;
    dst[1] = scaleT * -sinR;
    dst[5] = scaleT * cosR;
    dst[13] = scaleT * sinR * (translationS + 0.5) + scaleT * cosR * (translationT - 0.5) + 0.5;
}
var TexMatrixMode;
(function (TexMatrixMode) {
    TexMatrixMode[TexMatrixMode["BASIC"] = -1] = "BASIC";
    TexMatrixMode[TexMatrixMode["MAYA"] = 0] = "MAYA";
    TexMatrixMode[TexMatrixMode["MAX"] = 2] = "MAX";
})(TexMatrixMode || (TexMatrixMode = {}));
;
function calcTexMtx(dst, texMtxMode, scaleS, scaleT, rotation, translationS, translationT) {
    switch (texMtxMode) {
        case TexMatrixMode.BASIC:
            return calcTexMtx_Basic(dst, scaleS, scaleT, rotation, translationS, translationT);
        case TexMatrixMode.MAYA:
            return calcTexMtx_Maya(dst, scaleS, scaleT, rotation, translationS, translationT);
        case TexMatrixMode.MAX:
            return calcTexMtx_Max(dst, scaleS, scaleT, rotation, translationS, translationT);
        default:
            throw "whoops";
    }
}
function calcModelMtx(dst, scaleX, scaleY, scaleZ, rotationX, rotationY, rotationZ, translationX, translationY, translationZ) {
    var rX = Math.PI / 180 * rotationX;
    var rY = Math.PI / 180 * rotationY;
    var rZ = Math.PI / 180 * rotationZ;
    var sinX = Math.sin(rX),
        cosX = Math.cos(rX);
    var sinY = Math.sin(rY),
        cosY = Math.cos(rY);
    var sinZ = Math.sin(rZ),
        cosZ = Math.cos(rZ);
    dst[0] = scaleX * (cosY * cosZ);
    dst[1] = scaleX * (sinZ * cosY);
    dst[2] = scaleX * -sinY;
    dst[3] = 0.0;
    dst[4] = scaleY * (sinX * cosZ * sinY - cosX * sinZ);
    dst[5] = scaleY * (sinX * sinZ * sinY + cosX * cosZ);
    dst[6] = scaleY * (sinX * cosY);
    dst[7] = 0.0;
    dst[8] = scaleZ * (cosX * cosZ * sinY + sinX * sinZ);
    dst[9] = scaleZ * (cosX * sinZ * sinY - sinX * cosZ);
    dst[10] = scaleZ * (cosY * cosX);
    dst[11] = 0.0;
    dst[12] = translationX;
    dst[13] = translationY;
    dst[14] = translationZ;
    dst[15] = 1.0;
}
function parseResDic(buffer, tableOffs) {
    if (tableOffs === 0) return [];
    var view = buffer.createDataView();
    var tableSize = view.getUint32(tableOffs + 0x00);
    var tableCount = view.getUint32(tableOffs + 0x04);
    var entries = [];
    var tableIdx = tableOffs + 0x08;
    // Skip root entry.
    tableIdx += 0x10;
    for (var i = 0; i < tableCount; i++) {
        // There's a fancy search tree in here which I don't care about at all...
        var name = util_1.readString(buffer, tableOffs + view.getUint32(tableIdx + 0x08));
        var offs = tableOffs + view.getUint32(tableIdx + 0x0C);
        entries.push({ name: name, offs: offs });
        tableIdx += 0x10;
    }
    return entries;
}
function parseTEX0(buffer) {
    var view = buffer.createDataView();
    util_1.assert(util_1.readString(buffer, 0x00, 0x04) === 'TEX0');
    var version = view.getUint32(0x08);
    var supportedVersions = [0x01, 0x03];
    util_1.assert(supportedVersions.includes(version));
    var dataOffs = view.getUint32(0x10);
    var nameOffs = view.getUint32(0x14);
    var name = util_1.readString(buffer, nameOffs);
    var flags = view.getUint32(0x18);
    var width = view.getUint16(0x1C);
    var height = view.getUint16(0x1E);
    var format = view.getUint32(0x20);
    var mipCount = view.getUint32(0x24);
    var minLOD = view.getFloat32(0x28) * 1 / 8;
    var maxLOD = view.getFloat32(0x2C) * 1 / 8;
    var data = buffer.subarray(dataOffs);
    return { name: name, width: width, height: height, format: format, mipCount: mipCount, minLOD: minLOD, maxLOD: maxLOD, data: data };
}
//#endregion
//#region MDL0
var DisplayListRegisters = /** @class */function () {
    function DisplayListRegisters() {
        this.bp = new Uint32Array(0x100);
        this.cp = new Uint32Array(0x100);
        // Can have up to 16 values per register.
        this.xf = new Uint32Array(0x1000);
        // TEV colors are weird and are two things under the hood
        // with the same register address.
        this.kc = new Uint32Array(4 * 2 * 2);
        // Initialize defaults.
        this.bp[GX.BPRegister.SS_MASK] = 0x00FFFFFF;
    }
    DisplayListRegisters.prototype.bps = function (regBag) {
        // First byte has register address, other 3 have value.
        var regAddr = regBag >>> 24;
        var regWMask = this.bp[GX.BPRegister.SS_MASK];
        // Retrieve existing value, overwrite w/ mask.
        var regValue = this.bp[regAddr] & ~regWMask | regBag & regWMask;
        // The mask resets after use.
        this.bp[GX.BPRegister.SS_MASK] = 0x00FFFFFF;
        // Set new value.
        this.bp[regAddr] = regValue;
        // Copy TEV colors internally.
        if (regAddr >= GX.BPRegister.TEV_REGISTERL_0_ID && regAddr <= GX.BPRegister.TEV_REGISTERL_0_ID + 4 * 2) {
            var kci = regAddr - GX.BPRegister.TEV_REGISTERL_0_ID;
            var bank = regValue >>> 23 & 0x01;
            this.kc[bank * 4 * 2 + kci] = regValue;
        }
    };
    DisplayListRegisters.prototype.xfs = function (idx, sub, v) {
        util_1.assert(idx >= 0x1000);
        idx -= 0x1000;
        this.xf[idx * 0x10 + sub] = v;
    };
    DisplayListRegisters.prototype.xfg = function (idx, sub) {
        if (sub === void 0) {
            sub = 0;
        }
        util_1.assert(idx >= 0x1000);
        idx -= 0x1000;
        return this.xf[idx * 0x10 + sub];
    };
    return DisplayListRegisters;
}();
// TODO(jstpierre): Move this to gx_displaylist.ts
function runDisplayListRegisters(r, buffer) {
    var view = buffer.createDataView();
    for (var i = 0; i < buffer.byteLength;) {
        var cmd = view.getUint8(i++);
        switch (cmd) {
            case GX.Command.NOOP:
                continue;
            case GX.Command.LOAD_BP_REG:
                {
                    var regBag = view.getUint32(i);
                    i += 4;
                    r.bps(regBag);
                    break;
                }
            case GX.Command.LOAD_CP_REG:
                {
                    var regAddr = view.getUint8(i);
                    i++;
                    var regValue = view.getUint32(i);
                    i += 4;
                    r.cp[regAddr] = regValue;
                    break;
                }
            case GX.Command.LOAD_XF_REG:
                {
                    var len = view.getUint16(i) + 1;
                    i += 2;
                    util_1.assert(len <= 0x10);
                    var regAddr = view.getUint16(i);
                    i += 2;
                    for (var j = 0; j < len; j++) {
                        r.xfs(regAddr, j, view.getUint32(i));
                        i += 4;
                    }
                    // Clear out the other values.
                    for (var j = len; j < 16; j++) {
                        r.xfs(regAddr, j, 0);
                    }
                    break;
                }
            default:
                console.error("Unknown command " + cmd + " at " + i + " (buffer: 0x" + buffer.byteOffset.toString(16) + ")");
                throw "whoops 1";
        }
    }
}
function findTevOp(bias, scale, sub) {
    if (bias === GX.TevBias.$HWB_COMPARE) {
        switch (scale) {
            case GX.TevScale.$HWB_R8:
                return sub ? GX.TevOp.COMP_R8_EQ : GX.TevOp.COMP_R8_GT;
            case GX.TevScale.$HWB_GR16:
                return sub ? GX.TevOp.COMP_GR16_EQ : GX.TevOp.COMP_GR16_GT;
            case GX.TevScale.$HWB_BGR24:
                return sub ? GX.TevOp.COMP_BGR24_EQ : GX.TevOp.COMP_BGR24_GT;
            case GX.TevScale.$HWB_RGB8:
                return sub ? GX.TevOp.COMP_RGB8_EQ : GX.TevOp.COMP_RGB8_GT;
            default:
                throw "whoops 2";
        }
    } else {
        return sub ? GX.TevOp.SUB : GX.TevOp.ADD;
    }
}
function parseMDL0_TevEntry(buffer, r, numStagesCheck) {
    var view = buffer.createDataView();
    var size = view.getUint32(0x00);
    util_1.assert(size === 480 + 32);
    var index = view.getUint32(0x08);
    var numStages = view.getUint8(0x0C);
    util_1.assert(numStages === numStagesCheck);
    var dlOffs = 0x20;
    runDisplayListRegisters(r, buffer.subarray(dlOffs, 480));
}
var MapMode;
(function (MapMode) {
    MapMode[MapMode["TEXCOORD"] = 0] = "TEXCOORD";
    MapMode[MapMode["ENV_CAMERA"] = 1] = "ENV_CAMERA";
    MapMode[MapMode["PROJECTION"] = 2] = "PROJECTION";
    MapMode[MapMode["ENV_LIGHT"] = 3] = "ENV_LIGHT";
    MapMode[MapMode["ENV_SPEC"] = 4] = "ENV_SPEC";
})(MapMode = exports.MapMode || (exports.MapMode = {}));
function parseMDL0_MaterialEntry(buffer, version) {
    var view = buffer.createDataView();
    var size = view.getUint32(0x00);
    var nameOffs = view.getUint32(0x08);
    var name = util_1.readString(buffer, nameOffs);
    var index = view.getUint32(0x0C);
    var flags = view.getUint32(0x10);
    var translucent = !!(flags & 0x80000000);
    // genMode
    var numTexGens = view.getUint8(0x14);
    var numChans = view.getUint8(0x15);
    var numTevs = view.getUint8(0x16);
    var numInds = view.getUint8(0x17);
    var cullMode = view.getUint32(0x18);
    // matMisc
    var zCompLoc = !!view.getUint8(0x1C);
    var lightset = view.getInt8(0x1D);
    var fogset = view.getInt8(0x1E);
    // pad
    var indMethod0 = view.getUint8(0x20);
    var indMethod1 = view.getUint8(0x21);
    var indMethod2 = view.getUint8(0x22);
    var indMethod3 = view.getUint8(0x23);
    var nrmRefLight0 = view.getUint8(0x24);
    var nrmRefLight1 = view.getUint8(0x25);
    var nrmRefLight2 = view.getUint8(0x26);
    var nrmRefLight3 = view.getUint8(0x27);
    var tevOffs = view.getUint32(0x28);
    util_1.assert(numTevs <= 16);
    var numTexPltt = view.getUint32(0x2C);
    var texPlttOffs = view.getUint32(0x30);
    var endOfHeaderOffs = 0x34;
    if (version >= 0x0A) {
        endOfHeaderOffs += 0x04; // Fur
    }
    endOfHeaderOffs += 0x04; // user data
    // Run the mat DLs.
    var r = new DisplayListRegisters();
    var matDLOffs = view.getUint32(endOfHeaderOffs);
    var matDLSize = 32 + 128 + 64 + 160;
    runDisplayListRegisters(r, buffer.subarray(matDLOffs, matDLSize));
    // Run the TEV registers as well.
    parseMDL0_TevEntry(buffer.subarray(tevOffs), r, numTevs);
    // Now combine the whole thing.
    // TexGens.
    var texGens = [];
    for (var i = 0; i < numTexGens; i++) {
        var v = r.xfg(GX.XFRegister.XF_TEX0_ID + i);
        var TexProjection = void 0;
        (function (TexProjection) {
            TexProjection[TexProjection["ST"] = 0] = "ST";
            TexProjection[TexProjection["STQ"] = 1] = "STQ";
        })(TexProjection || (TexProjection = {}));
        var TexForm = void 0;
        (function (TexForm) {
            TexForm[TexForm["AB11"] = 0] = "AB11";
            TexForm[TexForm["ABC1"] = 1] = "ABC1";
        })(TexForm || (TexForm = {}));
        var TexGenType = void 0;
        (function (TexGenType) {
            TexGenType[TexGenType["REGULAR"] = 0] = "REGULAR";
            TexGenType[TexGenType["EMBOSS_MAP"] = 1] = "EMBOSS_MAP";
            TexGenType[TexGenType["COLOR_STRGBC0"] = 2] = "COLOR_STRGBC0";
            TexGenType[TexGenType["COLOR_STRGBC1"] = 2] = "COLOR_STRGBC1";
        })(TexGenType || (TexGenType = {}));
        var TexSourceRow = void 0;
        (function (TexSourceRow) {
            TexSourceRow[TexSourceRow["GEOM"] = 0] = "GEOM";
            TexSourceRow[TexSourceRow["NRM"] = 1] = "NRM";
            TexSourceRow[TexSourceRow["CLR"] = 2] = "CLR";
            TexSourceRow[TexSourceRow["BNT"] = 3] = "BNT";
            TexSourceRow[TexSourceRow["BNB"] = 4] = "BNB";
            TexSourceRow[TexSourceRow["TEX0"] = 5] = "TEX0";
            TexSourceRow[TexSourceRow["TEX1"] = 6] = "TEX1";
            TexSourceRow[TexSourceRow["TEX2"] = 7] = "TEX2";
            TexSourceRow[TexSourceRow["TEX3"] = 8] = "TEX3";
            TexSourceRow[TexSourceRow["TEX4"] = 9] = "TEX4";
            TexSourceRow[TexSourceRow["TEX5"] = 10] = "TEX5";
            TexSourceRow[TexSourceRow["TEX6"] = 11] = "TEX6";
            TexSourceRow[TexSourceRow["TEX7"] = 12] = "TEX7";
        })(TexSourceRow || (TexSourceRow = {}));
        var proj = v >>> 1 & 0x01;
        var form = v >>> 2 & 0x01;
        var tgType = v >>> 4 & 0x02;
        var src = v >>> 7 & 0x0F;
        var embossSrc = v >>> 12 & 0x07;
        var embossLgt = v >>> 15 & 0x07;
        var texGenType = void 0;
        var texGenSrc = void 0;
        if (tgType === TexGenType.REGULAR) {
            var srcLookup = [GX.TexGenSrc.POS, GX.TexGenSrc.NRM, GX.TexGenSrc.COLOR0, GX.TexGenSrc.BINRM, GX.TexGenSrc.TANGENT, GX.TexGenSrc.TEX0, GX.TexGenSrc.TEX1, GX.TexGenSrc.TEX2, GX.TexGenSrc.TEX3, GX.TexGenSrc.TEX4, GX.TexGenSrc.TEX5, GX.TexGenSrc.TEX6, GX.TexGenSrc.TEX7];
            texGenType = proj === TexProjection.ST ? GX.TexGenType.MTX2x4 : GX.TexGenType.MTX3x4;
            texGenSrc = srcLookup[src];
        } else if (tgType === TexGenType.EMBOSS_MAP) {
            texGenType = GX.TexGenType.BUMP0 + embossLgt;
            texGenSrc = GX.TexGenSrc.TEXCOORD0 + embossSrc;
        } else if (tgType === TexGenType.COLOR_STRGBC0) {
            texGenType = GX.TexGenType.SRTG;
            texGenSrc = GX.TexGenSrc.COLOR0;
        } else if (tgType === TexGenType.COLOR_STRGBC1) {
            texGenType = GX.TexGenType.SRTG;
            texGenSrc = GX.TexGenSrc.COLOR1;
        }
        // TODO(jstpierre): Figure out texgen matrices. Seems like in most cases BRRES
        // only supports postmtx.
        var matrix = GX.TexGenMatrix.IDENTITY;
        var dv = r.xfg(GX.XFRegister.XF_DUALTEX0_ID + i);
        var postMatrix = (dv >>> 0 & 0xFF) + GX.PostTexGenMatrix.PTTEXMTX0;
        var normalize = !!(dv >>> 8 & 0x01);
        texGens.push({ index: i, type: texGenType, source: texGenSrc, matrix: matrix, normalize: normalize, postMatrix: postMatrix });
    }
    // TEV stages.
    var tevStages = [];
    var tevOrders = [];
    // First up, parse RAS1_TREF into tev orders.
    for (var i = 0; i < 8; i++) {
        var v = r.bp[GX.BPRegister.RAS1_TREF_0_ID + i];
        var ti0 = v >>> 0 & 0x07;
        var tc0 = v >>> 3 & 0x07;
        var te0 = !!(v >>> 6 & 0x01);
        var cc0 = v >>> 7 & 0x07;
        // 7-10 = pad
        var ti1 = v >>> 12 & 0x07;
        var tc1 = v >>> 15 & 0x07;
        var te1 = !!(v >>> 18 & 0x01);
        var cc1 = v >>> 19 & 0x07;
        if (i * 2 + 0 >= numTevs) break;
        var order0 = {
            texMapId: te0 ? ti0 : GX.TexMapID.TEXMAP_NULL,
            texCoordId: tc0,
            channelId: cc0
        };
        tevOrders.push(order0);
        if (i * 2 + 1 >= numTevs) break;
        var order1 = {
            texMapId: te1 ? ti1 : GX.TexMapID.TEXMAP_NULL,
            texCoordId: tc1,
            channelId: cc1
        };
        tevOrders.push(order1);
    }
    util_1.assert(tevOrders.length === numTevs);
    // Now parse out individual stages.
    for (var i = 0; i < tevOrders.length; i++) {
        var color = r.bp[GX.BPRegister.TEV_COLOR_ENV_0_ID + i * 2];
        var colorInD = color >>> 0 & 0x0F;
        var colorInC = color >>> 4 & 0x0F;
        var colorInB = color >>> 8 & 0x0F;
        var colorInA = color >>> 12 & 0x0F;
        var colorBias = color >>> 16 & 0x03;
        var colorSub = !!(color >>> 18 & 0x01);
        var colorClamp = !!(color >>> 19 & 0x01);
        var colorScale = color >>> 20 & 0x03;
        var colorRegId = color >>> 22 & 0x03;
        var colorOp = findTevOp(colorBias, colorScale, colorSub);
        // Find the op.
        var alpha = r.bp[GX.BPRegister.TEV_ALPHA_ENV_0_ID + i * 2];
        // TODO(jstpierre): swap table
        var alphaInD = alpha >>> 4 & 0x07;
        var alphaInC = alpha >>> 7 & 0x07;
        var alphaInB = alpha >>> 10 & 0x07;
        var alphaInA = alpha >>> 13 & 0x07;
        var alphaBias = alpha >>> 16 & 0x03;
        var alphaSub = !!(alpha >>> 18 & 0x01);
        var alphaClamp = !!(alpha >>> 19 & 0x01);
        var alphaScale = alpha >>> 20 & 0x03;
        var alphaRegId = alpha >>> 22 & 0x03;
        var alphaOp = findTevOp(alphaBias, alphaScale, alphaSub);
        var ksel = r.bp[GX.BPRegister.TEV_KSEL_0_ID + (i >>> 1)];
        var konstColorSel = (i & 1 ? ksel >>> 14 : ksel >>> 4) & 0x1F;
        var konstAlphaSel = (i & 1 ? ksel >>> 19 : ksel >>> 9) & 0x1F;
        var indCmd = r.bp[GX.BPRegister.IND_CMD0_ID + i];
        var indTexStage = indCmd >>> 0 & 0x03;
        var indTexFormat = indCmd >>> 2 & 0x03;
        var indTexBiasSel = indCmd >>> 4 & 0x03;
        // alpha sel
        var indTexMatrix = indCmd >>> 9 & 0x0F;
        var indTexWrapS = indCmd >>> 13 & 0x07;
        var indTexWrapT = indCmd >>> 16 & 0x07;
        var indTexUseOrigLOD = !!(indCmd >>> 19 & 0x01);
        var indTexAddPrev = !!(indCmd >>> 20 & 0x01);
        var tevStage = {
            index: i,
            colorInA: colorInA, colorInB: colorInB, colorInC: colorInC, colorInD: colorInD, colorOp: colorOp, colorBias: colorBias, colorClamp: colorClamp, colorScale: colorScale, colorRegId: colorRegId,
            alphaInA: alphaInA, alphaInB: alphaInB, alphaInC: alphaInC, alphaInD: alphaInD, alphaOp: alphaOp, alphaBias: alphaBias, alphaClamp: alphaClamp, alphaScale: alphaScale, alphaRegId: alphaRegId,
            texCoordId: tevOrders[i].texCoordId,
            texMap: tevOrders[i].texMapId,
            channelId: tevOrders[i].channelId,
            konstColorSel: konstColorSel, konstAlphaSel: konstAlphaSel,
            indTexStage: indTexStage, indTexFormat: indTexFormat, indTexBiasSel: indTexBiasSel, indTexMatrix: indTexMatrix, indTexWrapS: indTexWrapS, indTexWrapT: indTexWrapT, indTexAddPrev: indTexAddPrev, indTexUseOrigLOD: indTexUseOrigLOD
        };
        tevStages.push(tevStage);
    }
    // Colors.
    var colorRegisters = [];
    var colorConstants = [];
    for (var i = 0; i < 8; i++) {
        var vl = r.kc[i * 2 + 0];
        var vh = r.kc[i * 2 + 1];
        var cr = (vl >>> 0 & 0x7FF) / 0xFF;
        var ca = (vl >>> 12 & 0x7FF) / 0xFF;
        var cb = (vh >>> 0 & 0x7FF) / 0xFF;
        var cg = (vh >>> 12 & 0x7FF) / 0xFF;
        var c = new GX_Material.Color(cr, cg, cb, ca);
        if (i < 4) colorRegisters[i] = c;else colorConstants[i - 4] = c;
    }
    // Alpha test.
    var ap = r.bp[GX.BPRegister.TEV_ALPHAFUNC_ID];
    var alphaTest = {
        referenceA: (ap >>> 0 & 0xFF) / 0xFF,
        referenceB: (ap >>> 8 & 0xFF) / 0xFF,
        compareA: ap >>> 16 & 0x07,
        compareB: ap >>> 19 & 0x07,
        op: ap >>> 22 & 0x07
    };
    var cm0 = r.bp[GX.BPRegister.PE_CMODE0_ID];
    var bmboe = cm0 >>> 0 & 0x01;
    var bmloe = cm0 >>> 1 & 0x01;
    var bmbop = cm0 >>> 11 & 0x01;
    var blendType = bmboe ? bmbop ? GX.BlendMode.SUBTRACT : GX.BlendMode.BLEND : bmloe ? GX.BlendMode.LOGIC : GX.BlendMode.NONE;
    ;
    var dstFactor = cm0 >>> 5 & 0x07;
    var srcFactor = cm0 >>> 8 & 0x07;
    var logicOp = cm0 >>> 12 & 0x0F;
    var blendMode = {
        type: blendType,
        dstFactor: dstFactor, srcFactor: srcFactor, logicOp: logicOp
    };
    var zm = r.bp[GX.BPRegister.PE_ZMODE_ID];
    var depthTest = !!(zm >>> 0 & 0x01);
    var depthFunc = zm >>> 1 & 0x07;
    var depthWrite = !!(zm >>> 4 & 0x01);
    var ropInfo = {
        blendMode: blendMode, depthFunc: depthFunc, depthTest: depthTest, depthWrite: depthWrite
    };
    var indTexStages = [];
    var iref = r.bp[GX.BPRegister.RAS1_IREF_ID];
    for (var i = 0; i < numInds; i++) {
        var index_1 = i;
        var ss = r.bp[GX.BPRegister.RAS1_SS0_ID + (index_1 >>> 2)];
        var scaleS = ss >>> 0x08 * (i & 1) + 0x00 & 0x0F;
        var scaleT = ss >>> 0x08 * (i & 1) + 0x04 & 0x0F;
        var texture = iref >>> 0x06 * i & 0x07;
        var texCoordId = iref >>> 0x06 * i & 0x07;
        indTexStages.push({ index: index_1, scaleS: scaleS, scaleT: scaleT, texCoordId: texCoordId, texture: texture });
    }
    var indTexMatrices = [];
    for (var i = 0; i < 3; i++) {
        var indTexScaleBase = 10;
        var indTexScaleBias = 0x11;
        var indOffs = i * 3;
        var mtxA = r.bp[GX.BPRegister.IND_MTXA0_ID + indOffs];
        var mtxB = r.bp[GX.BPRegister.IND_MTXB0_ID + indOffs];
        var mtxC = r.bp[GX.BPRegister.IND_MTXC0_ID + indOffs];
        var scaleBitsA = mtxA >>> 22 & 0x03;
        var scaleBitsB = mtxB >>> 22 & 0x03;
        var scaleBitsC = mtxC >>> 22 & 0x03;
        var scaleExp = scaleBitsC << 4 | scaleBitsB << 2 | scaleBitsA;
        var scale = Math.pow(2, scaleExp - indTexScaleBias - indTexScaleBase);
        var ma = ((mtxA >>> 0 & 0x07FF) << 21 >> 21) * scale;
        var mc = ((mtxA >>> 11 & 0x07FF) << 21 >> 21) * scale;
        var mx = ((mtxB >>> 0 & 0x07FF) << 21 >> 21) * scale;
        var mb = ((mtxB >>> 11 & 0x07FF) << 21 >> 21) * scale;
        var md = ((mtxC >>> 0 & 0x07FF) << 21 >> 21) * scale;
        var my = ((mtxC >>> 11 & 0x07FF) << 21 >> 21) * scale;
        var mat = gl_matrix_1.mat2d.fromValues(ma, mb, mc, md, mx, my);
        indTexMatrices.push(mat);
    }
    // Samplers
    var samplers = [];
    for (var i = 0; i < numTexPltt; i++) {
        var texPlttInfoOffs = texPlttOffs + i * 0x34;
        var nameTexOffs = view.getUint32(texPlttInfoOffs + 0x00);
        var namePltOffs = view.getUint32(texPlttInfoOffs + 0x04);
        // unk
        // unk
        var texMapId = view.getUint32(texPlttInfoOffs + 0x10);
        var tlutId = view.getUint32(texPlttInfoOffs + 0x14);
        var wrapS = view.getUint32(texPlttInfoOffs + 0x18);
        var wrapT = view.getUint32(texPlttInfoOffs + 0x1C);
        var minFilter = view.getUint32(texPlttInfoOffs + 0x20);
        var magFilter = view.getUint32(texPlttInfoOffs + 0x24);
        var lodBias = view.getFloat32(texPlttInfoOffs + 0x28) * 1 / 8;
        var maxAniso = view.getUint32(texPlttInfoOffs + 0x2C);
        var biasClamp = view.getUint8(texPlttInfoOffs + 0x30);
        var edgeLod = view.getUint8(texPlttInfoOffs + 0x31);
        var name_1 = util_1.readString(buffer, texPlttInfoOffs + nameTexOffs);
        var namePalette = namePltOffs !== 0 ? util_1.readString(buffer, texPlttInfoOffs + namePltOffs) : null;
        samplers[texMapId] = { name: name_1, namePalette: namePalette, lodBias: lodBias, wrapS: wrapS, wrapT: wrapT, minFilter: minFilter, magFilter: magFilter };
    }
    var srtFlags = view.getUint32(endOfHeaderOffs + 0x16C);
    var texMtxMode = view.getUint32(endOfHeaderOffs + 0x170);
    var texSrtTableIdx = endOfHeaderOffs + 0x174;
    var texMtxTableIdx = endOfHeaderOffs + 0x214;
    var texSrts = [];
    for (var i = 0; i < 8; i++) {
        // SRT
        var scaleS = view.getFloat32(texSrtTableIdx + 0x00);
        var scaleT = view.getFloat32(texSrtTableIdx + 0x04);
        var rotation = view.getFloat32(texSrtTableIdx + 0x08);
        var translationS = view.getFloat32(texSrtTableIdx + 0x0C);
        var translationT = view.getFloat32(texSrtTableIdx + 0x10);
        var refCamera = view.getInt8(texMtxTableIdx + 0x00);
        var refLight = view.getInt8(texMtxTableIdx + 0x01);
        var mapMode = view.getInt8(texMtxTableIdx + 0x02);
        var miscFlags = view.getInt8(texMtxTableIdx + 0x03);
        var m00 = view.getFloat32(texMtxTableIdx + 0x04);
        var m01 = view.getFloat32(texMtxTableIdx + 0x08);
        var m02 = view.getFloat32(texMtxTableIdx + 0x0C);
        var m03 = view.getFloat32(texMtxTableIdx + 0x10);
        var m10 = view.getFloat32(texMtxTableIdx + 0x14);
        var m11 = view.getFloat32(texMtxTableIdx + 0x18);
        var m12 = view.getFloat32(texMtxTableIdx + 0x1C);
        var m13 = view.getFloat32(texMtxTableIdx + 0x20);
        var m20 = view.getFloat32(texMtxTableIdx + 0x24);
        var m21 = view.getFloat32(texMtxTableIdx + 0x28);
        var m22 = view.getFloat32(texMtxTableIdx + 0x2C);
        var m23 = view.getFloat32(texMtxTableIdx + 0x30);
        var effectMtx = gl_matrix_1.mat4.fromValues(m00, m10, m20, 0, m01, m11, m21, 0, m02, m12, m22, 0, m03, m13, m23, 1);
        switch (mapMode) {
            case MapMode.TEXCOORD:
                // No matrix needed.
                break;
            case MapMode.PROJECTION:
            case MapMode.ENV_CAMERA:
            case MapMode.ENV_LIGHT:
                // Use the PNMTX0 matrix for projection and environment.
                // TODO(jstpierre): normal matrix for env camera / light.
                texGens[i].matrix = GX.TexGenMatrix.PNMTX0;
                break;
        }
        var srtMtx = gl_matrix_1.mat4.create();
        calcTexMtx(srtMtx, texMtxMode, scaleS, scaleT, rotation, translationS, translationT);
        var texSrt = { refCamera: refCamera, refLight: refLight, mapMode: mapMode, srtMtx: srtMtx, effectMtx: effectMtx };
        texSrts.push(texSrt);
        texSrtTableIdx += 0x14;
        texMtxTableIdx += 0x34;
    }
    var lightChannels = [];
    var colorMatRegs = [];
    var colorAmbRegs = [];
    var lightChannelTableIdx = endOfHeaderOffs + 0x3B4;
    for (var i = 0; i < 2; i++) {
        var ChanFlags = void 0;
        (function (ChanFlags) {
            ChanFlags[ChanFlags["MATCOLOR_COLOR"] = 1] = "MATCOLOR_COLOR";
            ChanFlags[ChanFlags["MATCOLOR_ALPHA"] = 2] = "MATCOLOR_ALPHA";
            ChanFlags[ChanFlags["AMBCOLOR_COLOR"] = 4] = "AMBCOLOR_COLOR";
            ChanFlags[ChanFlags["AMBCOLOR_ALPHA"] = 8] = "AMBCOLOR_ALPHA";
            ChanFlags[ChanFlags["CHANCTRL_COLOR"] = 16] = "CHANCTRL_COLOR";
            ChanFlags[ChanFlags["CHANCTRL_ALPHA"] = 32] = "CHANCTRL_ALPHA";
        })(ChanFlags || (ChanFlags = {}));
        var flags_1 = view.getUint32(lightChannelTableIdx + 0x00);
        var matColorR = view.getUint8(lightChannelTableIdx + 0x04) / 0xFF;
        var matColorG = view.getUint8(lightChannelTableIdx + 0x05) / 0xFF;
        var matColorB = view.getUint8(lightChannelTableIdx + 0x06) / 0xFF;
        var matColorA = view.getUint8(lightChannelTableIdx + 0x07) / 0xFF;
        var ambColorR = view.getUint8(lightChannelTableIdx + 0x08) / 0xFF;
        var ambColorG = view.getUint8(lightChannelTableIdx + 0x09) / 0xFF;
        var ambColorB = view.getUint8(lightChannelTableIdx + 0x0A) / 0xFF;
        var ambColorA = view.getUint8(lightChannelTableIdx + 0x0B) / 0xFF;
        var chanCtrlC = view.getUint32(lightChannelTableIdx + 0x0C);
        var chanCtrlA = view.getUint32(lightChannelTableIdx + 0x10);
        var chanCtrlCMatSrc = chanCtrlC >>> 0 & 0x01;
        var chanCtrlCEnable = !!(chanCtrlC >>> 1 & 0x01);
        var chanCtrlCAmbSrc = chanCtrlC >>> 6 & 0x01;
        var colorChannel = { lightingEnabled: chanCtrlCEnable, matColorSource: chanCtrlCMatSrc, ambColorSource: chanCtrlCAmbSrc };
        var chanCtrlAMatSrc = chanCtrlA >>> 0 & 0x01;
        var chanCtrlAEnable = !!(chanCtrlA >>> 1 & 0x01);
        var chanCtrlAAmbSrc = chanCtrlA >>> 6 & 0x01;
        var alphaChannel = { lightingEnabled: chanCtrlAEnable, matColorSource: chanCtrlAMatSrc, ambColorSource: chanCtrlAAmbSrc };
        colorMatRegs.push(new GX_Material.Color(matColorR, matColorG, matColorB, matColorA));
        colorAmbRegs.push(new GX_Material.Color(ambColorR, ambColorG, ambColorB, ambColorA));
        lightChannels.push({ colorChannel: colorChannel, alphaChannel: alphaChannel });
        lightChannelTableIdx += 0x14;
    }
    var gxMaterial = {
        index: index, name: name,
        lightChannels: lightChannels, cullMode: cullMode,
        tevStages: tevStages, texGens: texGens,
        colorRegisters: colorRegisters, colorConstants: colorConstants,
        indTexStages: indTexStages, alphaTest: alphaTest, ropInfo: ropInfo
    };
    return { index: index, name: name, translucent: translucent, gxMaterial: gxMaterial, samplers: samplers, texSrts: texSrts, indTexMatrices: indTexMatrices, colorMatRegs: colorMatRegs, colorAmbRegs: colorAmbRegs };
}
function parseMDL0_VtxData(buffer, vtxAttrib) {
    var view = buffer.createDataView();
    var dataOffs = view.getUint32(0x08);
    var nameOffs = view.getUint32(0x0C);
    var name = util_1.readString(buffer, nameOffs);
    var id = view.getUint32(0x10);
    var compCnt = view.getUint32(0x14);
    var compType = view.getUint32(0x18);
    var compShift = view.getUint8(0x1C);
    var stride = view.getUint8(0x1D);
    var count = view.getUint16(0x1E);
    // Color attributes don't have shift -- they store stride in the shift field.
    if (vtxAttrib === GX.VertexAttribute.CLR0) {
        stride = compShift;
        compShift = 0;
    }
    var numComponents = gx_displaylist_1.getComponentCountRaw(vtxAttrib, compCnt);
    var compSize = gx_displaylist_1.getComponentSizeRaw(compType);
    var compByteSize = numComponents * compSize;
    var dataByteSize = compByteSize * count;
    var data = buffer.subarray(dataOffs, dataByteSize);
    return { name: name, id: id, compCnt: compCnt, compType: compType, compShift: compShift, stride: stride, count: count, data: data };
}
function parseInputBufferSet(buffer, vtxAttrib, resDic) {
    var vtxBuffers = [];
    for (var i = 0; i < resDic.length; i++) {
        var entry = resDic[i];
        var vtxBufferData = parseMDL0_VtxData(buffer.subarray(entry.offs), vtxAttrib);
        util_1.assert(vtxBufferData.name === entry.name);
        util_1.assert(vtxBufferData.id === i);
        vtxBuffers.push(vtxBufferData);
    }
    return vtxBuffers;
}
function parseInputVertexBuffers(buffer, vtxPosResDic, vtxNrmResDic, vtxClrResDic, vtxTxcResDic) {
    var pos = parseInputBufferSet(buffer, GX.VertexAttribute.POS, vtxPosResDic);
    var nrm = parseInputBufferSet(buffer, GX.VertexAttribute.NRM, vtxNrmResDic);
    var clr = parseInputBufferSet(buffer, GX.VertexAttribute.CLR0, vtxClrResDic);
    var txc = parseInputBufferSet(buffer, GX.VertexAttribute.TEX0, vtxTxcResDic);
    return { pos: pos, nrm: nrm, clr: clr, txc: txc };
}
;
function parseMDL0_ShapeEntry(buffer, inputBuffers) {
    var view = buffer.createDataView();
    var mtxIdx = view.getInt32(0x08);
    // These offsets are relative to the start of the structure.
    var prePrimDLSize = view.getUint32(0x18);
    var prePrimDLCmdSize = view.getUint32(0x1C);
    var prePrimDLOffs = 0x18 + view.getUint32(0x20);
    var primDLSize = view.getUint32(0x24);
    var primDLCmdSize = view.getUint32(0x28);
    var primDLOffs = 0x24 + view.getUint32(0x2C);
    var VcdFlags;
    (function (VcdFlags) {
        VcdFlags[VcdFlags["PNMTXIDX"] = 1] = "PNMTXIDX";
        VcdFlags[VcdFlags["TEX0MTXIDX"] = 2] = "TEX0MTXIDX";
        VcdFlags[VcdFlags["TEX1MTXIDX"] = 4] = "TEX1MTXIDX";
        VcdFlags[VcdFlags["TEX2MTXIDX"] = 8] = "TEX2MTXIDX";
        VcdFlags[VcdFlags["TEX3MTXIDX"] = 16] = "TEX3MTXIDX";
        VcdFlags[VcdFlags["TEX4MTXIDX"] = 32] = "TEX4MTXIDX";
        VcdFlags[VcdFlags["TEX5MTXIDX"] = 64] = "TEX5MTXIDX";
        VcdFlags[VcdFlags["TEX6MTXIDX"] = 128] = "TEX6MTXIDX";
        VcdFlags[VcdFlags["TEX7MTXIDX"] = 256] = "TEX7MTXIDX";
        VcdFlags[VcdFlags["POS"] = 512] = "POS";
        VcdFlags[VcdFlags["NRM"] = 1024] = "NRM";
        VcdFlags[VcdFlags["CLR0"] = 2048] = "CLR0";
        VcdFlags[VcdFlags["CLR1"] = 4096] = "CLR1";
        VcdFlags[VcdFlags["TEX0"] = 8192] = "TEX0";
        VcdFlags[VcdFlags["TEX1"] = 16384] = "TEX1";
        VcdFlags[VcdFlags["TEX2"] = 32768] = "TEX2";
        VcdFlags[VcdFlags["TEX3"] = 65536] = "TEX3";
        VcdFlags[VcdFlags["TEX4"] = 131072] = "TEX4";
        VcdFlags[VcdFlags["TEX5"] = 262144] = "TEX5";
        VcdFlags[VcdFlags["TEX6"] = 524288] = "TEX6";
        VcdFlags[VcdFlags["TEX7"] = 1048576] = "TEX7";
    })(VcdFlags || (VcdFlags = {}));
    var vcdFlags = view.getUint32(0x30);
    var flags = view.getUint32(0x34);
    var nameOffs = view.getUint32(0x38);
    var name = util_1.readString(buffer, nameOffs);
    var id = view.getUint32(0x3C);
    var numVertices = view.getUint32(0x40);
    var numPolygons = view.getUint32(0x44);
    var idVtxPos = view.getInt16(0x48);
    util_1.assert(idVtxPos >= 0);
    var idVtxNrm = view.getInt16(0x4A);
    var idVtxClr0 = view.getInt16(0x4C);
    var idVtxClr1 = view.getInt16(0x4E);
    var idVtxTxc0 = view.getInt16(0x50);
    var idVtxTxc1 = view.getInt16(0x52);
    var idVtxTxc2 = view.getInt16(0x54);
    var idVtxTxc3 = view.getInt16(0x56);
    var idVtxTxc4 = view.getInt16(0x58);
    var idVtxTxc5 = view.getInt16(0x5A);
    var idVtxTxc6 = view.getInt16(0x5C);
    var idVtxTxc7 = view.getInt16(0x5E);
    var idVtxFurVec = view.getInt16(0x60);
    var idVtxFurPos = view.getInt16(0x62);
    var mtxSetOffs = view.getUint32(0x64);
    // Run preprim. This should get us our VAT / VCD.
    var r = new DisplayListRegisters();
    runDisplayListRegisters(r, buffer.subarray(prePrimDLOffs, prePrimDLSize));
    // VCD. Describes primitive data.
    var vcdL = r.cp[GX.CPRegister.VCD_LO_ID];
    var vcdH = r.cp[GX.CPRegister.VCD_HI_ID];
    var vcd = [];
    vcd[GX.VertexAttribute.PNMTXIDX] = { type: vcdL >>> 0 & 0x01 };
    vcd[GX.VertexAttribute.TEX0MTXIDX] = { type: vcdL >>> 1 & 0x01 };
    vcd[GX.VertexAttribute.TEX1MTXIDX] = { type: vcdL >>> 2 & 0x01 };
    vcd[GX.VertexAttribute.TEX2MTXIDX] = { type: vcdL >>> 3 & 0x01 };
    vcd[GX.VertexAttribute.TEX3MTXIDX] = { type: vcdL >>> 4 & 0x01 };
    vcd[GX.VertexAttribute.TEX4MTXIDX] = { type: vcdL >>> 5 & 0x01 };
    vcd[GX.VertexAttribute.TEX5MTXIDX] = { type: vcdL >>> 6 & 0x01 };
    vcd[GX.VertexAttribute.TEX6MTXIDX] = { type: vcdL >>> 7 & 0x01 };
    vcd[GX.VertexAttribute.TEX7MTXIDX] = { type: vcdL >>> 8 & 0x01 };
    vcd[GX.VertexAttribute.POS] = { type: vcdL >>> 9 & 0x03 };
    vcd[GX.VertexAttribute.NRM] = { type: vcdL >>> 11 & 0x03 };
    vcd[GX.VertexAttribute.CLR0] = { type: vcdL >>> 13 & 0x03 };
    vcd[GX.VertexAttribute.CLR1] = { type: vcdL >>> 15 & 0x03 };
    vcd[GX.VertexAttribute.TEX0] = { type: vcdH >>> 0 & 0x03 };
    vcd[GX.VertexAttribute.TEX1] = { type: vcdH >>> 2 & 0x03 };
    vcd[GX.VertexAttribute.TEX2] = { type: vcdH >>> 4 & 0x03 };
    vcd[GX.VertexAttribute.TEX3] = { type: vcdH >>> 6 & 0x03 };
    vcd[GX.VertexAttribute.TEX4] = { type: vcdH >>> 8 & 0x03 };
    vcd[GX.VertexAttribute.TEX5] = { type: vcdH >>> 10 & 0x03 };
    vcd[GX.VertexAttribute.TEX6] = { type: vcdH >>> 12 & 0x03 };
    vcd[GX.VertexAttribute.TEX7] = { type: vcdH >>> 14 & 0x03 };
    // Validate against our VCD flags.
    for (var attr = 0; attr <= GX.VertexAttribute.TEX7; attr++) {
        var vcdFlagsEnabled = !!(vcdFlags & 1 << attr);
        var vcdEnabled = !!(vcd[attr].type !== GX.AttrType.NONE);
        util_1.assert(vcdFlagsEnabled === vcdEnabled);
    }
    // VAT. Describes attribute formats.
    // BRRES always uses VTXFMT0.
    var vatA = r.cp[GX.CPRegister.VAT_A_ID + GX.VtxFmt.VTXFMT0];
    var vatB = r.cp[GX.CPRegister.VAT_B_ID + GX.VtxFmt.VTXFMT0];
    var vatC = r.cp[GX.CPRegister.VAT_C_ID + GX.VtxFmt.VTXFMT0];
    function vatFmt(compCnt, compType, compShift) {
        return { compCnt: compCnt, compType: compType, compShift: compShift };
    }
    var vat = [];
    //                                        compCnt               compType              compShift
    vat[GX.VertexAttribute.POS] = vatFmt(vatA >>> 0 & 0x01, vatA >>> 1 & 0x07, vatA >>> 4 & 0x1F);
    var nrm3 = !!(vatA >>> 31);
    var nrmCnt = nrm3 ? GX.CompCnt.NRM_NBT3 : vatA >>> 9 & 0x01;
    vat[GX.VertexAttribute.NRM] = vatFmt(nrmCnt, vatA >>> 10 & 0x07, 0);
    vat[GX.VertexAttribute.CLR0] = vatFmt(vatA >>> 13 & 0x01, vatA >>> 14 & 0x07, 0);
    vat[GX.VertexAttribute.CLR1] = vatFmt(vatA >>> 17 & 0x01, vatA >>> 18 & 0x07, 0);
    vat[GX.VertexAttribute.TEX0] = vatFmt(vatA >>> 21 & 0x01, vatA >>> 22 & 0x07, vatA >>> 25 & 0x1F);
    vat[GX.VertexAttribute.TEX1] = vatFmt(vatB >>> 0 & 0x01, vatB >>> 1 & 0x07, vatB >>> 4 & 0x1F);
    vat[GX.VertexAttribute.TEX2] = vatFmt(vatB >>> 9 & 0x01, vatB >>> 10 & 0x07, vatB >>> 13 & 0x1F);
    vat[GX.VertexAttribute.TEX3] = vatFmt(vatB >>> 18 & 0x01, vatB >>> 19 & 0x07, vatB >>> 22 & 0x1F);
    vat[GX.VertexAttribute.TEX4] = vatFmt(vatB >>> 27 & 0x01, vatB >>> 28 & 0x07, vatC >>> 0 & 0x1F);
    vat[GX.VertexAttribute.TEX5] = vatFmt(vatC >>> 5 & 0x01, vatC >>> 6 & 0x07, vatC >>> 9 & 0x1F);
    vat[GX.VertexAttribute.TEX6] = vatFmt(vatC >>> 14 & 0x01, vatC >>> 15 & 0x07, vatC >>> 18 & 0x1F);
    vat[GX.VertexAttribute.TEX7] = vatFmt(vatC >>> 23 & 0x01, vatC >>> 24 & 0x07, vatC >>> 27 & 0x1F);
    var vtxArrays = [];
    util_1.assert(idVtxPos >= 0);
    if (idVtxPos >= 0) vtxArrays[GX.VertexAttribute.POS] = { buffer: inputBuffers.pos[idVtxPos].data, offs: 0 };
    if (idVtxNrm >= 0) vtxArrays[GX.VertexAttribute.NRM] = { buffer: inputBuffers.nrm[idVtxNrm].data, offs: 0 };
    if (idVtxClr0 >= 0) vtxArrays[GX.VertexAttribute.CLR0] = { buffer: inputBuffers.clr[idVtxClr0].data, offs: 0 };
    if (idVtxClr1 >= 0) vtxArrays[GX.VertexAttribute.CLR1] = { buffer: inputBuffers.clr[idVtxClr1].data, offs: 0 };
    if (idVtxTxc0 >= 0) vtxArrays[GX.VertexAttribute.TEX0] = { buffer: inputBuffers.txc[idVtxTxc0].data, offs: 0 };
    if (idVtxTxc1 >= 0) vtxArrays[GX.VertexAttribute.TEX1] = { buffer: inputBuffers.txc[idVtxTxc1].data, offs: 0 };
    if (idVtxTxc2 >= 0) vtxArrays[GX.VertexAttribute.TEX2] = { buffer: inputBuffers.txc[idVtxTxc2].data, offs: 0 };
    if (idVtxTxc3 >= 0) vtxArrays[GX.VertexAttribute.TEX3] = { buffer: inputBuffers.txc[idVtxTxc3].data, offs: 0 };
    if (idVtxTxc4 >= 0) vtxArrays[GX.VertexAttribute.TEX4] = { buffer: inputBuffers.txc[idVtxTxc4].data, offs: 0 };
    if (idVtxTxc5 >= 0) vtxArrays[GX.VertexAttribute.TEX5] = { buffer: inputBuffers.txc[idVtxTxc5].data, offs: 0 };
    if (idVtxTxc6 >= 0) vtxArrays[GX.VertexAttribute.TEX6] = { buffer: inputBuffers.txc[idVtxTxc6].data, offs: 0 };
    if (idVtxTxc7 >= 0) vtxArrays[GX.VertexAttribute.TEX7] = { buffer: inputBuffers.txc[idVtxTxc7].data, offs: 0 };
    var vtxLoader = gx_displaylist_1.compileVtxLoader(vat, vcd);
    var loadedVertexLayout = vtxLoader.loadedVertexLayout;
    var loadedVertexData = vtxLoader.runVertices(vtxArrays, buffer.subarray(primDLOffs, primDLSize));
    util_1.assert(loadedVertexData.totalVertexCount === numVertices);
    return { name: name, loadedVertexLayout: loadedVertexLayout, loadedVertexData: loadedVertexData };
}
var NodeFlags;
(function (NodeFlags) {
    NodeFlags[NodeFlags["SRT_IDENTITY"] = 1] = "SRT_IDENTITY";
    NodeFlags[NodeFlags["TRANS_ZERO"] = 2] = "TRANS_ZERO";
    NodeFlags[NodeFlags["ROT_ZERO"] = 4] = "ROT_ZERO";
    NodeFlags[NodeFlags["SCALE_ONE"] = 8] = "SCALE_ONE";
    NodeFlags[NodeFlags["SCALE_HOMO"] = 16] = "SCALE_HOMO";
})(NodeFlags || (NodeFlags = {}));
var BillboardMode;
(function (BillboardMode) {
    BillboardMode[BillboardMode["NONE"] = 0] = "NONE";
    BillboardMode[BillboardMode["BILLBOARD"] = 1] = "BILLBOARD";
    BillboardMode[BillboardMode["PERSP_BILLBOARD"] = 2] = "PERSP_BILLBOARD";
    BillboardMode[BillboardMode["ROT"] = 3] = "ROT";
    BillboardMode[BillboardMode["PERSP_ROT"] = 4] = "PERSP_ROT";
    BillboardMode[BillboardMode["Y"] = 5] = "Y";
    BillboardMode[BillboardMode["PERSP_Y"] = 6] = "PERSP_Y";
})(BillboardMode = exports.BillboardMode || (exports.BillboardMode = {}));
function parseMDL0_NodeEntry(buffer) {
    var view = buffer.createDataView();
    var nameOffs = view.getUint32(0x08);
    var name = util_1.readString(buffer, nameOffs);
    var id = view.getUint32(0x0C);
    var mtxId = view.getUint32(0x10);
    var flags = view.getUint32(0x14);
    var billboardMode = view.getUint32(0x18);
    var bbrefNodeId = view.getUint32(0x1C);
    var scaleX = view.getFloat32(0x20);
    var scaleY = view.getFloat32(0x24);
    var scaleZ = view.getFloat32(0x28);
    var rotationX = view.getFloat32(0x2C);
    var rotationY = view.getFloat32(0x30);
    var rotationZ = view.getFloat32(0x34);
    var translationX = view.getFloat32(0x38);
    var translationY = view.getFloat32(0x3C);
    var translationZ = view.getFloat32(0x40);
    // TODO(jstpierre): NW4R doesn't appear to use this anymore?
    var bboxMinX = view.getFloat32(0x44);
    var bboxMinY = view.getFloat32(0x48);
    var bboxMinZ = view.getFloat32(0x4C);
    var bboxMaxX = view.getFloat32(0x50);
    var bboxMaxY = view.getFloat32(0x54);
    var bboxMaxZ = view.getFloat32(0x58);
    var bbox = new Camera_1.AABB(bboxMinX, bboxMinY, bboxMinZ, bboxMaxX, bboxMaxY, bboxMaxZ);
    var modelMatrix = gl_matrix_1.mat4.create();
    calcModelMtx(modelMatrix, scaleX, scaleY, scaleZ, rotationX, rotationY, rotationZ, translationX, translationY, translationZ);
    return { name: name, id: id, mtxId: mtxId, flags: flags, billboardMode: billboardMode, modelMatrix: modelMatrix, bbox: bbox };
}
var ByteCodeOp;
(function (ByteCodeOp) {
    ByteCodeOp[ByteCodeOp["NOP"] = 0] = "NOP";
    ByteCodeOp[ByteCodeOp["RET"] = 1] = "RET";
    ByteCodeOp[ByteCodeOp["NODEDESC"] = 2] = "NODEDESC";
    ByteCodeOp[ByteCodeOp["NODEMIX"] = 3] = "NODEMIX";
    ByteCodeOp[ByteCodeOp["DRAW"] = 4] = "DRAW";
    ByteCodeOp[ByteCodeOp["EVPMTX"] = 5] = "EVPMTX";
    ByteCodeOp[ByteCodeOp["MTXDUP"] = 6] = "MTXDUP";
})(ByteCodeOp = exports.ByteCodeOp || (exports.ByteCodeOp = {}));
;
function parseMDL0_NodeTreeBytecode(buffer) {
    var view = buffer.createDataView();
    var nodeTreeOps = [];
    var i = 0;
    while (true) {
        var op = view.getUint8(i);
        if (op === ByteCodeOp.RET) {
            break;
        } else if (op === ByteCodeOp.NODEDESC) {
            var nodeId = view.getUint16(i + 1);
            var parentMtxId = view.getUint16(i + 3);
            i += 5;
            nodeTreeOps.push({ op: op, nodeId: nodeId, parentMtxId: parentMtxId });
        } else if (op === ByteCodeOp.MTXDUP) {
            var toMtxId = view.getUint16(i + 1);
            var fromMtxId = view.getUint16(i + 3);
            i += 5;
            nodeTreeOps.push({ op: op, toMtxId: toMtxId, fromMtxId: fromMtxId });
        } else {
            throw "whoops";
        }
    }
    return nodeTreeOps;
}
function parseMDL0_DrawBytecode(buffer) {
    var view = buffer.createDataView();
    var drawOps = [];
    var i = 0;
    while (true) {
        var op = view.getUint8(i);
        if (op === ByteCodeOp.RET) {
            break;
        } else if (op === ByteCodeOp.DRAW) {
            var matId = view.getUint16(i + 1);
            var shpId = view.getUint16(i + 3);
            var nodeId = view.getUint16(i + 5);
            i += 8;
            drawOps.push({ matId: matId, shpId: shpId, nodeId: nodeId });
        } else {
            throw "whoops";
        }
    }
    return drawOps;
}
function parseMDL0_SceneGraph(buffer, byteCodeResDic) {
    var nodeTreeResDicEntry = byteCodeResDic.find(function (entry) {
        return entry.name === "NodeTree";
    });
    util_1.assert(nodeTreeResDicEntry !== null);
    var nodeTreeBuffer = buffer.subarray(nodeTreeResDicEntry.offs);
    var nodeTreeOps = parseMDL0_NodeTreeBytecode(nodeTreeBuffer);
    var drawOpaOps = [];
    var drawOpaResDicEntry = byteCodeResDic.find(function (entry) {
        return entry.name === "DrawOpa";
    });
    if (drawOpaResDicEntry) {
        var drawOpaBuffer = buffer.subarray(drawOpaResDicEntry.offs);
        drawOpaOps = parseMDL0_DrawBytecode(drawOpaBuffer);
    }
    var drawXluOps = [];
    var drawXluResDicEntry = byteCodeResDic.find(function (entry) {
        return entry.name === "DrawXlu";
    });
    if (drawXluResDicEntry) {
        var drawXluBuffer = buffer.subarray(drawXluResDicEntry.offs);
        drawXluOps = parseMDL0_DrawBytecode(drawXluBuffer);
    }
    return { nodeTreeOps: nodeTreeOps, drawOpaOps: drawOpaOps, drawXluOps: drawXluOps };
}
function parseMDL0(buffer) {
    var e_1, _a, e_2, _b;
    var view = buffer.createDataView();
    util_1.assert(util_1.readString(buffer, 0x00, 0x04) === 'MDL0');
    var version = view.getUint32(0x08);
    var supportedVersions = [0x08, 0x0B];
    util_1.assert(supportedVersions.includes(version));
    var offs = 0x10;
    function nextResDic() {
        var resDic = parseResDic(buffer, view.getUint32(offs));
        offs += 0x04;
        return resDic;
    }
    var byteCodeResDic = nextResDic();
    var nodeResDic = nextResDic();
    var vtxPosResDic = nextResDic();
    var vtxNrmResDic = nextResDic();
    var vtxClrResDic = nextResDic();
    var vtxTxcResDic = nextResDic();
    if (version >= 0x0A) {
        var furVecResDic = nextResDic();
        var furPosResDic = nextResDic();
    }
    var materialResDic = nextResDic();
    var tevResDic = nextResDic();
    var shpResDic = nextResDic();
    offs += 0x04; // Texture information
    offs += 0x04; // Palette information
    if (version >= 0x0A) {
        offs += 0x04; // User data
    }
    var nameOffs = view.getUint32(offs + 0x00);
    var name = util_1.readString(buffer, nameOffs);
    var infoOffs = offs + 0x04;
    var scalingRule = view.getUint32(infoOffs + 0x08);
    var texMtxMode = view.getUint32(infoOffs + 0x0C);
    var numVerts = view.getUint32(infoOffs + 0x10);
    var numPolygons = view.getUint32(infoOffs + 0x14);
    var isValidBBox = view.getUint8(infoOffs + 0x26);
    // TODO(jstpierre): Skyward Sword doesn't use this.
    var bbox = null;
    if (isValidBBox) {
        var bboxMinX = view.getFloat32(infoOffs + 0x28);
        var bboxMinY = view.getFloat32(infoOffs + 0x2C);
        var bboxMinZ = view.getFloat32(infoOffs + 0x30);
        var bboxMaxX = view.getFloat32(infoOffs + 0x34);
        var bboxMaxY = view.getFloat32(infoOffs + 0x38);
        var bboxMaxZ = view.getFloat32(infoOffs + 0x3C);
        bbox = new Camera_1.AABB(bboxMinX, bboxMinY, bboxMinZ, bboxMaxX, bboxMaxY, bboxMaxZ);
    }
    var materials = [];
    try {
        for (var materialResDic_1 = __values(materialResDic), materialResDic_1_1 = materialResDic_1.next(); !materialResDic_1_1.done; materialResDic_1_1 = materialResDic_1.next()) {
            var materialResDicEntry = materialResDic_1_1.value;
            var material = parseMDL0_MaterialEntry(buffer.subarray(materialResDicEntry.offs), version);
            util_1.assert(material.name === materialResDicEntry.name);
            materials.push(material);
        }
    } catch (e_1_1) {
        e_1 = { error: e_1_1 };
    } finally {
        try {
            if (materialResDic_1_1 && !materialResDic_1_1.done && (_a = materialResDic_1.return)) _a.call(materialResDic_1);
        } finally {
            if (e_1) throw e_1.error;
        }
    }
    var inputBuffers = parseInputVertexBuffers(buffer, vtxPosResDic, vtxNrmResDic, vtxClrResDic, vtxTxcResDic);
    var shapes = [];
    for (var i = 0; i < shpResDic.length; i++) {
        var shpResDicEntry = shpResDic[i];
        var shape = parseMDL0_ShapeEntry(buffer.subarray(shpResDicEntry.offs), inputBuffers);
        util_1.assert(shape.name === shpResDicEntry.name);
        shapes.push(shape);
    }
    var nodes = [];
    try {
        for (var nodeResDic_1 = __values(nodeResDic), nodeResDic_1_1 = nodeResDic_1.next(); !nodeResDic_1_1.done; nodeResDic_1_1 = nodeResDic_1.next()) {
            var nodeResDicEntry = nodeResDic_1_1.value;
            var node = parseMDL0_NodeEntry(buffer.subarray(nodeResDicEntry.offs));
            util_1.assert(node.name === nodeResDicEntry.name);
            nodes.push(node);
        }
    } catch (e_2_1) {
        e_2 = { error: e_2_1 };
    } finally {
        try {
            if (nodeResDic_1_1 && !nodeResDic_1_1.done && (_b = nodeResDic_1.return)) _b.call(nodeResDic_1);
        } finally {
            if (e_2) throw e_2.error;
        }
    }
    var sceneGraph = parseMDL0_SceneGraph(buffer, byteCodeResDic);
    return { name: name, bbox: bbox, materials: materials, shapes: shapes, nodes: nodes, sceneGraph: sceneGraph };
}
//#endregion
//#region Animation Core
var LoopMode;
(function (LoopMode) {
    LoopMode[LoopMode["ONCE"] = 0] = "ONCE";
    LoopMode[LoopMode["REPEAT"] = 1] = "REPEAT";
})(LoopMode = exports.LoopMode || (exports.LoopMode = {}));
var AnimationTrackType;
(function (AnimationTrackType) {
    AnimationTrackType[AnimationTrackType["LINEAR"] = 0] = "LINEAR";
    AnimationTrackType[AnimationTrackType["HERMITE"] = 1] = "HERMITE";
})(AnimationTrackType || (AnimationTrackType = {}));
function getAnimFrame(anim, frame) {
    // Be careful of floating point precision.
    var lastFrame = anim.duration;
    if (anim.loopMode === LoopMode.ONCE) {
        if (frame > lastFrame) frame = lastFrame;
        return frame;
    } else if (anim.loopMode === LoopMode.REPEAT) {
        while (frame > lastFrame) {
            frame -= lastFrame;
        }return frame;
    } else {
        throw "whoops";
    }
}
function lerp(k0, k1, t) {
    return k0 + (k1 - k0) * t;
}
function lerpPeriodic(k0, k1, t, kp) {
    if (kp === void 0) {
        kp = 180;
    }
    var ga = (k1 - k0) % kp;
    var g = 2 * ga % kp - ga;
    return k0 + g * t;
}
function sampleFloatAnimationTrackLinear(track, frame) {
    var frames = track.frames;
    var n = frames.length;
    if (n === 1) return frames[0];
    if (frame === 0) return frames[0];else if (frame > n - 1) return frames[n - 1];
    // Find the first frame.
    var idx0 = frame | 0;
    var k0 = frames[idx0];
    var idx1 = idx0 + 1;
    var k1 = frames[idx1];
    var t = frame - idx0;
    // Linear data is always used only with angles, so we always use periodic lerp here.
    return lerpPeriodic(k0, k1, t);
}
function cubicEval(cf0, cf1, cf2, cf3, t) {
    return ((cf0 * t + cf1) * t + cf2) * t + cf3;
}
function hermiteInterpolate(k0, k1, frame) {
    var length = k1.frame - k0.frame;
    var t = (frame - k0.frame) / length;
    var p0 = k0.value;
    var p1 = k1.value;
    var s0 = k0.tangent * length;
    var s1 = k1.tangent * length;
    var cf0 = p0 * 2 + p1 * -2 + s0 * 1 + s1 * 1;
    var cf1 = p0 * -3 + p1 * 3 + s0 * -2 + s1 * -1;
    var cf2 = p0 * 0 + p1 * 0 + s0 * 1 + s1 * 0;
    var cf3 = p0 * 1 + p1 * 0 + s0 * 0 + s1 * 0;
    return cubicEval(cf0, cf1, cf2, cf3, t);
}
function sampleFloatAnimationTrackHermite(track, frame) {
    var frames = track.frames;
    if (frames.length === 1) return frames[0].value;
    // Find the right-hand frame.
    var idx1 = 0;
    for (; idx1 < frames.length; idx1++) {
        if (frame < frames[idx1].frame) break;
    }
    if (idx1 === 0) return frames[0].value;else if (idx1 === frames.length) return frames[frames.length - 1].value;
    var idx0 = idx1 - 1;
    var k0 = frames[idx0];
    var k1 = frames[idx1];
    return hermiteInterpolate(k0, k1, frame);
}
function sampleFloatAnimationTrack(track, frame) {
    if (track.type === AnimationTrackType.LINEAR) return sampleFloatAnimationTrackLinear(track, frame);else if (track.type === AnimationTrackType.HERMITE) return sampleFloatAnimationTrackHermite(track, frame);else throw "whoops";
}
function makeConstantAnimationTrack(value) {
    return { type: AnimationTrackType.LINEAR, frames: Float32Array.of(value) };
}
function parseAnimationTrackC32(buffer, numKeyframes) {
    var frames = buffer.createTypedArray(Float32Array, 0x00, numKeyframes + 1, endian_1.Endianness.BIG_ENDIAN);
    return { type: AnimationTrackType.LINEAR, frames: frames };
}
function parseAnimationTrackF48(buffer) {
    var view = buffer.createDataView();
    var numKeyframes = view.getUint16(0x00);
    var invKeyframeRange = view.getFloat32(0x04);
    var scale = view.getFloat32(0x08);
    var offset = view.getFloat32(0x0C);
    var keyframeTableIdx = 0x10;
    var frames = [];
    for (var i = 0; i < numKeyframes; i++) {
        var frame = view.getInt16(keyframeTableIdx + 0x00) / 0x20; // S10.5
        var value = view.getUint16(keyframeTableIdx + 0x02) * scale + offset;
        var tangent = view.getInt16(keyframeTableIdx + 0x04) / 0x100; // S7.8
        var keyframe = { frame: frame, value: value, tangent: tangent };
        frames.push(keyframe);
        keyframeTableIdx += 0x06;
    }
    return { type: AnimationTrackType.HERMITE, frames: frames };
}
function parseAnimationTrackF96(buffer) {
    var view = buffer.createDataView();
    var numKeyframes = view.getUint16(0x00);
    var invKeyframeRange = view.getFloat32(0x04);
    var keyframeTableIdx = 0x08;
    var frames = [];
    for (var i = 0; i < numKeyframes; i++) {
        var frame = view.getFloat32(keyframeTableIdx + 0x00);
        var value = view.getFloat32(keyframeTableIdx + 0x04);
        var tangent = view.getFloat32(keyframeTableIdx + 0x08);
        var keyframe = { frame: frame, value: value, tangent: tangent };
        frames.push(keyframe);
        keyframeTableIdx += 0x0C;
    }
    return { type: AnimationTrackType.HERMITE, frames: frames };
}
var AnimationController = /** @class */function () {
    function AnimationController() {
        this.fps = 30;
    }
    AnimationController.prototype.getTimeInFrames = function () {
        var ms = this.timeMilliseconds;
        return ms / 1000 * this.fps;
    };
    AnimationController.prototype.updateTime = function (newTime) {
        this.timeMilliseconds = newTime;
    };
    return AnimationController;
}();
exports.AnimationController = AnimationController;
function stepF(f, maxt, step, callback) {
    for (var t = 0; t < maxt; t += step) {
        callback(t, f(t));
    }
}
var Graph = /** @class */function () {
    function Graph(ctx) {
        this.minv = undefined;
        this.maxv = undefined;
        this.ctx = ctx;
    }
    Graph.prototype.graphF = function (color, f, range) {
        var _this = this;
        var step = 1;
        stepF(f, range, step, function (t, v) {
            if (_this.minv === undefined) _this.minv = v;
            if (_this.maxv === undefined) _this.maxv = v;
            _this.minv = Math.min(_this.minv, v);
            _this.maxv = Math.max(_this.maxv, v);
        });
        // pad
        var displayMinV = this.minv;
        var displayMaxV = this.maxv;
        var ctx = this.ctx;
        var width = ctx.canvas.width;
        var height = ctx.canvas.height;
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.beginPath();
        stepF(f, range, step, function (t, v) {
            var xa = t / range * 1 / step;
            var ya = (v - displayMinV) / (displayMaxV - displayMinV);
            var x = xa * width;
            var y = (1 - ya) * height;
            ctx.lineTo(x, y);
        });
        ctx.stroke();
    };
    return Graph;
}();
function cv() {
    var canvas = document.createElement('canvas');
    canvas.width = 800;
    canvas.height = 400;
    var ctx = canvas.getContext('2d');
    ctx.fillStyle = 'white';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    canvas.style.position = 'absolute';
    canvas.style.top = '0';
    canvas.style.left = '0';
    [].forEach.call(document.querySelectorAll('canvas.cv'), function (e) {
        return document.body.removeChild(e);
    });
    canvas.classList.add('cv');
    document.body.appendChild(canvas);
    return ctx;
}
function findAnimationData_SRT0(srt0, materialName, texMtxIndex) {
    var matData = srt0.matAnimations.find(function (m) {
        return m.materialName === materialName;
    });
    if (matData === undefined) return null;
    var texData = matData.texAnimations[texMtxIndex];
    if (texData === undefined) return null;
    return texData;
}
function parseSRT0_TexData(buffer) {
    var view = buffer.createDataView();
    var Flags;
    (function (Flags) {
        Flags[Flags["SCALE_ONE"] = 2] = "SCALE_ONE";
        Flags[Flags["ROT_ZERO"] = 4] = "ROT_ZERO";
        Flags[Flags["TRANS_ZERO"] = 8] = "TRANS_ZERO";
        Flags[Flags["SCALE_UNIFORM"] = 16] = "SCALE_UNIFORM";
        Flags[Flags["SCALE_S_CONSTANT"] = 32] = "SCALE_S_CONSTANT";
        Flags[Flags["SCALE_T_CONSTANT"] = 64] = "SCALE_T_CONSTANT";
        Flags[Flags["ROT_CONSTANT"] = 128] = "ROT_CONSTANT";
        Flags[Flags["TRANS_S_CONSTANT"] = 256] = "TRANS_S_CONSTANT";
        Flags[Flags["TRANS_T_CONSTANT"] = 512] = "TRANS_T_CONSTANT";
    })(Flags || (Flags = {}));
    var flags = view.getUint32(0x00);
    var scaleS = null;
    var scaleT = null;
    var rotation = null;
    var translationS = null;
    var translationT = null;
    var animationTableIdx = 0x04;
    function nextAnimationTrack(isConstant) {
        var animationTrack;
        if (isConstant) {
            var value = view.getFloat32(animationTableIdx);
            animationTrack = makeConstantAnimationTrack(value);
        } else {
            // Relative to the table idx.
            var animationTrackOffs = animationTableIdx + view.getUint32(animationTableIdx);
            animationTrack = parseAnimationTrackF96(buffer.slice(animationTrackOffs));
        }
        animationTableIdx += 0x04;
        return animationTrack;
    }
    if (!(flags & Flags.SCALE_ONE)) scaleS = nextAnimationTrack(!!(flags & Flags.SCALE_S_CONSTANT));
    if (!(flags & Flags.SCALE_UNIFORM)) scaleT = nextAnimationTrack(!!(flags & Flags.SCALE_T_CONSTANT));else scaleT = scaleS;
    if (!(flags & Flags.ROT_ZERO)) rotation = nextAnimationTrack(!!(flags & Flags.ROT_CONSTANT));
    if (!(flags & Flags.TRANS_ZERO)) {
        translationS = nextAnimationTrack(!!(flags & Flags.TRANS_S_CONSTANT));
        translationT = nextAnimationTrack(!!(flags & Flags.TRANS_T_CONSTANT));
    }
    return { scaleS: scaleS, scaleT: scaleT, rotation: rotation, translationS: translationS, translationT: translationT };
}
function parseSRT0_MatData(buffer) {
    var view = buffer.createDataView();
    var materialNameOffs = view.getUint32(0x00);
    var materialName = util_1.readString(buffer, materialNameOffs);
    var texFlags = view.getUint32(0x04);
    var indFlags = view.getUint32(0x08);
    var flags = indFlags << 8 | texFlags;
    var texAnimationTableIdx = 0x0C;
    var texAnimations = [];
    // 8 normal animations, 4 indtex animations
    for (var i = 0; i < TexMtxIndex.COUNT; i++) {
        if (!(flags & 1 << i)) continue;
        var texAnimationOffs = view.getUint32(texAnimationTableIdx);
        texAnimationTableIdx += 0x04;
        texAnimations[i] = parseSRT0_TexData(buffer.slice(texAnimationOffs));
    }
    return { materialName: materialName, texAnimations: texAnimations };
}
function parseSRT0(buffer) {
    var e_3, _a;
    var view = buffer.createDataView();
    util_1.assert(util_1.readString(buffer, 0x00, 0x04) === 'SRT0');
    var version = view.getUint32(0x08);
    var supportedVersions = [0x04, 0x05];
    util_1.assert(supportedVersions.includes(version));
    var texSrtMatDataResDicOffs = view.getUint32(0x10);
    var texSrtMatDataResDic = parseResDic(buffer, texSrtMatDataResDicOffs);
    var offs = 0x14;
    if (version >= 0x05) {
        // user data
        offs += 0x04;
    }
    var nameOffs = view.getUint32(offs + 0x00);
    var name = util_1.readString(buffer, nameOffs);
    var duration = view.getUint16(offs + 0x08);
    var numMaterials = view.getUint16(offs + 0x0A);
    var texMtxMode = view.getUint32(offs + 0x0C);
    var loopMode = view.getUint32(offs + 0x10);
    var matAnimations = [];
    try {
        for (var texSrtMatDataResDic_1 = __values(texSrtMatDataResDic), texSrtMatDataResDic_1_1 = texSrtMatDataResDic_1.next(); !texSrtMatDataResDic_1_1.done; texSrtMatDataResDic_1_1 = texSrtMatDataResDic_1.next()) {
            var texSrtMatEntry = texSrtMatDataResDic_1_1.value;
            var matData = parseSRT0_MatData(buffer.slice(texSrtMatEntry.offs));
            matAnimations.push(matData);
        }
    } catch (e_3_1) {
        e_3 = { error: e_3_1 };
    } finally {
        try {
            if (texSrtMatDataResDic_1_1 && !texSrtMatDataResDic_1_1.done && (_a = texSrtMatDataResDic_1.return)) _a.call(texSrtMatDataResDic_1);
        } finally {
            if (e_3) throw e_3.error;
        }
    }
    util_1.assert(matAnimations.length === numMaterials);
    return { name: name, loopMode: loopMode, duration: duration, texMtxMode: texMtxMode, matAnimations: matAnimations };
}
var SRT0TexMtxAnimator = /** @class */function () {
    function SRT0TexMtxAnimator(animationController, srt0, texData) {
        this.animationController = animationController;
        this.srt0 = srt0;
        this.texData = texData;
        this.scratch = gl_matrix_1.mat4.create();
    }
    SRT0TexMtxAnimator.prototype._calcTexMtx = function (dst, texMtxMode) {
        var texData = this.texData;
        var frame = this.animationController.getTimeInFrames();
        var animFrame = getAnimFrame(this.srt0, frame);
        var scaleS = texData.scaleS ? sampleFloatAnimationTrack(texData.scaleS, animFrame) : 1;
        var scaleT = texData.scaleT ? sampleFloatAnimationTrack(texData.scaleT, animFrame) : 1;
        var rotation = texData.rotation ? sampleFloatAnimationTrack(texData.rotation, animFrame) : 0;
        var translationS = texData.translationS ? sampleFloatAnimationTrack(texData.translationS, animFrame) : 0;
        var translationT = texData.translationS ? sampleFloatAnimationTrack(texData.translationT, animFrame) : 0;
        calcTexMtx(dst, texMtxMode, scaleS, scaleT, rotation, translationS, translationT);
    };
    SRT0TexMtxAnimator.prototype.calcIndTexMtx = function (dst) {
        this._calcTexMtx(this.scratch, TexMatrixMode.BASIC);
        calc2dMtx(dst, this.scratch);
    };
    SRT0TexMtxAnimator.prototype.calcTexMtx = function (dst) {
        this._calcTexMtx(dst, this.srt0.texMtxMode);
    };
    return SRT0TexMtxAnimator;
}();
exports.SRT0TexMtxAnimator = SRT0TexMtxAnimator;
var TexMtxIndex;
(function (TexMtxIndex) {
    // Texture.
    TexMtxIndex[TexMtxIndex["TEX0"] = 0] = "TEX0";
    TexMtxIndex[TexMtxIndex["TEX1"] = 1] = "TEX1";
    TexMtxIndex[TexMtxIndex["TEX2"] = 2] = "TEX2";
    TexMtxIndex[TexMtxIndex["TEX3"] = 3] = "TEX3";
    TexMtxIndex[TexMtxIndex["TEX4"] = 4] = "TEX4";
    TexMtxIndex[TexMtxIndex["TEX5"] = 5] = "TEX5";
    TexMtxIndex[TexMtxIndex["TEX6"] = 6] = "TEX6";
    TexMtxIndex[TexMtxIndex["TEX7"] = 7] = "TEX7";
    // Indirect.
    TexMtxIndex[TexMtxIndex["IND0"] = 8] = "IND0";
    TexMtxIndex[TexMtxIndex["IND1"] = 9] = "IND1";
    TexMtxIndex[TexMtxIndex["IND2"] = 10] = "IND2";
    TexMtxIndex[TexMtxIndex["COUNT"] = 11] = "COUNT";
})(TexMtxIndex = exports.TexMtxIndex || (exports.TexMtxIndex = {}));
function bindSRT0Animator(animationController, srt0, materialName, texMtxIndex) {
    var texData = findAnimationData_SRT0(srt0, materialName, texMtxIndex);
    if (texData === null) return null;
    return new SRT0TexMtxAnimator(animationController, srt0, texData);
}
exports.bindSRT0Animator = bindSRT0Animator;
function findAnimationData_PAT0(pat0, materialName, texMapID) {
    var matData = pat0.matAnimations.find(function (m) {
        return m.materialName === materialName;
    });
    if (matData === undefined) return null;
    var texData = matData.texAnimations[texMapID];
    if (texData === undefined) return null;
    return texData;
}
function parsePAT0_MatData(buffer) {
    var view = buffer.createDataView();
    var materialNameOffs = view.getUint32(0x00);
    var materialName = util_1.readString(buffer, materialNameOffs);
    var flags = view.getUint32(0x04);
    var Flags;
    (function (Flags) {
        Flags[Flags["EXISTS"] = 1] = "EXISTS";
        Flags[Flags["CONSTANT"] = 2] = "CONSTANT";
        Flags[Flags["TEX_EXISTS"] = 4] = "TEX_EXISTS";
        Flags[Flags["PAL_EXISTS"] = 8] = "PAL_EXISTS";
    })(Flags || (Flags = {}));
    ;
    function parseAnimationTrackPAT0_TexFrameData(buffer) {
        var view = buffer.createDataView();
        var numKeyframes = view.getUint16(0x00);
        var invKeyframeRange = view.getFloat32(0x04);
        var keyframeTableIdx = 0x08;
        var frames = [];
        for (var i = 0; i < numKeyframes; i++) {
            var frame = view.getFloat32(keyframeTableIdx + 0x00);
            var texIndex = view.getUint16(keyframeTableIdx + 0x04);
            var palIndex = view.getUint16(keyframeTableIdx + 0x06);
            var keyframe = { frame: frame, texIndex: texIndex, palIndex: palIndex };
            frames.push(keyframe);
            keyframeTableIdx += 0x08;
        }
        return frames;
    }
    var animationTableIdx = 0x08;
    function nextAnimationTrack(isConstant) {
        var animationTrack;
        if (isConstant) {
            var texIndex = view.getUint16(animationTableIdx + 0x00);
            var palIndex = view.getUint16(animationTableIdx + 0x02);
            animationTrack = [{ frame: 0, texIndex: texIndex, palIndex: palIndex }];
        } else {
            var animationTrackOffs = view.getUint32(animationTableIdx);
            animationTrack = parseAnimationTrackPAT0_TexFrameData(buffer.slice(animationTrackOffs));
        }
        animationTableIdx += 0x04;
        return animationTrack;
    }
    var texAnimations = [];
    for (var i = 0; i < 8; i++) {
        var texFlags = flags >>> i * 4 & 0x0F;
        if (!(texFlags & Flags.EXISTS)) continue;
        var texIndexValid = !!(texFlags & Flags.TEX_EXISTS);
        var palIndexValid = !!(texFlags & Flags.PAL_EXISTS);
        var isConstant = !!(texFlags & Flags.CONSTANT);
        util_1.assert(texIndexValid && !palIndexValid);
        var animationTrack = nextAnimationTrack(isConstant);
        texAnimations[i] = { animationTrack: animationTrack, texIndexValid: texIndexValid, palIndexValid: palIndexValid };
    }
    return { materialName: materialName, texAnimations: texAnimations };
}
function parsePAT0(buffer) {
    var e_4, _a;
    var view = buffer.createDataView();
    util_1.assert(util_1.readString(buffer, 0x00, 0x04) === 'PAT0');
    var version = view.getUint32(0x08);
    var supportedVersions = [0x04];
    util_1.assert(supportedVersions.includes(version));
    var texPatMatDataResDicOffs = view.getUint32(0x10);
    var texPatMatDataResDic = parseResDic(buffer, texPatMatDataResDicOffs);
    var texNameOffsetTableOffs = view.getUint32(0x14);
    var palNameOffsetTableOffs = view.getUint32(0x18);
    var offs = 0x24;
    if (version >= 0x04) {
        // user data
        offs += 0x04;
    }
    var nameOffs = view.getUint32(offs + 0x00);
    var name = util_1.readString(buffer, nameOffs);
    var duration = view.getUint16(offs + 0x08);
    var numMaterials = view.getUint16(offs + 0x0A);
    var numTexNames = view.getUint16(offs + 0x0C);
    var numPalNames = view.getUint16(offs + 0x0E);
    var loopMode = view.getUint32(offs + 0x10);
    util_1.assert(numPalNames === 0);
    var matAnimations = [];
    try {
        for (var texPatMatDataResDic_1 = __values(texPatMatDataResDic), texPatMatDataResDic_1_1 = texPatMatDataResDic_1.next(); !texPatMatDataResDic_1_1.done; texPatMatDataResDic_1_1 = texPatMatDataResDic_1.next()) {
            var texPatMatEntry = texPatMatDataResDic_1_1.value;
            var matData = parsePAT0_MatData(buffer.slice(texPatMatEntry.offs));
            matAnimations.push(matData);
        }
    } catch (e_4_1) {
        e_4 = { error: e_4_1 };
    } finally {
        try {
            if (texPatMatDataResDic_1_1 && !texPatMatDataResDic_1_1.done && (_a = texPatMatDataResDic_1.return)) _a.call(texPatMatDataResDic_1);
        } finally {
            if (e_4) throw e_4.error;
        }
    }
    util_1.assert(matAnimations.length === numMaterials);
    var texNames = [];
    var texNameOffsetTableIdx = texNameOffsetTableOffs;
    for (var i = 0; i < numTexNames; i++) {
        var nameOffs_1 = view.getUint32(texNameOffsetTableIdx);
        var texName = util_1.readString(buffer, texNameOffsetTableOffs + nameOffs_1);
        texNames.push(texName);
        texNameOffsetTableIdx += 0x04;
    }
    return { name: name, loopMode: loopMode, duration: duration, matAnimations: matAnimations, texNames: texNames };
}
function findFrameData(frames, frame) {
    if (frames.length === 1) return frames[0];
    // Find the left-hand frame.
    var idx0 = frames.length;
    while (idx0-- > 0) {
        if (frame > frames[idx0].frame) break;
    }
    return frames[idx0];
}
var PAT0TexAnimator = /** @class */function () {
    function PAT0TexAnimator(animationController, pat0, texData) {
        this.animationController = animationController;
        this.pat0 = pat0;
        this.texData = texData;
    }
    PAT0TexAnimator.prototype.calcTextureMapping = function (textureMapping, textureHolder) {
        var texData = this.texData;
        var frame = this.animationController.getTimeInFrames();
        var animFrame = getAnimFrame(this.pat0, frame);
        var texFrameData = findFrameData(texData.animationTrack, animFrame);
        if (texData.texIndexValid) {
            var texName = this.pat0.texNames[texFrameData.texIndex];
            textureHolder.fillTextureMapping(textureMapping, texName);
        }
    };
    return PAT0TexAnimator;
}();
exports.PAT0TexAnimator = PAT0TexAnimator;
function bindPAT0Animator(animationController, pat0, materialName, texMapID) {
    var texData = findAnimationData_PAT0(pat0, materialName, texMapID);
    if (texData === null) return null;
    return new PAT0TexAnimator(animationController, pat0, texData);
}
exports.bindPAT0Animator = bindPAT0Animator;
//#endregion
//#region CLR0
var AnimatableColor;
(function (AnimatableColor) {
    AnimatableColor[AnimatableColor["MAT0"] = 0] = "MAT0";
    AnimatableColor[AnimatableColor["MAT1"] = 1] = "MAT1";
    AnimatableColor[AnimatableColor["AMB0"] = 2] = "AMB0";
    AnimatableColor[AnimatableColor["AMB1"] = 3] = "AMB1";
    AnimatableColor[AnimatableColor["C0"] = 4] = "C0";
    AnimatableColor[AnimatableColor["C1"] = 5] = "C1";
    AnimatableColor[AnimatableColor["C2"] = 6] = "C2";
    AnimatableColor[AnimatableColor["K0"] = 7] = "K0";
    AnimatableColor[AnimatableColor["K1"] = 8] = "K1";
    AnimatableColor[AnimatableColor["K2"] = 9] = "K2";
    AnimatableColor[AnimatableColor["K3"] = 10] = "K3";
    AnimatableColor[AnimatableColor["COUNT"] = 11] = "COUNT";
})(AnimatableColor = exports.AnimatableColor || (exports.AnimatableColor = {}));
function findAnimationData_CLR0(clr0, materialName, color) {
    var matData = clr0.matAnimations.find(function (m) {
        return m.materialName === materialName;
    });
    if (matData === undefined) return null;
    var clrData = matData.clrAnimations[color];
    if (clrData === undefined) return null;
    return clrData;
}
function parseColorDataFrames(buffer, numKeyframes, isConstant) {
    var view = buffer.createDataView();
    var frames;
    if (isConstant) {
        var color = view.getUint32(0x00);
        return Uint32Array.of(color);
    } else {
        var animationTrackOffs = view.getUint32(0x00);
        return buffer.createTypedArray(Uint32Array, animationTrackOffs, numKeyframes + 1, endian_1.Endianness.BIG_ENDIAN);
    }
}
function parseCLR0_MatData(buffer, numKeyframes) {
    var view = buffer.createDataView();
    var materialNameOffs = view.getUint32(0x00);
    var materialName = util_1.readString(buffer, materialNameOffs);
    var flags = view.getUint32(0x04);
    var Flags;
    (function (Flags) {
        Flags[Flags["EXISTS"] = 1] = "EXISTS";
        Flags[Flags["CONSTANT"] = 2] = "CONSTANT";
    })(Flags || (Flags = {}));
    ;
    var animationTableIdx = 0x08;
    function nextColorData(isConstant) {
        var mask = view.getUint32(animationTableIdx + 0x00);
        var frames = parseColorDataFrames(buffer.slice(animationTableIdx + 0x04), numKeyframes, isConstant);
        animationTableIdx += 0x08;
        return { mask: mask, frames: frames };
    }
    var clrAnimations = [];
    for (var i = 0; i < AnimatableColor.COUNT; i++) {
        var clrFlags = flags >>> i * 2 & 0x03;
        if (!(clrFlags & Flags.EXISTS)) continue;
        var isConstant = !!(clrFlags & Flags.CONSTANT);
        clrAnimations[i] = nextColorData(isConstant);
    }
    return { materialName: materialName, clrAnimations: clrAnimations };
}
function parseCLR0(buffer) {
    var e_5, _a;
    var view = buffer.createDataView();
    util_1.assert(util_1.readString(buffer, 0x00, 0x04) === 'CLR0');
    var version = view.getUint32(0x08);
    var supportedVersions = [0x03, 0x04];
    util_1.assert(supportedVersions.includes(version));
    var clrMatDataResDicOffs = view.getUint32(0x10);
    var clrMatDataResDic = parseResDic(buffer, clrMatDataResDicOffs);
    var offs = 0x14;
    if (version >= 0x04) {
        // user data
        offs += 0x04;
    }
    var nameOffs = view.getUint32(offs + 0x00);
    var name = util_1.readString(buffer, nameOffs);
    var duration = view.getUint16(offs + 0x08);
    var numMaterials = view.getUint16(offs + 0x0A);
    var loopMode = view.getUint32(offs + 0x0C);
    var matAnimations = [];
    try {
        for (var clrMatDataResDic_1 = __values(clrMatDataResDic), clrMatDataResDic_1_1 = clrMatDataResDic_1.next(); !clrMatDataResDic_1_1.done; clrMatDataResDic_1_1 = clrMatDataResDic_1.next()) {
            var clrMatEntry = clrMatDataResDic_1_1.value;
            var matData = parseCLR0_MatData(buffer.slice(clrMatEntry.offs), duration);
            matAnimations.push(matData);
        }
    } catch (e_5_1) {
        e_5 = { error: e_5_1 };
    } finally {
        try {
            if (clrMatDataResDic_1_1 && !clrMatDataResDic_1_1.done && (_a = clrMatDataResDic_1.return)) _a.call(clrMatDataResDic_1);
        } finally {
            if (e_5) throw e_5.error;
        }
    }
    util_1.assert(matAnimations.length === numMaterials);
    return { name: name, loopMode: loopMode, duration: duration, matAnimations: matAnimations };
}
function lerpColor(k0, k1, t) {
    var k0r = k0 >>> 24 & 0xFF;
    var k0g = k0 >>> 16 & 0xFF;
    var k0b = k0 >>> 8 & 0xFF;
    var k0a = k0 >>> 0 & 0xFF;
    var k1r = k1 >>> 24 & 0xFF;
    var k1g = k1 >>> 16 & 0xFF;
    var k1b = k1 >>> 8 & 0xFF;
    var k1a = k1 >>> 0 & 0xFF;
    var r = lerp(k0r, k1r, t);
    var g = lerp(k0g, k1g, t);
    var b = lerp(k0b, k1b, t);
    var a = lerp(k0a, k1a, t);
    return r << 24 | g << 16 | b << 8 | a;
}
function sampleColorData(frames, frame) {
    var n = frames.length;
    if (n === 1) return frames[0];
    if (frame === 0) return frames[0];else if (frame > n - 1) return frames[n - 1];
    // Find the first frame.
    var idx0 = frame | 0;
    var k0 = frames[idx0];
    var idx1 = idx0 + 1;
    var k1 = frames[idx1];
    var t = frame - idx0;
    return lerpColor(k0, k1, t);
}
var CLR0ColorAnimator = /** @class */function () {
    function CLR0ColorAnimator(animationController, clr0, clrData) {
        this.animationController = animationController;
        this.clr0 = clr0;
        this.clrData = clrData;
    }
    CLR0ColorAnimator.prototype.calcColor = function (dst, orig) {
        var clrData = this.clrData;
        var frame = this.animationController.getTimeInFrames();
        var animFrame = getAnimFrame(this.clr0, frame);
        var animColor = sampleColorData(clrData.frames, animFrame);
        var c = orig.get32() & clrData.mask | animColor;
        dst.copy32(c);
    };
    return CLR0ColorAnimator;
}();
exports.CLR0ColorAnimator = CLR0ColorAnimator;
function bindCLR0Animator(animationController, clr0, materialName, color) {
    var clrData = findAnimationData_CLR0(clr0, materialName, color);
    if (clrData === null) return null;
    return new CLR0ColorAnimator(animationController, clr0, clrData);
}
exports.bindCLR0Animator = bindCLR0Animator;
function parseCHR0_NodeData(buffer, numKeyframes) {
    var Flags;
    (function (Flags) {
        Flags[Flags["IDENTITY"] = 2] = "IDENTITY";
        Flags[Flags["RT_ZERO"] = 4] = "RT_ZERO";
        Flags[Flags["SCALE_ONE"] = 8] = "SCALE_ONE";
        Flags[Flags["SCALE_UNIFORM"] = 16] = "SCALE_UNIFORM";
        Flags[Flags["ROTATE_ZERO"] = 32] = "ROTATE_ZERO";
        Flags[Flags["TRANS_ZERO"] = 64] = "TRANS_ZERO";
        Flags[Flags["SCALE_USE_MODEL"] = 128] = "SCALE_USE_MODEL";
        Flags[Flags["ROTATE_USE_MODEL"] = 256] = "ROTATE_USE_MODEL";
        Flags[Flags["TRANS_USE_MODEL"] = 512] = "TRANS_USE_MODEL";
        Flags[Flags["SCALE_COMPENSATE_APPLY"] = 1024] = "SCALE_COMPENSATE_APPLY";
        Flags[Flags["SCALE_COMPENSATE_PARENT"] = 2048] = "SCALE_COMPENSATE_PARENT";
        Flags[Flags["CLASSIC_SCALE_OFF"] = 4096] = "CLASSIC_SCALE_OFF";
        Flags[Flags["SCALE_X_CONSTANT"] = 8192] = "SCALE_X_CONSTANT";
        Flags[Flags["SCALE_Y_CONSTANT"] = 16384] = "SCALE_Y_CONSTANT";
        Flags[Flags["SCALE_Z_CONSTANT"] = 32768] = "SCALE_Z_CONSTANT";
        Flags[Flags["ROTATE_X_CONSTANT"] = 65536] = "ROTATE_X_CONSTANT";
        Flags[Flags["ROTATE_Y_CONSTANT"] = 131072] = "ROTATE_Y_CONSTANT";
        Flags[Flags["ROTATE_Z_CONSTANT"] = 262144] = "ROTATE_Z_CONSTANT";
        Flags[Flags["TRANS_X_CONSTANT"] = 524288] = "TRANS_X_CONSTANT";
        Flags[Flags["TRANS_Y_CONSTANT"] = 1048576] = "TRANS_Y_CONSTANT";
        Flags[Flags["TRANS_Z_CONSTANT"] = 2097152] = "TRANS_Z_CONSTANT";
        Flags[Flags["REQUIRE_SCALE"] = 4194304] = "REQUIRE_SCALE";
        Flags[Flags["REQUIRE_ROTATE"] = 8388608] = "REQUIRE_ROTATE";
        Flags[Flags["REQUIRE_TRANS"] = 16777216] = "REQUIRE_TRANS";
        Flags[Flags["SCALE_NOT_EXIST"] = 138] = "SCALE_NOT_EXIST";
        Flags[Flags["ROTATE_NOT_EXIST"] = 294] = "ROTATE_NOT_EXIST";
        Flags[Flags["TRANS_NOT_EXIST"] = 582] = "TRANS_NOT_EXIST";
    })(Flags || (Flags = {}));
    ;
    var TrackFormat;
    (function (TrackFormat) {
        TrackFormat[TrackFormat["CONSTANT"] = 0] = "CONSTANT";
        TrackFormat[TrackFormat["_32"] = 1] = "_32";
        TrackFormat[TrackFormat["_48"] = 2] = "_48";
        TrackFormat[TrackFormat["_96"] = 3] = "_96";
        TrackFormat[TrackFormat["FRM_8"] = 4] = "FRM_8";
        TrackFormat[TrackFormat["FRM_16"] = 5] = "FRM_16";
        TrackFormat[TrackFormat["FRM_32"] = 6] = "FRM_32";
    })(TrackFormat || (TrackFormat = {}));
    ;
    var view = buffer.createDataView();
    var nodeNameOffs = view.getUint32(0x00);
    var nodeName = util_1.readString(buffer, nodeNameOffs);
    var flags = view.getUint32(0x04);
    var animationTableIdx = 0x08;
    function nextAnimationTrack(trackFormat, isConstant) {
        var animationTrack;
        if (isConstant || trackFormat === TrackFormat.CONSTANT) {
            var value = view.getFloat32(animationTableIdx);
            animationTrack = makeConstantAnimationTrack(value);
        } else if (trackFormat === TrackFormat._96) {
            // Relative to the beginning of the node.
            var animationTrackOffs = view.getUint32(animationTableIdx);
            animationTrack = parseAnimationTrackF96(buffer.slice(animationTrackOffs));
        } else if (trackFormat === TrackFormat._48) {
            var animationTrackOffs = view.getUint32(animationTableIdx);
            animationTrack = parseAnimationTrackF48(buffer.slice(animationTrackOffs));
        } else if (trackFormat === TrackFormat.FRM_32) {
            var animationTrackOffs = view.getUint32(animationTableIdx);
            animationTrack = parseAnimationTrackC32(buffer.slice(animationTrackOffs), numKeyframes);
        } else {
            console.warn("Unsupported animation track format", trackFormat);
            animationTrack = null;
        }
        animationTableIdx += 0x04;
        return animationTrack;
    }
    var scaleFormat = flags >>> 25 & 0x03;
    var rotationFormat = flags >>> 27 & 0x07;
    var translationFormat = flags >>> 30 & 0x03;
    var scaleX = null,
        scaleY = null,
        scaleZ = null;
    if (!(flags & Flags.SCALE_NOT_EXIST)) scaleX = nextAnimationTrack(scaleFormat, !!(flags & Flags.SCALE_X_CONSTANT));
    if (!(flags & Flags.SCALE_UNIFORM)) {
        scaleY = nextAnimationTrack(scaleFormat, !!(flags & Flags.SCALE_Y_CONSTANT));
        scaleZ = nextAnimationTrack(scaleFormat, !!(flags & Flags.SCALE_Z_CONSTANT));
    } else {
        scaleY = scaleX;
        scaleZ = scaleX;
    }
    var rotationX = null,
        rotationY = null,
        rotationZ = null;
    if (!(flags & Flags.ROTATE_NOT_EXIST)) {
        rotationX = nextAnimationTrack(rotationFormat, !!(flags & Flags.ROTATE_X_CONSTANT));
        rotationY = nextAnimationTrack(rotationFormat, !!(flags & Flags.ROTATE_Y_CONSTANT));
        rotationZ = nextAnimationTrack(rotationFormat, !!(flags & Flags.ROTATE_Z_CONSTANT));
    }
    var translationX = null,
        translationY = null,
        translationZ = null;
    if (!(flags & Flags.TRANS_NOT_EXIST)) {
        translationX = nextAnimationTrack(translationFormat, !!(flags & Flags.TRANS_X_CONSTANT));
        translationY = nextAnimationTrack(translationFormat, !!(flags & Flags.TRANS_Y_CONSTANT));
        translationZ = nextAnimationTrack(translationFormat, !!(flags & Flags.TRANS_Z_CONSTANT));
    }
    return {
        nodeName: nodeName,
        scaleX: scaleX, scaleY: scaleY, scaleZ: scaleZ,
        rotationX: rotationX, rotationY: rotationY, rotationZ: rotationZ,
        translationX: translationX, translationY: translationY, translationZ: translationZ
    };
}
function parseCHR0(buffer) {
    var e_6, _a;
    var view = buffer.createDataView();
    util_1.assert(util_1.readString(buffer, 0x00, 0x04) === 'CHR0');
    var version = view.getUint32(0x08);
    var supportedVersions = [0x03, 0x05];
    util_1.assert(supportedVersions.includes(version));
    var chrNodeDataResDicOffs = view.getUint32(0x10);
    var chrNodeDataResDic = parseResDic(buffer, chrNodeDataResDicOffs);
    var offs = 0x14;
    if (version >= 0x05) {
        // user data
        offs += 0x04;
    }
    var nameOffs = view.getUint32(offs + 0x00);
    var name = util_1.readString(buffer, nameOffs);
    var duration = view.getUint16(offs + 0x08);
    var numNodes = view.getUint16(offs + 0x0A);
    var loopMode = view.getUint32(offs + 0x0C);
    var scalingRule = view.getUint32(offs + 0x10);
    var nodeAnimations = [];
    try {
        for (var chrNodeDataResDic_1 = __values(chrNodeDataResDic), chrNodeDataResDic_1_1 = chrNodeDataResDic_1.next(); !chrNodeDataResDic_1_1.done; chrNodeDataResDic_1_1 = chrNodeDataResDic_1.next()) {
            var chrNodeEntry = chrNodeDataResDic_1_1.value;
            var nodeData = parseCHR0_NodeData(buffer.slice(chrNodeEntry.offs), duration);
            nodeAnimations.push(nodeData);
        }
    } catch (e_6_1) {
        e_6 = { error: e_6_1 };
    } finally {
        try {
            if (chrNodeDataResDic_1_1 && !chrNodeDataResDic_1_1.done && (_a = chrNodeDataResDic_1.return)) _a.call(chrNodeDataResDic_1);
        } finally {
            if (e_6) throw e_6.error;
        }
    }
    util_1.assert(nodeAnimations.length === numNodes);
    return { name: name, loopMode: loopMode, duration: duration, nodeAnimations: nodeAnimations };
}
var CHR0NodesAnimator = /** @class */function () {
    function CHR0NodesAnimator(animationController, chr0, nodeData) {
        this.animationController = animationController;
        this.chr0 = chr0;
        this.nodeData = nodeData;
        this.disabled = [];
        this.vizNodeId = undefined;
    }
    CHR0NodesAnimator.prototype.viz = function (nodeId) {
        this.vizNodeId = nodeId;
        this.vizGraph = new Graph(cv());
    };
    CHR0NodesAnimator.prototype.updviz = function (animFrame, nodeData) {
        var _this = this;
        var numFrames = this.chr0.duration;
        var ctx = this.vizGraph.ctx;
        var scale = 10;
        var maxt = numFrames / scale | 0;
        var offt = animFrame - maxt / 2;
        ctx.fillStyle = 'white';
        ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
        if (nodeData.rotationX) {
            this.vizGraph.graphF('red', function (t) {
                var animFrame = getAnimFrame(_this.chr0, t + offt);
                return sampleFloatAnimationTrack(nodeData.rotationX, animFrame);
            }, maxt);
        }
        if (nodeData.rotationY) {
            this.vizGraph.graphF('green', function (t) {
                var animFrame = getAnimFrame(_this.chr0, t + offt);
                return sampleFloatAnimationTrack(nodeData.rotationY, animFrame);
            }, maxt);
        }
        if (nodeData.rotationZ) {
            this.vizGraph.graphF('blue', function (t) {
                var animFrame = getAnimFrame(_this.chr0, t + offt);
                return sampleFloatAnimationTrack(nodeData.rotationZ, animFrame);
            }, maxt);
        }
        // const xa = (animFrame / numFrames) * ctx.canvas.width;
        var xa = 0.5 * ctx.canvas.width;
        ctx.beginPath();
        ctx.strokeStyle = 'black';
        ctx.lineTo(xa, 0);
        ctx.lineTo(xa, ctx.canvas.height);
        ctx.stroke();
    };
    CHR0NodesAnimator.prototype.calcModelMtx = function (dst, nodeId) {
        var nodeData = this.nodeData[nodeId];
        if (!nodeData) return false;
        if (this.disabled[nodeId]) return false;
        var frame = this.animationController.getTimeInFrames();
        var animFrame = getAnimFrame(this.chr0, frame);
        if (this.vizNodeId === nodeId) this.updviz(animFrame, nodeData);
        var scaleX = nodeData.scaleX ? sampleFloatAnimationTrack(nodeData.scaleX, animFrame) : 1;
        var scaleY = nodeData.scaleY ? sampleFloatAnimationTrack(nodeData.scaleY, animFrame) : 1;
        var scaleZ = nodeData.scaleZ ? sampleFloatAnimationTrack(nodeData.scaleZ, animFrame) : 1;
        var rotationX = nodeData.rotationX ? sampleFloatAnimationTrack(nodeData.rotationX, animFrame) : 0;
        var rotationY = nodeData.rotationY ? sampleFloatAnimationTrack(nodeData.rotationY, animFrame) : 0;
        var rotationZ = nodeData.rotationZ ? sampleFloatAnimationTrack(nodeData.rotationZ, animFrame) : 0;
        var translationX = nodeData.translationX ? sampleFloatAnimationTrack(nodeData.translationX, animFrame) : 0;
        var translationY = nodeData.translationY ? sampleFloatAnimationTrack(nodeData.translationY, animFrame) : 0;
        var translationZ = nodeData.translationZ ? sampleFloatAnimationTrack(nodeData.translationZ, animFrame) : 0;
        calcModelMtx(dst, scaleX, scaleY, scaleZ, rotationX, rotationY, rotationZ, translationX, translationY, translationZ);
        return true;
    };
    return CHR0NodesAnimator;
}();
exports.CHR0NodesAnimator = CHR0NodesAnimator;
function bindCHR0Animator(animationController, chr0, nodes) {
    var e_7, _a;
    var nodeData = [];
    var _loop_1 = function _loop_1(nodeAnimation) {
        var node = nodes.find(function (node) {
            return node.name === nodeAnimation.nodeName;
        });
        if (!node) return "continue";
        nodeData[node.id] = nodeAnimation;
    };
    try {
        for (var _b = __values(chr0.nodeAnimations), _c = _b.next(); !_c.done; _c = _b.next()) {
            var nodeAnimation = _c.value;
            _loop_1(nodeAnimation);
        }
    } catch (e_7_1) {
        e_7 = { error: e_7_1 };
    } finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        } finally {
            if (e_7) throw e_7.error;
        }
    }
    // No nodes found.
    if (nodeData.length === 0) return null;
    return new CHR0NodesAnimator(animationController, chr0, nodeData);
}
exports.bindCHR0Animator = bindCHR0Animator;
function parse(buffer) {
    var e_8, _a, e_9, _b, e_10, _c, e_11, _d, e_12, _e, e_13, _f;
    var view = buffer.createDataView();
    util_1.assert(util_1.readString(buffer, 0x00, 0x04) === 'bres');
    var littleEndian;
    switch (view.getUint16(0x04, false)) {
        case 0xFEFF:
            littleEndian = false;
            break;
        case 0xFFFE:
            littleEndian = true;
            break;
        default:
            throw new Error("Invalid BOM");
    }
    util_1.assert(!littleEndian);
    var fileLength = view.getUint32(0x08);
    var rootSectionOffs = view.getUint16(0x0C);
    var numSections = view.getUint16(0x0E);
    // Parse out root section.
    util_1.assert(util_1.readString(buffer, rootSectionOffs + 0x00, 0x04) === 'root');
    var rootResDic = parseResDic(buffer, rootSectionOffs + 0x08);
    // Models
    var mdl0 = [];
    var modelsEntry = rootResDic.find(function (entry) {
        return entry.name === '3DModels(NW4R)';
    });
    if (modelsEntry) {
        var modelsResDic = parseResDic(buffer, modelsEntry.offs);
        try {
            for (var modelsResDic_1 = __values(modelsResDic), modelsResDic_1_1 = modelsResDic_1.next(); !modelsResDic_1_1.done; modelsResDic_1_1 = modelsResDic_1.next()) {
                var mdl0Entry = modelsResDic_1_1.value;
                var mdl0_ = parseMDL0(buffer.subarray(mdl0Entry.offs));
                util_1.assert(mdl0_.name === mdl0Entry.name);
                mdl0.push(mdl0_);
            }
        } catch (e_8_1) {
            e_8 = { error: e_8_1 };
        } finally {
            try {
                if (modelsResDic_1_1 && !modelsResDic_1_1.done && (_a = modelsResDic_1.return)) _a.call(modelsResDic_1);
            } finally {
                if (e_8) throw e_8.error;
            }
        }
    }
    // Textures
    var tex0 = [];
    var texturesEntry = rootResDic.find(function (entry) {
        return entry.name === 'Textures(NW4R)';
    });
    if (texturesEntry) {
        var texturesResDic = parseResDic(buffer, texturesEntry.offs);
        try {
            for (var texturesResDic_1 = __values(texturesResDic), texturesResDic_1_1 = texturesResDic_1.next(); !texturesResDic_1_1.done; texturesResDic_1_1 = texturesResDic_1.next()) {
                var tex0Entry = texturesResDic_1_1.value;
                var tex0_ = parseTEX0(buffer.subarray(tex0Entry.offs));
                util_1.assert(tex0_.name === tex0Entry.name);
                tex0.push(tex0_);
            }
        } catch (e_9_1) {
            e_9 = { error: e_9_1 };
        } finally {
            try {
                if (texturesResDic_1_1 && !texturesResDic_1_1.done && (_b = texturesResDic_1.return)) _b.call(texturesResDic_1);
            } finally {
                if (e_9) throw e_9.error;
            }
        }
    }
    // Tex SRT Animations
    var srt0 = [];
    var animTexSrtsEntry = rootResDic.find(function (entry) {
        return entry.name === 'AnmTexSrt(NW4R)';
    });
    if (animTexSrtsEntry) {
        var animTexSrtResDic = parseResDic(buffer, animTexSrtsEntry.offs);
        try {
            for (var animTexSrtResDic_1 = __values(animTexSrtResDic), animTexSrtResDic_1_1 = animTexSrtResDic_1.next(); !animTexSrtResDic_1_1.done; animTexSrtResDic_1_1 = animTexSrtResDic_1.next()) {
                var srt0Entry = animTexSrtResDic_1_1.value;
                var srt0_ = parseSRT0(buffer.subarray(srt0Entry.offs));
                util_1.assert(srt0_.name === srt0Entry.name);
                srt0.push(srt0_);
            }
        } catch (e_10_1) {
            e_10 = { error: e_10_1 };
        } finally {
            try {
                if (animTexSrtResDic_1_1 && !animTexSrtResDic_1_1.done && (_c = animTexSrtResDic_1.return)) _c.call(animTexSrtResDic_1);
            } finally {
                if (e_10) throw e_10.error;
            }
        }
    }
    // Tex Pattern Animations
    var pat0 = [];
    var animTexPatsEntry = rootResDic.find(function (entry) {
        return entry.name === 'AnmTexPat(NW4R)';
    });
    if (animTexPatsEntry) {
        var animTexPatResDic = parseResDic(buffer, animTexPatsEntry.offs);
        try {
            for (var animTexPatResDic_1 = __values(animTexPatResDic), animTexPatResDic_1_1 = animTexPatResDic_1.next(); !animTexPatResDic_1_1.done; animTexPatResDic_1_1 = animTexPatResDic_1.next()) {
                var pat0Entry = animTexPatResDic_1_1.value;
                var pat0_ = parsePAT0(buffer.subarray(pat0Entry.offs));
                util_1.assert(pat0_.name === pat0Entry.name);
                pat0.push(pat0_);
            }
        } catch (e_11_1) {
            e_11 = { error: e_11_1 };
        } finally {
            try {
                if (animTexPatResDic_1_1 && !animTexPatResDic_1_1.done && (_d = animTexPatResDic_1.return)) _d.call(animTexPatResDic_1);
            } finally {
                if (e_11) throw e_11.error;
            }
        }
    }
    // Color Animations
    var clr0 = [];
    var animClrsEntry = rootResDic.find(function (entry) {
        return entry.name === 'AnmClr(NW4R)';
    });
    if (animClrsEntry) {
        var animClrResDic = parseResDic(buffer, animClrsEntry.offs);
        try {
            for (var animClrResDic_1 = __values(animClrResDic), animClrResDic_1_1 = animClrResDic_1.next(); !animClrResDic_1_1.done; animClrResDic_1_1 = animClrResDic_1.next()) {
                var clr0Entry = animClrResDic_1_1.value;
                var clr0_ = parseCLR0(buffer.subarray(clr0Entry.offs));
                util_1.assert(clr0_.name === clr0Entry.name);
                clr0.push(clr0_);
            }
        } catch (e_12_1) {
            e_12 = { error: e_12_1 };
        } finally {
            try {
                if (animClrResDic_1_1 && !animClrResDic_1_1.done && (_e = animClrResDic_1.return)) _e.call(animClrResDic_1);
            } finally {
                if (e_12) throw e_12.error;
            }
        }
    }
    // Node Animations
    var chr0 = [];
    var animChrsEntry = rootResDic.find(function (entry) {
        return entry.name === 'AnmChr(NW4R)';
    });
    if (animChrsEntry) {
        var animChrResDic = parseResDic(buffer, animChrsEntry.offs);
        try {
            for (var animChrResDic_1 = __values(animChrResDic), animChrResDic_1_1 = animChrResDic_1.next(); !animChrResDic_1_1.done; animChrResDic_1_1 = animChrResDic_1.next()) {
                var chr0Entry = animChrResDic_1_1.value;
                var chr0_ = parseCHR0(buffer.subarray(chr0Entry.offs));
                util_1.assert(chr0_.name === chr0Entry.name);
                chr0.push(chr0_);
            }
        } catch (e_13_1) {
            e_13 = { error: e_13_1 };
        } finally {
            try {
                if (animChrResDic_1_1 && !animChrResDic_1_1.done && (_f = animChrResDic_1.return)) _f.call(animChrResDic_1);
            } finally {
                if (e_13) throw e_13.error;
            }
        }
    }
    return { mdl0: mdl0, tex0: tex0, srt0: srt0, pat0: pat0, clr0: clr0, chr0: chr0 };
}
exports.parse = parse;
},{"../gx/gx_enum":"gx\\gx_enum.ts","../util":"util.ts","../gx/gx_material":"gx\\gx_material.ts","../gx/gx_displaylist":"gx\\gx_displaylist.ts","gl-matrix":"..\\node_modules\\gl-matrix\\src\\gl-matrix.js","../endian":"endian.ts","../Camera":"Camera.ts"}],"rres\\u8.ts":[function(require,module,exports) {
"use strict";
// Nintendo "U8" filesystem archives.
// http://wiki.tockdom.com/wiki/U8_(File_Format)
// http://wiibrew.org/wiki/U8_archive

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var __values = this && this.__values || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator],
        i = 0;
    if (m) return m.call(o);
    return {
        next: function next() {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("../util");
var U8Archive = /** @class */function () {
    function U8Archive() {}
    U8Archive.prototype.findDirParts = function (parts) {
        var e_1, _a;
        var dir = this.root;
        var _loop_1 = function _loop_1(part) {
            dir = dir.subdirs.find(function (subdir) {
                return subdir.name === part;
            });
            if (dir === undefined) return { value: null };
        };
        try {
            for (var parts_1 = __values(parts), parts_1_1 = parts_1.next(); !parts_1_1.done; parts_1_1 = parts_1.next()) {
                var part = parts_1_1.value;
                var state_1 = _loop_1(part);
                if ((typeof state_1 === "undefined" ? "undefined" : _typeof(state_1)) === "object") return state_1.value;
            }
        } catch (e_1_1) {
            e_1 = { error: e_1_1 };
        } finally {
            try {
                if (parts_1_1 && !parts_1_1.done && (_a = parts_1.return)) _a.call(parts_1);
            } finally {
                if (e_1) throw e_1.error;
            }
        }
        return dir;
    };
    U8Archive.prototype.findDir = function (path) {
        return this.findDirParts(path.split('/'));
    };
    U8Archive.prototype.findFile = function (path) {
        var parts = path.split('/');
        var filename = parts.pop();
        var dir = this.findDirParts(parts);
        if (dir === null) return null;
        var file = dir.files.find(function (file) {
            return file.name === filename;
        });
        if (!file) return null;
        return file;
    };
    return U8Archive;
}();
exports.U8Archive = U8Archive;
function parse(buffer) {
    var view = buffer.createDataView();
    util_1.assert(util_1.readString(buffer, 0x00, 0x04) === '\x55\xAA\x38\x2D');
    var tocOffs = view.getUint32(0x04, false);
    var headerSize = view.getUint32(0x08, false);
    // Pointer to data -- unused.
    var dataOffs = view.getUint32(0x0C, false);
    // Read root node to find string table.
    var NodeType;
    (function (NodeType) {
        NodeType[NodeType["File"] = 0] = "File";
        NodeType[NodeType["Directory"] = 1] = "Directory";
    })(NodeType || (NodeType = {}));
    var rootNodeType = view.getUint8(tocOffs + 0x00);
    util_1.assert(rootNodeType === NodeType.Directory);
    var rootNodeChildCount = view.getUint32(tocOffs + 0x08, false);
    var stringTableOffs = tocOffs + rootNodeChildCount * 0x0C;
    function readNode(nodeIndex, parentIndex) {
        var nodeOffs = tocOffs + nodeIndex * 0x0C;
        var nodeType = view.getUint8(nodeOffs + 0x00);
        var nodeNameOffs = view.getUint32(nodeOffs + 0x00) & 0x00FFFFFF;
        var nodeName = util_1.readString(buffer, stringTableOffs + nodeNameOffs);
        if (nodeType === NodeType.Directory) {
            var nodeParentIndex = view.getUint32(nodeOffs + 0x04, false);
            util_1.assert(nodeParentIndex === parentIndex);
            // The index of the first node *not* in this directory.
            var nextNodeIndex = view.getUint32(nodeOffs + 0x08, false);
            // Recurse.
            var files = [];
            var subdirs = [];
            for (var i = nodeIndex + 1; i < nextNodeIndex;) {
                var subNode = readNode(i, nodeIndex);
                if (subNode.kind === 'directory') {
                    subdirs.push(subNode);
                    i = subNode.nextNodeIndex;
                } else {
                    files.push(subNode);
                    i++;
                }
            }
            return { kind: 'directory', name: nodeName, files: files, subdirs: subdirs, nextNodeIndex: nextNodeIndex };
        } else if (nodeType === NodeType.File) {
            var nodeDataBegin = view.getUint32(nodeOffs + 0x04, false);
            var nodeDataSize = view.getUint32(nodeOffs + 0x08, false);
            var nodeBuffer = buffer.subarray(nodeDataBegin, nodeDataSize);
            return { kind: 'file', name: nodeName, buffer: nodeBuffer };
        } else {
            throw "whoops";
        }
    }
    // Root node (0) has parent index 0...
    var rootNode = readNode(0, 0);
    util_1.assert(rootNode.kind === 'directory');
    var archive = new U8Archive();
    archive.root = rootNode;
    return archive;
}
exports.parse = parse;
},{"../util":"util.ts"}],"rres\\render.ts":[function(require,module,exports) {
"use strict";

var __extends = this && this.__extends || function () {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
        d.__proto__ = b;
    } || function (d, b) {
        for (var p in b) {
            if (b.hasOwnProperty(p)) d[p] = b[p];
        }
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __values = this && this.__values || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator],
        i = 0;
    if (m) return m.call(o);
    return {
        next: function next() {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
var __importStar = this && this.__importStar || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) {
        if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    }result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var BRRES = __importStar(require("./brres"));
var GX_Material = __importStar(require("../gx/gx_material"));
var gl_matrix_1 = require("gl-matrix");
var gx_render_1 = require("../gx/gx_render");
var Camera_1 = require("../Camera");
var render_1 = require("../j3d/render");
var RRESTextureHolder = /** @class */function (_super) {
    __extends(RRESTextureHolder, _super);
    function RRESTextureHolder() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    RRESTextureHolder.prototype.addRRESTextures = function (gl, rres) {
        this.addTextures(gl, rres.tex0);
    };
    return RRESTextureHolder;
}(gx_render_1.TextureHolder);
exports.RRESTextureHolder = RRESTextureHolder;
var ModelRenderer = /** @class */function () {
    function ModelRenderer(gl, textureHolder, mdl0, namePrefix, materialHacks) {
        if (namePrefix === void 0) {
            namePrefix = '';
        }
        if (materialHacks === void 0) {
            materialHacks = null;
        }
        this.textureHolder = textureHolder;
        this.mdl0 = mdl0;
        this.namePrefix = namePrefix;
        this.materialHacks = materialHacks;
        this.materialCommands = [];
        this.shapeCommands = [];
        this.sceneParams = new gx_render_1.SceneParams();
        this.packetParams = new gx_render_1.PacketParams();
        this.matrixVisibility = [];
        this.matrixArray = [];
        this.matrixScratch = gl_matrix_1.mat4.create();
        this.bboxScratch = new Camera_1.AABB();
        this.colorOverrides = [];
        this.modelMatrix = gl_matrix_1.mat4.create();
        this.visible = true;
        this.isSkybox = false;
        this.renderHelper = new gx_render_1.GXRenderHelper(gl);
        this.translateModel(gl);
        this.name = namePrefix + "/" + mdl0.name;
    }
    ModelRenderer.prototype.bindCHR0 = function (animationController, chr0) {
        this.chr0NodeAnimator = BRRES.bindCHR0Animator(animationController, chr0, this.mdl0.nodes);
    };
    ModelRenderer.prototype.bindSRT0 = function (animationController, srt0) {
        for (var i = 0; i < this.materialCommands.length; i++) {
            var cmd = this.materialCommands[i];
            cmd.bindSRT0(animationController, srt0);
        }
    };
    ModelRenderer.prototype.bindPAT0 = function (animationController, pat0) {
        for (var i = 0; i < this.materialCommands.length; i++) {
            var cmd = this.materialCommands[i];
            cmd.bindPAT0(animationController, pat0);
        }
    };
    ModelRenderer.prototype.bindCLR0 = function (animationController, clr0) {
        for (var i = 0; i < this.materialCommands.length; i++) {
            var cmd = this.materialCommands[i];
            cmd.bindCLR0(animationController, clr0);
        }
    };
    ModelRenderer.prototype.bindRRESAnimations = function (animationController, rres) {
        for (var i = 0; i < rres.chr0.length; i++) {
            this.bindCHR0(animationController, rres.chr0[i]);
        }for (var i = 0; i < rres.srt0.length; i++) {
            this.bindSRT0(animationController, rres.srt0[i]);
        }for (var i = 0; i < rres.pat0.length; i++) {
            this.bindPAT0(animationController, rres.pat0[i]);
        }for (var i = 0; i < rres.clr0.length; i++) {
            this.bindCLR0(animationController, rres.clr0[i]);
        }
    };
    ModelRenderer.prototype.setColorOverride = function (i, color) {
        this.colorOverrides[i] = color;
    };
    ModelRenderer.prototype.setVisible = function (visible) {
        this.visible = visible;
    };
    ModelRenderer.prototype.render = function (state) {
        if (!this.visible) return;
        // Frustum cull.
        if (this.mdl0.bbox !== null) {
            var bbox = this.bboxScratch;
            bbox.transform(this.mdl0.bbox, this.modelMatrix);
            if (state.camera.frustum.intersect(bbox) === Camera_1.IntersectionState.FULLY_OUTSIDE) return;
        }
        // First, update our matrix state.
        this.execNodeTreeOpList(state, this.mdl0.sceneGraph.nodeTreeOps);
        this.renderHelper.bindUniformBuffers(state);
        gx_render_1.fillSceneParamsFromRenderState(this.sceneParams, state);
        this.renderHelper.bindSceneParams(state, this.sceneParams);
        // TODO(jstpierre): Split into two draws.
        this.execDrawOpList(state, this.mdl0.sceneGraph.drawOpaOps);
        this.execDrawOpList(state, this.mdl0.sceneGraph.drawXluOps);
    };
    ModelRenderer.prototype.destroy = function (gl) {
        this.renderHelper.destroy(gl);
        this.materialCommands.forEach(function (cmd) {
            return cmd.destroy(gl);
        });
        this.shapeCommands.forEach(function (cmd) {
            return cmd.destroy(gl);
        });
    };
    ModelRenderer.prototype.execDrawOpList = function (state, opList) {
        var lastMatId = -1;
        for (var i = 0; i < opList.length; i++) {
            var op = opList[i];
            var node = this.mdl0.nodes[op.nodeId];
            if (this.matrixVisibility[node.mtxId] === Camera_1.IntersectionState.FULLY_OUTSIDE) continue;
            var matCommand = this.materialCommands[op.matId];
            if (!matCommand.visible) continue;
            var usesEnvelope = node.mtxId < 0;
            if (usesEnvelope) throw "whoops";
            var shpCommand = this.shapeCommands[op.shpId];
            var nodeModelMtx = this.matrixArray[node.mtxId];
            var modelView = state.updateModelView(this.isSkybox, nodeModelMtx);
            if (op.matId != lastMatId) {
                matCommand.exec(state, this.renderHelper);
                lastMatId = op.matId;
            }
            gl_matrix_1.mat4.copy(this.packetParams.u_PosMtx[0], modelView);
            this.renderHelper.bindPacketParams(state, this.packetParams);
            shpCommand.exec(state);
        }
    };
    ModelRenderer.prototype.growMatrixArray = function (opList) {
        for (var i = 0; i < opList.length; i++) {
            var op = opList[i];
            var dstMtxId = void 0;
            if (op.op === BRRES.ByteCodeOp.NODEDESC) {
                var node = this.mdl0.nodes[op.nodeId];
                dstMtxId = node.mtxId;
            } else if (op.op === BRRES.ByteCodeOp.MTXDUP) {
                dstMtxId = op.toMtxId;
            } else {
                throw "whoops";
            }
            var newSize = dstMtxId + 1;
            while (this.matrixArray.length < newSize) {
                this.matrixArray.push(gl_matrix_1.mat4.create());
            }
        }
    };
    ModelRenderer.prototype.execNodeTreeOpList = function (state, opList) {
        gl_matrix_1.mat4.copy(this.matrixArray[0], this.modelMatrix);
        this.matrixVisibility[0] = Camera_1.IntersectionState.PARTIAL_INTERSECT;
        for (var i = 0; i < opList.length; i++) {
            var op = opList[i];
            if (op.op === BRRES.ByteCodeOp.NODEDESC) {
                var node = this.mdl0.nodes[op.nodeId];
                var parentMtxId = op.parentMtxId;
                var dstMtxId = node.mtxId;
                var modelMatrix = void 0;
                if (this.chr0NodeAnimator && this.chr0NodeAnimator.calcModelMtx(this.matrixScratch, op.nodeId)) {
                    modelMatrix = this.matrixScratch;
                } else {
                    modelMatrix = node.modelMatrix;
                }
                gl_matrix_1.mat4.mul(this.matrixArray[dstMtxId], this.matrixArray[parentMtxId], modelMatrix);
                var bboxScratch = this.bboxScratch;
                bboxScratch.transform(node.bbox, this.matrixArray[dstMtxId]);
                this.matrixVisibility[dstMtxId] = state.camera.frustum.intersect(bboxScratch);
            } else if (op.op === BRRES.ByteCodeOp.MTXDUP) {
                var srcMtxId = op.fromMtxId;
                var dstMtxId = op.toMtxId;
                gl_matrix_1.mat4.copy(this.matrixArray[dstMtxId], this.matrixArray[srcMtxId]);
                this.matrixVisibility[dstMtxId] = this.matrixVisibility[srcMtxId];
            }
        }
    };
    ModelRenderer.prototype.translateModel = function (gl) {
        var e_1, _a;
        this.growMatrixArray(this.mdl0.sceneGraph.nodeTreeOps);
        try {
            for (var _b = __values(this.mdl0.materials), _c = _b.next(); !_c.done; _c = _b.next()) {
                var material = _c.value;
                this.materialCommands.push(new Command_Material(gl, this, this.textureHolder, material, this.materialHacks));
            }
        } catch (e_1_1) {
            e_1 = { error: e_1_1 };
        } finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally {
                if (e_1) throw e_1.error;
            }
        }
        this.bufferCoalescer = gx_render_1.loadedDataCoalescer(gl, this.mdl0.shapes.map(function (shape) {
            return shape.loadedVertexData;
        }));
        for (var i = 0; i < this.mdl0.shapes.length; i++) {
            var shape = this.mdl0.shapes[i];
            this.shapeCommands.push(new Command_Shape(gl, this.bufferCoalescer.coalescedBuffers[i], shape));
        }
    };
    return ModelRenderer;
}();
exports.ModelRenderer = ModelRenderer;
var Command_Shape = /** @class */function () {
    function Command_Shape(gl, coalescedBuffers, shape) {
        this.shape = shape;
        this.shapeHelper = new gx_render_1.GXShapeHelper(gl, coalescedBuffers, shape.loadedVertexLayout, shape.loadedVertexData);
    }
    Command_Shape.prototype.exec = function (state) {
        var gl = state.gl;
        this.shapeHelper.drawSimple(gl);
    };
    Command_Shape.prototype.destroy = function (gl) {
        this.shapeHelper.destroy(gl);
    };
    return Command_Shape;
}();
var matrixScratch = gl_matrix_1.mat4.create();
var Command_Material = /** @class */function () {
    function Command_Material(gl, model, textureHolder, material, materialHacks) {
        this.model = model;
        this.textureHolder = textureHolder;
        this.material = material;
        this.materialHacks = materialHacks;
        this.materialParams = new gx_render_1.MaterialParams();
        this.glSamplers = [];
        this.srt0Animators = [];
        this.pat0Animators = [];
        this.clr0Animators = [];
        this.visible = true;
        this.program = new GX_Material.GX_Program(this.material.gxMaterial, this.materialHacks);
        this.program.name = this.material.name;
        this.renderFlags = GX_Material.translateRenderFlags(this.material.gxMaterial);
        this.translateSamplers(gl);
    }
    Command_Material.prototype.bindSRT0 = function (animationController, srt0) {
        for (var i = 0; i < BRRES.TexMtxIndex.COUNT; i++) {
            var srtAnimator = BRRES.bindSRT0Animator(animationController, srt0, this.material.name, i);
            if (srtAnimator) this.srt0Animators[i] = srtAnimator;
        }
    };
    Command_Material.prototype.bindPAT0 = function (animationController, pat0) {
        for (var i = 0; i < 8; i++) {
            var patAnimator = BRRES.bindPAT0Animator(animationController, pat0, this.material.name, i);
            if (patAnimator) this.pat0Animators[i] = patAnimator;
        }
    };
    Command_Material.prototype.bindCLR0 = function (animationController, clr0) {
        for (var i = 0; i < BRRES.AnimatableColor.COUNT; i++) {
            var clrAnimator = BRRES.bindCLR0Animator(animationController, clr0, this.material.name, i);
            if (clrAnimator) this.clr0Animators[i] = clrAnimator;
        }
    };
    Command_Material.prototype.translateSamplers = function (gl) {
        for (var i = 0; i < 8; i++) {
            var sampler = this.material.samplers[i];
            if (!sampler) continue;
            // Check sampler validity.
            if (!this.textureHolder.hasTexture(sampler.name)) console.warn("Missing texture:", sampler.name);
            var glSampler = gl.createSampler();
            gl.samplerParameteri(glSampler, gl.TEXTURE_MIN_FILTER, gx_render_1.translateTexFilter(gl, sampler.minFilter));
            gl.samplerParameteri(glSampler, gl.TEXTURE_MAG_FILTER, gx_render_1.translateTexFilter(gl, sampler.magFilter));
            gl.samplerParameteri(glSampler, gl.TEXTURE_WRAP_S, gx_render_1.translateWrapMode(gl, sampler.wrapS));
            gl.samplerParameteri(glSampler, gl.TEXTURE_WRAP_T, gx_render_1.translateWrapMode(gl, sampler.wrapT));
            this.glSamplers[i] = glSampler;
        }
    };
    Command_Material.prototype.calcPostTexMtx = function (dst, texIdx, state, flipY) {
        var texMtxIdx = BRRES.TexMtxIndex.TEX0 + texIdx;
        var texSrt = this.material.texSrts[texIdx];
        var flipYScale = flipY ? -1.0 : 1.0;
        if (texSrt.mapMode === BRRES.MapMode.PROJECTION) {
            Camera_1.texProjPerspMtx(dst, state.fov, state.getAspect(), 0.5, -0.5 * flipYScale, 0.5, 0.5);
            // XXX(jstpierre): ZSS hack. Reference camera 31 is set up by the game to be an overhead
            // camera for clouds. Kill it until we can emulate the camera system in this game...
            if (texSrt.refCamera === 31) {
                dst[0] = 0;
                dst[5] = 0;
            }
        } else if (texSrt.mapMode === BRRES.MapMode.ENV_CAMERA) {
            Camera_1.texEnvMtx(dst, 0.5, -0.5 * flipYScale, 0.5, 0.5);
        } else {
            gl_matrix_1.mat4.identity(dst);
        }
        // Apply effect matrix.
        gl_matrix_1.mat4.mul(dst, texSrt.effectMtx, dst);
        // Calculate SRT.
        if (this.srt0Animators[texMtxIdx]) {
            this.srt0Animators[texMtxIdx].calcTexMtx(matrixScratch);
        } else {
            gl_matrix_1.mat4.copy(matrixScratch, texSrt.srtMtx);
        }
        // SRT matrices have translation in fourth component, but we want our matrix to have translation
        // in third component. Swap.
        var tx = matrixScratch[12];
        matrixScratch[12] = matrixScratch[8];
        matrixScratch[8] = tx;
        var ty = matrixScratch[13];
        matrixScratch[13] = matrixScratch[9];
        matrixScratch[9] = ty;
        gl_matrix_1.mat4.mul(dst, matrixScratch, dst);
    };
    Command_Material.prototype.calcIndMtx = function (dst, indIdx) {
        var texMtxIdx = BRRES.TexMtxIndex.IND0 + indIdx;
        if (this.srt0Animators[texMtxIdx]) {
            this.srt0Animators[texMtxIdx].calcIndTexMtx(dst);
        } else {
            gl_matrix_1.mat2d.copy(dst, this.material.indTexMatrices[indIdx]);
        }
    };
    Command_Material.prototype.fillMaterialParams = function (materialParams, state) {
        var _this = this;
        for (var i = 0; i < 8; i++) {
            var sampler = this.material.samplers[i];
            if (!sampler) continue;
            var m = materialParams.m_TextureMapping[i];
            if (this.pat0Animators[i]) {
                this.pat0Animators[i].calcTextureMapping(m, this.textureHolder);
            } else {
                this.textureHolder.fillTextureMapping(m, sampler.name);
            }
            // Fill in sampler state.
            m.glSampler = this.glSamplers[i];
            m.lodBias = sampler.lodBias;
        }
        var calcColor = function calcColor(dst, fallbackColor, i, a) {
            var color;
            if (_this.model.colorOverrides[i]) {
                color = _this.model.colorOverrides[i];
            } else {
                color = fallbackColor;
            }
            if (_this.clr0Animators[a]) {
                _this.clr0Animators[a].calcColor(dst, color);
            } else {
                dst.copy(color);
            }
        };
        calcColor(materialParams.u_ColorMatReg[0], this.material.colorMatRegs[0], render_1.ColorOverride.MAT0, BRRES.AnimatableColor.MAT0);
        calcColor(materialParams.u_ColorMatReg[1], this.material.colorMatRegs[1], render_1.ColorOverride.MAT1, BRRES.AnimatableColor.MAT1);
        calcColor(materialParams.u_ColorAmbReg[0], this.material.colorAmbRegs[0], render_1.ColorOverride.AMB0, BRRES.AnimatableColor.AMB0);
        calcColor(materialParams.u_ColorAmbReg[1], this.material.colorAmbRegs[1], render_1.ColorOverride.AMB1, BRRES.AnimatableColor.AMB1);
        calcColor(materialParams.u_KonstColor[0], this.material.gxMaterial.colorConstants[0], render_1.ColorOverride.K0, BRRES.AnimatableColor.K0);
        calcColor(materialParams.u_KonstColor[1], this.material.gxMaterial.colorConstants[1], render_1.ColorOverride.K1, BRRES.AnimatableColor.K1);
        calcColor(materialParams.u_KonstColor[2], this.material.gxMaterial.colorConstants[2], render_1.ColorOverride.K2, BRRES.AnimatableColor.K2);
        calcColor(materialParams.u_KonstColor[3], this.material.gxMaterial.colorConstants[3], render_1.ColorOverride.K3, BRRES.AnimatableColor.K3);
        calcColor(materialParams.u_Color[0], this.material.gxMaterial.colorRegisters[0], render_1.ColorOverride.CPREV, -1);
        calcColor(materialParams.u_Color[1], this.material.gxMaterial.colorRegisters[1], render_1.ColorOverride.C0, BRRES.AnimatableColor.C0);
        calcColor(materialParams.u_Color[2], this.material.gxMaterial.colorRegisters[2], render_1.ColorOverride.C1, BRRES.AnimatableColor.C1);
        calcColor(materialParams.u_Color[3], this.material.gxMaterial.colorRegisters[3], render_1.ColorOverride.C2, BRRES.AnimatableColor.C2);
        for (var i = 0; i < 8; i++) {
            this.calcPostTexMtx(materialParams.u_PostTexMtx[i], i, state, materialParams.m_TextureMapping[i].flipY);
        }for (var i = 0; i < 3; i++) {
            this.calcIndMtx(materialParams.u_IndTexMtx[i], i);
        }
    };
    Command_Material.prototype.exec = function (state, renderHelper) {
        var gl = state.gl;
        state.useProgram(this.program);
        state.useFlags(this.renderFlags);
        this.fillMaterialParams(this.materialParams, state);
        renderHelper.bindMaterialParams(state, this.materialParams);
        renderHelper.bindMaterialTextures(state, this.materialParams, this.program);
    };
    Command_Material.prototype.destroy = function (gl) {
        this.program.destroy(gl);
        this.glSamplers.forEach(function (sampler) {
            return gl.deleteSampler(sampler);
        });
    };
    return Command_Material;
}();
},{"./brres":"rres\\brres.ts","../gx/gx_material":"gx\\gx_material.ts","gl-matrix":"..\\node_modules\\gl-matrix\\src\\gl-matrix.js","../gx/gx_render":"gx\\gx_render.ts","../Camera":"Camera.ts","../j3d/render":"j3d\\render.ts"}],"rres\\zss_scenes.ts":[function(require,module,exports) {
"use strict";
// Skyward Sword

var __values = this && this.__values || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator],
        i = 0;
    if (m) return m.call(o);
    return {
        next: function next() {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
var __read = this && this.__read || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o),
        r,
        ar = [],
        e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {
            ar.push(r.value);
        }
    } catch (error) {
        e = { error: error };
    } finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
            if (e) throw e.error;
        }
    }
    return ar;
};
var __importStar = this && this.__importStar || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) {
        if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    }result["default"] = mod;
    return result;
};
var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var UI = __importStar(require("../ui"));
var CX = __importStar(require("../compression/CX"));
var BRRES = __importStar(require("./brres"));
var U8 = __importStar(require("./u8"));
var util_1 = require("../util");
var Progressable_1 = __importDefault(require("../Progressable"));
var render_1 = require("../render");
var render_2 = require("./render");
var gx_material_1 = require("../gx/gx_material");
var gl_matrix_1 = require("gl-matrix");
var render_3 = require("../j3d/render");
var SAND_CLOCK_ICON = '<svg viewBox="0 0 100 100" height="20" fill="white"><g><path d="M79.3,83.3h-6.2H24.9h-6.2c-1.7,0-3,1.3-3,3s1.3,3,3,3h60.6c1.7,0,3-1.3,3-3S81,83.3,79.3,83.3z"/><path d="M18.7,14.7h6.2h48.2h6.2c1.7,0,3-1.3,3-3s-1.3-3-3-3H18.7c-1.7,0-3,1.3-3,3S17,14.7,18.7,14.7z"/><path d="M73.1,66c0-0.9-0.4-1.8-1.1-2.4L52.8,48.5L72,33.4c0.7-0.6,1.1-1.4,1.1-2.4V20.7H24.9V31c0,0.9,0.4,1.8,1.1,2.4l19.1,15.1   L26,63.6c-0.7,0.6-1.1,1.4-1.1,2.4v11.3h48.2V66z"/></g></svg>';
var materialHacks = {
    colorLightingFudge: function colorLightingFudge(p) {
        return "0.5 * " + p.matSource;
    },
    alphaLightingFudge: function alphaLightingFudge(p) {
        return "1.0";
    }
};
var ModelArchiveCollection = /** @class */function () {
    function ModelArchiveCollection() {
        this.search = [];
        this.loaded = new Map();
    }
    ModelArchiveCollection.prototype.addSearchPath = function (archive) {
        this.search.push(archive);
    };
    ModelArchiveCollection.prototype.findFile = function (path) {
        var e_1, _a;
        try {
            for (var _b = __values(this.search), _c = _b.next(); !_c.done; _c = _b.next()) {
                var archive = _c.value;
                var file = archive.findFile(path);
                if (file) return file;
            }
        } catch (e_1_1) {
            e_1 = { error: e_1_1 };
        } finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally {
                if (e_1) throw e_1.error;
            }
        }
        return null;
    };
    ModelArchiveCollection.prototype.loadRRESFromArc = function (gl, textureHolder, path) {
        if (this.loaded.has(path)) return this.loaded.get(path);
        var file = util_1.assertExists(this.findFile(path));
        var arch = U8.parse(file.buffer);
        var rres = BRRES.parse(arch.findFile('g3d/model.brres').buffer);
        textureHolder.addRRESTextures(gl, rres);
        this.loaded.set(path, rres);
        return rres;
    };
    return ModelArchiveCollection;
}();
var SkywardSwordScene = /** @class */function () {
    function SkywardSwordScene(gl, stageId, systemArchive, objPackArchive, stageArchive) {
        var e_2, _a, e_3, _b, e_4, _c, e_5, _d, e_6, _e;
        this.stageId = stageId;
        this.systemArchive = systemArchive;
        this.objPackArchive = objPackArchive;
        this.stageArchive = stageArchive;
        this.mainColorTarget = new render_1.ColorTarget();
        this.stageBZS = null;
        this.roomBZSes = [];
        this.oarcCollection = new ModelArchiveCollection();
        this.models = [];
        // Uses WaterDummy. Have to render after everything else. TODO(jstpierre): How does engine know this?
        this.indirectModels = [];
        // Skybox is rendered specially...
        this.vrboxModel = null;
        this.textureHolder = new render_2.RRESTextureHolder();
        this.animationController = new BRRES.AnimationController();
        this.textures = this.textureHolder.viewerTextures;
        this.oarcCollection.addSearchPath(this.stageArchive);
        this.oarcCollection.addSearchPath(this.objPackArchive);
        var systemRRES = BRRES.parse(systemArchive.findFile('g3d/model.brres').buffer);
        this.textureHolder.addRRESTextures(gl, systemRRES);
        var needsSkyCmn = this.stageId.startsWith('F0') || this.stageId === 'F406';
        if (needsSkyCmn) this.oarcCollection.loadRRESFromArc(gl, this.textureHolder, 'oarc/SkyCmn.arc');
        // Water animations appear in Common.arc.
        this.commonRRES = this.oarcCollection.loadRRESFromArc(gl, this.textureHolder, 'oarc/Common.arc');
        // Load stage.
        this.stageRRES = BRRES.parse(stageArchive.findFile('g3d/stage.brres').buffer);
        this.textureHolder.addRRESTextures(gl, this.stageRRES);
        this.stageBZS = this.parseBZS(stageArchive.findFile('dat/stage.bzs').buffer);
        var stageLayout = this.stageBZS.layouts[0];
        this.spawnLayout(gl, stageLayout);
        // Load rooms.
        var roomArchivesDir = stageArchive.findDir('rarc');
        if (roomArchivesDir) {
            try {
                for (var _f = __values(roomArchivesDir.files), _g = _f.next(); !_g.done; _g = _f.next()) {
                    var roomArchiveFile = _g.value;
                    var roomArchive = U8.parse(roomArchiveFile.buffer);
                    var roomRRES = BRRES.parse(roomArchive.findFile('g3d/room.brres').buffer);
                    this.textureHolder.addRRESTextures(gl, roomRRES);
                    try {
                        for (var _h = __values(roomRRES.mdl0), _j = _h.next(); !_j.done; _j = _h.next()) {
                            var mdl0 = _j.value;
                            this.spawnModel(gl, mdl0, roomRRES, roomArchiveFile.name);
                        }
                    } catch (e_3_1) {
                        e_3 = { error: e_3_1 };
                    } finally {
                        try {
                            if (_j && !_j.done && (_b = _h.return)) _b.call(_h);
                        } finally {
                            if (e_3) throw e_3.error;
                        }
                    }
                    var roomBZS = this.parseBZS(roomArchive.findFile('dat/room.bzs').buffer);
                    this.roomBZSes.push(roomBZS);
                    var layout = roomBZS.layouts[0];
                    this.spawnLayout(gl, layout);
                }
            } catch (e_2_1) {
                e_2 = { error: e_2_1 };
            } finally {
                try {
                    if (_g && !_g.done && (_a = _f.return)) _a.call(_f);
                } finally {
                    if (e_2) throw e_2.error;
                }
            }
        }
        try {
            outer:
            // Find any indirect scenes.
            for (var _k = __values(this.models), _l = _k.next(); !_l.done; _l = _k.next()) {
                var modelRenderer = _l.value;
                try {
                    for (var _m = __values(modelRenderer.mdl0.materials), _o = _m.next(); !_o.done; _o = _m.next()) {
                        var material = _o.value;
                        try {
                            for (var _p = __values(material.samplers), _q = _p.next(); !_q.done; _q = _p.next()) {
                                var sampler = _q.value;
                                if (sampler.name === 'DummyWater') {
                                    this.indirectModels.push(modelRenderer);
                                    continue outer;
                                }
                            }
                        } catch (e_6_1) {
                            e_6 = { error: e_6_1 };
                        } finally {
                            try {
                                if (_q && !_q.done && (_e = _p.return)) _e.call(_p);
                            } finally {
                                if (e_6) throw e_6.error;
                            }
                        }
                    }
                } catch (e_5_1) {
                    e_5 = { error: e_5_1 };
                } finally {
                    try {
                        if (_o && !_o.done && (_d = _m.return)) _d.call(_m);
                    } finally {
                        if (e_5) throw e_5.error;
                    }
                }
            }
        } catch (e_4_1) {
            e_4 = { error: e_4_1 };
        } finally {
            try {
                if (_l && !_l.done && (_c = _k.return)) _c.call(_k);
            } finally {
                if (e_4) throw e_4.error;
            }
        }
    }
    SkywardSwordScene.prototype.createPanels = function () {
        var e_7, _a;
        var panels = [];
        var layersPanel = new UI.LayerPanel();
        layersPanel.setLayers(this.models);
        panels.push(layersPanel);
        // Construct a list of past/future models.
        var futureModels = [];
        var pastModels = [];
        try {
            for (var _b = __values(this.models), _c = _b.next(); !_c.done; _c = _b.next()) {
                var modelRenderer = _c.value;
                if (modelRenderer.mdl0.name.startsWith('model_obj')) futureModels.push(modelRenderer);
                // Lanayru Sand Sea has a "past" decal on top of a future zone.
                if (this.stageId === 'F301_1' && modelRenderer.mdl0.name === 'model1_s') pastModels.push(modelRenderer);
            }
        } catch (e_7_1) {
            e_7 = { error: e_7_1 };
        } finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally {
                if (e_7) throw e_7.error;
            }
        }
        if (futureModels.length || pastModels.length) {
            var futurePanel = new UI.Panel();
            futurePanel.setTitle(SAND_CLOCK_ICON, "Time Stones");
            var selector = new UI.SimpleSingleSelect();
            selector.setStrings(['Past', 'Future']);
            selector.onselectionchange = function (index) {
                var e_8, _a, e_9, _b;
                var isFuture = index === 1;
                try {
                    for (var futureModels_1 = __values(futureModels), futureModels_1_1 = futureModels_1.next(); !futureModels_1_1.done; futureModels_1_1 = futureModels_1.next()) {
                        var modelRenderer = futureModels_1_1.value;
                        modelRenderer.setVisible(isFuture);
                    }
                } catch (e_8_1) {
                    e_8 = { error: e_8_1 };
                } finally {
                    try {
                        if (futureModels_1_1 && !futureModels_1_1.done && (_a = futureModels_1.return)) _a.call(futureModels_1);
                    } finally {
                        if (e_8) throw e_8.error;
                    }
                }
                try {
                    for (var pastModels_1 = __values(pastModels), pastModels_1_1 = pastModels_1.next(); !pastModels_1_1.done; pastModels_1_1 = pastModels_1.next()) {
                        var modelRenderer = pastModels_1_1.value;
                        modelRenderer.setVisible(!isFuture);
                    }
                } catch (e_9_1) {
                    e_9 = { error: e_9_1 };
                } finally {
                    try {
                        if (pastModels_1_1 && !pastModels_1_1.done && (_b = pastModels_1.return)) _b.call(pastModels_1);
                    } finally {
                        if (e_9) throw e_9.error;
                    }
                }
                layersPanel.syncLayerVisibility();
            };
            selector.selectItem(0); // Past
            futurePanel.contents.appendChild(selector.elem);
            panels.push(futurePanel);
        }
        return panels;
    };
    SkywardSwordScene.prototype.destroy = function (gl) {
        this.textureHolder.destroy(gl);
        this.models.forEach(function (model) {
            return model.destroy(gl);
        });
    };
    SkywardSwordScene.prototype.render = function (state) {
        var _this = this;
        var gl = state.gl;
        this.animationController.updateTime(state.time);
        this.mainColorTarget.setParameters(gl, state.onscreenColorTarget.width, state.onscreenColorTarget.height);
        state.useRenderTarget(this.mainColorTarget);
        gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT);
        // Skybox is rendered first. Also, use larger clip planes for the skybox, since it's so large.
        // The actual game probably renders this with a different reference camera..
        state.setClipPlanes(10, 90000000);
        if (this.vrboxModel) {
            this.vrboxModel.render(state);
        }
        state.useFlags(render_1.depthClearFlags);
        gl.clear(gl.DEPTH_BUFFER_BIT);
        state.setClipPlanes(10, 500000);
        this.models.forEach(function (model) {
            if (_this.indirectModels.includes(model)) return;
            model.render(state);
        });
        // Copy to main render target.
        state.useRenderTarget(state.onscreenColorTarget);
        state.blitColorTarget(this.mainColorTarget);
        if (this.indirectModels.length) {
            var textureOverride = { glTexture: this.mainColorTarget.resolvedColorTexture, width: gx_material_1.EFB_WIDTH, height: gx_material_1.EFB_HEIGHT, flipY: true };
            this.textureHolder.setTextureOverride("DummyWater", textureOverride);
        }
        this.indirectModels.forEach(function (modelRenderer) {
            modelRenderer.render(state);
        });
    };
    SkywardSwordScene.prototype.spawnModel = function (gl, mdl0, rres, namePrefix) {
        var e_10, _a, e_11, _b;
        var modelRenderer = new render_2.ModelRenderer(gl, this.textureHolder, mdl0, namePrefix, materialHacks);
        this.models.push(modelRenderer);
        try {
            // Bind animations.
            for (var _c = __values(rres.srt0), _d = _c.next(); !_d.done; _d = _c.next()) {
                var srt0 = _d.value;
                modelRenderer.bindSRT0(this.animationController, srt0);
            }
        } catch (e_10_1) {
            e_10 = { error: e_10_1 };
        } finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            } finally {
                if (e_10) throw e_10.error;
            }
        }
        try {
            // Water animations are in the common archive.
            for (var _e = __values(this.commonRRES.srt0), _f = _e.next(); !_f.done; _f = _e.next()) {
                var srt0 = _f.value;
                modelRenderer.bindSRT0(this.animationController, srt0);
            }
        } catch (e_11_1) {
            e_11 = { error: e_11_1 };
        } finally {
            try {
                if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
            } finally {
                if (e_11) throw e_11.error;
            }
        }
        return modelRenderer;
    };
    SkywardSwordScene.prototype.spawnModelName = function (gl, rres, modelName, namePrefix) {
        var mdl0 = rres.mdl0.find(function (model) {
            return model.name === modelName;
        });
        return this.spawnModel(gl, mdl0, rres, namePrefix);
    };
    SkywardSwordScene.prototype.spawnObj = function (gl, name, unk1, unk2) {
        // In the actual engine, each obj is handled by a separate .rel (runtime module)
        // which knows the actual layout. The mapping of obj name to .rel is stored in main.dol.
        // We emulate that here.
        var models = [];
        if (name === 'CityWtr') {
            // For City Water, we spawn three objects, the second one being an indirect object.
            models.push(this.spawnModelName(gl, this.stageRRES, 'StageF000Water0', name));
            models.push(this.spawnModelName(gl, this.stageRRES, 'StageF000Water1', name));
            models.push(this.spawnModelName(gl, this.stageRRES, 'StageF000Water2', name));
        } else if (name === 'Grave') {
            models.push(this.spawnModelName(gl, this.stageRRES, 'StageF000Grave', name));
        } else if (name === 'Shed') {
            // Door to Batreaux's lair
            models.push(this.spawnModelName(gl, this.stageRRES, 'StageF000Shed', name));
        } else if (name === 'Windmil') {
            var model = this.spawnModelName(gl, this.stageRRES, 'StageF000Windmill', name);
            var StageF000WindmillCHR0 = this.stageRRES.chr0.find(function (c) {
                return c.name === 'StageF000Windmill';
            });
            model.bindCHR0(this.animationController, StageF000WindmillCHR0);
            models.push(model);
        } else if (name === 'Blade') {
            // Skyloft decorations... flags, pinwheels, etc.
            var model = this.spawnModelName(gl, this.stageRRES, 'StageF000Blade', name);
            var StageF000BladeCHR0 = this.stageRRES.chr0.find(function (c) {
                return c.name === 'StageF000Blade';
            });
            model.bindCHR0(this.animationController, StageF000BladeCHR0);
            models.push(model);
        } else if (name === 'LHHarp') {
            // "Lighthouse Harp"
            models.push(this.spawnModelName(gl, this.stageRRES, 'StageF000Harp', name));
        } else if (name === 'LHLight') {
            // "Lighthouse Light"
            models.push(this.spawnModelName(gl, this.stageRRES, 'StageF000Light', name));
        } else if (name === 'Heartf') {
            var FlowerHeartRRES = this.oarcCollection.loadRRESFromArc(gl, this.textureHolder, 'oarc/FlowerHeart.arc');
            models.push(this.spawnModelName(gl, FlowerHeartRRES, 'FlowerHeart', name));
        } else if (name === 'Pumpkin') {
            var PumpkinRRES = this.oarcCollection.loadRRESFromArc(gl, this.textureHolder, 'oarc/Pumpkin.arc');
            models.push(this.spawnModelName(gl, PumpkinRRES, 'Pumpkin', name));
        } else if (name === 'DmtGate') {
            // "Dormitory Gate"
            // Seems it can also use StageF400Gate, probably when Skyloft crashes to the ground (spoilers).
            // Seems to make two of them... skip for now, not that important...
        } else if (name === 'IslLOD') {
            // First parameter appears to contain the island LOD to load...
            var islId = unk1 & 0x0F;
            var islName = ['IslLODA', 'IslLODB', 'IslLODC', 'IslLODD', 'IslLODE'][islId];
            var IslLODRRES = this.oarcCollection.loadRRESFromArc(gl, this.textureHolder, "oarc/" + islName + ".arc");
            var model = this.spawnModelName(gl, IslLODRRES, islName, name);
            models.push(model);
        } else if (name === 'ClawSTg') {
            // Clawshot Target
            var ShotMarkRRES = this.oarcCollection.loadRRESFromArc(gl, this.textureHolder, "oarc/ShotMark.arc");
            models.push(this.spawnModelName(gl, ShotMarkRRES, 'ShotMark', name));
        } else if (name === 'Vrbox') {
            // First parameter appears to contain the Vrbox to load.
            var boxId = unk1 & 0x0F;
            var boxName = ['Vrbox00', 'Vrbox01', 'Vrbox02', 'Vrbox03'][boxId];
            var VrboxRRES = this.oarcCollection.loadRRESFromArc(gl, this.textureHolder, "oarc/" + boxName + ".arc");
            var model = this.spawnModelName(gl, VrboxRRES, boxName, name);
            model.isSkybox = true;
            this.vrboxModel = model;
            // This color is probably set by the day/night system...
            model.setColorOverride(render_3.ColorOverride.C2, new gx_material_1.Color(1, 1, 1, 1));
            model.setColorOverride(render_3.ColorOverride.K3, new gx_material_1.Color(1, 1, 1, 1));
            models.push(model);
        } else if (name === 'CmCloud') {
            // Cumulus Cloud
            var F020CloudRRES = this.oarcCollection.loadRRESFromArc(gl, this.textureHolder, "oarc/F020Cloud.arc");
            var model = this.spawnModelName(gl, F020CloudRRES, 'F020Cloud', name);
            models.push(model);
        } else if (name === 'UdCloud') {
            // Under Clouds
            var F020UnderCloudRRES = this.oarcCollection.loadRRESFromArc(gl, this.textureHolder, "oarc/F020UnderCloud.arc");
            var model = this.spawnModelName(gl, F020UnderCloudRRES, 'F020UnderCloud', name);
            models.push(model);
        } else if (name === 'ObjBld') {
            // Object Building. Appears to only be used for the dowsing station? Why?
            var DowsingZoneE300RRES = this.oarcCollection.loadRRESFromArc(gl, this.textureHolder, "oarc/DowsingZoneE300.arc");
            models.push(this.spawnModelName(gl, DowsingZoneE300RRES, 'DowsingZoneE300', name));
        } else if (name === 'WtrF100') {
            var WaterF100RRES = this.oarcCollection.loadRRESFromArc(gl, this.textureHolder, "oarc/WaterF100.arc");
            models.push(this.spawnModelName(gl, WaterF100RRES, 'model0', name));
            models.push(this.spawnModelName(gl, WaterF100RRES, 'model1', name));
            models.push(this.spawnModelName(gl, WaterF100RRES, 'model2', name));
            models.push(this.spawnModelName(gl, WaterF100RRES, 'model3', name));
        } else if (name === 'GodCube') {
            var GoddessCubeRRES = this.oarcCollection.loadRRESFromArc(gl, this.textureHolder, "oarc/GoddessCube.arc");
            models.push(this.spawnModelName(gl, GoddessCubeRRES, 'GoddessCube', name));
        } else if (name === 'LavF200') {
            var LavaF200RRES = this.oarcCollection.loadRRESFromArc(gl, this.textureHolder, "oarc/LavaF200.arc");
            models.push(this.spawnModelName(gl, LavaF200RRES, 'LavaF200', name));
        } else if (name === 'UDLava') {
            var UpdwnLavaRRES = this.oarcCollection.loadRRESFromArc(gl, this.textureHolder, "oarc/UpdwnLava.arc");
            models.push(this.spawnModelName(gl, UpdwnLavaRRES, 'UpdwnLavaA', name));
            models.push(this.spawnModelName(gl, UpdwnLavaRRES, 'UpdwnLavaB', name));
            models.push(this.spawnModelName(gl, UpdwnLavaRRES, 'UpdwnLavaC', name));
        } else {
            console.log("Unknown object", name);
        }
        return models;
    };
    SkywardSwordScene.prototype.spawnLayout = function (gl, layout) {
        var e_12, _a, e_13, _b, e_14, _c, e_15, _d;
        var q = gl_matrix_1.quat.create();
        try {
            for (var _e = __values(layout.obj), _f = _e.next(); !_f.done; _f = _e.next()) {
                var obj = _f.value;
                var models = this.spawnObj(gl, obj.name, obj.unk1, obj.unk2);
                // Set model matrix.
                var rotationX = 180 * (obj.rotX / 0x7FFF);
                var rotationY = 180 * (obj.rotY / 0x7FFF);
                gl_matrix_1.quat.fromEuler(q, rotationX, rotationY, 0);
                try {
                    for (var models_1 = __values(models), models_1_1 = models_1.next(); !models_1_1.done; models_1_1 = models_1.next()) {
                        var modelRenderer = models_1_1.value;
                        gl_matrix_1.mat4.fromRotationTranslation(modelRenderer.modelMatrix, q, [obj.tx, obj.ty, obj.tz]);
                    }
                } catch (e_13_1) {
                    e_13 = { error: e_13_1 };
                } finally {
                    try {
                        if (models_1_1 && !models_1_1.done && (_b = models_1.return)) _b.call(models_1);
                    } finally {
                        if (e_13) throw e_13.error;
                    }
                }
            }
        } catch (e_12_1) {
            e_12 = { error: e_12_1 };
        } finally {
            try {
                if (_f && !_f.done && (_a = _e.return)) _a.call(_e);
            } finally {
                if (e_12) throw e_12.error;
            }
        }
        try {
            // Now do scalable objects...
            for (var _g = __values(layout.sobj), _h = _g.next(); !_h.done; _h = _g.next()) {
                var obj = _h.value;
                var models = this.spawnObj(gl, obj.name, obj.unk1, obj.unk2);
                // Set model matrix.
                var rotation = 180 * (obj.rotY / 0x7FFF);
                gl_matrix_1.quat.fromEuler(q, 0, rotation, 0);
                try {
                    for (var models_2 = __values(models), models_2_1 = models_2.next(); !models_2_1.done; models_2_1 = models_2.next()) {
                        var modelRenderer = models_2_1.value;
                        gl_matrix_1.mat4.fromRotationTranslationScale(modelRenderer.modelMatrix, q, [obj.tx, obj.ty, obj.tz], [obj.sx, obj.sy, obj.sz]);
                    }
                } catch (e_15_1) {
                    e_15 = { error: e_15_1 };
                } finally {
                    try {
                        if (models_2_1 && !models_2_1.done && (_d = models_2.return)) _d.call(models_2);
                    } finally {
                        if (e_15) throw e_15.error;
                    }
                }
            }
        } catch (e_14_1) {
            e_14 = { error: e_14_1 };
        } finally {
            try {
                if (_h && !_h.done && (_c = _g.return)) _c.call(_g);
            } finally {
                if (e_14) throw e_14.error;
            }
        }
    };
    SkywardSwordScene.prototype.parseBZS = function (buffer) {
        var view = buffer.createDataView();
        function parseChunkTable(tableOffs, count) {
            var chunks = [];
            var tableIdx = tableOffs;
            for (var i = 0; i < count; i++) {
                var name_1 = util_1.readString(buffer, tableIdx + 0x00, 0x04, false);
                var count_1 = view.getUint16(tableIdx + 0x04);
                // pad
                // offs is relative to this entry.
                var offs = tableIdx + view.getUint32(tableIdx + 0x08);
                chunks.push({ name: name_1, count: count_1, offs: offs });
                tableIdx += 0x0C;
            }
            return chunks;
        }
        // Header.
        var headerChunkTable = parseChunkTable(0x00, 0x01);
        util_1.assert(headerChunkTable.length === 1);
        var v001 = headerChunkTable[0];
        util_1.assert(v001.name === 'V001' && v001.offs === 0x0C);
        var roomChunkTable = parseChunkTable(v001.offs, v001.count);
        function parseObj(offs) {
            var unk1 = view.getUint32(offs + 0x00);
            var unk2 = view.getUint32(offs + 0x04);
            var tx = view.getFloat32(offs + 0x08);
            var ty = view.getFloat32(offs + 0x0C);
            var tz = view.getFloat32(offs + 0x10);
            var rotX = view.getInt16(offs + 0x14);
            var rotY = view.getInt16(offs + 0x16);
            var unk4 = view.getInt16(offs + 0x18);
            var unk5 = view.getUint8(offs + 0x1A);
            var unk6 = view.getUint8(offs + 0x1B);
            var name = util_1.readString(buffer, offs + 0x1C, 0x08, true);
            return { unk1: unk1, unk2: unk2, tx: tx, ty: ty, tz: tz, rotX: rotX, rotY: rotY, unk4: unk4, unk5: unk5, unk6: unk6, name: name };
        }
        function parseSobj(offs) {
            var unk1 = view.getUint32(offs + 0x00);
            var unk2 = view.getUint32(offs + 0x04);
            var tx = view.getFloat32(offs + 0x08);
            var ty = view.getFloat32(offs + 0x0C);
            var tz = view.getFloat32(offs + 0x10);
            var sx = view.getFloat32(offs + 0x14);
            var sy = view.getFloat32(offs + 0x18);
            var sz = view.getFloat32(offs + 0x1C);
            var rotY = view.getInt16(offs + 0x20);
            var unk4 = view.getUint16(offs + 0x22);
            var unk5 = view.getUint8(offs + 0x26);
            var unk6 = view.getUint8(offs + 0x27);
            var name = util_1.readString(buffer, offs + 0x28, 0x08, true);
            return { unk1: unk1, unk2: unk2, tx: tx, ty: ty, tz: tz, sx: sx, sy: sy, sz: sz, rotY: rotY, unk4: unk4, unk5: unk5, unk6: unk6, name: name };
        }
        var layoutsChunk = roomChunkTable.find(function (chunk) {
            return chunk.name === 'LAY ';
        });
        // Parse layouts table.
        function parseLayout(index) {
            var layoutsTableIdx = layoutsChunk.offs + index * 0x08;
            var layoutChunkTableCount = view.getUint16(layoutsTableIdx + 0x00);
            // pad
            var layoutChunkTableOffs = layoutsTableIdx + view.getUint32(layoutsTableIdx + 0x04);
            var layoutChunkTable = parseChunkTable(layoutChunkTableOffs, layoutChunkTableCount);
            // Look for objects table.
            var obj = [];
            var objChunk = layoutChunkTable.find(function (chunk) {
                return chunk.name === 'OBJ ';
            });
            if (objChunk) for (var i = 0; i < objChunk.count; i++) {
                obj.push(parseObj(objChunk.offs + i * 0x24));
            }var sobj = [];
            var sobjChunk = layoutChunkTable.find(function (chunk) {
                return chunk.name === 'SOBJ';
            });
            if (sobjChunk) for (var i = 0; i < sobjChunk.count; i++) {
                sobj.push(parseSobj(sobjChunk.offs + i * 0x30));
            }var stagChunk = layoutChunkTable.find(function (chunk) {
                return chunk.name === 'STAG';
            });
            if (stagChunk) for (var i = 0; i < stagChunk.count; i++) {
                sobj.push(parseSobj(stagChunk.offs + i * 0x30));
            }return { obj: obj, sobj: sobj };
        }
        var layouts = [];
        layouts.push(parseLayout(0));
        return { layouts: layouts };
    };
    return SkywardSwordScene;
}();
var SkywardSwordSceneDesc = /** @class */function () {
    function SkywardSwordSceneDesc(id, name) {
        this.id = id;
        this.name = name;
    }
    SkywardSwordSceneDesc.prototype.createScene = function (gl) {
        var _this = this;
        var basePath = "data/zss";
        var systemPath = basePath + "/System.arc";
        var objPackPath = basePath + "/ObjectPack.arc.LZ";
        var stagePath = basePath + "/" + this.id + "_stg_l0.arc.LZ";
        return Progressable_1.default.all([util_1.fetch(systemPath), util_1.fetch(objPackPath), util_1.fetch(stagePath)]).then(function (buffers) {
            var _a = __read(buffers, 3),
                systemBuffer = _a[0],
                objPackBuffer = _a[1],
                stageBuffer = _a[2];
            var commonRRESes = [];
            var systemArchive = U8.parse(systemBuffer);
            var objPackArchive = U8.parse(CX.decompress(objPackBuffer));
            var stageArchive = U8.parse(CX.decompress(stageBuffer));
            return new SkywardSwordScene(gl, _this.id, systemArchive, objPackArchive, stageArchive);
        });
    };
    return SkywardSwordSceneDesc;
}();
var id = "zss";
var name = "The Legend of Zelda: Skyward Sword";
var sceneDescs = [new SkywardSwordSceneDesc("D100", "Skyview Temple"), new SkywardSwordSceneDesc("D101", "Ancient Cistern"), new SkywardSwordSceneDesc("D200", "Earth Temple"), new SkywardSwordSceneDesc("D201", "Fire Sanctuary (A)"), new SkywardSwordSceneDesc("D201_1", "Fire Sanctuary (B)"), new SkywardSwordSceneDesc("D300", "Lanayru Mining Facility (A)"), new SkywardSwordSceneDesc("D300_1", "Lanayru Mining Facility (B)"), new SkywardSwordSceneDesc("D301", "Sandship"), new SkywardSwordSceneDesc("F000", "Skyloft"), new SkywardSwordSceneDesc("F001r", "Skyloft - Knight's Academy"), new SkywardSwordSceneDesc("D000", "Skyloft - Waterfall Cave"), new SkywardSwordSceneDesc("F100", "Faron Woods"), new SkywardSwordSceneDesc("F100_1", "Faron Woods - Inside the Great Tree"), new SkywardSwordSceneDesc("F101", "Faron Woods - Deep Woods"), new SkywardSwordSceneDesc("F102", "Faron Woods - Lake Floria"), new SkywardSwordSceneDesc("F102_1", "Faron Woods - Outside Skyview Temple"), new SkywardSwordSceneDesc("F102_2", "Faron Woods - Faron's Lair"), new SkywardSwordSceneDesc("F103", "Faron Woods (Flooded)"), new SkywardSwordSceneDesc("F200", "Eldin Volcano"), new SkywardSwordSceneDesc("F201_1", "Eldin Volcano - Inside Volcano"), new SkywardSwordSceneDesc("F201_3", "Eldin Volcano - Fire Sanctuary Entrance"), new SkywardSwordSceneDesc("F201_4", "Eldin Volcano - Volcano Summit - Waterfall"), new SkywardSwordSceneDesc("F202_1", "Eldin Volcano - Despacito 202_1"), new SkywardSwordSceneDesc("F210", "Eldin Volcano - Caves"), new SkywardSwordSceneDesc("F211", "Eldin Volcano - Thrill Digger"), new SkywardSwordSceneDesc("F221", "Eldin Volcano - Despacito 221"), new SkywardSwordSceneDesc("F300", "Lanayru Desert"), new SkywardSwordSceneDesc("F300_1", "Lanayru Desert - Ancient Harbor"), new SkywardSwordSceneDesc("F300_2", "Lanayru Desert - Lanayru Mine"), new SkywardSwordSceneDesc("F300_3", "Lanayru Desert - Power Generator #1"), new SkywardSwordSceneDesc("F300_4", "Lanayru Desert - Power Generator #2"), new SkywardSwordSceneDesc("F300_5", "Lanayru Desert - Temple of Time"), new SkywardSwordSceneDesc("F301", "Lanayru Sand Sea - Docks"), new SkywardSwordSceneDesc("F301_1", "Lanayru Sand Sea - The Sea"), new SkywardSwordSceneDesc("F301_2", "Lanayru Desert - Pirate Stronghold"), new SkywardSwordSceneDesc("F301_3", "Lanayru Desert - Skipper's Retreat"), new SkywardSwordSceneDesc("F301_4", "Lanayru Desert - Shipyard"), new SkywardSwordSceneDesc("F301_5", "Lanayru Desert - Skipper's Retreat Shack"), new SkywardSwordSceneDesc("F301_7", "Lanayru Desert - Shipyard Construction Bay"), new SkywardSwordSceneDesc("F302", "Lanayru Desert - Lanayru Gorge"), new SkywardSwordSceneDesc("F303", "Lanayru Desert - Lanayru Caves"), new SkywardSwordSceneDesc("F400", "Sacred Grounds - Despacito 400"), new SkywardSwordSceneDesc("F401", "Sacred Grounds - Despacito 401"), new SkywardSwordSceneDesc("F402", "Sacred Grounds - Despacito 402"), new SkywardSwordSceneDesc("F403", "Sacred Grounds - Despacito 403"), new SkywardSwordSceneDesc("F404", "Sacred Grounds - Despacito 404"), new SkywardSwordSceneDesc("F405", "Sacred Grounds - Despacito 405"), new SkywardSwordSceneDesc("F406", "Sacred Grounds - Despacito 406"), new SkywardSwordSceneDesc("F407", "Sacred Grounds - Despacito 407")];
exports.sceneGroup = { id: id, name: name, sceneDescs: sceneDescs };
},{"../ui":"ui.ts","../compression/CX":"compression\\CX.ts","./brres":"rres\\brres.ts","./u8":"rres\\u8.ts","../util":"util.ts","../Progressable":"Progressable.ts","../render":"render.ts","./render":"rres\\render.ts","../gx/gx_material":"gx\\gx_material.ts","gl-matrix":"..\\node_modules\\gl-matrix\\src\\gl-matrix.js","../j3d/render":"j3d\\render.ts"}],"rres\\elb_scenes.ts":[function(require,module,exports) {
"use strict";
// Elebits

var __values = this && this.__values || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator],
        i = 0;
    if (m) return m.call(o);
    return {
        next: function next() {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
var __importStar = this && this.__importStar || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) {
        if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    }result["default"] = mod;
    return result;
};
var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var UI = __importStar(require("../ui"));
var BRRES = __importStar(require("./brres"));
var util_1 = require("../util");
var Progressable_1 = __importDefault(require("../Progressable"));
var render_1 = require("./render");
var materialHacks = {
    colorLightingFudge: function colorLightingFudge(p) {
        return "" + p.matSource;
    },
    alphaLightingFudge: function alphaLightingFudge(p) {
        return '1.0';
    }
};
var BasicRRESScene = /** @class */function () {
    function BasicRRESScene(gl, stageRRESes) {
        var e_1, _a;
        this.stageRRESes = stageRRESes;
        this.models = [];
        this.textureHolder = new render_1.RRESTextureHolder();
        this.animationController = new BRRES.AnimationController();
        this.textures = this.textureHolder.viewerTextures;
        try {
            for (var stageRRESes_1 = __values(stageRRESes), stageRRESes_1_1 = stageRRESes_1.next(); !stageRRESes_1_1.done; stageRRESes_1_1 = stageRRESes_1.next()) {
                var stageRRES = stageRRESes_1_1.value;
                this.textureHolder.addRRESTextures(gl, stageRRES);
                util_1.assert(stageRRES.mdl0.length === 1);
                var modelRenderer = new render_1.ModelRenderer(gl, this.textureHolder, stageRRES.mdl0[0], '', materialHacks);
                this.models.push(modelRenderer);
                modelRenderer.bindRRESAnimations(this.animationController, stageRRES);
            }
        } catch (e_1_1) {
            e_1 = { error: e_1_1 };
        } finally {
            try {
                if (stageRRESes_1_1 && !stageRRESes_1_1.done && (_a = stageRRESes_1.return)) _a.call(stageRRESes_1);
            } finally {
                if (e_1) throw e_1.error;
            }
        }
    }
    BasicRRESScene.prototype.createPanels = function () {
        var panels = [];
        if (this.models.length > 1) {
            var layersPanel = new UI.LayerPanel();
            layersPanel.setLayers(this.models);
            panels.push(layersPanel);
        }
        return panels;
    };
    BasicRRESScene.prototype.destroy = function (gl) {
        this.textureHolder.destroy(gl);
        this.models.forEach(function (model) {
            return model.destroy(gl);
        });
    };
    BasicRRESScene.prototype.render = function (state) {
        this.animationController.updateTime(state.time);
        this.models.forEach(function (model) {
            model.render(state);
        });
    };
    return BasicRRESScene;
}();
exports.BasicRRESScene = BasicRRESScene;
function makeElbPath(stg, room) {
    var z = util_1.leftPad('' + room, 2);
    return "data/elb/" + stg + "_" + z + "_disp01.brres";
}
var ElebitsSceneDesc = /** @class */function () {
    function ElebitsSceneDesc(id, name, rooms) {
        this.id = id;
        this.name = name;
        this.rooms = rooms;
    }
    ElebitsSceneDesc.prototype.createScene = function (gl) {
        var _this = this;
        var paths = this.rooms.map(function (room) {
            return makeElbPath(_this.id, room);
        });
        var progressables = paths.map(function (path) {
            return util_1.fetch(path);
        });
        return Progressable_1.default.all(progressables).then(function (buffers) {
            var stageRRESes = buffers.map(function (buffer) {
                return BRRES.parse(buffer);
            });
            return new BasicRRESScene(gl, stageRRESes);
        });
    };
    return ElebitsSceneDesc;
}();
function createBasicRRESSceneFromBuffer(gl, buffer) {
    var stageRRES = BRRES.parse(buffer);
    return new BasicRRESScene(gl, [stageRRES]);
}
exports.createBasicRRESSceneFromBuffer = createBasicRRESSceneFromBuffer;
function range(start, count) {
    if (start === void 0) {
        start = 1;
    }
    if (count === void 0) {
        count = 18;
    }
    var L = [];
    for (var i = start; i < start + count; i++) {
        L.push(i);
    }return L;
}
var id = "elb";
var name = "Elebits";
var sceneDescs = [new ElebitsSceneDesc("stg01", "Mom and Dad's House", range(1, 18)), new ElebitsSceneDesc("stg03", "The Town", [1]), new ElebitsSceneDesc("stg02", "Amusement Park - Main Hub", [1, 5]), new ElebitsSceneDesc("stg02", "Amusement Park - Castle", [2]), new ElebitsSceneDesc("stg02", "Amusement Park - Entrance", [3, 6]), new ElebitsSceneDesc("stg02", "Amusement Park - Space", [4]), new ElebitsSceneDesc("stg04", "Tutorial", [1, 2])];
exports.sceneGroup = { id: id, name: name, sceneDescs: sceneDescs };
},{"../ui":"ui.ts","./brres":"rres\\brres.ts","../util":"util.ts","../Progressable":"Progressable.ts","./render":"rres\\render.ts"}],"rres\\mkwii_scenes.ts":[function(require,module,exports) {
"use strict";
// Mario Kart Wii

var __importStar = this && this.__importStar || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) {
        if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    }result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var BRRES = __importStar(require("./brres"));
var U8 = __importStar(require("./u8"));
var Yaz0 = __importStar(require("../compression/Yaz0"));
var util_1 = require("../util");
var gl_matrix_1 = require("gl-matrix");
var render_1 = require("./render");
var render_2 = require("../render");
var MarioKartRenderer = /** @class */function () {
    function MarioKartRenderer(gl, courseRRES, skyboxRRES) {
        this.courseRRES = courseRRES;
        this.skyboxRRES = skyboxRRES;
        this.textureHolder = new render_1.RRESTextureHolder();
        this.textures = this.textureHolder.viewerTextures;
        this.animationController = new BRRES.AnimationController();
        this.textureHolder.addRRESTextures(gl, skyboxRRES);
        this.textureHolder.addRRESTextures(gl, courseRRES);
        util_1.assert(skyboxRRES.mdl0.length === 1);
        this.skyboxRenderer = new render_1.ModelRenderer(gl, this.textureHolder, skyboxRRES.mdl0[0], 'vrbox');
        this.skyboxRenderer.isSkybox = true;
        util_1.assert(courseRRES.mdl0.length === 1);
        this.courseRenderer = new render_1.ModelRenderer(gl, this.textureHolder, courseRRES.mdl0[0], 'course');
        // Mario Kart Wii courses appear to be very, very big. Scale them down a bit.
        var scaleFactor = 0.1;
        gl_matrix_1.mat4.fromScaling(this.courseRenderer.modelMatrix, [scaleFactor, scaleFactor, scaleFactor]);
        gl_matrix_1.mat4.fromScaling(this.skyboxRenderer.modelMatrix, [scaleFactor, scaleFactor, scaleFactor]);
        // Bind animations.
        this.skyboxRenderer.bindRRESAnimations(this.animationController, skyboxRRES);
        this.courseRenderer.bindRRESAnimations(this.animationController, courseRRES);
    }
    MarioKartRenderer.prototype.destroy = function (gl) {
        this.textureHolder.destroy(gl);
    };
    MarioKartRenderer.prototype.render = function (state) {
        var gl = state.gl;
        this.animationController.updateTime(state.time);
        this.skyboxRenderer.render(state);
        state.useFlags(render_2.depthClearFlags);
        gl.clear(gl.DEPTH_BUFFER_BIT);
        this.courseRenderer.render(state);
    };
    return MarioKartRenderer;
}();
var MarioKartWiiSceneDesc = /** @class */function () {
    function MarioKartWiiSceneDesc(id, name) {
        this.id = id;
        this.name = name;
    }
    MarioKartWiiSceneDesc.prototype.createScene = function (gl) {
        return util_1.fetch("data/mkwii/" + this.id + ".szs").then(function (buffer) {
            return Yaz0.decompress(buffer);
        }).then(function (buffer) {
            var arch = U8.parse(buffer);
            var courseRRES = BRRES.parse(arch.findFile('./course_model.brres').buffer);
            var skyboxRRES = BRRES.parse(arch.findFile('./vrcorn_model.brres').buffer);
            var scene = new MarioKartRenderer(gl, courseRRES, skyboxRRES);
            return scene;
        });
    };
    return MarioKartWiiSceneDesc;
}();
var id = 'mkwii';
var name = 'Mario Kart Wii';
var sceneDescs = [new MarioKartWiiSceneDesc('beginner_course', "Luigi Circuit"), new MarioKartWiiSceneDesc('farm_course', "Moo Moo Meadows"), new MarioKartWiiSceneDesc('kinoko_course', "Mushroom Gorge"), new MarioKartWiiSceneDesc('factory_course', "Toad's Factory"), new MarioKartWiiSceneDesc('castle_course', "Mario Circuit"), new MarioKartWiiSceneDesc('shopping_course', "Coconut Mall"), new MarioKartWiiSceneDesc('boardcross_course', "DK Summit"), new MarioKartWiiSceneDesc('truck_course', "Wario's Gold Mine"), new MarioKartWiiSceneDesc('senior_course', "Daisy Circuit"), new MarioKartWiiSceneDesc('water_course', "Koopa Cape"), new MarioKartWiiSceneDesc('treehouse_course', "Maple Treeway"), new MarioKartWiiSceneDesc('volcano_course', "Grumble Volcano"), new MarioKartWiiSceneDesc('desert_course', "Dry Dry Ruins"), new MarioKartWiiSceneDesc('ridgehighway_course', "Moonview Highway"), new MarioKartWiiSceneDesc('koopa_course', "Bowser's Castle"), new MarioKartWiiSceneDesc('rainbow_course', "Rainbow Road"), new MarioKartWiiSceneDesc('old_peach_gc', "GCN Peach Beach"), new MarioKartWiiSceneDesc('old_falls_ds', "DS Yoshi Falls"), new MarioKartWiiSceneDesc('old_obake_sfc', "SNES Ghost Valley 2"), new MarioKartWiiSceneDesc('old_mario_64', "N64 Mario Raceway"), new MarioKartWiiSceneDesc('old_sherbet_64', "N64 Sherbet Land"), new MarioKartWiiSceneDesc('old_heyho_gba', "GBA Shy Guy Beach"), new MarioKartWiiSceneDesc('old_town_ds', "DS Delfino Square"), new MarioKartWiiSceneDesc('old_waluigi_gc', "GCN Waluigi Stadium"), new MarioKartWiiSceneDesc('old_desert_ds', "DS Desert Hills"), new MarioKartWiiSceneDesc('old_donkey_64', "N64 DK's Jungle Parkway"), new MarioKartWiiSceneDesc('old_mario_gc', "GC Mario Circuit"), new MarioKartWiiSceneDesc('old_mario_sfc', "SNES Mario Circuit 3"), new MarioKartWiiSceneDesc('old_garden_ds', "DS Peach Gardens"), new MarioKartWiiSceneDesc('old_donkey_gc', "GCN DK Mountain"), new MarioKartWiiSceneDesc('old_koopa_64', "N64 Bowser's Castle"), new MarioKartWiiSceneDesc('block_battle', "Block Plaza"), new MarioKartWiiSceneDesc('venice_battle', "Delfino Pier"), new MarioKartWiiSceneDesc('skate_battle', "Funky Stadium"), new MarioKartWiiSceneDesc('casino_battle', "Chain Chomp Wheel"), new MarioKartWiiSceneDesc('sand_battle', "Thwomp Desert"), new MarioKartWiiSceneDesc('old_battle4_sfc', "SNES Battle Course 4"), new MarioKartWiiSceneDesc('old_battle3_gba', "GBA Battle Course 3"), new MarioKartWiiSceneDesc('old_matenro_64', "N64 Skyscraper"), new MarioKartWiiSceneDesc('old_CookieLand_gc', "GCN Cookie Land"), new MarioKartWiiSceneDesc('old_House_ds', "DS Twilight House"), new MarioKartWiiSceneDesc('ring_mission', "Galaxy Colosseum")];
exports.sceneGroup = { id: id, name: name, sceneDescs: sceneDescs };
},{"./brres":"rres\\brres.ts","./u8":"rres\\u8.ts","../compression/Yaz0":"compression\\Yaz0.ts","../util":"util.ts","gl-matrix":"..\\node_modules\\gl-matrix\\src\\gl-matrix.js","./render":"rres\\render.ts","../render":"render.ts"}],"main.ts":[function(require,module,exports) {
"use strict";

var __read = this && this.__read || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o),
        r,
        ar = [],
        e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {
            ar.push(r.value);
        }
    } catch (error) {
        e = { error: error };
    } finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
            if (e) throw e.error;
        }
    }
    return ar;
};
var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
};
var __importStar = this && this.__importStar || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) {
        if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    }result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var viewer_1 = require("./viewer");
var ArrayBufferSlice_1 = __importDefault(require("./ArrayBufferSlice"));
var Progressable_1 = __importDefault(require("./Progressable"));
var ZTP = __importStar(require("./j3d/ztp_scenes"));
var MKDD = __importStar(require("./j3d/mkdd_scenes"));
var ZWW = __importStar(require("./j3d/zww_scenes"));
var SMS = __importStar(require("./j3d/sms_scenes"));
var SMG = __importStar(require("./j3d/smg_scenes"));
var SM64DS = __importStar(require("./sm64ds/scenes"));
var MDL0 = __importStar(require("./mdl0/scenes"));
var ZELVIEW = __importStar(require("./zelview/scenes"));
var OOT3D = __importStar(require("./oot3d/scenes"));
var FRES = __importStar(require("./fres/scenes"));
var SPL = __importStar(require("./fres/splatoon_scenes"));
var DKSIV = __importStar(require("./dksiv/scenes"));
var MP1 = __importStar(require("./metroid_prime/scenes"));
var LM = __importStar(require("./luigis_mansion/scenes"));
var ZSS = __importStar(require("./rres/zss_scenes"));
var ELB = __importStar(require("./rres/elb_scenes"));
var MKWII = __importStar(require("./rres/mkwii_scenes"));
var J3D = __importStar(require("./j3d/scenes"));
var ui_1 = require("./ui");
var Camera_1 = require("./Camera");
var sceneGroups = [ZTP.sceneGroup, ZSS.sceneGroup, ZWW.sceneGroup, SMS.sceneGroup, SMG.sceneGroup, MKDD.sceneGroup, MKWII.sceneGroup, ELB.sceneGroup, LM.sceneGroup, SM64DS.sceneGroup, SPL.sceneGroup, MDL0.sceneGroup, ZELVIEW.sceneGroup, OOT3D.sceneGroup, DKSIV.sceneGroup, MP1.sceneGroup];
var DroppedFileSceneDesc = /** @class */function () {
    function DroppedFileSceneDesc(file) {
        this.file = file;
        this.id = file.name;
        this.name = file.name;
    }
    DroppedFileSceneDesc.prototype._loadFileAsPromise = function (file) {
        var request = new FileReader();
        request.readAsArrayBuffer(file);
        var p = new Promise(function (resolve, reject) {
            request.onload = function () {
                var buffer = request.result;
                var slice = new ArrayBufferSlice_1.default(buffer);
                resolve(slice);
            };
            request.onerror = function () {
                reject();
            };
            request.onprogress = function (e) {
                if (e.lengthComputable) pr.setProgress(e.loaded / e.total);
            };
        });
        var pr = new Progressable_1.default(p);
        return pr;
    };
    DroppedFileSceneDesc.prototype.createSceneFromFile = function (gl, file, buffer) {
        if (file.name.endsWith('.brres')) return Promise.resolve(ELB.createBasicRRESSceneFromBuffer(gl, buffer));
        if (file.name.endsWith('.bfres')) return Promise.resolve(FRES.createSceneFromFRESBuffer(gl, buffer));
        if (file.name.endsWith('.szs')) return FRES.createSceneFromSARCBuffer(gl, buffer);
        // XXX(jstpierre): Figure out WTF to do here...
        var promise = J3D.createMultiSceneFromBuffer(gl, buffer);
        if (promise) return promise;
        return null;
    };
    DroppedFileSceneDesc.prototype.createScene = function (gl) {
        var _this = this;
        return this._loadFileAsPromise(this.file).then(function (result) {
            return _this.createSceneFromFile(gl, _this.file, result);
        });
    };
    return DroppedFileSceneDesc;
}();
var SceneLoader = /** @class */function () {
    function SceneLoader(viewer) {
        this.viewer = viewer;
    }
    SceneLoader.prototype.setScene = function (scene, sceneDesc, cameraState) {
        this.currentScene = scene;
        var cameraControllerClass;
        if (sceneDesc !== null) cameraControllerClass = sceneDesc.defaultCameraController;
        if (cameraControllerClass === undefined) cameraControllerClass = Camera_1.FPSCameraController;
        var cameraController = new cameraControllerClass();
        this.viewer.setCameraController(cameraController);
        if (cameraState !== null) {
            cameraController.deserialize(cameraState);
        } else if (scene !== null && scene.resetCamera) {
            scene.resetCamera(cameraController.camera);
        } else {
            cameraController.camera.identity();
        }
        this.viewer.setScene(scene);
        this.onscenechanged();
    };
    SceneLoader.prototype.loadSceneDesc = function (sceneDesc, cameraState) {
        var _this = this;
        this.setScene(null, null, null);
        var gl = this.viewer.renderState.gl;
        var progressable = sceneDesc.createScene(gl);
        progressable.then(function (scene) {
            _this.setScene(scene, sceneDesc, cameraState);
        });
        return progressable;
    };
    return SceneLoader;
}();
var Main = /** @class */function () {
    function Main() {
        var _this = this;
        this.canvas = document.createElement('canvas');
        this.canvas.onmousedown = function () {
            _this._deselectUI();
        };
        this.canvas.ondragover = function (e) {
            _this.dragHighlight.style.display = 'block';
            e.preventDefault();
        };
        this.canvas.ondragleave = function (e) {
            _this.dragHighlight.style.display = 'none';
            e.preventDefault();
        };
        this.canvas.ondrop = this._onDrop.bind(this);
        document.body.appendChild(this.canvas);
        window.onresize = this._onResize.bind(this);
        this._onResize();
        window.addEventListener('keydown', this._onKeyDown.bind(this));
        this.viewer = new viewer_1.Viewer(this.canvas);
        this.viewer.oncamerachanged = function () {
            _this._queueSaveState();
        };
        this.viewer.start();
        this.sceneLoader = new SceneLoader(this.viewer);
        this.sceneLoader.onscenechanged = this._onSceneChanged.bind(this);
        this._makeUI();
        this.groups = sceneGroups;
        this.droppedFileGroup = { id: "drops", name: "Dropped Files", sceneDescs: [] };
        this.groups.push(this.droppedFileGroup);
        this._loadSceneGroups();
        // Load the state from the hash
        this._loadState(window.location.hash.slice(1));
        // Make the user choose a scene if there's nothing loaded by default...
        if (this.currentSceneDesc === undefined) this.ui.sceneSelect.setExpanded(true);
    }
    Main.prototype._deselectUI = function () {
        this.canvas.focus();
    };
    Main.prototype._onDrop = function (e) {
        this.dragHighlight.style.display = 'none';
        e.preventDefault();
        var transfer = e.dataTransfer;
        var file = transfer.files[0];
        var sceneDesc = new DroppedFileSceneDesc(file);
        this.droppedFileGroup.sceneDescs.push(sceneDesc);
        this._loadSceneGroups();
        this._loadSceneDesc(this.droppedFileGroup, sceneDesc);
    };
    Main.prototype._onResize = function () {
        var devicePixelRatio = window.devicePixelRatio || 1;
        this.canvas.setAttribute('style', "width: " + window.innerWidth + "px; height: " + window.innerHeight + "px;");
        this.canvas.width = window.innerWidth * devicePixelRatio;
        this.canvas.height = window.innerHeight * devicePixelRatio;
    };
    Main.prototype._loadState = function (state) {
        var parts = state.split(';');
        var _a = __read(parts, 2),
            sceneState = _a[0],
            cameraState = _a[1];
        var _b = __read(sceneState.split('/')),
            groupId = _b[0],
            sceneRest = _b.slice(1);
        var sceneId = decodeURIComponent(sceneRest.join('/'));
        var group = this.groups.find(function (g) {
            return g.id === groupId;
        });
        if (!group) return;
        var desc = group.sceneDescs.find(function (d) {
            return d.id === sceneId;
        });
        var hasDesc = desc !== undefined;
        this.lastSavedState = state;
        this._loadSceneDesc(group, desc, cameraState);
    };
    Main.prototype._getState = function () {
        var groupId = this.currentSceneGroup.id;
        var sceneId = this.currentSceneDesc.id;
        var camera = this.viewer.cameraController.serialize();
        return groupId + "/" + sceneId + ";" + camera;
    };
    Main.prototype._saveState = function () {
        // If we're currently loading a scene, don't save out...
        if (this.sceneLoader.currentScene === null) return;
        var newState = this._getState();
        if (this.lastSavedState !== newState) {
            window.history.replaceState('', '', '#' + newState);
            this.lastSavedState = newState;
        }
    };
    Main.prototype._queueSaveState = function () {
        var _this = this;
        if (this.saveTimeout !== 0) clearTimeout(this.saveTimeout);
        this.saveTimeout = setTimeout(function () {
            _this._saveState();
            _this.saveTimeout = 0;
        }, 100);
    };
    Main.prototype._onSceneChanged = function () {
        var scene = this.viewer.scene;
        this.ui.sceneChanged();
        if (scene && scene.createPanels) this.ui.setScenePanels(scene.createPanels());else this.ui.setScenePanels([]);
    };
    Main.prototype._onSceneDescSelected = function (sceneGroup, sceneDesc) {
        this._loadSceneDesc(sceneGroup, sceneDesc);
    };
    Main.prototype._loadSceneDesc = function (sceneGroup, sceneDesc, cameraState) {
        if (cameraState === void 0) {
            cameraState = null;
        }
        if (this.currentSceneDesc === sceneDesc) return;
        this.currentSceneGroup = sceneGroup;
        this.currentSceneDesc = sceneDesc;
        this.ui.sceneSelect.setCurrentDesc(this.currentSceneGroup, this.currentSceneDesc);
        var progressable = this.sceneLoader.loadSceneDesc(sceneDesc, cameraState);
        this.ui.sceneSelect.setProgressable(progressable);
        // TODO(jstpierre): Probably a better place to put this.
        // Set window title.
        document.title = sceneDesc.name + " - " + sceneGroup.name + " - Model Viewer";
        this._deselectUI();
        this._saveState();
    };
    Main.prototype._loadSceneGroups = function () {
        this.ui.sceneSelect.setSceneGroups(this.groups);
    };
    Main.prototype._makeUI = function () {
        this.uiContainers = document.createElement('div');
        document.body.appendChild(this.uiContainers);
        this.ui = new ui_1.UI(this.viewer);
        this.ui.elem.style.position = 'absolute';
        this.ui.elem.style.left = '2em';
        this.ui.elem.style.top = '2em';
        this.uiContainers.appendChild(this.ui.elem);
        this.ui.sceneSelect.onscenedescselected = this._onSceneDescSelected.bind(this);
        this.dragHighlight = document.createElement('div');
        this.uiContainers.appendChild(this.dragHighlight);
        this.dragHighlight.style.position = 'absolute';
        this.dragHighlight.style.left = '0';
        this.dragHighlight.style.right = '0';
        this.dragHighlight.style.top = '0';
        this.dragHighlight.style.bottom = '0';
        this.dragHighlight.style.backgroundColor = 'rgba(255, 255, 255, 0.5)';
        this.dragHighlight.style.boxShadow = '0 0 40px 5px white inset';
        this.dragHighlight.style.display = 'none';
        this.dragHighlight.style.pointerEvents = 'none';
    };
    Main.prototype._toggleUI = function () {
        this.uiContainers.style.display = this.uiContainers.style.display === 'none' ? '' : 'none';
    };
    Main.prototype._onKeyDown = function (e) {
        if (e.code === 'KeyZ') {
            this._toggleUI();
            e.preventDefault();
        }
    };
    return Main;
}();
window.main = new Main();
},{"./viewer":"viewer.ts","./ArrayBufferSlice":"ArrayBufferSlice.ts","./Progressable":"Progressable.ts","./j3d/ztp_scenes":"j3d\\ztp_scenes.ts","./j3d/mkdd_scenes":"j3d\\mkdd_scenes.ts","./j3d/zww_scenes":"j3d\\zww_scenes.ts","./j3d/sms_scenes":"j3d\\sms_scenes.ts","./j3d/smg_scenes":"j3d\\smg_scenes.ts","./sm64ds/scenes":"sm64ds\\scenes.ts","./mdl0/scenes":"mdl0\\scenes.ts","./zelview/scenes":"zelview\\scenes.ts","./oot3d/scenes":"oot3d\\scenes.ts","./fres/scenes":"fres\\scenes.ts","./fres/splatoon_scenes":"fres\\splatoon_scenes.ts","./dksiv/scenes":"dksiv\\scenes.ts","./metroid_prime/scenes":"metroid_prime\\scenes.ts","./luigis_mansion/scenes":"luigis_mansion\\scenes.ts","./rres/zss_scenes":"rres\\zss_scenes.ts","./rres/elb_scenes":"rres\\elb_scenes.ts","./rres/mkwii_scenes":"rres\\mkwii_scenes.ts","./j3d/scenes":"j3d\\scenes.ts","./ui":"ui.ts","./Camera":"Camera.ts"}],"..\\node_modules\\parcel-bundler\\src\\builtins\\hmr-runtime.js":[function(require,module,exports) {
var global = arguments[3];
var OVERLAY_ID = '__parcel__error__overlay__';

var OldModule = module.bundle.Module;

function Module(moduleName) {
  OldModule.call(this, moduleName);
  this.hot = {
    data: module.bundle.hotData,
    _acceptCallbacks: [],
    _disposeCallbacks: [],
    accept: function (fn) {
      this._acceptCallbacks.push(fn || function () {});
    },
    dispose: function (fn) {
      this._disposeCallbacks.push(fn);
    }
  };

  module.bundle.hotData = null;
}

module.bundle.Module = Module;

var parent = module.bundle.parent;
if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {
  var hostname = '' || location.hostname;
  var protocol = location.protocol === 'https:' ? 'wss' : 'ws';
  var ws = new WebSocket(protocol + '://' + hostname + ':' + '58772' + '/');
  ws.onmessage = function (event) {
    var data = JSON.parse(event.data);

    if (data.type === 'update') {
      console.clear();

      data.assets.forEach(function (asset) {
        hmrApply(global.parcelRequire, asset);
      });

      data.assets.forEach(function (asset) {
        if (!asset.isNew) {
          hmrAccept(global.parcelRequire, asset.id);
        }
      });
    }

    if (data.type === 'reload') {
      ws.close();
      ws.onclose = function () {
        location.reload();
      };
    }

    if (data.type === 'error-resolved') {
      console.log('[parcel] ✨ Error resolved');

      removeErrorOverlay();
    }

    if (data.type === 'error') {
      console.error('[parcel] 🚨  ' + data.error.message + '\n' + data.error.stack);

      removeErrorOverlay();

      var overlay = createErrorOverlay(data);
      document.body.appendChild(overlay);
    }
  };
}

function removeErrorOverlay() {
  var overlay = document.getElementById(OVERLAY_ID);
  if (overlay) {
    overlay.remove();
  }
}

function createErrorOverlay(data) {
  var overlay = document.createElement('div');
  overlay.id = OVERLAY_ID;

  // html encode message and stack trace
  var message = document.createElement('div');
  var stackTrace = document.createElement('pre');
  message.innerText = data.error.message;
  stackTrace.innerText = data.error.stack;

  overlay.innerHTML = '<div style="background: black; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; opacity: 0.85; font-family: Menlo, Consolas, monospace; z-index: 9999;">' + '<span style="background: red; padding: 2px 4px; border-radius: 2px;">ERROR</span>' + '<span style="top: 2px; margin-left: 5px; position: relative;">🚨</span>' + '<div style="font-size: 18px; font-weight: bold; margin-top: 20px;">' + message.innerHTML + '</div>' + '<pre>' + stackTrace.innerHTML + '</pre>' + '</div>';

  return overlay;
}

function getParents(bundle, id) {
  var modules = bundle.modules;
  if (!modules) {
    return [];
  }

  var parents = [];
  var k, d, dep;

  for (k in modules) {
    for (d in modules[k][1]) {
      dep = modules[k][1][d];
      if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) {
        parents.push(k);
      }
    }
  }

  if (bundle.parent) {
    parents = parents.concat(getParents(bundle.parent, id));
  }

  return parents;
}

function hmrApply(bundle, asset) {
  var modules = bundle.modules;
  if (!modules) {
    return;
  }

  if (modules[asset.id] || !bundle.parent) {
    var fn = new Function('require', 'module', 'exports', asset.generated.js);
    asset.isNew = !modules[asset.id];
    modules[asset.id] = [fn, asset.deps];
  } else if (bundle.parent) {
    hmrApply(bundle.parent, asset);
  }
}

function hmrAccept(bundle, id) {
  var modules = bundle.modules;
  if (!modules) {
    return;
  }

  if (!modules[id] && bundle.parent) {
    return hmrAccept(bundle.parent, id);
  }

  var cached = bundle.cache[id];
  bundle.hotData = {};
  if (cached) {
    cached.hot.data = bundle.hotData;
  }

  if (cached && cached.hot && cached.hot._disposeCallbacks.length) {
    cached.hot._disposeCallbacks.forEach(function (cb) {
      cb(bundle.hotData);
    });
  }

  delete bundle.cache[id];
  bundle(id);

  cached = bundle.cache[id];
  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    cached.hot._acceptCallbacks.forEach(function (cb) {
      cb();
    });
    return true;
  }

  return getParents(global.parcelRequire, id).some(function (id) {
    return hmrAccept(global.parcelRequire, id);
  });
}
},{}]},{},["..\\node_modules\\parcel-bundler\\src\\builtins\\hmr-runtime.js","main.ts"], null)
//# sourceMappingURL=/main.c7802961.map