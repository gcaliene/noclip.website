
// Build our WAT WebAssembly modules.

const path = require('path');
const wabt = require('wabt');
const fs = require('fs');
const { spawnSync } = require('child_process');

function buildBinaryArray(binary) {
    const binData = new Uint8Array(binary.buffer);
    const binStr = binData.join(',');
    const src = `new Uint8Array([${binStr}])`;
    return src;
}

function buildModuleExportsInterface(exportName, wasmModule) {
    const modExports = WebAssembly.Module.exports(wasmModule);

    function getModuleExportType(exp) {
        switch (exp.kind) {
        case 'global':
            return `number`;
        case 'memory':
            return `WebAssembly.Memory`;
        default:
            throw "whoops";
        }
    }

    const lines = [];
    lines.push(`export interface ${exportName}Exports {`);
    for (const exp of modExports) {
        // For now, consumers are expected to provide signatures,
        // until this information is available through the toolchain...
        if (exp.kind === 'function')
            continue;
        lines.push(`    ${exp.name}: ${getModuleExportType(exp)};`);
    }
    lines.push('}');
    return lines.join('\n');
}

function compileAssemblyScript(filename) {
    const outFilename = filename.replace('.ts', '.wat');
    // TODO(jstpierre): noRuntime flag is gone, noLib seems to cause an assert fail in the compiler somewhere... ugh.
    const res = spawnSync('node', [path.join(__dirname, '../node_modules/assemblyscript/bin/asc'), '--baseDir', __dirname, filename, '--noLib', '-O', '-c', '-o', outFilename]);

    if (res.status !== 0) {
        console.error(res.stderr.toString('utf8'));
        throw new Error("Could not compile");
    }

    return outFilename;
}

function buildModuleCode(mod) {
    const exportName = mod.exportName;
    const filename = mod.filename;

    const watFilename = compileAssemblyScript(filename);
    const wat = fs.readFileSync(path.join(__dirname, watFilename));
    const wabtModule = wabt.parseWat(watFilename, wat);
    wabtModule.resolveNames();
    wabtModule.validate();
    const binary = wabtModule.toBinary({});

    const wasmModule = new WebAssembly.Module(binary.buffer);
    buildModuleExportsInterface(exportName, wasmModule);

    const binArrayStr = buildBinaryArray(binary);

    return `
// ${filename}
${buildModuleExportsInterface(exportName, wasmModule)}
const ${exportName}Code = ${binArrayStr};
export function ${exportName}Instance(imports?: any): Promise<${exportName}Exports> {
    return WebAssembly.compile(${exportName}Code).then((module: WebAssembly.Module) => {
        return WebAssembly.instantiate(module, imports);
    }).then((instance: WebAssembly.Instance) => {
        return (<${exportName}Exports> instance.exports);
    });
}
`;
}

function buildModulesFile(modules) {
    let s = `// Generated by build_wat.js\n`;
    for (const module of modules) {
        s += buildModuleCode(module);
    }
    return s;
}

function main() {
    const out = buildModulesFile([
        { exportName: 'yaz0_as', filename: 'assembly/Yaz0_as.ts' },
        { exportName: 'gx_texture_as', filename: 'assembly/gx_texture_as.ts' },
    ]);
    fs.writeFileSync(path.join(__dirname, 'wat_modules.ts'), out);
}

main();
